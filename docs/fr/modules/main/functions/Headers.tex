\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}     % Encodage du texte (caractères accentués).
\usepackage[french]{babel}      % Langue du document.
\usepackage[sfdefault]{roboto}  % Police d'écriture utilisée dans le document.
\usepackage[T1]{fontenc}		% Règle de césure pour les caractères accentués (pour le compilateur).

\usepackage{fancyhdr}           % Ajout de headers et footers à chaque page du document.
\usepackage{hyperref}           % Création de liens cliquables pointant vers d'autres parties du document.

\usepackage[usenames,dvipsnames]{xcolor}	% Coloration du texte.
\usepackage{verbatim}						% Mise en page des paragraphes.

\usepackage[document]{ragged2e}								% Justification du texte.
\usepackage[a4paper,margin=1in,footskip=0.25in]{geometry}	% Mise en page du document.

\fontfamily{Roboto}

\pagecolor{black}
\title{\color{red}Fonctions du fichier de librairie \color{lime}Headers.lib}\color{white}
\author{Dimitri OBEID}
\date{2021}
\pagestyle{fancy}

\pdfinfo{
  /Title    (Fonctions du fichier de librairie Headers.lib)
  /Author   (Dimitri OBEID)
  /Creator  (Dimitri OBEID)
  /Producer (Dimitri OBEID)
  /Subject  (Fonctions du fichier de librairie Headers.lib)
  /Keywords ()
}

% Definition de couleurs.
\definecolor{mauve}{RGB}{128, 0, 128}
\definecolor{brick}{HTML}{be480a}

\begin{document}
 \maketitle
 \tableofcontents
 \newpage

\color{red}
\section{Présentation}\color{white}

\color{green}
\subsection{Présentation}\color{white}

\begin{justify}
    Ce fichier source inclut des fonctions servant à la création de headers, séparant ce qu'un développeur de scripts Bash peut imaginer comme étant deux grandes étapes différentes d'un script.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Définitions des éléments mentionnés}\color{white}

\color{blue}
\subsubsection{Chemins de fichiers}\color{white}

\textbf{Nom du fichier : \color{lime}Checkings.lib}\\[1\baselineskip]

\textbf{Dossier parent : \color{orange}\$\_\_BU\_MAIN\_ROOT\_DIR\_PATH\color{lime}/lib/functions/main}\\[1\baselineskip]


% -----------------------

\color{lime}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Nom du fichier : \color{lime}Colors.conf}\\[1\baselineskip]

\textbf{Dossier parent : \color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}\\[1\baselineskip]


% -----------------------

\color{lime}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Nom du fichier : \color{lime}Status.conf}\\[1\baselineskip]

\textbf{Dossier parent : \color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}\\[1\baselineskip]


% -----------------------

\color{lime}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Nom du fichier : \color{lime}Text.conf}\\[1\baselineskip]

\textbf{Dossier parent : \color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}\\[1\baselineskip]


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{blue}
\subsubsection{Fonctions externes appelées}\color{white}

\textbf{Fonction : \color{mauve}BU::IsChar}\\[1\baselineskip]

\begin{justify}
    \textbf{Description :} Cette fonction verifie que la valeur enregistrée dans une variable soit un simple caractère alphanumérique.
\end{justify}

\textbf{Fichier de définition : \color{lime}Checkings.lib}\\[1\baselineskip]


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{blue}
\subsubsection{Variables globales externes et / ou variables d'environnement appelées}\color{white}

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_COLOR...}\\[1\baselineskip]

\begin{justify}
    \textbf{Description :} Chacune des variables globales commençant par ce nom retourne un code couleu encodé lors de l'appel d'une de ces variables, grâce à l'appel simultané d'une fonction.
\end{justify}

\textbf{Fichier de définition : \color{lime}Colors.conf}\\[1\baselineskip]


% -----------------------

\color{orange}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_STAT\_ECHO}\\[1\baselineskip]

\begin{justify}
    \textbf{Description :} Cette variable globale sert à mettre le script dans un état dit ``stable'', vérifiant si un texte peut être redirigé vers un fichier de logs sans provoquer de boucles infinies, dans le cas où un rappel de la même fonction dans l'état précédent peut causer ceci.
\end{justify}

\textbf{Fichier de définition : \color{lime}Status.conf}\\[1\baselineskip]


% -----------------------

\color{orange}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_TXT\_CHAR\_HEADER\_LINE}\\[1\baselineskip]

\begin{justify}
    \textbf{Description :} Cette variable globale enregistre le caractère par défaut à afficher sur chaque colonne d'une ligne d'un header.
\end{justify}

\textbf{Fichier de définition : \color{lime}Text.conf}\\[1\baselineskip]


% -----------------------

% -----------------------------------------------

% /////////////////////////////////////////////////////////////////////////////////////////////// %

\color{red}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{red}
\section{Fonctions}\color{white}

\color{green}
\subsection{Création de base d'un header}\color{white}

\color{blue}
\subsubsection{BU::Main::Headers::DrawLine}\color{white}

\textbf{Fonction : \color{mauve}BU::Main::Headers::DrawLine}\\

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Description :}\\
    Cette fonction dessine une ligne en remplissant chaque colonne du terminal avec un caractère choisi et passé en second argument.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\textbf{Paramètres :}\\[1\baselineskip]
\begin{tabular}{|l|l|}
\hline
\textbf{Paramètre} & \textbf{Type} \\
\hline
\textbf{\color{orange}p\_lineChar} & Caractère\\
\hline
\textbf{\color{orange}p\_lineColor} & Substitution de commande\\
\hline
\textbf{\color{orange}p\_strlen} & Nombre entier\\
\hline
\textbf{\color{orange}p\_bgColor} & Substitution de commande\\
\hline
\end{tabular}\\[1\baselineskip]

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\
    La fonction \textbf{\color{mauve}BU::Main::Headers::DrawLine} vérifie d'abord que la valeur du second paramètre \textbf{\color{orange}p\_lineChar} soit bien un simple caractère (alphabétique ou numérique) via la fonction \textbf{\color{mauve}IsChar}, définie dans le fichier \textbf{\color{lime}Checkings.lib}. Si ce n'est pas le cas, ce paramètre est redéfini, et seul le premier caractère de la chaîne est récupéré pour l'affichage de la ligne.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Si} une substitution de commande est passée au paramètre \textbf{\color{orange}p\_lineColor}, \textbf{\color{brick}alors} la fonction actuelle l'exécute. Cette substitution \textbf{DOIT} être un appel de la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetTextColor}.
\end{justify}

\begin{justify}
    Une fois la commande exécutée pendant la comparaison, la commande \textbf{\color{gray}echo} est appelée avec ses options \textbf{\color{gray}-ne} pour encoder la couleur de la ligne de caractère à dessiner.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Fin de la condition.}\\
\end{justify}


\begin{justify}
    Une fois la vérification de coloration de la ligne effectuée, la fonction \textbf{\color{brick}en fait de même avec la couleur de fond}, dont la valeur a été passée au paramètre \textbf{\color{orange}p\_bgColor} via une substitution de commande, qui \textbf{DOIT} être un appel de la la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetBGColor}.
\end{justify}

\begin{justify}
    Une fois les deux condition précédentes vérifiées, la fonction vérifie si une valeur est passée au paramètre \textbf{\color{orange}p\_strlen}, pour créer une ligne d'une longueur définie.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Si} une valeur est passée au paramètre \textbf{\color{orange}p\_strlen}, \textbf{\color{brick}alors},
\end{justify}

\begin{justify}
    \textbf{\color{brick}Si} cette valeur est un nombre entier, \textbf{\color{brick}alors} une boucle \textbf{\color{cyan}for} est exécutée pour afficher \textbf{n} caractères selon la longueur du mode texte.
\end{justify}

\begin{justify}
     \textbf{\color{cyan}Pour} un nombre \textbf{\color{orange}i} allant de \textbf{\color{cyan}1} au nombre enregistré dans le paramètre \textbf{\color{orange}p\_strlen}, on affiche \textbf{\color{orange}i} fois, sans retour à la ligne, le caractère passé en deuxième argument (\textbf{\color{orange}\$p\_lineChar}). \textbf{\color{cyan}Fin de la boucle « pour »}.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Sinon, si} cette valeur n'est pas un nombre entier, alors un message d'avertissement est affiché via un appel de la fonction \textbf{\color{mauve}BU::Main::Errors::HandleSmallErrors}. \textbf{\color{brick}Fin de la condition}.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Sinon, si} aucune valeur n'est passée au paramètre \textbf{\color{orange}p\_strlen}, \textbf{\color{brick}alors} une boucle \textbf{\color{cyan}for} est exécutée pour .
\end{justify}

\begin{justify}
     \textbf{\color{cyan}Pour} un nombre \textbf{\color{orange}i} allant de \textbf{\color{cyan}1} au nombre de colonnes présentes dans le mode texte du terminal (nombre obtenu grâce à la commande \textbf{\color{gray}eval echo}), on affiche \textbf{\color{orange}i} fois, sans retour à la ligne, le caractère passé en deuxième argument (\textbf{\color{orange}\$p\_lineChar}). \textbf{\color{cyan}Fin de la boucle « pour »}.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Fin de la condition}.
\end{justify}

\begin{justify}
    Enfin, une fois l'une des deux boucles exécutée, \textbf{\color{brick}si} les paramètres \textbf{\color{orange}\$p\_lineColor} \textbf{\color{brick}OU} \textbf{\color{orange}\$p\_bgColor} contiennent une valeur, \textbf{\color{brick}alors} la fonction ré-encode la couleur d'affichage du texte \textbf{ET} du fond selon la couleur par défaut du terminal. \textbf{\color{brick}Fin de la condition}.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\
    Appelez cette fonction pour dessiner une ligne devant remplir la totalité des colonnes d'une ligne du terminal.
\end{justify}


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{blue}
\subsubsection{BU::HeaderBase}\color{white}

\textbf{Fonction : \color{mauve}BU::HeaderBase}\\

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Description :}\\
    Cette fonction affiche un header complet, avec ses deux lignes entourant une chaîne de caractères.
\end{justify}


\par\noindent\rule{\textwidth}{0.4pt}

\textbf{Paramètres :}\\[1\baselineskip]
\begin{tabular}{|l|l|}
\hline 
\textbf{\color{orange}p\_lineColor} & Ce paramètre attend un code couleur \\ 
\hline 
\textbf{\color{orange}p\_lineChar} & Ce paramètre attend un seul caractère \\ 
\hline 
\textbf{\color{orange}p\_stringColor} & Ce paramètre attend un code couleur \\ 
\hline 
\textbf{\color{orange}p\_stringTxt} & Ce paramètre attend une chaîne de caractères\\ 
\hline 
\end{tabular}\\[1\baselineskip]

\par\noindent\rule{\textwidth}{0.4pt}

\textbf{Variables :}\\[1\baselineskip]
\begin{tabular}{|l|l|}
\hline
\textbf{\color{orange}p\_lineColor} & Ce paramètre attend un code couleur \\ 
\hline
\end{tabular}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\
    Tout d'abord, la fonction \textbf{\color{mauve}BU::HeaderBase} vérifie l'état de la variable de statut \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_ECHO}, puis en adaptant la commande d'affichage de texte à appeler.\\[1\baselineskip]

    Ensuite, elle appelle la fonction \textbf{\color{mauve}BU::Main::Headers::DrawLine} en y passant en arguments ses deux premiers paramètres.
\end{justify}

\begin{justify}
    Une fois ceci fait, un saut de ligne est effectué, et un message est affiché, avec la couleur choisie encodée en premier (troisième paramètre) et le texte passé en quatrième argument.
\end{justify}

\begin{justify}
    La commande de ré-initialisation de décoration du terminal (définie dans les fichiers \textbf{\color{lime}Colors.conf} et \textbf{\color{lime}Text.conf}) est ensuite appelée pour réinitialiser la couleur d'affichage de texte selon la configuration du terminal.
\end{justify}

\begin{justify}
    Appelez cette fonction pour afficher un texte entre deux lignes, et pour davantage personnaliser cet affichage si vous ne trouvez pas votre compte parmi les fonctions proposées dans les sections suivantes : \textbf{\color{green}Headers unicolores} et \textbf{\color{green}Headers multicolores}.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\
    Appelez cette fonction pour marquer une séparation entre plusieurs étapes de votre script, tout en affichant un header dont vous pouvez personnaliser l'affichage des couleurs.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers unicolores}\color{white}

\begin{justify}
    \textbf{Description :}
    Chacune de ces fonctions appelle la fonction \textbf{\color{mauve}BU::HeaderBase}, en lui passant ses trois premiers arguments prédéfinis.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Paramètre :}\\
    \textbf{\color{orange}\$1} --> Ce paramètre attend la chaîne de caractère à afficher.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\
    Chacune des fonctions de cette catégorie appelle la fonction \textbf{\color{mauve}BU::HeaderBase}, en lui passant en premier et troisième arguments un même code couleur \textbf{\color{orange}\$\_\_BU\_MAIN\_COLOR...}, un caractère défini par la variable \textbf{\color{orange}\$\_\_BU\_MAIN\_TXT\_CHAR\_HEADER\_LINE} en deuxième argument, puis la chaîne de caractères à afficher en quatrième argument (seul paramètre que prennent ces fonctions).
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\
    Appelez une de ces fonctions pour marquer une séparation entre plusieurs étapes de votre script, tout en affichant un header unicolore sans avoir à passer ses trois premiers arguments.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers bicolores}\color{white}

\begin{justify}
    \textbf{Note :} En raison du trop grand nombre de fonctions à déclarer, plus aucune nouvelle couleur ne sera ajoutée parmi les 23 couleurs actuelles (qui représentent en tout plus de 500 fonctions déclarées rien que dans ce fichier de librairie).
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    Pour davantage faciliter la tâche des développeurs, des fonctions de création de headers bicolores existent.
\end{justify}

\begin{justify}
    Elles fonctionnent chacune de la même manière que les fonctions de la catégorie précédente, à deux exceptions près :

    \begin{itemize}
        \item \textbf{le nom :} chaque fonction porte le nom de la couleur à afficher sur chaque ligne, puis le nom de la couleur à appliquer au texte.\\

        \item \textbf{le nom (bis) :} Il n'y a pas de fonction portant deux fois le nom de la même couleur, car le rendu serait le même que celui des fonctions de la catégorie précédente.
    \end{itemize}
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers tricolores}\color{white}

\begin{justify}
    Étant donné la charge de travail nécessaire pour créer ces headers, il serait beaucoup trop fastidieux de créer tous ces headers prédéfinis.
\end{justify}

\begin{justify}
    Pour vous donner une idée de la quantité de travail, prenez la formule mathématique suivante :
\end{justify}

\[nbcol * (nbcol - 1) * nbcol\]

\begin{justify}
    Où nbcol = nombre de codes couleurs disponibles.
\end{justify}

\begin{justify}
    Au moment où j'ai écrit cette partie de la documentation (dimanche 29 août 2021), il existait 12 codes couleurs disponibles.
\end{justify}

\begin{justify}
    En effectuant le calcul précédent, nous obtenons donc \textbf{12 * 11 * 12 = 1 584 combinaisons possibles}, sans parler de l'ajout d'éventuels nouveaux codes couleurs.
\end{justify}

\begin{justify}
    Il faudra donc se contenter d'appeler la fonction \textbf{\color{mauve}BU::HeaderBase}, suivie de ses 4 arguments, dont chaque valeur sera différente des autres.
\end{justify}

\end{document}

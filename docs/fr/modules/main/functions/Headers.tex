\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}     % Encodage du texte (caractères accentués).
\usepackage[french]{babel}      % Langue du document.
\usepackage[sfdefault]{roboto}  % Police d'écriture utilisée dans le document.
\usepackage[T1]{fontenc}		% Règle de césure pour les caractères accentués (pour le compilateur).

\usepackage{fancyhdr}           % Ajout de headers et footers à chaque page du document.
\usepackage{hyperref}           % Création de liens cliquables pointant vers d'autres parties du document.
\usepackage{parskip}

\usepackage[usenames,dvipsnames]{xcolor}	% Coloration du texte.
\usepackage{verbatim}						% Mise en page des paragraphes.

\usepackage[document]{ragged2e}								% Justification du texte.
\usepackage[a4paper,margin=1in,footskip=0.25in]{geometry}	% Mise en page du document.

\fontfamily{Roboto}

\pagecolor{black}
\title{\color{red}Fonctions du fichier de librairie \color{lime}Headers.lib}\color{white}
\author{Dimitri OBEID}
\date{2021}
\pagestyle{fancy}

\pdfinfo{
  /Title    (Fonctions du fichier de librairie Headers.lib)
  /Author   (Dimitri OBEID)
  /Creator  (Dimitri OBEID)
  /Producer (Dimitri OBEID)
  /Subject  (Fonctions du fichier de librairie Headers.lib)
  /Keywords ()
}

% Definition de couleurs.
\definecolor{mauve}{RGB}{128, 0, 128}
\definecolor{brick}{HTML}{be480a}

% Mise en page des paragraphes.
\setlength{\parskip}{1em}

\begin{document}
\maketitle
\newpage

\hypertarget{contents}{}
\tableofcontents
\newpage

\color{red}
\section{Présentation}\color{white}

\color{green}
\subsection{Présentation}\color{white}

\begin{justify}
    Ce fichier source inclut des fonctions servant à la création de headers, séparant ce qu'un développeur de scripts Bash peut imaginer comme étant deux grandes étapes différentes d'un script.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Définitions des éléments mentionnés}\color{white}

\color{blue}
\subsubsection{Chemins de fichiers}\color{white}

\begin{justify}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Dossier parent} & \textbf{Nom du fichier}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}    & \textbf{\color{lime}Colors.conf}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}    & \textbf{\color{lime}Status.conf}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MODULE\_UTILS\_ROOT\color{lime}/config/modules/main}    & \textbf{\color{lime}Text.conf}\\
        \hline
    \end{tabular}
    
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Dossier parent} & \textbf{Nom du fichier}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MAIN\_ROOT\_DIR\_PATH\color{lime}/lib/functions/main}   & \textbf{\color{lime}Checkings.lib}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MAIN\_ROOT\_DIR\_PATH\color{lime}/lib/functions/main}   & \textbf{\color{lime}Decho.lib}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MAIN\_ROOT\_DIR\_PATH\color{lime}/lib/functions/main}   & \textbf{\color{lime}Echo.lib}\\
        \hline
        \textbf{\color{orange}\$\_\_BU\_MAIN\_ROOT\_DIR\_PATH\color{lime}/lib/functions/main}   & \textbf{\color{lime}Errors.lib}\\
        \hline
    \end{tabular}

\end{justify}\setlength{\parskip}{2em}


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\setlength{\parskip}{1em}

\color{blue}
\subsubsection{Fonctions externes appelées}\color{white}

\begin{justify}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Fonction} & \textbf{Fichier de définition}\\
        \hline
        \textbf{\color{mauve}BU::IsAlphaNumChar}    & \textbf{\color{lime}Checkings.lib}\\
        \hline
        \textbf{\color{mauve}BU::IsInt}             & \textbf{\color{lime}Checkings.lib}\\
        \hline
        \textbf{\color{mauve}BU::IsIntpos}          & \textbf{\color{lime}Checkings.lib}\\
        \hline
        \textbf{\color{mauve}BU::DechoBGColor}              & \textbf{\color{lime}Decho.lib}\\
        \hline
        \textbf{\color{mauve}BU::DechoHighlightFunction}    & \textbf{\color{lime}Decho.lib}\\
        \hline  
        \textbf{\color{mauve}BU::Newline}           & \textbf{\color{lime}Echo.lib}\\
        \hline
        \textbf{\color{mauve}BU::EchoMsg}           & \textbf{\color{lime}Echo.lib}\\
        \hline
        \textbf{\color{mauve}BU::Main::Errors::HandleSmallErrors}   & \textbf{\color{lime}Errors.lib}\\
        \hline      
    \end{tabular}
\end{justify}\setlength{\parskip}{2em}


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\setlength{\parskip}{1em}

\color{blue}
\subsubsection{Variables globales externes et / ou variables d'environnement appelées}\color{white}

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_COLOR\_BG\_...}\\[1\baselineskip]

\textbf{Description :}

\begin{justify}
    Chacune des variables globales de couleur de fond commençant par ce nom retourne le résultat de la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetBGColor} lors de l'appel d'une de ces variables, pour colorer l'arrière plan du texte selon le code couleur.
\end{justify}

\textbf{Fichier de définition : \color{lime}Colors.conf}\\[1\baselineskip]


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{blue}
\subsubsection{Variables globales externes et / ou variables d'environnement appelées}\color{white}

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_COLOR\_TXT\_...}\\[1\baselineskip]

\textbf{Description :}

\begin{justify}
    Chacune des variables globales de couleur de texte commençant par ce nom retourne le résultat de la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetTextColor} lors de l'appel d'une de ces variables, pour colorer le texte selon le code couleur.
\end{justify}

\textbf{Fichier de définition : \color{lime}Colors.conf}\\[1\baselineskip]


% -----------------------

\color{orange}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_STAT\_ECHO}\\[1\baselineskip]

\textbf{Description :}

\begin{justify}
    Cette variable globale sert à mettre le script dans un état dit ``stable'', vérifiant si un texte peut être redirigé vers un fichier de logs sans provoquer de boucles infinies, dans le cas où un rappel de la même fonction dans l'état précédent peut causer ceci.
\end{justify}

\textbf{Fichier de définition : \color{lime}Status.conf}\\[1\baselineskip]


% -----------------------

\color{orange}\par\noindent\rule{\textwidth}{0.4pt}\color{white}\\[1\baselineskip]

\textbf{Variable : \color{orange}\$\_\_BU\_MAIN\_TXT\_CHAR\_HEADER\_LINE}\\[1\baselineskip]

\textbf{Description :}

\begin{justify}
    Cette variable globale enregistre le caractère par défaut à afficher sur chaque colonne d'une ligne d'un header.
\end{justify}

\textbf{Fichier de définition : \color{lime}Text.conf}\\[1\baselineskip]


% -----------------------

% -----------------------------------------------

% /////////////////////////////////////////////////////////////////////////////////////////////// %

\color{red}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{red}
\section{Fonctions}\color{white}

\color{green}
\subsection{Création de base d'un header}\color{white}

\color{blue}
\subsubsection{BU::Main::Headers::DrawLine}\color{white}

\textbf{Fonction : \color{mauve}BU::Main::Headers::DrawLine}\setlength{\parskip}{1em}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Description :}\\[1\baselineskip]
    Cette fonction dessine une ligne en remplissant chaque colonne du terminal avec un caractère choisi et passé en second argument.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}\\

\begin{justify}
    \textbf{Paramètres :}

    \begin{tabular}{|l|l|}
        \hline
        \textbf{Paramètre} & \textbf{Type}\\
        \hline
        \textbf{\color{orange}p\_lineChar} & Caractère\\
        \hline
        \textbf{\color{orange}p\_lineColor} & Substitution de commande\\
        \hline
        \textbf{\color{orange}p\_strlen} & Nombre entier\\
        \hline
        \textbf{\color{orange}p\_bgColor} & Substitution de commande\\
        \hline
    \end{tabular}
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\[1\baselineskip]
    La fonction \textbf{\color{mauve}BU::Main::Headers::DrawLine} vérifie tout d'abord que la valeur du second paramètre \textbf{\color{orange}p\_lineChar} soit bien un simple caractère (alphabétique ou numérique) via la fonction \textbf{\color{mauve}IsChar}, définie dans le fichier \textbf{\color{lime}Checkings.lib}. Si ce n'est pas le cas, ce paramètre est redéfini, et seul le premier caractère de la chaîne est récupéré pour l'affichage de la ligne.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Si} une substitution de commande est passée au paramètre \textbf{\color{orange}p\_lineColor}, \textbf{\color{brick}alors} la fonction actuelle l'exécute. Cette substitution \textbf{DOIT} être un appel de la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetTextColor}.
\end{justify}

\begin{justify}
    Une fois la commande exécutée pendant la comparaison, la commande \textbf{\color{gray}echo} est appelée avec ses options \textbf{\color{gray}-ne} pour encoder la couleur de la ligne de caractère à dessiner.
\end{justify}

\begin{justify}
    \textbf{\color{brick}Fin de la condition.}
\end{justify}\setlength{\parskip}{2em}


\begin{justify}
    Une fois la vérification de coloration de la ligne effectuée, la fonction \textbf{\color{brick}en fait de même avec la couleur de fond}, dont la valeur a été passée au paramètre \textbf{\color{orange}p\_bgColor} via une substitution de commande, qui \textbf{DOIT} être un appel de la la fonction \textbf{\color{mauve}BU::Main::ModConfig::Colors::SetBGColor}.
\end{justify}\setlength{\parskip}{1em}

\begin{justify}
    Une fois les deux condition précédentes vérifiées, la fonction vérifie si une valeur est passée au paramètre \textbf{\color{orange}p\_strlen}, pour créer une ligne d'une longueur définie.
\end{justify}\setlength{\parskip}{2em}

\begin{justify}
    \textbf{\color{brick}Si} une valeur est passée au paramètre \textbf{\color{orange}p\_strlen}, \textbf{\color{brick}alors} :\par
\end{justify}\setlength{\parskip}{1em}

\begin{itemize}
    \item
    {
        \begin{justify}
            \textbf{\color{brick}Si} cette valeur est un nombre entier, \textbf{\color{brick}alors} une boucle \textbf{\color{cyan}for} est exécutée pour afficher \textbf{n} caractères selon le nombre de colonnes défini via ce paramètre.\setlength{\parskip}{2em}
        \end{justify}\setlength{\parskip}{1em}

        \begin{itemize}
            \item
            {
                \begin{justify}
                    \textbf{\color{cyan}Pour} un nombre \textbf{\color{orange}i} allant de \textbf{\color{cyan}1} au nombre enregistré dans le paramètre \textbf{\color{orange}p\_strlen}, on affiche \textbf{\color{orange}i} fois, sans retour à la ligne, le caractère passé en deuxième argument (\textbf{\color{orange}\$p\_lineChar}).
                \end{justify}\setlength{\parskip}{1em}

                \begin{justify}
                    \textbf{\color{cyan}Fin de la boucle « pour »}.
                \end{justify}
            }
        \end{itemize}

        \begin{justify}
            \textbf{\color{brick}Sinon, si} cette valeur n'est pas un nombre entier, alors un message d'avertissement est affiché via un appel de la fonction \textbf{\color{mauve}BU::Main::Errors::HandleSmallErrors}.
        \end{justify}\setlength{\parskip}{1em}

        \begin{justify}
            \textbf{\color{brick}Fin de la condition}.
        \end{justify}\setlength{\parskip}{1em}
    }
\end{itemize}


\begin{justify}
    \textbf{\color{brick}Sinon, si} aucune valeur n'est passée au paramètre \textbf{\color{orange}p\_strlen}, \textbf{\color{brick}alors} une boucle \textbf{\color{cyan}for} est exécutée pour afficher \textbf{n} caractères selon la longueur du mode texte.
\end{justify}\setlength{\parskip}{1em}

\begin{itemize}
    \item
    {
        \begin{justify}
            \textbf{\color{cyan}Pour} un nombre \textbf{\color{orange}i} allant de \textbf{\color{cyan}1} au nombre de colonnes présentes dans le mode texte du terminal (nombre obtenu grâce à la commande \textbf{\color{gray}eval echo}), on affiche \textbf{\color{orange}i} fois, sans retour à la ligne, le caractère passé en deuxième argument (\textbf{\color{orange}\$p\_lineChar}).
        \end{justify}\setlength{\parskip}{1em}

        \begin{justify}
            \textbf{\color{cyan}Fin de la boucle « pour »}.
        \end{justify}
    }
\end{itemize}

\begin{justify}
    \textbf{\color{brick}Fin de la condition}.
\end{justify}\setlength{\parskip}{2em}


\begin{justify}
    Enfin, une fois l'une des deux boucles exécutée, \textbf{\color{brick}si} les paramètres \textbf{\color{orange}p\_lineColor} \textbf{\color{brick}OU} \textbf{\color{orange}p\_bgColor} contiennent une valeur, \textbf{\color{brick}alors} la fonction ré-encode la couleur d'affichage du texte \textbf{ET} celle de coloration du fond, selon la couleur par défaut du terminal. \textbf{\color{brick}Fin de la condition}.
\end{justify}\setlength{\parskip}{1em}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\[1\baselineskip]
    Appelez cette fonction pour dessiner une ligne devant remplir la totalité des colonnes d'une ligne du terminal \textbf{ou} une ligne au nombre de colonnes bien défini.
\end{justify}


% -----------------------

\color{blue}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{blue}
\subsubsection{BU::HeaderBase}\color{white}

\textbf{Fonction : \color{mauve}BU::HeaderBase}\\

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Description :}\\[1\baselineskip]
    Cette fonction affiche un header complet, avec ses deux lignes entourant une chaîne de caractères.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Paramètres :}

    \begin{tabular}{|l|l|}
        \hline
        \textbf{\color{orange}p\_lineColor} & Substitution de commande\\ 
        \hline
        \textbf{\color{orange}p\_lineChar} & Caractère\\ 
        \hline
        \textbf{\color{orange}p\_stringColor} & Substitution de commande\\ 
        \hline
        \textbf{\color{orange}p\_stringTxt} & Chaîne de caractères\\ 
        \hline
        \textbf{\color{orange}p\_strlen} & Chaîne de caractères « strlen »\\
        \hline
        \textbf{\color{orange}p\_bgColorCol} & Substitution de commande\\
        \hline
        \textbf{\color{orange}p\_bgColorPos} & Nombre entier « 1 », « 2 » et / ou « 3 »\\
        \hline
    \end{tabular}
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}\\

\begin{justify}
    \textbf{Variables :}\\[1\baselineskip]
    \begin{tabular}{|l|l|}
        \hline
        \textbf{\color{orange}v\_stat\_time\_newline} & Nombre décimal\\
        \hline
        \textbf{\color{orange}v\_stat\_time\_txt} & Nombre décimal\\
        \hline
        \textbf{\color{orange}v\_strlen} & Nombre entier\\
        \hline
    \end{tabular}
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\[1\baselineskip]
    Tout d'abord, sachant que le paramètre \textbf{\color{orange}p\_strlen} attend précisément la chaîne de caractères \textbf{strlen}, la fonction se doit de récupérer la longueur de la chaîne de caractères principale précédemment passée en argument (paramètre \textbf{\color{orange}p\_stringTxt}).
\end{justify}

\begin{justify}
    Il en est ainsi pour éviter que l'utilisateur n'ait à retaper la même chaîne de caractères ou à définir une nouvelle variable pour afficher cette dernière, puis récupérer son nombre de caractères via un enchaînement de processus avec un tube (\textbf{\color{gray}echo \color{orange}"\$var" \color{white} | \color{gray}wc -c}) (méthode utilisée par la fonction actuelle) ou de cette manière : \textbf{\color{gray}echo \color{orange}``\$\{\#var\}''}.
\end{justify}\setlength{\parskip}{2em}


\begin{justify}
    Dans un soucis de temps de pause cohérent, la fonction \textbf{\color{mauve}BU::HeaderBase} change la valeur des variables globales de statut \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_TIME\_NEWLINE} et \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_TIME\_TXT}, mettant ainsi le temps de pause du script de ces variable à 0 secondes.\par
\end{justify}

\begin{justify}
    Pour laisser le choix aux développeurs quant à la ligne à colorer (première ou deuxième ligne de caractères, ou la chaîne de caractères du milieu), le paramètre \textbf{\color{orange}p\_bgColorPos} accepte un nombre comprenant entre un et chiffres, correspondants à la ligne à colorer, et dont les valeurs acceptées sont \textbf{1}, \textbf{2} et / ou \textbf{3}.
\end{justify}\setlength{\parskip}{1em}

\begin{justify}
    \textbf{\color{brick}Si} aucune valeur n'est passée au paramètre \textbf{\color{orange}p\_bgColorPos} lors de l'appel de la fonction, \textbf{\color{brick}alors} cette dernière appelle la fonction \textbf{\color{mauve}BU::Main::Headers::DrawLine} en y passant en arguments la valeur des paramètres et variables \textbf{\color{orange}p\_lineChar}, \textbf{\color{orange}p\_lineColor}, \textbf{\color{orange}v\_strlen} et \textbf{\color{orange}p\_bgColor} (ces deux derniers arguments seront traités par la fonction appelée s'ils contiennent une valeur).
\end{justify}\setlength{\parskip}{1em}

\begin{justify}
    \textbf{\color{brick}Sinon, si} une valeur est passée au paramètre \textbf{\color{orange}p\_bgColorPos} lors de l'appel de la fonction, \textbf{\color{brick}alors} :
\end{justify}

\begin{itemize}
    \item
    {
        \begin{justify}
            Pour connaitre la valeur de chaque chiffre enregistré dans ce paramètre, Un tableau est créé et prend en valeurs chacun des chiffres.
        \end{justify}\setlength{\parskip}{1em}

        \begin{justify}
            \textbf{\color{brick}Si} un nombre entier positif est passé à ce même paramètre \textbf{ET} que ce nombre entier soit plus grand ou égal à 1 \textbf{ET} qu'il soit plus petit ou égal à 3, \textbf{\color{brick}alors} :
        \end{justify}\setlength{\parskip}{1em}

        \begin{justify}
            \item
            {
                \begin{justify}
                    \textbf{\color{cyan}Pour} un nombre \textbf{\color{orange}i} de valeurs dans l'intervalle autorisée :
                \end{justify}

                \begin{itemize}
                    \item
                    {
                        \begin{justify}
                            \textbf{\color{brick}Si} l'un des chiffres de ce nombre à trois chiffres est égal à \textbf{1}, \textbf{\color{brick}alors} la fonction \textbf{\color{mauve}BU::DechoBGColor} est appelée pour colorier le fond de la zone de texte où la première ligne de caractères est affichée.
                        \end{justify}\setlength{\parskip}{1em}

                        \begin{justify}
                            \textbf{\color{brick}Sinon, si} l'un des chiffres de ce nombre à trois chiffres est égal à \textbf{2}, \textbf{\color{brick}alors} la fonction \textbf{\color{mauve}BU::DechoBGColor} est appelée pour colorier le fond de la zone de texte où la chaîne de caractères principale est affichée.
                        \end{justify}\setlength{\parskip}{1em}

                        \begin{justify}
                            \textbf{\color{brick}Sinon, si} l'un des chiffres de ce nombre à trois chiffres est égal à \textbf{3}, \textbf{\color{brick}alors} la fonction \textbf{\color{mauve}BU::DechoBGColor} est appelée pour coloriee le fond de la zone de texte où la seconde ligne de caractères est affichée.
                        \end{justify}\setlength{\parskip}{1em}

                        \begin{justify}
                            \textbf{\color{brick}Sinon, si} l'un des chiffres de ce nombre à trois chiffres n'est pas égal à l'une des trois valeurs attendues, \textbf{\color{brick}Sinon, si} un message d'avertissement est affiché sur la zone de texte.
                        \end{justify}\setlength{\parskip}{1em}

                        \begin{justify}
                            \textbf{\color{brick}Fin de la condition}.
                        \end{justify}
                    }
                \end{itemize}

                \begin{justify}
                    \textbf{\color{cyan}Fin de la boucle « pour »}.
                \end{justify}
            }
        \end{justify}

        \item
        {
            \begin{justify}
                \textbf{\color{brick}Sinon, si} un nombre entier positif est passé à ce paramètre \textbf{ET} que sa longueur est supérieure à trois chiffres, \textbf{\color{brick}alors} un message d'avertissement est affiché sur la zone de texte.
            \end{justify}\setlength{\parskip}{1em}

            \begin{justify}
                \textbf{\color{brick}Sinon, si} aucune valeur n'est passée à ce paramètre, \textbf{\color{brick}alors} un message d'avertissement est affiché sur la zone de texte.
            \end{justify}

            \begin{justify}
                \textbf{\color{brick}Sinon, si} une valeur inattendue est passée à ce paramètre, \textbf{\color{brick}alors} un message d'avertissement est affiché sur la zone de texte.
            \end{justify}

            \begin{justify}
                \textbf{\color{brick}Fin de la condition}.
            \end{justify}
        }
    }
\end{itemize}

\begin{justify}
    \textbf{\color{brick}Fin de la condition}.
\end{justify}\setlength{\parskip}{2em}


\begin{justify}
    Une fois le header (ou un message d'avertissement affiché), un saut de ligne est effectué, puis le script se met en pause pendant le nombre de secondes défini par la valeur enregistrée dans la variable globale de statut \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_TIME\_HEADER}.
\end{justify}\setlength{\parskip}{1em}

\begin{justify}
    Finalement, les valeurs des deux variables globales de statut \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_TIME\_NEWLINE} et \textbf{\color{orange}\$\_\_BU\_MAIN\_STAT\_TIME\_TXT}, modifiées au début de la fonction, sont restaurées.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\[1\baselineskip]
    Appelez cette fonction pour afficher un texte entre deux lignes, pour marquer une séparation entre plusieurs étapes de votre script, et pour davantage personnaliser cet affichage si vous ne trouvez pas votre compte parmi les fonctions proposées dans les sous-sections suivantes : \textbf{\color{green}Headers unicolores} et \textbf{\color{green}Headers multicolores}.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers unicolores}\color{white}

\begin{justify}
    \textbf{Description :}
    Chacune de ces fonctions appelle la fonction \textbf{\color{mauve}BU::HeaderBase}, en lui passant ses trois premiers arguments prédéfinis.
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Paramètres positionnels :}\\[1\baselineskip]
    \begin{tabular}{|l|l|}
        \hline
        \textbf{\color{orange}\$1} & Chaîne de caractères\\
        \hline
        \textbf{\color{orange}\$2} & Chaîne de caractères « strlen »\\
        \hline
        \textbf{\color{orange}\$3} & Substitution de commande\\
        \hline
        \textbf{\color{orange}\$4} & Nombre entier « 1 », « 2 » et / ou « 3 »\\
        \hline
    \end{tabular}
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Fonctionnement :}\\[1\baselineskip]
    Chacune des fonctions de cette catégorie appelle la fonction \textbf{\color{mauve}BU::HeaderBase}, en lui passant en premier et troisième arguments une même substitution de commande (\textbf{\color{orange}\$\_\_BU\_MAIN\_COLOR...}), puis un caractère défini par la variable \textbf{\color{orange}\$\_\_BU\_MAIN\_TXT\_CHAR\_HEADER\_LINE} en deuxième argument.
\end{justify}

\begin{justify}
    Vient enfin le passage des valeurs des paramètres positionnels : la chaîne de caractères à afficher (\textbf{\color{orange}\$1}), la chaîne de caractères \textbf{strlen} (\textbf{\color{orange}\$2}), la substitution de commande colorant l'arrière plan du texte (\textbf{\color{orange}\$3}) et la position de la ligne à colorer (\textbf{\color{orange}\$4}).
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    \textbf{Utilisation :}\\[1\baselineskip]
    Appelez une de ces fonctions pour marquer une séparation entre plusieurs étapes de votre script, tout en affichant un header unicolore sans avoir à passer ses trois premiers arguments.
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers bicolores}\color{white}

\begin{justify}
    \textbf{Note :} En raison du trop grand nombre de fonctions à déclarer, plus aucune nouvelle couleur ne sera officiellement ajoutée parmi les 23 couleurs actuelles (qui représentent en tout plus de 500 fonctions déclarées rien que dans ce fichier de librairie).
\end{justify}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{justify}
    Pour davantage faciliter la tâche des développeurs, des fonctions de création de headers bicolores existent.
\end{justify}

\begin{justify}
    Chaque fonction porte le nom de la couleur à afficher sur chaque ligne, puis le nom de la couleur à appliquer au texte.
\end{justify}

\begin{justify}
    Elles fonctionnent chacune de la même manière que les fonctions de la catégorie précédente, à deux exceptions près :

    \begin{itemize}
        \item \textbf{le nom des fonctions et des variables :} Il n'y a pas de fonction portant deux fois le nom de la même couleur, ni d'appels double des mêmes variables, car le résultat et le rendu seraient le même que celui des fonctions de la sous-catégorie précédente.\setlength{\parskip}{1em}
    \end{itemize}
\end{justify}


% -----------------------

% -----------------------------------------------

\color{green}\par\noindent\rule{\textwidth}{0.4pt}\color{white}

\color{green}
\subsection{Headers tricolores}\color{white}

\begin{justify}
    Étant donné la charge de travail nécessaire pour créer ces headers, il serait beaucoup trop fastidieux de créer tous ces headers prédéfinis.
\end{justify}

\begin{justify}
    Pour vous donner une idée de la quantité de travail, prenez la formule mathématique suivante :
\end{justify}

\[nbcol * (nbcol - 1) * nbcol\]

\begin{justify}
    Où nbcol = nombre de codes couleurs disponibles.
\end{justify}

\begin{justify}
    Au moment où j'ai écrit cette partie de la documentation (dimanche 29 août 2021), il existait 12 codes couleurs disponibles.
\end{justify}

\begin{justify}
    En effectuant le calcul précédent, nous obtenons donc \textbf{12 * 11 * 12 = 1 584 combinaisons possibles}, sans parler de l'ajout d'éventuels nouveaux codes couleurs.
\end{justify}

\begin{justify}
    Il faudra donc se contenter d'appeler la fonction \textbf{\color{mauve}BU::HeaderBase}, suivie de ses 4 arguments, dont chaque valeur sera différente des autres.
\end{justify}

\end{document}

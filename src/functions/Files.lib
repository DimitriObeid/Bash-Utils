#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT FILES PROCESSING FUNCTIONS

# Separate processing steps displays from the rest of the main script with a line.

# Featured functions and files from the "functions" folder :
#   - DrawLine      -> Headers.lib
#   - HandleErrors  -> Headers.lib
function ProcessingFile
{
    #***** Parameters *****
    function=$1
    
    #***** Variables *****
    char="'"
    
    #***** Code *****
    # On commence par dessiner la première ligne du bloc.
	sleep "$PROJECT_STATUS_SLEEP_LINE"
    DrawLine "$COL_RESET" "$char"
    
    EchoNewstep "$MSG_FILE_PROCESSING_BEGIN"
    Newline
    
    if $("$function"); then
        EchoSuccess "$MSG_FILE_PROCESSING_END_SUCC"
		DrawLine "$COL_RESET" "$char"
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		Newline
    else
        EchoError "$MSG_FILE_PROCESSING_END_FAIL"
		DrawLine "$COL_RESET" "$char"
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		Newline
    fi
}

## OVERWRITING CONTENT

# Overwrite a file

# Required functions and files from the "functions" folder :
#	- EchoError			-> Echo.lib
#	- EchoNewstep		-> Echo.lib
#	- EchoSuccess		-> Echo.lib
#	- Newline			-> Echo.lib
function OverwriteFile
{
    #***** Parameters *****
    path=$1
    
    #***** Code *****
    EchoNewstep "$MSG_FILE_NONEMPTY_1."
	EchoNewstep "$MSG_FILE_NONEMPTY_2."
	Newline

	if true > "$path"; then
		EchoSuccess "$MSG_FILE_NONEMPTY_SUCC."
		Newline

		EchoSuccess "$MSG_FILE_PROCESSING_END_SUCC."
		DrawLine "$COL_RESET" "$block_char"
    else
        EchoError "$MSG_FILE_NONEMPTY_FAIL."
		Newline
    fi
}

# -----------------------------------------------

## FILE CREATION

# File creation function.
# LORS DE SON APPEL, LA SORTIE DE CETTE FONCTION DOIT ÊTRE REDIRIGÉE SOIT VERS LE TERMINAL ET LE FICHIER DE LOGS, SOIT VERS LE FICHIER DE LOGS UNIQUEMENT.

# Required files and functions :
#   - Echo.sh       -> EchoErrorTimer
#   - Echo.sh       -> EchoNewstepTimer
#   - Echo.sh       -> EchoSuccessTimer
#   - Headers.sh    -> DrawLine   
#   - Headers.sh    -> HandleErrors
function Makefile
{
	#***** Paramètres *****
	local parent=$1		# Emplacement depuis la racine du dossier parent du fichier à traiter.
	local name=$2		# Nom du fichier à traiter (dans son dossier parent).
	local sleep_blk=$3	# Temps de pause du script avant et après la création d'un bloc d'informations sur le traitement du fichier.
	local sleep_txt=$4	# Temps d'affichage des messages de passage à une nouvelle sous-étape, d'échec ou de succès.

	#***** Autres variables *****
	local path="$parent/$name"	# Chemin du fichier à traiter.
	local block_char="'"		# Caractère composant la ligne.

	#***** Code *****
	# On commence par dessiner la première ligne du bloc.
	sleep "$sleep_blk"
	DrawLine "$COL_RESET" "$block_char"

	EchoNewstep "$MSG_FILE_PROCESSING_BEGIN."
	Newline

	# Si le fichier à traiter n'existe pas, on le crée avec l'aide de la commande "touch".
	if [ ! -f "$path" ]; then
        EchoNewstep "$MSG_FILE_MKFILE_CREATE."
		Newline

		touch "$path"
        # On vérifie que le fichier a bien été créé en vérifiant le code de retour de la commande "touch" via la fonction "HandleErrors".
        # Une erreur peut venir du fait que l'utilisateur n'a pas lancé son script en mode super-utilisateur, script qui a tenté de créer un fichier
        # dans un dossier où l'utilisateur n'a pas le droit de créer un fichier sans privilèges du super-utilisateur
        HandleErrors "$?" "$MSG_FILE_MKFILE_FAIL" "" "$lineno"
        EchoSuccess "$MSG_FILE_MKFILE_SUCCESS."
        Newline
	
	# Sinon, si le fichier à créer existe déjà ET qu'il n'est pas vide.
	elif [ -f "$path" ] && [ -s "$path" ]; then
        OverwriteFile "$path"
		return

	# Sinon, si le fichier à créer existe déjà ET qu'il est vide.
	elif [ -f "$path" ] && [ ! -s "$path" ]; then
		EchoSuccess "$MSG_MKFILE_EMPTY."
		Newline

		EchoSuccess "$MSG_MKFILE_PROCESSING_END_SUCC."
		DrawLine "$COL_RESET" "$block_char"

		return
	fi
}

# -----------------------------------------------

## TEXT FILES PARSING

# Getting a specific line from a text file.
function GetLineFromTextFile
{
    #***** Parameters *****
    source=$1   # File to parse
    line=$2     # Line to get
    
    #***** Variables *****
    i=0     # Line incrementer
    
    #***** Code *****
    cat "$source" | while read -r line; do
        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ))
        
        # ... until it reaches the wanted line.
        if [ "$i" -eq "$line" ]; then
            # Creating a variable and storing the line's text.
            FILE_GETTXTLINE="$line"
        fi
    done
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS

## (UN)COMPRESSION FUNCTIONS

# Décompression des archives des logiciels selon la méthode de compression utilisée (voir la fonction "SoftwareInstall").
function Uncompress
{
    #***** Paramètres *****
    cmd=$1     # Commande de décompression propre à une méthode de compression.
    # TODO : Vérifier si cette procédure est bonne
    option=$2  # Option de la commande de décompression (dans le cas où l'appel d'une option n'est pas obligatoire, laisser une chaîne de caractères vide lors de l'appel de la fonction).
    path=$3    # Chemin vers l'archive à décompresser.
    name=$4    # Nom de l'archive.

    #***** Code *****
    # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
    "$cmd $option $path"

    HandleErrors "$?" "LA DÉCOMPRESSION DE L'ARCHIVE $(DechoE "$name") A ÉCHOUÉE"
    
    EchoSuccess "La décompression de l'archive $(DechoS "$name") s'est effectuée avec brio."
    Newline
}

function Compress
{
    #***** Parameters *****
    
    #***** Code *****
    
    
    return
}

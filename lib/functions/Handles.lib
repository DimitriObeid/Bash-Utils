#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CHECKING FOR IDENTIFIANTS

## EFFECTIVE USER IDENTIFIANTS CHECKING

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID)

# Required functions and files :
#   - HandleErrors      -> Bash-Utils/src/functions/Headers.lib
function CheckRootEUID
{
    if [ "$EUID" -ne 0 ]; then
        HandleErrors "1" "Error : you need root user's privileges to perform this action." ""
    fi
}


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CHECKING TEXTS

## COLOR CHECKINGS

# Checking line colors
function CheckLineColor
{
    #***** Parameters *****
    color_code=$1

    #***** Code *****
    if [ "$color_code" != "$(tput sgr0)" ]; then
        echo "$(tput setaf 196)Error :$(tput sgr0) the \"tput\" command's option is not \"sgr0\"."; echo
        exit 1
    elif [ "$color_code" -lt 0 ] && [ "$color_code" -gt 0 ]; then
        echo "$(tput setaf 196)Error :$(tput sgr0) the \"tput setaf\" command's value is incorrect."; echo
        exit 1
    else
        echo "$(tput setaf 196)Error :$(tput sgr0) the \"tput\" command's option is incorrect."; echo
        exit 1
    fi
}

# Checking the " variable's value.
function CheckTextColor
{
    #***** Parameters *****
    opt=$1
    color_code=$2

    #***** Code *****
    if [ -n "$opt" ]; then
        if [ "$opt" = "setaf" ] ; then
            if [[ "$color_code" =~ ^([0-9]+\.?|[0-9]*\.[0-9]+)$ ]]; then
                if [ "$color_code" -lt 0 ] || [ "$color_code" -gt 255 ]; then
                    echo "$(tput setaf 196)Error :$(tput sgr0) the \"tput setaf\" command's value is incorrect."
                    echo "The $(tput setaf 6)tput setaf$(tput sgr0) option's value range is $(tput setaf 6) 0 - 255 $(tput sgr0)"; exit 1
                fi
            else
                echo "$(tput setaf 196)Error :$(tput sgr0) the \"$(tput setaf 6)tput setaf$(tput sgr0) option's value\" is not a number."; exit 1
            fi

        elif [ "$opt" != "sgr0" ]; then
            echo "$(tput setaf 196)Error :$(tput sgr0) the \"tput\" command's option is incorrect."; exit 1
        fi
    else
        echo "$(tput setaf 196)Error :$(tput sgr0) no value passed as \"tput\" command's option argument"; exit 1
    fi
}


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## FILE PATHS CHECKING

# Checking for "$PROJECT_LOG_PATH"

# Required functions and files :
function CheckProjectLogPath
{
    if [ -z "$PROJECT_LOG_PATH" ]; then
        EchoError "$TXT_RED_TAB Error : no path provided into the PROJECT_LOG_PATH variable.$COL_RESET"; echo;
        exit 1
    fi
}

# Checking for project's log file's status, then write
function CheckProjectLogStatus
{
    #***** Parameters *****
    string=$1

    #**** Code *****
    CheckSTAT_LOG
    CheckSTAT_LOG_REDIRECT
    CheckProjectLogPath
    CheckSTAT_TIME_HEADER
    CheckSTAT_TIME_LINE
    CheckSTAT_TIME_TXT
    
    if [ "$PROJECT_STATUS_LOG" = "true" ] && [ -n "$STAT_LOG_REDIRECT" ]; then
        if [ "$STAT_LOG_REDIRECT" = "log" ] || [ "$STAT_LOG_REDIRECT" -eq 1 ]; then
            echo "[$TIME_DATE] $string" >> "$PROJECT_LOG_PATH" || \
                { echo "$(ColorChar "setaf" "$COL_RED") Unable to write into the $PROJECT_LOG_PATH file$(ColorChar "sgr0")"; exit 1; }
        elif [ "$STAT_LOG_REDIRECT" = "tee" ] || [ "$STAT_LOG_REDIRECT" -eq 2 ]; then
            echo "$string"
            echo "[$TIME_DATE] $string" >> "$PROJECT_LOG_PATH" || \
                { echo "$(ColorChar "setaf" "$COL_RED") Unable to write into the $PROJECT_LOG_PATH file$(ColorChar "sgr0")"; exit 1; }
        fi
    else
        echo "$string"
    fi
}

# -----------------------------------------------

## ERROR HANDLING FUNCTIONS

# Handling command outputs.
function HandleErrors
{
	#***** Paramètres *****
	local return_code=$1       # Code de retour de la dernière commande lancée
	local error_string=$2      # Chaîne de caractères du type d'erreur à afficher.
	local advice_string=$3     # Chaîne de caractères affichants un conseil pour orienter l'utilisateur vers la meilleure solution en cas de problème.
    local lineno=$4            # Ligne à laquelle le message d'erreur s'est produite.

	# ***** Code *****
	CheckSTAT_ERROR
	
	if [ "$return_code" -eq 0 ]; then
        return
    else
        if [ -n "$STAT_ERROR" ] && [ "$STAT_ERROR" = "fatal" ]; then
            HeaderBase "$COL_RED" "-" "$COL_RED" "FATAL ERROR : $(Decho "${error_string^^}")"

            EchoError "A fatal error occured :"
            EchoError "$error_string"
            Newline

            if [ -z "$advice_string" ]; then
                EchoError "No advice to give."
                Newline
            else
                EchoError "$advice_string"
                Newline
            fi
            
            if [ -z "$lineno" ]; then
                false
            else
                EchoError "The fatal error in question occurred in the line $(DechoE "$lineno")."
                Newline
            fi
                
            EchoError "Stopping the execution of $(DechoE "$(basename "$0")")."
            Newline

            exit 1
        elif [ -z "$STAT_ERROR" ]; then
            HeaderBase "$(ColorChar "setaf" "$COL_RED") "-" "$(ColorChar "$COL_RED" "$COL_RED") "ERROR : ${error_string^^}"
            
            EchoError "An error occured !"
            EchoError "$error_string"
            Newline
            
            if [ -z "$advice_string" ]; then
                EchoError "No advice to give."
                Newline
            else
                EchoError "$advice_string"
                Newline
            fi
            
            if [ -z "$lineno" ]; then
                false
            else
                EchoError "The error in question occurred in the line $(DechE "$lineno")."
                Newline
            fi
            
            EchoNewstep "Do you want to stop the execution of $(DechoE "$(basename "$0")") ? $(DechoN "(yes/no)")"
            Newline
            
            function ReadExitScript
            {
                read -rp "Enter your answer : " ans_exit_script
            
                case ${ans_exit_script,,} in
                    "yes")
                            EchoError "Aborting script execution."
                            Newline
                            
                            exit 1
                        ;;
                    "no")
                        EchoSuccess "Resuming script execution.s"
                        Newline
                        
                        # In case a "non-fatal" error occured in a function passed in argument while calling the "ProcessingDir" or the "ProcessingFile" functions.
                        return 1
                        ;;
                    *)
                        EchoError "Please enter a valid answer : $(DechoE "yes") or $(DechoE "no")."
                        ;;
                esac
            }
        else
            EchoError
        fi
    fi
}

#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CHECKING FOR IDENTIFIANTS

## EFFECTIVE USER IDENTIFIANTS CHECKING

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID)

# Required functions and files :
#   - HandleErrors      -> Bash-Utils/src/functions/Headers.lib
function CheckRootEUID
{
    if [ "$EUID" -ne 0 ]; then
        HandleErrors "1" "Error : you need root user's privileges to perform this action." ""
    fi
}


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CHECKING TEXTS

## COLOR CHECKINGS

# Checking line colors

# I'm not sure if i'll keep this function.
function CheckLineColor
{
    #***** Parameters *****
    p_colorCode=$1

    #***** Code *****
    if [ "$p_colorCode" != "$(tput sgr0)" ]; then
        echo "$(tput setaf 196)Error :$(tput sgr0) the $(tput setaf "$COL_CYAN")tput$(tput sgr0) command's option is not $(tput setaf "$COL_CYAN")sgr0$(tput sgr0)."; echo
        exit 1
    elif [ "$p_colorCode" -lt 0 ] && [ "$p_colorCode" -gt 0 ]; then
        echo "$(tput setaf 196)Error :$(tput sgr0) the $(tput setaf "$COL_CYAN")tput setaf$(tput sgr0) command's value is incorrect."; echo
        exit 1
    else
        echo "$(tput setaf 196)Error :$(tput sgr0) the $(tput setaf "$COL_CYAN")tput$(tput sgr0) command's option is incorrect."; echo
        exit 1
    fi
}

# Checking the " variable's value.
function CheckTextColor
{
    #***** Parameters *****
    p_option=$1
    p_colorCode=$2
    
    #***** Variables *****
    v_colCyan="$(tput setaf 6)"
    v_colRed="$(tput setaf 196)"
    v_string="$(tput setaf 196)IN $v_colCyan$(basename "${BASH_SOURCE[0]}")$v_colRed, FUNCTION $v_colCyan${FUNCNAME[0]}$v_colRed --> Error :"
    v_colReset="$(tput sgr0)"

    #***** Code *****
    # Spacing the conditions to make the code cleaner.
    if [ -n "$p_option" ]; then

        if [ "$p_option" = "setaf" ] ; then

            if [[ "$p_colorCode" =~ ^([0-9]+\.?|[0-9]*\.[0-9]+)$ ]]; then

                if [ "$p_colorCode" -lt 0 ] || [ "$p_colorCode" -gt 255 ]; then

                    echo "$v_string the$v_colCyan tput setaf$v_colRed command's value is incorrect." >&2

                    echo "The$col_cyan tput setaf$col_red option's value range is $v_colCyan 0 - 255 $v_colReset" >&2

                    echo >&2; ExitSourced
                fi
    
            else
                echo "$v_string the$v_colCyan tput setaf$v_colRed option's value is not a number.$v_colReset" >&2; echo >&2; ExitSourced
            fi

        elif [ "$p_option" != "sgr0" ]; then
            echo "$v_string the$v_colCyan tput$v_colRed command's option is incorrect.$v_colReset" >&2; echo >&2; ExitSourced
        fi
        
    else
        echo "$v_string no value passed as$col_cyan tput$v_colRed command's option argument$v_colReset" >&2; echo >&2; ExitSourced
    fi
}


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## FILE PATHS CHECKING

# Checking for "$PROJECT_LOG_PATH"

# Required functions and files :
function CheckProjectLogPath
{
    if [ -z "$PROJECT_LOG_PATH" ]; then
        echo "$(tput setaf "$COL_RED") Error : no path provided into the PROJECT_LOG_PATH variable.$(tput sgr0)" >&2
        echo >&2; ExitSourced
    fi
}

# Checking for project's log file's status, then write
function CheckProjectLogStatus
{
    #***** Parameters *****
    p_string=$1

    #**** Code *****
    CheckSTAT_LOG
    CheckSTAT_LOG_REDIRECT
    CheckProjectLogPath
    CheckSTAT_TIME_HEADER
    CheckSTAT_TIME_LINE
    CheckSTAT_TIME_TXT
    
    if [ "$PROJECT_STATUS_LOG" = "true" ] && [ -n "$STAT_LOG_REDIRECT" ]; then
        if [ "$STAT_LOG_REDIRECT" = "log" ] || [ "$STAT_LOG_REDIRECT" -eq 1 ]; then
            echo "[$TIME_DATE] $p_string" >> "$PROJECT_LOG_PATH" || \
                { echo "$(ColorChar "setaf" "$COL_RED") Unable to write into the $PROJECT_LOG_PATH file$(ColorChar "sgr0")" >&2; echo >&2; ExitSourced; }
        elif [ "$STAT_LOG_REDIRECT" = "tee" ] || [ "$STAT_LOG_REDIRECT" -eq 2 ]; then
            echo "$p_string"
            echo "[$TIME_DATE] $p_string" >> "$PROJECT_LOG_PATH" || \
                { echo "$(ColorChar "setaf" "$COL_RED") Unable to write into the $PROJECT_LOG_PATH file$(ColorChar "sgr0")" >&2; echo >&2; ExitSourced; }
        fi
    else
        echo "$p_string"
    fi
}

# -----------------------------------------------

## ERROR HANDLING FUNCTIONS

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function ExitSourced { kill "$$"; }

# Handling command outputs.
function HandleErrors
{
	#***** Paramètres *****
	p_returnCode=$1     # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	p_errorString=$2    # Chaîne de caractères du type d'erreur à afficher.
	p_adviceString=$3   # Chaîne de caractères affichants un conseil pour orienter l'utilisateur vers la meilleure solution en cas de problème.
	p_file=$4            # The name of the file where the error occured.
	p_function=$5        # The name of the function where the error occured.
	p_lineno=$6          # Ligne à laquelle le message d'erreur s'est produite.

    #***** Variables *****
    v_headerString="IN $(DechoE "$p_file"), FUNCTION $(DechoE "$p_function"), LINE $(DechoE "$p_lineno") -->"

	# ***** Code *****
	CheckSTAT_ERROR
	
	if [ "$p_returnCode" -eq 0 ]; then
        return
    else
        if [ -n "$STAT_ERROR" ] && [ "$STAT_ERROR" = "fatal" ]; then
            HeaderRed "$v_headerString FATAL ERROR : $(DechoE "${p_errorString^^}")" >&2

            if [ -z "$p_adviceString" ]; then
                EchoError "No advice to give." >&2
                Newline >&2
            else
                EchoError "Advice : $p_adviceString" >&2
                Newline >&2
            fi
            
            EchoError "STAT_ERROR status : $STAT_ERROR" >&2
            Newline >&2
                
            EchoError "Stopping the execution of $(DechoE "$(basename "$0")")." >&2
            Newline >&2

            exit 1

        elif [ -z "$STAT_ERROR" ]; then
            HeaderRed "$v_headerString FATAL ERROR : $(DechoE "${p_errorString^^}")" >&2

            if [ -z "$p_adviceString" ]; then
                EchoError "No advice to give." >&2
                Newline >&2
            else
                EchoError "Advice : $p_adviceString" >&2
                Newline >&2
            fi
            
            KbInputYesNo "Do you want to stop the execution of $(DechoE "$(basename "$0")") ? $(DechoN "(yes/no)")" \
                "$(echo "Aborting script execution." && exit 1)" \
                "Resuming script execution." >&2
        fi
    fi
}

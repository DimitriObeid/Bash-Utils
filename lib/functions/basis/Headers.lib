#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FUNCTIONS WITHOUT REDIRECTIONS TOWARDS A LOG FILE

## DÉFINITION DES FONCTIONS DE CRÉATION DE HEADERS

# Fonction de création et d'affichage de lignes selon le nombre de colonnes de la zone de texte du terminal.
function DrawLine
{
	#***** Parameters *****
	p_lineColor=$1	# Deuxième paramètre servant à définir la couleur souhaitée du caractère lors de l'appel de la fonction.
	p_lineChar=$2	# Premier paramètre servant à définir le caractère souhaité lors de l'appel de la fonction.

	#***** Variables *****
	v_statTimeTxt="0.0003"
	
	#***** Code *****
	# As the line drawing program is using the same timer than the text displaying pause, the sleeping time must be reduced drastically,
	# or else, the drawing time will be very long, as this pause time will apply for each line character written.
	if [ "$STAT_LOG_REDIRECT" != "log" ] && [ "$STAT_TIME_TXT" != "$v_statTimeTxt" ]; then
        OLD_STAT_TIME_TXT="$STAT_TIME_TXT"
        STAT_TIME_TXT="$v_statTimeTxt"
    fi

    # Defining the color of the wished character for the whole line before displaying the first character.
    # If the value of the "$p_lineColor" parameter (which stores the text's color encoding) is not empty,
    # then we write the color's encoding into the terminal, which displays the color, and not its encoding in text.
    
    # The color's encoding can be written via the "tput setaf $value" command. The line is empty before the first
    # ASCII characters if the first parameter "$p_lineColor" is passed as an empty string, which means that no
    # "tput setaf $value" command was executed.

    # Since we want to write the characters composing the header line after the color encoding string, we use the options
	# '-n' (no line breaks) and '-e' (interpret backslashes) of the "echo" command to avoid making a line break after the
	# end of the string, to write the next string directly after the line.
    
	# Since all the columns in the row are used, the following characters will be written in the row, as if a line break has been made.
	if test "$p_lineColor" != ""; then
		echo -ne "$p_lineColor"
	fi

    # Displaying the desired character on the whole line. To do this, using a "for" loop, we start reading it from
	# the first column (1), then we read the entire line to the end of the terminal's text box. At each call
	# of the "echo" command, a character is displayed and colored according to the encoding defined and written above.
	
	# La variable 'i' de la boucle "for i in" a été remplacée par un underscore '_' pour que Shellcheck arrête d'envoyer un message d'avertissement
	# ("warning") en raison de la non-déclaration de la variable 'i', bien que cela ne change strictement rien lors de l'exécution du script.
	
	# The 'i' variable in the "for i in" loop has been replaced by an underscore '_' to stop Shellcheck from sending a warning
	# message due to the non-declaration of the variable 'i', although this does not change anything when the script is executed.
	for _ in $(eval echo "{1..$TXT_COLS}"); do
		echo -n "$p_lineChar"
	done

    # Definition (here, reinitialization) of the color of the characters following the last character of the header line
	# using the same code snippet as the first condition, to write the terminal's base color encoding (it is recommended 
	# to call the "tput sgr0" command to reset the color according to the profile options of the terminal).
	# As with any color encoding, this plain text will not be displayed on the terminal.

	# En pratique, La couleur des caractères suivants est déjà encodée quand ils sont appelés via une des fonctions d'affichage.
	# Cette réinitialisation de la couleur du texte n'est qu'une mini-sécurité permettant d'éviter d'avoir la couleur de l'invite de
	# commandes encodée avec la couleur des headers si l'exécution du script est interrompue de force avec la combinaison "CTRL + C"
	# ou mise en pause avec la combinaison "CTRL + Z", par exemple.
	if test "$p_lineColor" != ""; then
        echo -ne "$COL_RESET"
	fi

	# Étant donné que l'on a utilisé l'option '-n' de la commande "echo", on effectue un saut de ligne pour éviter d'avoir à le répéter après chaque appel de la commande pour laisser un espace vide entre la ligne et le prochain caractère.
	echo
	
	if [ "$STAT_LOG_REDIRECT" != "log" ] && [ "$STAT_TIME_TXT" = "$v_statTimeTxt" ]; then
        STAT_TIME_TXT="$OLD_STAT_TIME_TXT"
    fi

	return
}

# Fonction de création de base d'un header (Couleur et caractère de ligne, couleur et chaîne de caractères).
function HeaderBase
{
	#***** Parameters *****
	p_lineColor=$1      # Deuxième paramètre servant à définir la couleur souhaitée du caractère lors de l'appel de la fonction.
	p_lineChar=$2       # Premier paramètre servant à définir le caractère souhaité lors de l'appel de la fonction.
	p_stringColor=$3	   # Définition de la couleur de la chaîne de caractères du header.
	p_stringTxt=$4      # Chaîne de caractères affichée dans chaque header.
	
	# Le problème vient d'ici, c'est parce que la variable "string" d'ici porte le même nom que l'argument de la fonction cible.
	# TODO : vérifier comment outrepasser ceci sans modifier le nom de la variable quand je serai de nouveau connecté.
	
	#***** Variables *****
	HEADERBASE_COLOR_LINE="$p_lineColor"
	HEADERBASE_COLOR_TEXT="$p_stringColor"
	
	#***** Code *****
	Newline
	
	EchoMsg "$(DrawLine "$(tput setaf "$p_lineColor")" "$p_lineChar")"
	EchoMsg "$(tput setaf "$p_stringColor")##> $p_stringTxt$COL_RESET"
	EchoMsg "$(DrawLine "$(tput setaf "$p_lineColor")" "$p_lineChar")"
	Newline

	return
}

# Header display function when changing step.
function HeaderStep { HeaderBase "$(tput setaf "$COL_CYAN")" "-" "$(tput setaf "$COL_CYAN")" "$1"; }

# Header display function when switching to a new package category during package installation.
function HeaderInstall { HeaderBase "$(tput setaf "$COL_YELLOW")" "-" "$(tput setaf "$COL_GREEN")" "$1"; }

# -----------------------------------------------

## UNICOLOR HEADERS

# Copy-paste this function to avoid losing time while creating unicolor headers :
# function Header<col> { HeaderBase "$COL_"" "-" "$COL_"" "$1"; }

function HeaderBlue { HeaderBase "$COL_BLUE" "-" "$COL_BLUE" "$1"; }
function HeaderCyan { HeaderBase "$COL_CYAN" "-" "$COL_CYAN" "$1"; }
function HeaderGreen { HeaderBase "$COL_GREEN" "-" "$COL_GREEN" "$1"; }
function HeaderRed { HeaderBase "$COL_RED" "-" "$COL_RED" "$1"; }
function HeaderYellow { HeaderBase "$COL_YELLOW" "-" "$COL_YELLOW" "$1"; }

# -----------------------------------------------

## BICOLOR HEADERS

# Copy-paste this function to avoid losing time while creating multicolor headers :
# function Header<col1><col2> { HeaderBase "$COL_" "-" "$COL_" "$1"; }

# Blue lines, differently colored text.
function HeaderBlueCyan { HeaderBase "$COL_BLUE" "-" "$COL_CYAN" "$1"; }
function HeaderBlueGreen { HeaderBase "$COL_BLUE" "-" "$COL_GREEN" "$1"; }
function HeaderBlueRed { HeaderBase "$COL_BLUE" "-" "$COL_RED" "$1"; }
function HeaderBlueYellow { HeaderBase "$COL_BLUE" "-" "$COL_YELLOW" "$1"; }

# Cyan lines, differently colored text.
function HeaderCyanBlue { HeaderBase "$COL_CYAN" "-" "$COL_BLUE" "$1"; }
function HeaderCyanGreen { HeaderBase "$COL_CYAN" "-" "$COL_GREEN" "$1"; }
function HeaderCyanRed { HeaderBase "$COL_CYAN" "-" "$COL_RED" "$1"; }
function HeaderCyanYellow { HeaderBase "$COL_CYAN" "-" "$COL_YELLOW" "$1"; }

# Green lines, differently colored text.
function HeaderGreenBlue { HeaderBase "$COL_GREEN" "-" "$COL_BLUE" "$1"; }
function HeaderGreenCyan { HeaderBase "$COL_GREEN" "-" "$COL_CYAN" "$1"; }
function HeaderGreenRed { HeaderBase "$COL_GREEN" "-" "$COL_RED" "$1"; }
function HeaderGreenYellow { HeaderBase "$COL_GREEN" "-" "$COL_YELLOW" "$1"; }

# Purple lines, differently colored text
function HeaderPurpleBlue { HeaderBase "$COL_PURPLE" "-" "$COL_BLUE" "$1"; }

# Red lines, differently colored text.
function HeaderRedBlue { HeaderBase "$COL_RED" "-" "$COL_BLUE" "$1"; }
function HeaderRedCyan { HeaderBase "$COL_RED" "-" "$COL_CYAN" "$1"; }
function HeaderRedGreen { HeaderBase "$COL_RED" "-" "$COL_GREEN" "$1"; }
function HeaderRedYellow { HeaderBase "$COL_RED" "-" "$COL_YELLOW" "$1"; }

# Yellow lines, differently colored text.
function HeaderYellowBlue { HeaderBase "$COL_YELLOW" "-" "$COL_BLUE" "$1"; }
function HeaderYellowCyan { HeaderBase "$COL_YELLOW" "-" "$COL_CYAN" "$1"; }
function HeaderYellowGreen { HeaderBase "$COL_YELLOW" "-" "$COL_GREEN" "$1"; }
function HeaderYellowRed { HeaderBase "$COL_YELLOW" "-" "$COL_RED" "$1"; }

#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION

## WRITING DIFFERENTLY COLORED TEXT BETWEEN TEXT

# Text's inside decoration procssing.

# Usage :
#	Decho "<Text to write>" "${__BU_COLOR_<TO_DISPLAY>}"
 
# Featured functions and files from the "functions" folder : none
function Decho
{
    #***** Parameters *****
    local p_string=$1
    local p_newColor=$2

    #***** Variables *****
    if [ ! -f "$__PROJECT_COLOR_CODE_FILE_PATH" ]; then
        echo "${__BU_COLOR_RESET}" >&2
		echo "${__BU_COLOR_WARNING}Warning ! The ${__BU_COLOR_HIGHLIGHT}$__BASH_UTILS_FILE_COLOR_CODE_PATH${__BU_COLOR_WARNING} temporary file doesn't exists !${__BU_COLOR_RESET}" >&2
		
		return 1
    else
        local v_oldColor
            v_oldColor="$(cat "$__PROJECT_COLOR_CODE_FILE_PATH")"
    fi

    #***** Code *****
    if [ "$p_newColor" = "$v_oldColor" ]; then
		p_newColor="$(( p_newColor+2 ))"
		tput setaf "$p_newColor"
	fi

	echo -e "$(tput setaf "$p_newColor")$p_string$(tput setaf "$v_oldColor")" && IsInt "$v_oldColor" && echo "$v_oldColor" > "$__BASH_UTILS_FILE_COLOR_CODE_PATH"
}

# Easy "Decho()" function call.
function DechoHighlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"; }
function DechoBlue 		{ Decho "$1" "$__BU_COLOR_BLUE"; }
function DechoCyan 		{ Decho "$1" "$__BU_COLOR_CYAN"; }
function DechoGreen 	{ Decho "$1" "$__BU_COLOR_GREEN"; }
function DechoOrange 	{ Decho "$1" "$__BU_COLOR_ORANGE"; }
function DechoPurple 	{ Decho "$1" "$__BU_COLOR_PURPLE"; }
function DechoRed		{ Decho "$1" "$__BU_COLOR_RED"; }
function DechoYellow 	{ Decho "$1" "$__BU_COLOR_YELLOW"; }

# -----------------------------------------------

## DISPLAYING A COLORED MESSAGE WITH A PAUSE TIME DEPENDING ON THE "$__STAT_TIME_TXT" status variable.

# Error message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoError
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_ERROR}$__BU_TXT_TAB$__BU_TXT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" >&2

    sleep "$__STAT_TIME_TXT"
}

# Normal message (without any extra color), with redirection checking.

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoMsg
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "$p_string" "$p_option" "${p_arrExtraArgs[@]}"

    sleep "$__STAT_TIME_TXT"
}

# New sub-step message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoNewstep
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_ORANGE}$__BU_TXT_TAB$__BU_TXT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}"

    sleep "$__STAT_TIME_TXT"
}

# Read input values

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#	- CheckProjectLogStatus		--> Checkings.lib
function EchoRead
{
	#***** Parameters *****
	local p_string=$1
	
	#***** Code *****
	if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__STAT_LOG" = "true" ] && [ -n "$__STAT_LOG_REDIRECT" ]; then
		echo "$p_string" >> "$__PROJECT_LOG_FILE_PATH"
	fi
}

# Success message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoSuccess
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_SUCCESS}$__BU_TXT_TAB$__BU_TXT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" >&1

    sleep "$__STAT_TIME_TXT"
}

# Warning message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoWarning
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_WARNING}$__BU_TXT_TAB$__BU_TXT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" 1>&2

    sleep "$__STAT_TIME_TXT"
}

# -----------------------------------------------

## TEXT FORMATTING

# Keep the same text format between lowercased or uppercased text printed by a formatting text function ("ToLowercase()" OR "ToUppercase()") or a parameter expansion.
function KeepFormating
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	echo "$p_string"
}

# Print a lowercased text.

# Usage :
#	ToLowercase "<Text to write>"
function ToLowercase
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	echo "$p_string" | tr '[:upper:]' '[:lower:]'
}

# Print an uppercased text.

# Usage :
#	ToUppercase "<Text to write>"
function ToUppercase
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	echo "$p_string" | tr '[:lower:]' '[:upper:]'
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINE BREAKS

## LINE BREAKS ACCORDING TO THE "$MAIN_SCRIPT_LOG" VARIABLE VALUE.

# Redirecting the output of the "echo" command

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
#	- HandleErrors				--> Checkings.lib
function Newline
{
    #***** Parameters *****
    local number=$1

    #***** Code *****
    if [ -n "$number" ] && ! IsInt "$number"; then
        HandleErrors "1" "THE NUMBER OF LINE BREAKS MUST BE AN INTEGER" \
            "Check at the mentionned file in the 4th $(DechoE "HandleErrors") function's argument" "$number" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-3 ))"
    else
        if [ -n "$number" ]; then
            # Doing X line breaks according to the number passed as argument.
            for ((i=0; i<number; i++)); do
                CheckProjectLogStatus "" "" "nodate"
            done
        else
            CheckProjectLogStatus "" "" "nodate"
        fi
    fi
}

#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### NAMED PIPES CREATION

## FIFO CREATION

# This function is called once in the next function, to print all advices given in the called "InitErrMsg()" function.
function __CreateFIFO
{
    #***** Parameters *****
    local arr=("$@")        # "HandleErrors()" function's number of advices (in the "mkfifo" command's failure handling in the "CreateFIFO()" function).
    
    #***** Variables *****
    local i=0

    #***** Code *****
    for val in "${arr[@]}"; do
        i=$(( i+1 ))

        # 166 --> Orange
        # 196 --> Red
        EchoInit "$(tput setaf 166)$i$(tput setaf 196)/$(tput setaf 166)${#arr[@]}$(tput sgr0) : $val$(tput sgr0)"
    done
}

# Creating a named pipe to get a variable's value instead of declaring it in a sub-shell, and thus, losing its modified value.
function CreateFIFO
{
    #***** Parameters *****
    local p_path=$1

    #***** Code *****
    if [ ! -d "$__PROJECT_FIFO_DIR_PATH" ]; then
        EchoInit "Creating the $(DechoN "$__PROJECT_FIFO_DIR_PATH")"; EchoInit
        EchoInit "$(mkdir -pv "$__PROJECT_FIFO_DIR_PATH")"
    fi

    EchoInit "Creating the $(tput setaf 6)$p_path$(tput sgr0) FIFO."
    EchoInit
    
    if [ ! -p "$p_path" ]; then
        if mkfifo "$p_path"; then
            EchoInit "Created FIFO : $(tput setaf 6)$p_path$(tput sgr0)"
        else
            InitErrMsg "$(echo "UNABLE TO CREATE THIS FIFO --> $(tput setaf 196)$p_path$(tput sgr0) ! PLEASE CHECK AT THE FOLLOWING ADVICES TO RESOLVE THIS ERROR !" \
            "$(__CreateFIFO \
                "Project's FIFOs path --> $(tput setaf 196)$__PROJECT_FIFO_DIR_PATH$(tput sgr0)" \
                "$(tput setaf 196)Writing rights$(tput sgr0)")")"
        fi
    else
        EchoInit "Existing FIFO --> $(tput setaf 6)$p_path$(tput sgr0)" "$(( LINENO-3 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### NAMED PIPES READING

## FIFO READING

# Reading from a named pipe.
function ReadFromFIFO
{
    #***** Parameters *****
    p_fifoPath=$1               # FIFO's path.
    p_fifoVarName=$2            # Stored variable's name.
    p_fifoCurrentVarValue=$3    # Stored variable's value to get.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__BASH_UTILS_IS_INITIALIZING" = "true" ]; then
        # TODO : Test
        echo "Fonctionnalités à implémenter ici."
    else
        CheckArgs_ReadFromFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue"
        
        CheckProjectLogStatus "Read the $p_fifoPath FIFO to find the $p_fifoCurrentVarValue value."
        CheckProjectLogStatus
            
        while true; do
            if read -r line < "$p_fifoPath"; then
                if [[ "$line" == "$v_varLine" ]]; then
                    # Gathering the wanted value
                    echo "$p_newVar"
                    break
                else
                    CheckProjectLogStatus "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $LINENO --> ERROR :" "-ne"
                    CheckProjectLogStatus "THE $(tput setaf 196)$v_varLine$(tput sgr0) STRING WAS NOT FOUND IN THE $(tput setaf 196)$p_fifoPath$(tput sgr0) FIFO"
                    
                    ExitError
                fi
            fi
        done
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Writing into a named pipe
function WriteIntoFIFO
{
    #***** Parameters *****
    p_fifoPath=$1		# FIFO's path to write into.
    p_fifoVarName=$2    # Stored variable's name
    p_newVar=$3         # Stored variable's new value.
    p_existingPath=$4   # Handling missing FIFO, to define specific instructions.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    CheckArgs_WriteIntoFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue" "$p_newVar"

    if [ ! -p "$p_fifoPath" ]; then
        if [ "$p_existingPath" = "nopath" ]; then
            return
        else
            # Line break with the "CheckProjectLogStatus" function without any argument.
            CheckProjectLogStatus
            
            # As this function is called by the functions called in the "HandleErrors" function, calling this last function will cause an infinite loop
            # Redefining a part of its behavior was necessary to prevent this situation.
            DrawLine "$(tput setaf 196)" "-"
            CheckProjectLogStatus "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $LINENO --> ERROR :" "-ne"
            CheckProjectLogStatus "NO VALUE PASSED IN THE  \"p_existingPath\"  PARAMETER !" "-e"
            CheckProjectLogStatus

            CheckProjectLogStatus ""
        fi
    fi
    # If the file size is equal to 0 (empty file)
    if [ ! -s "$p_fifoPath" ]; then
        cat << EOF > "$p_fifoPath"
        $v_varLine="$p_newVar"
EOF
    fi
}

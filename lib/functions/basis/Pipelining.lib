#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### NAMED PIPES CREATION

## FIFO CREATION

# This function is called once in the next function.
function __CreateFIFO
{
    #***** Parameters *****
    local arr=("$@")
    
    #***** Variables *****
    local i=0

    #***** Code *****
    for val in "${arr[@]}"; do
        i=$(( i+1 ))
        
        # 166 --> Orange
        # 196 --> Red
        EchoError "$(tput setaf 166)$i$(tput setaf 196)/$(tput setaf 166)${#arr[@]}$(tput sgr0) : $val$(tput sgr0)"
    done
}

# Creating a named pipe to get a variable's value instead of declaring it in a sub-shell, and thus, losing its modified value.
function CreateFIFO
{
    #***** Parameters *****
    local p_path=$1

    #***** Code *****
    if [ ! -d "$__PROJECT_FIFO_DIR_PATH" ]; then
        EchoNewstep "Creating the $(DechoN "$__PROJECT_FIFO_DIR_PATH")"; Newline
        EchoMsg "$(mkdir -pv "$__PROJECT_FIFO_DIR_PATH")"
    fi
    
    EchoNewstep "Creating the $(tput setaf 6)$p_path$(tput sgr0) FIFO."
    Newline
    
    if [ ! -p "$p_path" ]; then
        if mkfifo "$p_path"; then
            EchoSuccess "The  $(DechoS "$p_path")  FIFO already exists"
        else
            HandleErrors "1" "UNABLE TO CREATE THIS FIFO --> $(DechoE "$p_path")" \
                "$(__CreateFIFO \
                    "Project's FIFOs path --> $(DechoE "$__PROJECT_FIFO_DIR_PATH")" \
                    "$(DechoE "Writing rights")")" \
                "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-3 ))"

            EchoSuccess "Successfully created this FIFO --> $(tput setaf 6)$p_path$(tput sgr0)." "$(( LINENO-1 ))"
            Newline
        fi
    else
        EchoSuccess "Existing FIFO --> $(tput setaf 6)$p_path$(tput sgr0)" "$(( LINENO-3 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### NAMED PIPES READING

## FIFO READING

# Reading from a named pipe.
function ReadFromFIFO
{
    #***** Parameters *****
    p_fifoPath=$1               # FIFO's path.
    p_fifoVarName=$2            # Stored variable's name.
    p_fifoCurrentVarValue=$3    # Stored variable's value to get.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    CheckArgs_ReadFromFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue"
    
    EchoNewstep "Read the $p_fifoPath FIFO to find the $p_fifoCurrentVarValue value."
    Newline
        
    while true; do
        if read -r line < "$p_fifoPath"; then
            if [[ "$line" == "$v_varLine" ]]; then
                # Gathering the wanted value
                echo "$p_newVar"
                break
            else
                HandleErrors "1" "THE $(DechoE "$v_varLine") STRING WAS NOT FOUND IN THE $(DechoE "$p_fifoPath") FIFO" \
                    "" "$v_varLine" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))"
            fi
        fi
    done
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Writing into a named pipe
function WriteIntoFIFO
{
    #***** Parameters *****
    p_fifoPath=$1		# FIFO's path to write into.
    p_fifoVarName=$2    # Stored variable's name
    p_newVar=$3         # Stored variable's new value.
    p_existingPath=$4   # Handling missing FIFO, to define specific instructions.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    CheckArgs_WriteIntoFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue" "$p_newVar"

    if [ ! -p "$p_fifoPath" ]; then
        if [ "$p_existingPath" = "nopath" ]; then
            return
        else
            # Line break with the "CheckProjectLogPath" function without any argument.
            CheckProjectLogPath
            
            # As this function is called by the functions called in the "HandleErrors" function, calling this last function will cause an infinite loop
            # Redefining a part of its behavior was necessary to prevent this situation.
            DrawLine "$(tput setaf 196)" "-"
            CheckProjectLogPath "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $LINENO --> ERROR :" "-ne"
            CheckProjectLogPath "NO VALUE PASSED IN THE  \"p_existingPath\"  PARAMETER !" "-e"
            CheckProjectLogPath

            CheckProjectLogPath ""
        fi
    fi
    # If the file size is equal to 0 (empty file)
    if [ ! -s "$p_fifoPath" ]; then
        cat << EOF > "$p_fifoPath"
        $v_varLine="$p_newVar"
EOF
    fi
}

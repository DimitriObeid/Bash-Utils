#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### NAMED PIPES CREATION

## FIFO CREATION

# This function is called once in the next function, to print all advices given in the called "InitErrMsg()" function.
function __CreateFIFO
{
    #***** Parameters *****
    local arr=("$@")        # "HandleErrors()" function's number of advices (in the "mkfifo" command's failure handling in the "CreateFIFO()" function).
    
    #***** Variables *****
    local i=0

    #***** Code *****
    for val in "${arr[@]}"; do
        i=$(( i+1 ))

        # 166 --> Orange
        # 196 --> Red
        EchoInit "$(tput setaf 166)$i${__COLOR_CODE_ERROR}/$(tput setaf 166)${#arr[@]}${__COLOR_CODE_RESET} : $val${__COLOR_CODE_RESET}"
    done
}

# Creating a named pipe to get a variable's value instead of declaring it in a sub-shell, and thus, losing its modified value.
function CreateFIFO
{
    #***** Parameters *****
    local p_path=$1

    #***** Code *****
    if [ ! -d "$__PROJECT_FIFO_DIR_PATH" ]; then
        EchoInit "Creating the $(DechoN "$__PROJECT_FIFO_DIR_PATH")"; EchoInit
        EchoInit "$(mkdir -pv "$__PROJECT_FIFO_DIR_PATH")"
    fi

    EchoInit "Creating the ${__COLOR_CODE_HIGHLIGHT}$p_path${__COLOR_CODE_RESET} FIFO."
    EchoInit
    
    if [ ! -p "$p_path" ]; then
        if mkfifo "$p_path"; then
            EchoInit "Created FIFO : ${__COLOR_CODE_HIGHLIGHT}$p_path${__COLOR_CODE_RESET}"
        else
            InitErrMsg "$(echo "UNABLE TO CREATE THIS FIFO --> ${__COLOR_CODE_HIGHLIGHT}$p_path${__COLOR_CODE_ERROR} ! PLEASE CHECK AT THE FOLLOWING ADVICES TO RESOLVE THIS ERROR !" \
            "$(__CreateFIFO \
                "Project's FIFOs path --> ${__COLOR_CODE_ERROR}$__PROJECT_FIFO_DIR_PATH${__COLOR_CODE_RESET}" \
                "${__COLOR_CODE_ERROR}Writing rights${__COLOR_CODE_RESET}")")"
        fi
    else
        EchoInit "Existing FIFO --> ${__COLOR_CODE_HIGHLIGHT}$p_path${__COLOR_CODE_RESET}" "$(( LINENO-3 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### NAMED PIPES READING

## FIFO READING

# Reading from a named pipe.
function ReadFromFIFO
{
    #***** Parameters *****
    p_fifoPath=$1               # FIFO's path.
    p_fifoVarName=$2            # Stored variable's name.
    p_fifoCurrentVarValue=$3    # Stored variable's value to get.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__BASH_UTILS_IS_INITIALIZING" = "true" ]; then
        # TODO : Test
        echo "Fonctionnalités à implémenter ici."
    else
        CheckArgs_ReadFromFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue"
        
        CheckProjectLogStatus "Read the $p_fifoPath FIFO to find the $p_fifoCurrentVarValue value."
        CheckProjectLogStatus
            
        while true; do
            if read -r line < "$p_fifoPath"; then
                if [[ "$line" == "$v_varLine" ]]; then
                    # Gathering the wanted value
                    echo "$p_newVar"
                    break
                else
                    CheckProjectLogStatus "${__COLOR_CODE_ERROR}IN ${__COLOR_CODE_HIGHLIGHT}$(basename "${BASH_SOURCE[0]}")${__COLOR_CODE_ERROR}, FUNCTION ${__COLOR_CODE_HIGHLIGHT}${FUNCNAME[0]}${__COLOR_CODE_ERROR}, LINE ${__COLOR_CODE_HIGHLIGHT}$(( LINENO-1 ))${__COLOR_CODE_ERROR} --> ERROR :" "-ne"
                    CheckProjectLogStatus "${__COLOR_CODE_ERROR}THE ${__COLOR_CODE_HIGHLIGHT}$v_varLine${__COLOR_CODE_ERROR} STRING WAS NOT FOUND IN THE ${__COLOR_CODE_HIGHLIGHT}$p_fifoPath${__COLOR_CODE_ERROR} FIFO${__COLOR_CODE_RESET}"
                    
                    ExitError
                fi
            fi
        done
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Writing into a named pipe
function WriteIntoFIFO
{
    #***** Parameters *****
    p_fifoPath=$1		# FIFO's path to write into.
    p_fifoVarName=$2    # Stored variable's name
    p_newVar=$3         # Stored variable's new value.
    p_existingPath=$4   # Handling missing FIFO, to define specific instructions.

    #***** Variables *****
    v_varLine="$p_fifoVarName=\"$p_fifoCurrentVarValue\""

    #***** Code *****
    CheckArgs_WriteIntoFIFO "$p_fifoPath" "$p_fifoVarName" "$p_fifoCurrentVarValue" "$p_newVar"

    if [ ! -p "$p_fifoPath" ]; then
        if [ "$p_existingPath" = "nopath" ]; then
            return
        else
			lineno="$(( LINENO-1 ))"

            # Line break with the "CheckProjectLogStatus" function without any argument.
            CheckProjectLogStatus
            
            # As this function is called by the functions called in the "HandleErrors" function, calling this last function will cause an infinite loop
            # Redefining a part of its behavior was necessary to prevent this situation.
            DrawLine "${__COLOR_CODE_ERROR}" "-"
            CheckProjectLogStatus "IN ${__COLOR_CODE_HIGHLIGHT}$(basename "${BASH_SOURCE[0]}")${__COLOR_CODE_ERROR}, FUNCTION ${__COLOR_CODE_HIGHLIGHT}${FUNCNAME[0]}${__COLOR_CODE_ERROR}, LINE ${__COLOR_CODE_HIGHLIGHT}$lineno${__COLOR_CODE_ERROR} --> ERROR :" "-ne"
            CheckProjectLogStatus "NO VALUE PASSED IN THE  ${__COLOR_CODE_HIGHLIGHT}p_existingPath${__COLOR_CODE_ERROR}  PARAMETER !${__COLOR_CODE_RESET}" "-e"
            CheckProjectLogStatus

            CheckProjectLogStatus ""
        fi
    fi
    # If the file size is equal to 0 (empty file)
    if [ ! -s "$p_fifoPath" ]; then
        cat << EOF > "$p_fifoPath"
        $v_varLine="$p_newVar"
EOF
    fi
}

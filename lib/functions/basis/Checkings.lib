#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CHECKING FOR IDENTIFIANTS

## EFFECTIVE USER IDENTIFIANTS CHECKING

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - HandleErrors      -> Bash-Utils/lib/functions/basis/Handles.lib
function CheckRootEUID
{
    if [ "$EUID" -ne 0 ]; then
        HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARGUMENT VALUES CHECKING

## "Directories.lib" FILE'S FUNCTION

# "ProcessingDir" function.
function CheckArgs_ProcessingDir
{
    #***** Parameters *****

    #***** Code *****
    return
}

# "OverwriteDir" function.
function CheckArgs_OverwriteDir
{
    #***** Parameters ****
    local p_path=$1         # Path of the directory to overwrite.

    #***** Code *****
    # If the target folder path is missing (no path is given).
    if [ -z "$p_path" ]; then
        HandleErrors "1" "THE $(DechoE "p_path") PARAMETER HAS NO VALUE" "Please pass the path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if the given folder path is incorrect.
    elif [ ! -d "$p_path" ]; then
        HandleErrors "1" "THE $(DechoE "p_path") PARAMETER'S VALUE IS INCORRECT" "Please pass the correct path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# "Makedir" function.
function CheckArgs_Makedir
{
    #***** Parameters *****
    local p_parent=$1       # Parent folder's path.
    local p_name=$2         # Name of the folder to create.

    #***** Code *****
    # If the parent folder's path is missing (no path is given).
    if [ -z  "$p_parent" ]; then
        HandleErrors "1" "" "" "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if the parent folder's path is incorrect.
    elif [ ! -d "$p_parent" ]; then
        HandleErrors "1" "" "" "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if the folder's name is missing (no name is given).
    elif [ -z "$p_name" ]; then
        HandleErrors "1" "" "" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# -----------------------------------------------

## "Files.lib" FILE's FUNCTION

# "ProcessingFile" function.
function CheckArgs_ProcessingFile
{
    #***** Parameters *****
    local p_function=$1     # 

    #***** Code *****
    if [ -z "$p_function" ]; then
        HandleErrors "1" "THE $(DechoE "p_function") PARAMETER'S VALUE IS INCORRECT" "Please pass a valid file processing function as first argument" \
            "$p_function" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# "OverwriteFile" function.
function CheckArgs_OverwriteFile
{
    #***** Parameters ****
    local p_path=$1         # Path of the file to overwrite.

    #***** Code *****
    # If the target file's path is missing (no path is given).
    if [ -z "$p_path" ]; then
        HandleErrors "1" "THE $(DechoE "p_path") PARAMETER HAS NO VALUE" "Please pass the path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if if the given file path is incorrect.
    elif [ ! -d "$p_path" ]; then
        HandleErrors "1" "THE $(DechoE "p_path") PARAMETER'S VALUE IS INCORRECT" "Please pass the correct path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# "Makefile" function's arguments.
function CheckArgs_Makefile
{
    #***** Parameters *****
    local p_parent=$1       # File to create's Parent folder path. 
    local p_name=$2         # Name of the file to create.

    #***** Code *****
    # If the parent folder's path is missing (no path is given).
    if [ -z "$p_parent" ]; then
        HandleErrors "1" "THE $(DechoE "p_parent") PARAMETER HAS NO VALUE" "Please pass the path of the new directory's parent folder as first argument" \
            "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if the parent folder's path is incorrect.
    elif [ ! -d "$p_parent" ]; then
        HandleErrors "1" "THE $(DechoE "p_parent") PARAMETER'S VALUE IS INCORRECT" "Please pass a valid parent directory path as first argument" \
            "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

    # Else, if the file's name is missing (no name is given).
    elif [ -z "$p_name" ]; then
        HandleErrors "1" "THE $(DechoE "p_name") PARAMETER HAS NO VALUE" "Please pass the name of the folder to create as second argument" \
            "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# -----------------------------------------------

## "Handles.lib" FILE

# Checking if an argument is provided in the "Is..." functions (check the "VARIABLES VALUES CHECKING" section for more informations).
function CheckArgs_IsCorrectValue
{
    if [ "$#" -eq 0 ]; then
        HandleErrors "1" "" "" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# -----------------------------------------------

## "Pipelining.lib" FILE

# Displaying text according to the color variable's FIFO existence and the message to display.
# There's no need to check for the string variable's value existence, as an empty value gives a line break.
function CheckArgs_EchoContext
{
    #***** Parameters *****
    local p_stat=$1; shift

    #***** Variables *****
    local v_statArr; v_statArr=('E' 'N' 'S' 'W')

    #***** Code *****
    if [ -z "$p_stat" ]; then
        HandleErrors "1" "THE $(DechoE "p_stat") PARAMETER HAS NO VALUE" "Please pass a valid value : 'E', 'N', 'S' OR 'W'" \
            "$p_stat" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    else
        for val in "${v_statArr[@]}"; do
            if [ "$p_stat" = "$val" ]; then
                local v_succ="$val"
                break
            fi
            
            # Checking if the "v_succ" variable is not empty as the loop ends.
            if [ -z "$v_succ" ]; then
                HandleErrors "1" "THE $(DechoE "v_succ") VARIABLE CONTAINS NO VALUE" \
                "Please pass one of the following valid value when calling the $(DechoE "EchoFIFO") function : 'E', 'N', 'S' OR 'W'" \
                "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
            fi
        done
    fi
}

# "ReadFromFIFO" function.
function CheckArgs_ReadFromFIFO
{
    #***** Parameters *****
    local p_fifoPath=$1                 # FIFO's path.
    local p_fifoVarName=$2              # Stored variable's name.
#     local p_fifoCurrentVarValue=$3    # Stored variable's value to get.

    #***** Code *****
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__BASH_UTILS_IS_INITIALIZING" = "true" ]; then
        if [ -z "$p_fifoPath" ]; then
            EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER HAS NO VALUE" "1"

        elif [ ! -f "$p_fifoPath" ]; then
            EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER HAS NO VALUE" "1"
        fi
    else
        if [ -z "$p_fifoPath" ]; then
            Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER HAS NO VALUE" >&2;         Newline >&2; ExitError

        elif [ ! -f "$p_fifoPath" ]; then
            Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER'S VALUE IS INCORRECT" >&2; Newline >&2; ExitError
        fi
    fi
}

# "WriteIntoFIFO" function.
function CheckArgs_WriteIntoFIFO
{
    #***** Parameters ****
    local p_fifoPath=$1         # FIFO's path to write into.
    local p_fifoVarName=$2      # Stored variable's name
#     local p_newVar=$3         # Stored variable's new value.
#     local p_existingPath=$4   # Handling missing FIFO, to define specific instructions.

    #***** Code *****
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__BASH_UTILS_IS_INITIALIZING" = "true" ]; then
        if [ -z "$p_fifoPath" ]; then
            EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER HAS NO VALUE" "1";            EchoInit >&2; ExitError

        elif [ ! -f "$p_fifoPath" ]; then
            EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER'S VALUE IS INCORRECT" "1";    EchoInit >&2; ExitError
            
        elif [ -z "$p_fifoVarName" ]; then
            EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_fifoVarName' PARAMETER HAS NO VALUE" "1";         EchoInit >&2; ExitError

    #     elif [ -z "$p_newVar" ]; then
    #         EchoInit >&2; InitErrMsg "${FUNCNAME[0]} : THE 'p_newVar' PARAMETER HAS NO VALUE" "1";            EchoInit >&2; ExitError

        fi
    else
        if [ -z "$p_fifoPath" ]; then
            Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER HAS NO VALUE" >&2;         Newline >&2; ExitError

        elif [ ! -f "$p_fifoPath" ]; then
            Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_fifoPath' PARAMETER'S VALUE IS INCORRECT" >&2; Newline >&2; ExitError
            
        elif [ -z "$p_fifoVarName" ]; then
            Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_fifoVarName' PARAMETER HAS NO VALUE" >&2;      Newline >&2; ExitError

    #     elif [ -z "$p_newVar" ]; then
    #         Newline >&2; CheckProjectLogPath "${FUNCNAME[0]} : THE 'p_newVar' PARAMETER HAS NO VALUE" >&2;           Newline >&2; ExitError

        fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### VARIABLES VALUES CHECKING

## NUMBER VALUES

# Checking floating value.
function IsFloat
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking floating and integer value.
function IsFloatInt
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^([0-9]+\.?|[0-9]*\.[0-9]+)$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking integer value.
function IsInt
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^[+-]?[0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------

## STRING VALUES

# Checking if value is an alphabetic string (not any number allowed)
function IsAlpha
{
    #***** Parameters *****
    local p_value=$1
    
    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ [A-Z] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking if vialue is an aplhanumeric string.
function IsAlphaNum
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ [^a-zA-Z0-9\ ] ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## FILE PATHS CHECKING

# Checking for "$PROJECT_LOG_PATH"

# Required functions and files :
function CheckProjectLogPath
{
    if [ -z "$__PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__COL_RED}IN $(DechoE "$(basename "${BASH_SOURCE[0]}")"), function $(DechoE "${FUNCNAME[0]}"), LINE $(DechoE "$(( LINENO-1 ))") --> " >&2
        echo "FATAL ERROR : NO PATH PROVIDED INTO THE $(DechoE "PROJECT_LOG_PATH") VARIABLE" >&2
        echo "Please add the path as argument.$__COL_RESET" >&2; echo >&2
        ExitError

    elif [ ! -f "$__PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__COL_RED}IN $(DechoE "$(basename "${BASH_SOURCE[0]}")"), FUNCTION $(DechoE "${FUNCNAME[0]}"), LINE $(DechoE "$(( LINENO-1 ))") --> " >&2
        echo "FATAL ERROR : BAD PATH PROVIDED INTO THE $(DechoE "PROJECT_LOG_PATH") VARIABLE" >&2
        echo "Please correct the path passed as argument.$__COL_RESET" >&2; echo >&2
        ExitError

    fi
}

function CheckProjectLogStatusPrintWarningArrayValue
{
    echo -e "${__COL_YELLOW}Warning : incorrect argument given as extra argument array in $__COL_CYAN${BASH_SOURCE[0]}$__COL_YELLOW,  function ${__COL_CYAN}CheckProjectLogStatus$__COL_YELLOW --> $val$__COL_RESET" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.
function CheckProjectLogStatus
{
    #***** Parameters *****
    local p_string=$1       # String to display.
    local p_option=$2       # "echo" command options.
    shift 2

    local p_extraArgs=("$@")    # More processing arguments (like the processing of a whole line-long string).

    #***** Variables *****
    local v_acceptedExtraArgs=('nodate')        # Allowed extra arguments list for the "$p_extraArgs" array of arguments.
    local v_errorEcho
    v_errorEcho="$(tput setaf 196)Unable to write into the $(DechoE "$__PROJECT_LOG_FILE_PATH") file.$(tput sgr0)"

    # If the text is redirected towards the log path only, it's better to put every timer status variables values to '0'.
    if [ "$__STAT_LOG_REDIRECT" = "true" ]; then
        if [ "$__STAT_LOG_REDIRECT" = "log" ] && [ "$__STAT_TIME_TXT" -gt 0 ]; then

            # Backup the old values to restore them when the log processing will be done.
            local __OLD_STAT_TIME_TXT="$__STAT_TIME_TXT"
            __STAT_TIME_TXT="0"; CheckSTAT_TIME_TXT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi
    
    #**** Code *****
    CheckProjectLogPath
    CheckSTAT_LOG           "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_LOG_REDIRECT  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_TIME_TXT      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    # If a log file exists AND if "$__STAT_LOG" value is "false" AND if "$__STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__STAT_LOG" = "true" ] && [ -n "$__STAT_LOG_REDIRECT" ]; then

        # If messages must be redirected in the log file only ("$__STAT_LOG_REDIRECT" value is equal to "log")
        if [ "$__STAT_LOG_REDIRECT" = "log" ]; then

            # Checking if the extra arguments array contains an allowed value, by checking the "$v_acceptedExtraArgs" array's values.
            if [[ "${p_extraArgs[*]}" =~ ${v_acceptedExtraArgs[*]} ]]; then

                for val in "${p_extraArgs[@]}"; do

                    # If the "nodate" value is passed as argument.
                    if [ "$val" = "nodate" ]; then
                        case "$p_option" in
                            '-n')
                                echo -ne "$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac
                    

                    # Else, if an unsupported option is passed (note for myself : the extra args checking
                    # "for" loop (for val in "${p_extraArgs[@]}"; do) is still running (for the "log" option)).
                    else
                        case "$p_option" in
                            '-n')
                                echo -ne "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "${__COL_YELLOW}Warning : incorrect argument given as extra argument array in $__COL_CYAN${BASH_SOURCE[0]}$__COL_YELLOW,  function $__COL_CYAN${FUNCNAME[0]}$__COL_YELLOW --> $val$__COL_RESET" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "[$__TIME_DATE]$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "${__COL_YELLOW}Warning : incorrect argument given as extra argument array in $__COL_CYAN${BASH_SOURCE[0]}$__COL_YELLOW,  function $__COL_CYAN${FUNCNAME[0]}$__COL_YELLOW --> $val$__COL_RESET" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac
                    fi
                done
                
            # Else, if no argument is passed in "$p_extraArgs" parameter array.
            else
                case "$p_option" in
                    '-n')
                        echo -ne "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                    '')
                        echo -e "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                esac
            fi
        
        sleep "$__STAT_TIME_TXT"

        # Else, if messages must be redirected in the log file AND to the terminal ("$__STAT_LOG_REDIRECT" value is equal to "tee")
        elif [ "$__STAT_LOG_REDIRECT" = "tee" ]; then

            # Checking if the extra arguments array contains an allowed value, by checking the "$v_acceptedExtraArgs" array's values.
            if [[ "${p_extraArgs[*]}" =~ ${v_acceptedExtraArgs[*]} ]]; then

                for val in "${p_extraArgs[@]}"; do

                    # If the "nodate" value is passed as argument.
                    if [ "$val" = "nodate" ]; then
                        case "$p_option" in
                            '-n')
                                echo -ne "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac
                    
                    # Else, if an unsupported option is passed (note for myself : the extra args checking
                    # "for" loop (for val in "${p_extraArgs[@]}"; do) is still running (for the "tee" option)).
                    else
                        case "$p_option" in
                            '-n')
                                echo -ne "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "${__COL_YELLOW}Warning : incorrect argument given as extra argument array in $__COL_CYAN${BASH_SOURCE[0]}$__COL_YELLOW, function $__COL_CYAN${FUNCNAME[0]}$__COL_YELLOW --> $val$__COL_RESET" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "${__COL_YELLOW}Warning : incorrect argument given as extra argument array in $__COL_CYAN${BASH_SOURCE[0]}$__COL_YELLOW, function $__COL_CYAN${FUNCNAME[0]}$__COL_YELLOW --> $val$__COL_RESET" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac
                    fi
                done

            # Else, if no argument is passed in "$p_extraArgs" parameter array.
            else
                case "$p_option" in
                    '-n')
                        echo -ne "$p_string"
                        echo -ne "[$__TIME_DATE_DISPLAY] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                    '')
                        echo -e "$p_string"
                        echo -e "[$__TIME_DATE_DISPLAY] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                esac
            fi
            
            sleep "$__STAT_TIME_TXT"
        fi

    # Else, if no log file exists OR if "$__STAT_LOG" value is "false" OR if "$__STAT_LOG_REDIRECT" has no redirection value. 
    else
        case "$p_option" in
            '-n')
                echo -ne "$p_string"
                ;;
            '')
                echo -e "$p_string"
                ;;
        esac
        
        sleep "$__STAT_TIME_TXT"
        
    fi

    # Restore timer status variables old values if they were modified because of the redirection to the log file only.
    if [ "$__STAT_LOG_REDIRECT" = "true" ]; then
        if [ "$__STAT_LOG_REDIRECT" = "log" ] && [ "$__STAT_TIME_TXT" -eq 0 ]; then
        
            # Backup the old values to restore them when the log processing will be done, then check if the correct values were reassignated.
            __STAT_TIME_TXT="$__OLD_STAT_TIME_TXT"; CheckSTAT_TIME_TXT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi
}

# -----------------------------------------------

## DIRECTORIES PATHS CHECKING

# 

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS

## EXIT HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function ExitError
{
    # In case the "exit" command didn't worked, the program has to be killed.
    CheckSTAT_EXIT_CODE "$(basename "${BASH_SOURCE[0]}")" "$LINENO"; exit "$__STAT_EXIT_CODE" || kill "$$"
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   - 
function HandleErrors
{
	#***** Paramètres *****
	local p_returnCode=$1     # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2    # Chaîne de caractères du type d'erreur à afficher.
	local p_adviceString=$3   # Chaîne de caractères affichants un conseil pour orienter l'utilisateur vers la meilleure solution en cas de problème.
    local p_badValue=$4       # Incorrect value which caused the error.
	local p_file=$5           # The name of the file where the error occured.
	local p_function=$6       # The name of the function where the error occured.
	local p_lineno=$7         # Ligne à laquelle le message d'erreur s'est produite.

    #***** Variables *****
    local v_hdrString
    v_hdrString="$(echo -e "IN $(DechoE "$p_file"), FUNCTION $(DechoE "$p_function"), LINE $(DechoE "$p_lineno") -->")"

	# ***** Code *****
	CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$p_returnCode" -eq 0 ]; then
        return
    else
        if [ "$__STAT_LOG_REDIRECT" = "log" ]; then
            __STAT_LOG_REDIRECT="tee"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi

        if [ -n "$__STAT_ERROR" ] && [ "$__STAT_ERROR" = "fatal" ]; then
            HeaderRed "$v_hdrString FATAL ERROR : $(DechoE "${p_errorString^^}")" >&2
        else
            HeaderRed "$v_hdrString ERROR : $(DechoE "${p_errorString^^}")" >&2
        fi

        if [ -z "$p_adviceString" ]; then
            EchoError "No advice to give."; Newline >&2
        else
            EchoError "$(DechoE "Advice") : $p_adviceString" >&2; Newline >&2
        fi
            
        if [ -z "$p_badValue" ]; then
            EchoError "Value(s) that caused this error : $(DechoOrange 'No value //OR\\ an unknown error')"; Newline >&2
        else
            EchoError "Value(s) that caused this error : $(DechoE "$p_badValue")"; Newline >&2
        fi

        if [ "$__STAT_ERROR" = "fatal" ]; then
            EchoError "Stopping the execution of $(DechoE "$(basename "$0")")."; Newline >&2
            ExitError "$__STAT_EXIT_CODE"
        else
            KbInputYesNo "Do you want to stop the execution of $(DechoE "$(basename "$0")") ? (yes/no)" \
                "Resuming script execution." "return" >&1 "Aborting script execution." >&2 "exit"
        fi
    fi
}

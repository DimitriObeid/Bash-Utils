#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CHECKING FOR IDENTIFIANTS

## EFFECTIVE USER IDENTIFIANTS CHECKING

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - HandleErrors      -> Bash-Utils/lib/functions/basis/Handles.lib
function CheckRootEUID
{
    if [ "$EUID" -ne 0 ]; then
        HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARGUMENT VALUES CHECKING : UTILITES FUNCTIONS

## TEXT FORMATING FUNCTIONS

# Cut the text of the function's name before and with the underscore.
function CutCheck
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	#shellcheck disable=SC2001
	sed 's/^[^_]*_//' <<< "$p_string"
}

# -----------------------------------------------

## PATH CHECKING FUNCTIONS

# Check if the script is about to work at the root directory ('/').
function TriggerRootDirWarning
{
	#***** Parameters *****
	p_path=$1

	#***** Variables *****
#	v_root_directories=$( \/snap
		'/' '/bin' '/boot' \
		'/dev' '/etc' '/home' \
		'/lib' '/lib32' '/lib64' \
		'/libx32' '/lost+found' \
		'/media' '/mnt' '/opt' \
		'/proc' '/root' '/run' '/sbin' \
		'/snap' '/srv' '/sys' \
		'/tmp' '/usr' '/var' \)

	#***** Code *****
	# Checking if the given path points towards the root directory or one of its subfolders
	# TODO : detecting if path points to a root sub-folder (like [ if "$p_path" = "/" ] || [ "$p_path" | cut blablabla ]).
	if [ "$p_path" = "/" ] || [ "${p_path##/<dir>/}" ]; then
		if [ "$__STAT_OPERATE_ROOT" = "forbidden" ]; then
			EchoError "WARNING !!!!!! READ THIS MESSAGE CAREFULLY !!!!!!"
			EchoError "The script was trying to operate at the root directory (or one of its sub directories) without authorization"
			EchoError "Given path : $(DechoHighlight "$p_path")"
			Newline

			ExitError
		elif [ "$__STAT_OPERATE_ROOT" = "restricted" ]; then
			EchoWarning "WARNING !!!!!!! DO NOT SKIP THIS MESSAGE BEFORE READING IT !!!!!!"
			EchoWarning "You are about to operate at the root directory or one of its present sub-folders !"
			EchoWarning "Given path : $(DechoHighlight "$p_path")"
			Newline
				
			EchoWarning "Do you want to continue the script's execution ? (yes / no)"
			read -rp "Enter your answer : " __read_TriggerRootDirWarning
			EchoRead "$__read_TriggerRootDirWarning"
			Newline

			# Calling the function that processes the given answer.
			CaseRead_TriggerRootDirWarning
		fi
	fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASIS FUNCTIONS ARGUMENT VALUES CHECKING

## "basis/Checkings.lib" FILE

# Checking if an argument is provided in the "Is..." functions (check the below "VARIABLES VALUES CHECKING" section for more informations).
function CheckArgs_IsCorrectValue
{
    if [ "$#" -eq 0 ]; then
        HandleErrors "1" "" "" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN FUNCTIONS ARGUMENT VALUES CHECKING

## "main/Directories.lib" FILE'S FUNCTION

# "ProcessingDir" function.
function CheckArgs_ProcessingDir
{
    #***** Parameters *****
    local p_function=$1
    local p_parent=$2
    local p_name=$3

    #***** Code *****
    if [ -z "$p_function" ]; then
        HandleErrors "1" "NO FUNCTION NAME PASSED AS ARGUMENT" \
            "THE FUNCTION $(DechoHighlight "$(CutCheck "${FUNCNAME[0]}")") NEEDS A FUNCTION PASSED AS FIRST ARGUMENT TO WORK PROPERLY" \
            "$p_function" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    elif [ -z "$p_parent" ] || [ -z "$p_name" ]; then
        HandleErrors "1" "AT LEAST ONE OF THE TWO $(DechoHighlight "$(CutCheck "${FUNCNAME[0]}")")'S LAST ARGUMENTS IS MISSING" \
            "The function $(DechoHighlight "$(CutCheck "${FUNCNAME[0]}")") needs a function passed as first argument to work properly" \
            "$p_function" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
    fi
}

# "OverwriteDir" function.
function CheckArgs_OverwriteDir
{
    #***** Parameters ****
    local p_path=$1         # Path of the directory to overwrite.

    #***** Code *****
    # If the target folder path is missing (no path is given).
    local lineno="$LINENO"; if [ -z "$p_path" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_path')") PARAMETER HAS NO VALUE" "Please pass the path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the given folder path is incorrect.
    local lineno="$LINENO"; elif [ ! -d "$p_path" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_path')") PARAMETER'S VALUE IS INCORRECT" "Please pass the correct path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"
    fi
}

# "Makedir" function.
function CheckArgs_Makedir
{
    #***** Parameters *****
    local p_parent=$1       # Parent folder's path.
    local p_name=$2         # Name of the folder to create.

    #***** Code *****
    # If the parent folder's path is missing (no path is given).
    local lineno="$LINENO"; if [ -z  "$p_parent" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_parent')") PARAMETER HAS NO VALUE" "" "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the parent folder's path is incorrect.
    local lineno="$LINENO"; elif [ ! -d "$p_parent" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_parent')") PARAMETER'S VALUE IS INCORRECT" "" "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the folder's name is missing (no name is given).
    local lineno="$LINENO"; elif [ -z "$p_name" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_name')") PARAMETER HAS NO VALUE" "" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"
    fi
}

# -----------------------------------------------

## "main/Files.lib" FILE's FUNCTION

# "ProcessingFile" function.
function CheckArgs_ProcessingFile
{
    #***** Parameters *****
    local p_function=$1     # 

    #***** Code *****
    local lineno="$LINENO"; if [ -z "$p_function" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_function')") PARAMETER'S VALUE IS INCORRECT" "Please pass a valid file processing function as first argument" \
            "$p_function" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"
    fi
}

# "OverwriteFile" function.
function CheckArgs_OverwriteFile
{
    #***** Parameters ****
    local p_path=$1         	# Path of the file to overwrite.
	local p_authorization=$2	# Authorization to overwrite the file.

    #***** Code *****
    # If the target file's path is missing (no path is given).
    local lineno="$LINENO"; if [ -z "$p_path" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_path')") PARAMETER HAS NO VALUE" "Please pass the path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the given file path is incorrect.
    local lineno="$LINENO"; elif [ ! -d "$p_path" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_path')") PARAMETER'S VALUE IS INCORRECT" "Please pass the correct path of the directory to overwrite as argument" \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"
			
	local lineno="$LINENO"; elif [ -z "$p_authorization" ]; then

		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_authorization')") PARAMETER HAS NO VALUE" "Please enter a valid value for the overwrite authorization" "$p_authorization" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno" 
    fi
}

# "Makefile" function's arguments.
function CheckArgs_Makefile
{
    #***** Parameters *****
    local p_parent=$1       # File to create's Parent folder path. 
    local p_name=$2         # Name of the file to create.

    #***** Code *****
    # If the parent folder's path is missing (no path is given).
    local lineno="$LINENO"; if [ -z "$p_parent" ]; then
        
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_parent')") PARAMETER HAS NO VALUE" "Please pass the path of the new directory's parent folder as first argument" \
            "$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the parent folder's path is incorrect.
    local lineno="$LINENO"; elif [ ! -d "$p_parent" ]; then
    
		# shellcheck disable=SC2016
		HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_parent')") PARAMETER'S VALUE IS INCORRECT" "Please pass a valid parent directory path as first argument" \
				"$p_parent" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

    # Else, if the file's name is missing (no name is given).
    local lineno="$LINENO"; elif [ -z "$p_name" ]; then

		# shellcheck disable=SC2016
        HandleErrors "1" "THE $(ToLowercase "$(CutCheck "${FUNCNAME[0]}")'s") $(DechoHighlight "$(ToLowercase '$p_name')") PARAMETER HAS NO VALUE" "Please pass the name of the folder to create as second argument" \
            "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASIS FUNCTIONS VALUES HANDLING

## "basis/Echo.lib" FILE

# Checking if the color code file exists.
function HandleVal_Decho
{
    if [ ! -f "$__PROJECT_COLOR_CODE_FILE_PATH" ]; then
        echo "$__BU_COLOR_RESET" >&2; echo "${__BU_COLOR_WARNING}Warning ! The ${__BU_COLOR_HIGHLIGHT}$__PROJECT_COLOR_CODE_FILE_PATH${__BU_COLOR_WARNING} temporary file doesn't exists !${__BU_COLOR_RESET}" >&2; echo >&2

		CheckProjectRelatedFile "$__PROJECT_COLOR_CODE_FILE_PATH"
		
		touch "$__PROJECT_COLOR_CODE_FILE_PATH" || { echo >&2; echo "${__BU_COLOR_ERROR}BASH UTILS ERROR ! The ${__BU_COLOR_HIGHLIGHT}$__PROJECT_COLOR_CODE_FILE_PATH${__BU_COLOR_ERROR} temporary file doesn't exists !${__BU_COLOR_RESET}" >&2; echo >&2; ExitError; }
    fi
}

# -----------------------------------------------



# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### VARIABLES VALUES CHECKING

## NUMBER VALUES

# Checking floating value.
function IsFloat
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking floating and integer value.
function IsFloatInt
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^([0-9]+\.?|[0-9]*\.[0-9]+)$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking integer value.
function IsInt
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ ^[+-]?[0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------

## STRING VALUES

# Checking if value is an alphabetic string (not any number allowed)
function IsAlpha
{
    #***** Parameters *****
    local p_value=$1
    
    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ [A-Z] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking if vialue is an aplhanumeric string.
function IsAlphaNum
{
    #***** Parameters *****
    local p_value=$1

    #***** Code *****
    CheckArgs_IsCorrectValue "$p_value"

    if [[ "$p_value" =~ [^a-zA-Z0-9\ ] ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## FILE PATHS CHECKING

# Checking for an existent directory path (for the "HandleErrors()" function mainly).
function CheckDirPathExists
{
    #***** Parameters *****
    p_path=$1               # Path of the (in)existent directory.

    #***** Code *****
    if [ ! -f "$p_path" ]; then
        DechoBoldItalicHighlight "<missing directory path>"
    fi
}

# Checking for an existent file path (for the "HandleErrors()" function mainly).
function CheckFilePathExists
{
    #***** Parameters *****
    p_path=$1               # Path of the (in)existent file.

    #***** Code *****
    if [ ! -f "$p_path" ]; then
        DechoBoldItalicHighlight "<missing file path>"
    fi
}

# Checking for "$PROJECT_LOG_PATH"

# Required functions and files :
function CheckProjectLogPath
{
    if [ -z "$__PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__BU_COLOR_ERROR}IN $(DechoHighlight "$(basename "${BASH_SOURCE[0]}")"), function $(DechoHighlight "${FUNCNAME[0]}"), LINE $(DechoHighlight "$(( LINENO-1 ))") --> " >&2
        echo "FATAL ERROR : NO PATH PROVIDED INTO THE $(DechoHighlight "PROJECT_LOG_PATH") VARIABLE" >&2
        echo "Please add the path as argument.${__BU_COLOR_RESET}" >&2; echo >&2
        ExitError

    elif [ ! -f "$__PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__BU_COLOR_ERROR}IN $(DechoHighlight "$(basename "${BASH_SOURCE[0]}")"), FUNCTION $(DechoHighlight "${FUNCNAME[0]}"), LINE $(DechoHighlight "$(( LINENO-1 ))") --> " >&2
        echo "FATAL ERROR : BAD PATH PROVIDED INTO THE $(DechoHighlight "PROJECT_LOG_PATH") VARIABLE" >&2
        echo "Please correct the path passed as argument.${__BU_COLOR_RESET}" >&2; echo >&2
        ExitError

    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.
function CheckProjectLogStatus
{
    #***** Parameters *****
    local p_string=$1       # String to display.
    local p_option=$2       # "echo" command options.
    shift 2

    local p_extraArgs=("$@")    # More processing arguments (like the processing of a whole line-long string).

    #***** Variables *****
    local a_acceptedExtraArgs=('nodate')        # Allowed extra arguments list for the "$p_extraArgs" array of arguments.
    local v_errorEcho
		v_errorEcho="${__BU_COLOR_ERROR}Unable to write into the $(Decho "$__PROJECT_LOG_FILE_PATH" "${__BU_COLOR_HIGHLIGHT}") file.${__BU_COLOR_RESET}"
	
	local v_warning_array_value
		v_warning_array_value="${__BU_COLOR_WARNING}Warning : incorrect argument given as extra argument array in ${__BU_COLOR_HIGHLIGHT}${BASH_SOURCE[0]}${__BU_COLOR_WARNING},  function ${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}${__BU_COLOR_WARNING} --> $val${__BU_COLOR_RESET}"

    # If the text is redirected towards the log path only, it's better to put every timer status variables values to '0'.
    if [ "$__STAT_LOG_REDIRECT" = "true" ]; then
        if [ "$__STAT_LOG_REDIRECT" = "log" ] && [ "$__STAT_TIME_TXT" -gt 0 ]; then

            # Backup the old values to restore them when the log processing will be done.
            local __BU_OLD_STAT_TIME_TXT="$__STAT_TIME_TXT"
            __STAT_TIME_TXT="0"; CheckSTAT_TIME_TXT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi
    
    #**** Code *****
    CheckProjectLogPath
    CheckSTAT_LOG           "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_LOG_REDIRECT  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_TIME_TXT      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    # If a log file exists AND if "$__STAT_LOG" value is "false" AND if "$__STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__STAT_LOG" = "true" ] && [ -n "$__STAT_LOG_REDIRECT" ]; then

        # If messages must be redirected in the log file only ("$__STAT_LOG_REDIRECT" value is equal to "log")
        if [ "$__STAT_LOG_REDIRECT" = "log" ]; then

            # Checking if the extra arguments array contains an allowed value, by checking the "$a_acceptedExtraArgs" array's values.
            if [[ "${p_extraArgs[*]}" =~ ${a_acceptedExtraArgs[*]} ]]; then

                for val in "${p_extraArgs[@]}"; do

                    # If the "nodate" value is passed as argument.
                    if [ "$val" = "nodate" ]; then
                        case "$p_option" in
                            '-n')
                                echo -ne "$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac

                    # Else, if an unsupported option is passed (note for myself : the extra args checking
                    # "for" loop (for val in "${p_extraArgs[@]}"; do) is still running (for the "log" option)).
                    else
                        case "$p_option" in
                            '-n')
                                echo -ne "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "$v_warning_array_value" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "[$__TIME_DATE]$p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                echo -e "$v_warning_array_value" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac
                    fi
                done

            # Else, if no argument is passed in "$p_extraArgs" parameter array.
            else
                case "$p_option" in
                    '-n')
                        echo -ne "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                    '')
                        echo -e "[$__TIME_DATE] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                esac
            fi

        sleep "$__STAT_TIME_TXT"

        # Else, if messages must be redirected in the log file AND to the terminal ("$__STAT_LOG_REDIRECT" value is equal to "tee")
        elif [ "$__STAT_LOG_REDIRECT" = "tee" ]; then

            # Checking if the extra arguments array contains an allowed value, by checking the "$a_acceptedExtraArgs" array's values.
            if [[ "${p_extraArgs[*]}" =~ ${a_acceptedExtraArgs[*]} ]]; then

                for val in "${p_extraArgs[@]}"; do

                    # If the "nodate" value is passed as argument.
                    if [ "$val" = "nodate" ]; then
                        case "$p_option" in
                            '-n')
                                echo -ne "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                            '')
                                echo -e "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                                ;;
                        esac

					# Else, if an unsupported option is passed (note for myself : the extra args checking
					# "for" loop (for val in "${p_extraArgs[@]}"; do) is still running (for the "tee" option)).
					else
						case "$p_option" in
							'-n')
								echo -ne "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
								echo -e "$v_warning_array_value" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
								;;
							'')
								echo -e "$p_string" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
								echo -e "$v_warning_array_value" 2>&1 | tee -a "$__PROJECT_LOG_FILE_PATH" || { echo >&2; echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
								;;
						esac
					fi
				done

            # Else, if no argument is passed in "$p_extraArgs" parameter array.
            else
                case "$p_option" in
                    '-n')
                        echo -ne "$p_string"
                        echo -ne "[$__TIME_DATE_DISPLAY] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                    '')
                        echo -e "$p_string"
                        echo -e "[$__TIME_DATE_DISPLAY] $p_string" >> "$__PROJECT_LOG_FILE_PATH" || { echo "$v_errorEcho" >&2; echo >&2; ExitSourced; }
                        ;;
                esac
            fi
            
            sleep "$__STAT_TIME_TXT"
        fi

    # Else, if no log file exists OR if "$__STAT_LOG" value is "false" OR if "$__STAT_LOG_REDIRECT" has no redirection value. 
    else
        case "$p_option" in
			'-n')
				echo -ne "$p_string"
				;;
			'')
				echo -e "$p_string"
				;;
		esac

        sleep "$__STAT_TIME_TXT"
	fi

    # Restore timer status variables old values if they were modified because of the redirection to the log file only.
    if [ "$__STAT_LOG_REDIRECT" = "true" ]; then
        if [ "$__STAT_LOG_REDIRECT" = "log" ] && [ "$__STAT_TIME_TXT" -eq 0 ]; then
        
            # Backup the old values to restore them when the log processing will be done, then check if the correct values were reassignated.
            __STAT_TIME_TXT="$__BU_OLD_STAT_TIME_TXT"; CheckSTAT_TIME_TXT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi
}

# -----------------------------------------------

## DIRECTORIES PATHS CHECKING

# 

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS

## EXIT HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function ExitError
{
    # In case the "exit" command didn't worked, the program has to be killed.
    CheckSTAT_EXIT_CODE "$(basename "${BASH_SOURCE[0]}")" "$LINENO"; exit "$__STAT_EXIT_CODE" || kill "$$"
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   - 
function HandleErrors
{
	#***** Paramètres *****
	local p_returnCode=$1     # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2    # Chaîne de caractères du type d'erreur à afficher.
	local p_adviceString=$3   # Chaîne de caractères affichants un conseil pour orienter l'utilisateur vers la meilleure solution en cas de problème.
    local p_badValue=$4       # Incorrect value which caused the error.
	local p_file=$5           # The name of the file where the error occured.
	local p_function=$6       # The name of the function where the error occured.
	local p_lineno=$7         # Ligne à laquelle le message d'erreur s'est produite.

    #***** Variables *****
    local v_hdrString
	
	if [ -n "$p_function" ]; then
		v_hdrString="$(echo -e "IN $(DechoHighlight "$p_file"), FUNCTION $(DechoHighlight "$p_function"), LINE $(DechoHighlight "$p_lineno") -->")"
	else
		v_hdrString="$(echo -e "IN $(DechoHighlight "$p_file"), LINE $(DechoHighlight "$p_lineno") -->")"
	fi

	# ***** Code *****
	CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$p_returnCode" -eq 0 ]; then
        return
    else
        if [ "$__STAT_LOG_REDIRECT" = "log" ]; then
            __STAT_LOG_REDIRECT="tee"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi

        if [ -n "$__STAT_ERROR" ] && [ "$__STAT_ERROR" = "fatal" ]; then
            HeaderRed "$v_hdrString FATAL ERROR : ${p_errorString^^}" >&2
        else
            HeaderRed "$v_hdrString ERROR : ${p_errorString^^}" >&2
        fi

        if [ -z "$p_adviceString" ]; then
            EchoError "No advice to give."; Newline >&2
        else
            EchoError "$(DechoHighlight "Advice") : $p_adviceString" >&2; Newline >&2
        fi
            
        if [ -z "$p_badValue" ]; then
            EchoError "Value(s) that caused this error : $(DechoOrange 'No value') OR $(DechoOrange 'an unknown error')"; Newline >&2
        else
            EchoError "Value(s) that caused this error : $(DechoHighlight "$p_badValue")"; Newline >&2
        fi

        if [ "$__STAT_ERROR" = "fatal" ]; then
            EchoError "Stopping the execution of $(DechoHighlight "$(basename "$0")")."; Newline >&2
            ExitError "$__STAT_EXIT_CODE"
        else
			# Calling the function that processes the given answer.
			CaseRead_HandleErrors
        fi
    fi
}

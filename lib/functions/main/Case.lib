#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Case.lib
# Module        : Main
# Author(s)     : Dimitri Obeid
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == en_* ]]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### LIBRARY RESOURCES

## VARIABLES

# __BU_MAIN_CASE_INVALID_ANSWER="Please enter a valid answer ($(BU.Main.Decho.Decho.Highlight 'yes') or ($(BU.Main.Decho.Decho.Highlight 'no')) !";
#
# __BU_MAIN_CASE_ASK_CONTINUE_EXEC="Do you want to continue the script's execution ? (yes / no)";
#
# __BU_MAIN_CASE_ANSWER_PROMPT="Enter your answer : ";
#
# __BU_MAIN_CASE_RESUME_EXEC="Resuming the execution of the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") script.";
#
# __BU_MAIN_CASE_CANCEL_EXEC="Aborting the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'s execution.";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### READING CASE STATEMENTS BY FUNCTIONS
#### DEBUG ID : case::reading-case-statements-by-functions

__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS="case::reading-case-statements-by-functions";

## "Directories.lib" FILE
## DEBUG ID : directories.lib-file

__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE="${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}::directories.lib-file";

# "BU.Main.Directories.TriggerRootDirWarning" function.
function BU.Main.Case.Read_DirectoriesTriggerRootDirWarning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE}";

    #**** Variables ****
    local __read_TriggerRootDirWarning; # VAR TYPE : String     - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VTriggerRootDirWarning='1';

    BU.Main.Echo.Newstep "${__BU_MAIN_CASE_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_CASE_ANSWER_PROMPT}" __read_TriggerRootDirWarning;
	BU.Main.Echo.Read "${__read_TriggerRootDirWarning}";
	BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_TriggerRootDirWarning,,}" in
		"yes")
            BU.Main.Echo.Newstep "${__BU_MAIN_CASE_RESUME_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
            BU.Main.Echo.Error "${__BU_MAIN_CASE_CANCEL_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_CASE_INVALID_ANSWER}";
			BU.Main.Case.Read_DirectoriesTriggerRootDirWarning;
			;;
	esac
}

# -----------------------------------------------

## "Errors.lib" FILE
## DEBUG ID : errors.lib-file

__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE="${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}::errors.lib-file";

# "BU.Main.Errors.HandleErrors" function, with the "${__BU_MAIN_STAT_ECHO}" variable set to "false".
function BU.Main.Case.Read_Errors.HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE}";

    #**** Variables ****
    local __read_HandleErrors; # VAR TYPE : String      - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VReadHandleErrors='1';

	BU.Main.Echo.Newstep "${__BU_MAIN_CASE_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_CASE_ANSWER_PROMPT}" __read_HandleErrors;
	BU.Main.Echo.Read "${__read_HandleErrors}";
    BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_HandleErrors,,}" in
		"yes")
			BU.Main.Echo.Newstep "${__BU_MAIN_CASE_RESUME_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
			BU.Main.Echo.Error "${__BU_MAIN_CASE_CANCEL_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			BU.Main.Errors.Exit "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_CASE_INVALID_ANSWER}";
			BU.Main.Case.Read_Errors.HandleErrors;
			;;
	esac
}

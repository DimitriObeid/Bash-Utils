#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Text.lib
# Module        : Main
# Description   : Functions specially made for text processing (cutting fields / characters, ).
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### 

## 

# Cut the date displayed before a string.
function BU::Main::Text::CutLogDateFromString()     { BU::Main::Text::CutLastFieldFromDelimiter "$1" '] ';  return 0; }

# Cut the dash written before a command option call (to be improved).
function BU::Main::Text::CutDashFromOption()        { BU::Main::Text::CutLastFieldFromDelimiter "$1" '-';   return 0; }

# Cut every part of a string before and with the delimiter.
function BU::Main::Text::CutFromCharacter()
{
    #**** Parameters ****
    p_target=$1         # String to process.
    # $2                # Delimiter.
    p_iterations=$3     # Iterations.

    #**** Code ****
    if [ -n "$p_iterations" ] && ! BU::IsInt "$p_iterations"; then
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1'
    fi

    if [ -z "$p_iterations" ] || [ "$p_iterations" -lt 1 ]; then
        p_iterations='1'
    fi

    for ((i=0; i<p_iterations; i++)); do
        #shellcheck disable=SC2001
        p_target="$(sed "s/^[^$2]*$2//" <<< "$p_target")"
        p_target="$p_target"
    done

    echo -ne "$p_target"; return 0
}

# Cut the last field of a string.
function BU::Main::Text::CutLastFieldFromDelimiter()
{
    #**** Parameters ****
    #   $1  --> string to process
    #   $2  --> delimiter

    #**** Code ****
    "$1"="${1##*$2)}"; echo -ne "$1" && return 0
}

# Cut any part of a string after a delimiter.
function BU::Main::Text::CutStringAfterDelim()
{
    #**** Parameters ****
    #   $1  --> string to process
    #   $2  --> delimiter
    #   $3  --> iterations

    #**** Code ****
    return
}

# Getting the size of a string.
function BU::Main::Text::GetStringSize()
{
    #**** Parameters ****
    p_string=$1

    #**** Variables ****
    v_size="${#p_string}"

    #**** Code ****
    echo "$v_size"; return 0
}

# Getting the number of words in a string.
function BU::Main::Text::GetStringWordsNumber()
{
    #**** Parameters ****
    p_string=$1

    #**** Code ****
    echo "$p_string" | wc -w; return 0
}

# Reverse words of a string according to a delimiter.

# Examples with the '|' and '/' delimiter:
# animal | big | car | donut    --> donut | car | big | animal
# /home/user/Documents          --> Documents/user/home
function BU::Main::Text::ReverseStringWordsOrder()
{
    #**** Parameters ****
    #   $1  --> string to process
    #   $2  --> delimiter

    #**** Code ****
    echo -ne "$1" | tr "$2" '\n' | tac | tr '\n' "$2" && return 0
}

#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Text.lib
# Module        : Main
# Description   : Functions specially made for text processing (cutting fields / characters, ).
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT PROCESSING FUNCTIONS
#### DEBUG ID : text::text-processing-functions

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS="text::text-processing-functions";

## CUTTING TEXT
## DEBUG ID : cutting-text

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS::cutting-text";

# Cut the date displayed before a string.
function BU::Main::Text::CutLogDateFromString()     { BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT"; BU::Main::Text::CutSubStringAfterNthDelim "$1" '] ';  BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0; }

# Cut the dash written before a command option call (to be improved).
function BU::Main::Text::CutDashFromOption()        { BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT"; BU::Main::Text::CutSubStringAfterNthDelim "$1" '-';   BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0; }

# Cut every part of a string after and with the delimiter, which can be both a single character or a string.
function BU::Main::Text::CutSubStringAfterNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT";

    #**** Parameters ****
    local p_string=$1;              # String    - Default : NULL    - String to process.
    local p_delimiter=$2;           # String    - Default : NULL    - Delimiter.
    local p_iterations=${3:-1};     # Int       - Default : 1       - Iterations.
    local p_count=$4;               # String    - Default : NULL    - Allow to set a counter of skipped delimiters.

    #**** Variables ****
    if [ -n "$p_count" ] && [ "${p_count,,}" = 'count' ]; then local v_count=0; fi

	# Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_fieldtmp="";

	# Let this variable empty, it is used to store the new string with every fields cut from the original string.
	local v_newString="";

	local x;

    #**** Code ****
    if ! BU::Main::Args__Text::CutSubStringAfterNthDelim "$p_string" "$p_delimiter" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    if [ -n "$p_iterations" ] && ! BU::IsInt "$p_iterations"; then
        BU::EchoWarning "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
	x="$(BU::Main::Text::GetSubStringOccurences "$p_string" "$p_target")";

    for ((i=0; i<x; i++)); do
		if [ "$i" = "$p_iterations" ]; then break; fi

        v_fieldtmp="${p_string%%$p_delimiter*}";
		v_fieldtmp="${v_fieldtmp#*$p_delimiter}";

		if [ -z "$p_newString" ]; then
			p_newString="$v_fieldtmp";
		else
			p_newString="$p_newString$p_delimiter$v_fieldtmp";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

	if [ "${p_count,,}" != 'count' ]; then echo -ne "$p_newString"; else echo -ne "$v_count"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Cut every part of a string before and with the delimiter, which can be both a single character or a string.
function BU::Main::Text::CutSubStringBeforeNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT";

    #**** Parameters ****
    local p_string=$1;              # String    - Default : NULL    - String to process.
    local p_delimiter=$2;           # String    - Default : NULL    - Delimiter.
    local p_iterations=${3:-1};     # Int       - Default : 1       - Iterations.
    local p_count=$4;               # String    - Default : NULL    - Allow to set a counter of skipped delimiters.

    #**** Variables ****
    if [ -n "$p_count" ] && [ "${p_count,,}" = 'count' ]; then local v_count=0; fi

    #**** Code ****
    if ! BU::Main::Args__Text::CutSubStringBeforeNthDelim "$p_string" "$p_delimiter" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    if [ -n "$p_iterations" ] && ! BU::IsInt "$p_iterations"; then
        BU::EchoWarning "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
    fi

    for ((i=0; i<p_iterations; i++)); do

        #shellcheck disable=SC2001
        p_string="$(sed "s/^[^$p_delimiter]*$p_delimiter//" <<< "$p_string")";
        p_string="$p_string";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ "${p_count,,}" != 'count' ]; then echo -ne "$p_string"; else echo -ne "$v_count"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Cut the very first field of a string, before the delimiter, in order to get everything that follows the first field.
function BU::Main::Text::CutFirstFieldBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT";

    #**** Parameters ****
    local p_string=$1;	# String    - Default : NULL    - String to process.
    local p_delim=$2;	# String	- Default : NULL	- Delimiter

    #**** Code ****
	if ! BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims "$p_string" "$p_delim" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$?"; fi

    echo "${p_string%$p_delim*}" && BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Cut the very last field of a string, in order to get everything that preceeds the last field.
function BU::Main::Text::CutLastFieldAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT";

    #**** Parameters ****
    local p_string=$1;	# String    - Default : NULL    - String to process.
    local p_delim=$2;	# String	- Default : NULL	- Delimiter

    #**** Code ****
	if ! BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims "$p_string" "$p_delim" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$?"; fi

    echo "${p_string#*$p_delim}" && BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Deleting letters in a string.
function BU::Main::Text::DeleteLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT";

    #**** Parameters ****
    local p_string=$1;      # String    - Default : NULL    - String to process.
    shift;

    local p_char=("$@");    # String    - Default : NULL    - Letters and strings to remove.

    #**** Code ****
    if ! BU::ArrayIsNotEmpty; then BU::EchoError "No string passed as first argument"; BU::Newline; return 1; fi

    if ! BU::Main::Args__Text::DeleteLettersInString "$p_string" "$(basename "${BASH_SOURCE[0]}")" "${FUCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$?"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# -----------------------------------------------

## FORMATTING TEXT
## DEBUG ID : text::text-processing-functions::formatting-text

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS::formatting-text";

# Keep the same text format between lowercased or uppercased text printed by a formatting text function ("BU::Main::Echo::ToLowercase()" OR "BU::Main::Echo::ToUppercase()") or a parameter expansion.
# This function is planned to be used between force-uppered/lowered text, to keep the original text formatting of the wanted string excerpt.
function BU::Main::Echo::KeepFormatting()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT";

	#**** Parameters ****
#	p_string=$1;           # String to display.
#	p_old_formatting=$2;   # Former tectxt formatting.

	#**** Code ****
# 	echo -ne &>/dev/null; echo -ne "$p_string";
#
# 	if [ "${p_old_formatting,,}" = 'l' ]; then
#         echo -ne "$(BU::Main::Echo::ToLowercase "$p_string")";
# 	elif [ "${p_old_formatting^^}" = 'U' ]; then
#         echo -ne "$(BU::Main::Echo::ToUppercase "$p_string")";
# 	else
#         echo -ne "<<|| No reformatting precised in the $(BU::Main::Echo::ToLowercase "${FUNCNAME[0]}()") function ||>>";
# 	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Print a lowercased text.

# Usage :
#	BU::Main::Echo::ToLowercase "<Text to write>"
function BU::Main::Echo::ToLowercase()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT";

	#**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.

	#**** Code ****
	echo "$p_string" | tr '[:upper:]' '[:lower:]'; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Print an uppercased text.

# Usage :
#	BU::Main::Echo::ToUppercase "<Text to write>"
function BU::Main::Echo::ToUppercase()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT";

	#**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.

	#**** Code ****
	echo "$p_string" | tr '[:lower:]' '[:upper:]'; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## GETTING TEXT
## DEBUG ID : getting-text

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS::getting-text"

# Getting the occurences of a character in a main string.
function BU::Main::Text::GetCharacterOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.
    local p_target=$2;  # Char      - Default : NULL    - Targeted character.

    #**** Variables ****
    local v_occurences="${p_string//[^$p_target]}";

    #**** Code ****
    if ! BU::Main::Args__Text::GetCharacterOccurences "$p_string" "$p_target" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$?"; fi

    echo -ne "${#v_occurences}";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Get the very first field of a string, and cut everything that follows the first delimiter.
function BU::Main::Text::GetFirstFieldBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;	# String    - Default : NULL    - String to process.
    local p_delim=$2;	# String	- Default : NULL	- Delimiter

    #**** Code ****
	if ! BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims "$p_string" "$p_delim" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    echo "${p_string%%$p_delim*}" && BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Get the very last field of a string, and cut everything that preceeds the last delimiter.
function BU::Main::Text::GetLastFieldAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;	# String    - Default : NULL    - String to process.
    local p_delim=$2;	# String	- Default : NULL	- Delimiter

    #**** Code ****
	if ! BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims "$p_string" "$p_delim" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

	echo "${p_string##*$p_delim}" && BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Getting substring after a delimiter, which can be both a single character or a string.
BU::Main::Text::GetSubStringAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;              # String    - Default : NULL    - String to process.
    local p_delim=$2;               # Char      - Default : NULL    - Delimiter
    local p_iterations=${3:-1};     # Int       - Default : 1       - Iterations
    local p_count=$4;               # String    - Default : NULL    - Allow to set a counter of skipped delimiters.
    local p_init=$5;                # String    - Default : NULL    - RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    if [ -n "$p_count" ] && [ "${p_count,,}" = 'count' ]; then local v_count=0; fi

    #**** Code ****
    if [ -z "$p_init" ] || [ -n "$p_init" ] && [ "${p_init,,}" != '--init' ]; then
        if ! BU::Main::Args__Text::GetSubStringAfterDelim "$p_string" "$p_delim" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi
    fi

    # WARNING ! DO NOT put double quotes between the "$(seq "$p_iterations")", or else it will not word split, and the loop will only run once !
    for i in $(seq "$p_iterations"); do
        p_string="${p_string#*$p_delim}";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done;

    if [ "${p_count,,}" != 'count' ]; then echo -ne "$p_string"; else echo -ne "$v_count"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Getting substring before a delimiter, which can be both a single character or a string.
BU::Main::Text::GetSubStringBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;              # String    - Default : NULL    - String to process.
    local p_delim=$2;               # Char      - Default : NULL    - Delimiter
    local p_iterations=${3:-1};     # Int       - Default : 1       - Iterations
    local p_count=$4;               # String    - Default : NULL    - Allow to set a counter of skipped delimiters.
    local p_init=$5;                # String    - Default : NULL    - RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    if [ -n "$p_count" ] && [ "${p_count,,}" = 'count' ]; then local v_count=0; fi

	# Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_fieldtmp="";

	# Let this variable empty, it is used to store the new string with every fields cut from the original string.
	local v_newString="";

	local x;

    #**** Code ****
    if [ -z "$p_init" ] || [ -n "$p_init" ] && [ "${p_init,,}" != '--init' ]; then
        if ! BU::Main::Args__Text::GetSubStringBeforeDelim "$p_string" "$p_delim" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

        if [ -n "$p_iterations" ] && ! BU::IsInt "$p_iterations"; then
            BU::EchoWarning "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
        fi
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
    if [ "${p_init,,}" == '--init' ]; then
        x="$(BU::Main::Text::GetSubStringOccurences "$p_string" "$p_target" "--init")";
	else
        x="$(BU::Main::Text::GetSubStringOccurences "$p_string" "$p_target")";
    fi

    for ((i=0; i<x; i++)); do
		if [ "$i" = "$p_iterations" ]; then break; fi

        v_fieldtmp="${p_string##*$p_delim}";
		v_fieldtmp="${v_fieldtmp%$p_delim*}";

		if [ -z "$v_newString" ]; then
			v_newString="$v_fieldtmp";
		else
			v_newString="$v_newString$p_delim$v_fieldtmp";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ -z "$p_init" ] || [ -n "$p_init" ] && [ "${p_init,,}" != '--init' ]; then
	    v_newString="$(BU::Main::Text::ReverseStringWordsOrder "$v_newString" "$p_delim")";
    else
        v_newString="$(BU::Main::Text::ReverseStringWordsOrder "$v_newString" "$p_delim" '--init')";
    fi

	if [ "${p_count,,}" != 'count' ]; then echo -e "$v_newString"; else echo "$p_count"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the occurences of a sub-string in a main string (it also works with a single character).
function BU::Main::Text::GetSubStringOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.
    local p_target=$2;  # String    - Default : NULL    - Targeted sub-string.
    local p_init=$3;    # String    - Default : NULL    - RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module (this function is called by the "BU::Main::Text::GetSubStringBeforeDelim()" function, which is called in the "BU::ModuleInit::ParseCSVLang()" function).

	#**** Variables ****
	local tmp;
	local count;

    #**** Code ****
    if [ -z "$p_init" ] || [ -n "$p_init" ] && [ "${p_init,,}" != '--init' ]; then
        if ! BU::Main::Args__Text::GetSubStringOccurences "$p_string" "$p_target" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi
    fi

	# https://stackoverflow.com/a/50601141

	# This removes all occurrences of "$p_string" from $CommandResult and places it in tmp.
	# Actually we're using substring replacement here with replacement string missing.

	# Syntax for substring replacement is "${p_string//substring/replacement}" (this replaces all occurrences of substring with replacement).
	tmp="${p_string//$p_target}";

	# This gives us the number of occurrences of "$p_string" in $CommandResult.

	# ${#p_string} gives string length so (${#p_string} - ${#tmp]) is length of all occurrences of "$p_target" (remember, we removed all occurrences of "$p_target" from "$p_string" and placed the result in "$tmp").
	count="$(((${#p_string} - ${#tmp}) / ${#p_target}))";

	echo -e "$count";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the size of a string in byte.
function BU::Main::Text::GetStringByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.

    #**** Code ****
    echo -ne "$p_string" | wc --bytes; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the size of a string in characters.
function BU::Main::Text::GetStringCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.

    #**** Code ****
    echo -ne "$p_string" | wc --chars; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the number of words in a string.
function BU::Main::Text::GetStringWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT";

    #**** Parameters ****
    local p_string=$1;  # String    - Default : NULL    - String to process.

    #**** Code ****
    echo -ne "$p_string" | wc -w; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## REVERSING TEXT
## DEBUG ID : reversing-text

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS::reversing-text";

# Reverse words of a string according to a delimiter.

# Examples with the '|' and '/' delimiter:
# animal | big | car | donut    --> donut | car | big | animal
# /home/user/Documents          --> Documents/user/home
function BU::Main::Text::ReverseStringWordsOrder()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT";

    #**** Parameters ****
    local p_string=$1;	# String    - Default : NULL    - String to process.
    local p_delim=$2;	# String	- Default : NULL	- Delimiter
    local p_init=$3;    # String    - Default : NULL    - RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module (this function is called by the "BU::Main::Text::GetSubStringAfterDelim()" function, which is called in the "BU::ModuleInit::ParseCSVLang()" function).


	#**** Variables ****
	# Leave this variable empty, it will store the reversed string.
	local reversed="";

    #**** Code ****
    if [ -z "$p_init" ] || [ -n "$p_init" ] && [ "${p_init,,}" != 'init' ]; then
        if ! BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims "$p_string" "$p_delim" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi
    fi

	IFS="$p_delim" read -ra line <<< "$p_string";

	# shellcheck disable=SC2219
	let x="${#line[@]}-1";

	while [ "$x" -ge 0 ]; do
		if [ "$x" -gt 0 ]; then reversed="$reversed${line[x]}$delim"; else reversed="$reversed${line[x]}"; fi

		(( x-- ));
	done

	echo -e "$reversed";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## SPLITTING TEXT
## DEBUG ID : splitting-text

# shellcheck disable=SC2034
BU::ModuleInit::CheckIsDebugging && __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS::splitting-text";

# Splitting a string from a given delimiter, in order to store it in an array.
# function BU::Main::Text::SplitStringFromDelim()
# {
#     # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
#     BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
#         "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS" \
#         "$__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT";
#
#     #**** Parameters ****
#     local p_string=$1;          # String    - Default : NULL    - String to process.
#     local p_delim=$2;           # Delimiter.
#     local p_order=$3;           # Splitting order (L|l = left to right, R|r = right to left).
#     local p_iterations=$4;      # Number of delimiters to process.
#     local p_ignore_delim=$5;    # Number of delimiters to ignore before splitting the string.
#
#     #**** Code ****
#     if [ -z "$p_iterations" ] || [ "$p_iterations" -eq 0 ]; then
#         p_iterations='1';
#     fi
#
#     # If the string has to be processed from left to right.
#     if [ "${p_order^^}" = 'L|l' ]; then
#         for ((i=0; i<p_iterations; i++)); do
#             if [ -z "$p_ignore_delim" ] || [ "$p_ignore_delim" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if the string has to be processed from right to left.
#     elif [ "${p_order^^}" = 'R|r' ]; then
#         for ((i=0; i<p_iterations; i++)); do
#             if [ -z "$p_ignore_delim" ] || [ "$p_ignore_delim" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if no value is passed to the order processer.
#     elif [ -z "$p_order" ]; then
#         false
#
#     # Else, if an unsupported value is passed to the order processer.
#     else
#         false
#     fi
#
#     BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
# }

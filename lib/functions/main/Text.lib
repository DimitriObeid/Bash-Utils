#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : Text.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# Contributors  :
#   -


# ----------------------
# SCRIPT'S DESCRIPTION :

# Functions specially made for text processing (cutting fields / characters, ).


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154


# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    if [[ "${LANG}" == de_* ]]; then
        echo -e "ACHTUNG !" >&2; echo >&2;
        echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
        echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

    elif [[ "${LANG}" == es_* ]]; then
        echo -e "ATENCIÓN !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
        echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

    elif [[ "${LANG}" == fr_* ]]; then
        echo -e "ATTENTION !" >&2; echo >&2;
        echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
        echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

    elif [[ "${LANG}" == hi_* ]]; then
        echo -e "चेतावनी!" >&2; echo >&2;
        echo -e "यह शेल स्क्रिप्ट (${BASH_SOURCE[0]}) सीधे निष्पादित करने के लिए नहीं है!" >&2; echo >&2;
        echo -e "इस स्क्रिप्ट को अपने प्रोजेक्ट स्क्रिप्ट में शामिल करके ही इस्तेमाल करें।" >&2;

    elif [[ "${LANG}" == id_* ]]; then
        echo -e "PERINGATAN !" >&2; echo >&2;
        echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
        echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

    elif [[ "${LANG}" == ja_* ]]; then
        echo -e "警告 ！" >&2; echo >&2;
        echo -e "このシェルスクリプト（${BASH_SOURCE[0]}）は、直接実行することはできません！" >&2; echo >&2;
        echo -e "このスクリプトは、プロジェクトスクリプトに含める必要があり、このスクリプトと一緒にしか使用できません。" >&2;

    elif [[ "${LANG}" == ko_* ]]; then
        echo -e "경고 !" >&2; echo >&2;
        echo -e "이 셸 스크립트(${BASH_SOURCE[0]})는 직접 실행하도록 설계되지 않았습니다!" >&2; echo >&2;
        echo -e "프로젝트 스크립트에 포함하여 이 스크립트만 사용하십시오." >&2;

    elif [[ "${LANG}" == pt_* ]]; then
        echo -e "ATENÇÃO !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
        echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

    elif [[ "${LANG}" == ru_* ]]; then
        echo -e "ВНИМАНИЕ !" >&2; echo >&2;
        echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
        echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

    elif [[ "${LANG}" == sv_* ]]; then
        echo -e "VARNING!" >&2; echo >&2;
        echo -e "Detta skalskript (${BASH_SOURCE[0]}) är inte avsett att köras direkt!" >&2; echo >&2;
        echo -e "Använd endast detta skript genom att inkludera det i ditt projektskript." >&2;

    elif [[ "${LANG}" == tr_* ]]; then
        echo -e "UYARI!" >&2; echo >&2;
        echo -e "Bu kabuk betiği (${BASH_SOURCE[0]}) doğrudan çalıştırılmak üzere tasarlanmamıştır!" >&2; echo >&2;
        echo -e "Proje kodunuza dahil ederek yalnızca bu kodu kullanın." >&2;

    elif [[ "${LANG}" == uk_* ]]; then
        echo -e "УВАГА !" >&2; echo >&2;
        echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
        echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

    elif [[ "${LANG}" == zh_* ]]; then
        echo -e "警告 !" >&2; echo >&2;
        echo -e "这个shell脚本(${BASH_SOURCE[0]})是不能直接执行的!" >&2; echo >&2;
        echo -e "只使用这个脚本并将其纳入你的项目脚本。" >&2;

    else
        echo -e "WARNING !" >&2; echo >&2;
        echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
        echo -e "Use only this script by including it in your project script." >&2;

    fi;
    
    echo >&2; 
    
    exit 1; 
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT PROCESSING FUNCTIONS
#### DEBUG ID : "bu::main::text::text-processing-functions"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS="bu::main::text::text-processing-functions";

## CUTTING TEXT
## DEBUG ID : "cutting-text"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::cutting-text";

# ···········································
# Cutting the date displayed before a string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - sed       | (-E)


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib

#   - BU.Main.Text.CutSubStringAfterNthDelim()  -> Main -> Text.lib (this file)

# shellcheck disable=
function BU.Main.Text.CutLogDateFromString()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Code ****
    echo "${1}" | sed -E 's/^\[ [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} \] *//';
    
    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
    
    return 0;
}

# ············································
# Cutting any log information before a string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib

#   - BU.Main.Text.CutSubStringAfterNthDelim()  -> Main -> Text.lib (this file)

# shellcheck disable=
function BU.Main.Text.CutLogInfoFromString()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Code ****
    BU.Main.Text.CutSubStringAfterNthDelim "${1}" '] ';
    
    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
    
    return 0;
}

# ·······································································
# Cutting the dash written before a command option call (to be improved).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib

#   - BU.Main.Text.CutSubStringAfterNthDelim()  -> Main -> Text.lib (this file)

# shellcheck disable=
function BU.Main.Text.CutDashFromOption()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Code ****
    BU.Main.Text.CutSubStringAfterNthDelim "${1}" '-';
    
    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
    
    return 0;
}

# ··················································································
# Cutting the first character from a string, and getting every following characters.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutFirstCharacter()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo "${p_string:1}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ················································································
# Cutting the last character from a string, and getting every previous characters.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - declare   | (-i)
#   - echo      |
#   - local     |
#   - shopt     | (-s | -u)


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutLastCharacter()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Variables ****
    declare -i v_length;        # VAR TYPE : Int        - DESC : Storing the length of the character.

    #**** Code ****
    # Getting the number of characters from this string.
    v_length="${#p_string}";

    shopt -s extglob;

    # Printing the wanted character.
    echo "${p_string%%+("${p_string:$(( v_length - 1 ))}")}";

    shopt -u extglob;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ··············································································································
# Cutting every part of a string after and with the delimiter, which can be both a single character or a string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - declare   | (-i)
#   - echo      | (-e | -n)
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutSubStringAfterNthDelim()    -> Main -> Args.lib

#   - BU.Main.Checkings.IsInt()                         -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                           -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                            -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutSubStringAfterNthDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations.
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.

    #**** Variables ****
    declare -i i;                   # VAR TYPE : Int        - DESC : "For" loop counter.
	declare -i x;                   # VAR TYPE : Int        - DESC :

    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

	local v_fieldtmp="";            # VAR TYPE : String     - DESC : Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_newString="";           # VAR TYPE : String     - DESC : Let this variable empty, it is used to store the new string with every fields cut from the original string.

    #**** Code ****
    if ! BU.Main.Args__Text.CutSubStringAfterNthDelim "${p_string}" "${p_delimiter}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
	x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_delimiter}")";

    for ((i=0; i<x; i++)); do
		if [ "${i}" == "${p_iterations}" ]; then break; fi

        v_fieldtmp="${p_string%%"${p_delimiter}"*}";
		v_fieldtmp="${v_fieldtmp#*"${p_delimiter}"}";

		if [ -z "${v_newString}" ]; then
			v_newString="${v_fieldtmp}";
		else
			v_newString="${v_newString}${p_delimiter}${v_fieldtmp}";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

	if [ "${p_count,,}" != 'count' ]; then echo -ne "${v_newString}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# ···········································································································
# Cut every part of a string before and with the delimiter, which can be both a single character or a string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - declare   | (-i)
#   - echo      | (-e | -n)
#   - local     |
#   - sed       |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutSubStringBeforeNthDelim()   -> Main -> Args.lib

#   - BU.Main.Checkings.IsInt()                         -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                           -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutSubStringBeforeNthDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations.
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.

    #**** Variables ****
    declare -i i;                   # VAR TYPE : Int        - DESC : "For" loop counter.

    local p_string_tmp;             # VAR TYPE : String     - DESC :

    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

    #**** Code ****
    if ! BU.Main.Args__Text.CutSubStringBeforeNthDelim "${p_string}" "${p_delimiter}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer.";
        
        p_iterations='1';
    fi

    for ((i=0; i<p_iterations; i++)); do

        # shellcheck disable=SC2001
        p_string="$(sed "s/^[^${p_delimiter}]*${p_delimiter}//" <<< "${p_string}")";

        # This variable's purpose is to avoid assigning the "${p_string}" variable to itself, because if so, the assignment would have done nothing.
        p_string_tmp="${p_string}";
        p_string="${p_string_tmp}";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ "${p_count,,}" != 'count' ]; then echo -ne "${p_string}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ····················································································································
# Cut the very first field of a string, before the delimiter, in order to get everything that follows the first field.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |
#   - echo      |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                                   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutFirstFieldBeforeDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo "${p_string%"${p_delim}"*}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# ·····························································································
# Cut the very last field of a string, in order to get everything that preceeds the last field.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |
#   - echo      |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                                   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.CutLastFieldAfterDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo "${p_string#*"${p_delim}"}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# ··················································
# Deleting letters and sub-strings in a main string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |
#   - printf    |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.DeleteLettersInString()    -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib

#   - BU.Main.Text.ReplaceLettersInString()         -> Main -> Text.lib (this file)

# shellcheck disable=
function BU.Main.Text.DeleteLettersInString()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_chars=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Letters and / or strings to replace.
    local p_occurences=${3:-one}    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : one      - DESC : Replace one occurence (default) or every occurences (value : all)
    local p_replacement=${4:-' '};  # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : ' '      - DESC : Replacing the former character / sub-string by an empty space (default (' ')) OR deleting them by remplacing them with an empty character ('').

    #**** Code ****
    if ! BU.DevBin.LibCompiler.Function.IsCompiler; then
        if ! BU.Main.Args__Text.DeleteLettersInString \
            "${p_string}" \
            "$(basename \
                "${BASH_SOURCE[0]}")" \
            "${FUCNAME[0]}" \
            "${LINENO}";
        then
            local C="${?}";

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return "${C}";
        fi
    fi

    BU.Main.Text.ReplaceLettersInString "${p_string}" "${p_chars}" "$([ "${p_replacement}" == '' ] && printf '' || printf ' ')" || {
        local C="${?}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# ···················································
# Replacing letters and sub-strings in a main string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :

#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ReplaceLettersInString()
{
    if ! BU.DevBin.LibCompiler.Function.IsCompiler && ! BU.DevBin.LCFAL.Function.IsShellScriptLCFAL; then
        # This function call makes it easier for the user to find the current function and its executed
        # content if it is called during the execution of the main script with the "$(bash -x)" command.
        BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
            "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
            "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";
    fi

    #**** Parameters ****
    local p_string=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};          # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Letters and / or strings to replace.
    local p_occurences=${3:-one}        # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : one      - DESC : Replace one occurence (default) or every occurences (value : all)
    local p_replacement=${4:-$'\0'};    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Replacing the former character / sub-strings by another character / sub-string.

    #**** Code ****
    if [ "${p_occurences,,}" == 'all' ]; then
        echo "${p_string//${p_delim}/"${p_replacement}"}";
    else
        echo "${p_string/${p_delim}/"${p_replacement}"}";
    fi

    if ! BU.DevBin.LibCompiler.Function.IsCompiler && ! BU.DevBin.LCFAL.Function.IsShellScriptLCFAL; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
    fi

    return 0;
}

## ==============================================

## FORMATTING TEXT
## DEBUG ID : "formatting-text"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}.formatting-text";

# ······························································································································································································
# Keep the same text format between lowercased or uppercased text printed by a formatting text function ("BU.Main.Text.ToLowercase()" OR "BU.Main.Text.ToUppercase()") or a parameter expansion.
# This function is planned to be used between force-uppered/lowered text, to keep the original text formatting of the wanted string excerpt.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.KeepFormatting()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
#	p_string=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to display.
#	p_old_formatting=${2:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Former text formatting.

	#**** Code ****
# 	echo -ne &>/dev/null; echo -ne "${p_string}";
#
# 	if [ "${p_old_formatting,,}" == 'l' ]; then
#         echo -ne "$(BU.Main.Text.ToLowercase "${p_string}")";
# 	elif [ "${p_old_formatting^^}" == 'U' ]; then
#         echo -ne "$(BU.Main.Text.ToUppercase "${p_string}")";
# 	else
#         echo -ne "<<|| No reformatting precised in the $(BU.Main.Text.ToLowercase "${FUNCNAME[0]}()") function ||>>";
# 	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ························
# Print a lowercased text.

# Usage :
#	BU.Main.Text.ToLowercase "<Text to write>"

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |
#   - tr        |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ToLowercase()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

	#**** Code ****
	echo "${p_string}" | tr '[:upper:]' '[:lower:]'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ·························
# Print an uppercased text.

# Usage :
#	BU.Main.Text.ToUppercase "<Text to write>"

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |
#   - tr        |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ToUppercase()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

	#**** Code ****
	echo "${p_string}" | tr '[:lower:]' '[:upper:]'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

## ==============================================

## GETTING TEXT
## DEBUG ID : "getting-text"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::getting-text";

# ·······················································
# Getting the occurences of a character in a main string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      | (-n | -e)
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetCharacterOccurences()   -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetCharacterOccurences()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Variables ****
    local v_occurences="${p_string//[^${p_target}]}";

    #**** Code ****
    if ! BU.Main.Args__Text.GetCharacterOccurences "${p_string}" "${p_target}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo -ne "${#v_occurences}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ·····································································
# Getting the occurences of a string pattern in the values of an array.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetCharacterOccurences()   -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetCharacterOccurencesFromArray()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_array=${1:-$'\0'};      # ARG TYPE : String - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted array to process.
    local p_target=${2:-$'\0'};     # ARG TYPE : Char   - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.
    local p_valToDisplay=${3:-2};   # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : 2        - Desc : Printing the number of indexes only where an occurence was found (0), the number of occurences only (1), or both (2).

    #**** Code ****
    if ! BU.Main.Args__Text.GetCharacterOccurencesFromArray \
        "${p_array}" \
        "${p_target}" \
        "${p_valToDisplay}" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${LINENO}";
    then
        local C="${?}";
        
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
        
        return "${?}";
    fi

    return 0;
}

# ·························································································
# Get the very first character of a string, and cut everything that follows this character.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetFirstLastCharacter()    -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetFirstCharacter()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    if ! BU.Main.Args__Text.GetFirstLastCharacter "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    echo "${p_string:0:1}"; return 0;
}

# ··························································································
# Get the very first field of a string, and cut everything that follows the first delimiter.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                                   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetFirstFieldBeforeDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    echo "${p_string%%"${p_delim}"*}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ··········································································
# Get the very last character of a string, and cut the preceding characters.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetFirstLastCharacter()    -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetLastCharacter()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Variables ****
    declare -i v_length;        # VAR TYPE : Int        - DESC : Storing the length of the character.

    #**** Code ****
    if ! BU.Main.Args__Text.GetFirstLastCharacter "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Getting the number of characters from this string.
    v_length="${#p_string}";

    # Printing the wanted character.
    echo "${p_string:$(( v_length - 1 )):1}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ·························································································
# Get the very last field of a string, and cut everything that preceeds the last delimiter.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                                   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetLastFieldAfterDelim()
{
    local __v_functions=('BU.DevBin.LibDebug.Function.IsShellScriptLibDebug');

    # This method, which uses the previously defined array, allows to avoid the call of too many functions while checking if a condition is valid or not.
    for func in "${__v_functions[@]}"; do
        if declare -F "${func}" &>/dev/null; then
            if ! "${func}"; then
                # This function call makes it easier for the user to find the current function and its executed
                # content if it is called during the execution of the main script with the "$(bash -x)" command.
                BU.Main.Echo.Debug \
                    "main" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
                    "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";
            fi
        fi
    done

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};  # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Variables ****
    local v_functions0=();      # VAR TYPE : Array      - DESC : Array of functions to call while checking the validity of a condition.

    #**** Code ****
    v_functions0+=("${__v_functions[@]}");

    unset __v_functions;

    for func in "${__v_functions0[@]}"; do
        if declare -F "${func}" &>/dev/null; then
            if  ! "${func}" && \
                ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims \
                    "${p_string}" \
                    "${p_delim}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${LINENO}";
            then
                local C="${?}";

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                return "${C}";
            fi
        fi
    done

	echo "${p_string##*"${p_delim}"}";

    for func in "${__v_functions[@]}"; do
        if declare -F "${func}" &>/dev/null; then
            if ! "${func}"; then
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
            fi
        fi
    done

	return 0;
}

# ······················································································
# Getting substring after a delimiter, which can be both a single character or a string.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetSubStringAfterDelim()   -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetSubStringAfterDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Number of iterations.
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.
    local p_init=${5:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.GetSubStringAfterDelim "${p_string}" "${p_delim}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    fi

    # WARNING ! DO NOT put double quotes between the >>  $(seq "${p_iterations}")  <<, or else it will not word split, and the loop will only run once !
    for i in $(seq "${p_iterations}"); do
        p_string="${p_string#*"${p_delim}"}";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done;

    if [ "${p_count,,}" != 'count' ]; then echo -ne "${p_string}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# ·······················································································
# Getting substring before a delimiter, which can be both a single character or a string.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetSubStringBeforeDelim()  -> Main -> Args.lib

#   - BU.Main.Checkings.IsInt()                     -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                        -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetSubStringBeforeDelim()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.
    local p_init=${5:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    declare -i i;                   # VAR TYPE : Int        - DESC : "For" loop counter.

    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

	local v_fieldtmp="";            # VAR TYPE : String     - DESC : Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_newString="";           # VAR TYPE : String     - DESC : Let this variable empty, it is used to store the new string with every fields cut from the original string.
	local x;                        # VAR TYPE : INT        - DESC :

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.GetSubStringBeforeDelim "${p_string}" "${p_delim}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

        if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
            BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
        fi
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
    if [ "${p_init,,}" == '--init' ]; then
        x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_target}" "--init")";
	else
        x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_target}")";
    fi

    for ((i=0; i<x; i++)); do
		if [ "${i}" == "${p_iterations}" ]; then break; fi

        v_fieldtmp="${p_string##*"${p_delim}"}";
		v_fieldtmp="${v_fieldtmp%"${p_delim}"*}";

		if [ -z "${v_newString}" ]; then
			v_newString="${v_fieldtmp}";
		else
			v_newString="${v_newString}${p_delim}${v_fieldtmp}";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
	    v_newString="$(BU.Main.Text.ReverseStringWordsOrder "${v_newString}" "${p_delim}")";
    else
        v_newString="$(BU.Main.Text.ReverseStringWordsOrder "${v_newString}" "${p_delim}" 'rm --first+last' '--init')";
    fi

	if [ "${p_count,,}" != 'count' ]; then echo -e "${v_newString}"; else echo "${p_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}


# ································································································
# Getting the occurences of a sub-string in a main string (it also works with a single character).

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.GetSubStringOccurences()   -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetSubStringOccurences()
{
    if ! BU.DevBin.LibCompiler.Function.IsCompiler; then
        # This function call makes it easier for the user to find the current function and its executed
        # content if it is called during the execution of the main script with the "$(bash -x)" command.
        BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
            "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
            "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";
    fi

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};  # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted sub-string.
    local p_init=${3:-$'\0'};    # ARG TYPE : String    - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module (this function is called by the "BU.Main.Text.GetSubStringBeforeDelim()" function, which is called in the "BU.ModuleInit.ParseCSVLang()" function).

	#**** Variables ****
	local tmp;      # VAR TYPE :
	local count;    # VAR TYPE :

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]] && ! BU.DevBin.LibCompiler.Function.IsCompiler; then
        if ! BU.Main.Args__Text.GetSubStringOccurences "${p_string}" "${p_target}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    fi

	# https://stackoverflow.com/a/50601141

	# This removes all occurrences of "${p_target}" from "${p_string}" and places it in tmp.
	# Actually we're using substring replacement here with replacement string missing.

	# Syntax for substring replacement is "${p_string//substring/replacement}" (this replaces all occurrences of substring with replacement).
	tmp="${p_string//${p_target}}";

	# This gives us the number of occurrences of "${p_target}" in "${p_string}".

	# ${#p_string} gives string length so (${#p_string} - ${#tmp]) is length of all occurrences of "${p_target}" (remember, we removed all occurrences of "${p_target}" from "${p_string}" and placed the result in "${tmp}").
	count="$(((${#p_string} - ${#tmp}) / ${#p_target}))";

	echo -e "${count}";

    if ! BU.DevBin.LibCompiler.Function.IsCompiler; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";
    fi

    return 0;
}

# ·····································
# Getting the size of a string in byte.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetStringByteSize()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --bytes; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ···········································
# Getting the size of a string in characters.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetStringCharactersNumber()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # VAR TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --chars; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ········································
# Getting the number of words in a string.

# Featured shell commands and their option(s) :
#   - basename
#   - echo      (-n -e)
#   - wc        (--words)


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.GetStringWordsNumber()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --words; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

## ==============================================

## LISTING TEXT
## DEBUG ID : "listing-text"

declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__LISTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::listing-text";

# ···········································
# Getting every characters present in a file.

# Featured shell commands and their option(s) :
#   - basename
#   - fold      (-w1)
#   - sort      (-u)


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ListCharactersFromFile() {
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__LISTING_TEXT}";

    #*** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : Filepath   - REQUIRED | DEFAULT VAL : NULL     - DESC : File to process.
#    local p_layout=${2:-$'\0'};     # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    fold -w1 "${p_filepath}" | sort -u || {
        local C="${?}"; BU.Main.Echo.Warning "Failed to get the list of each character from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ······································
# Getting every words present in a file.

# Featured shell commands and their option(s) :
#   - basename
#   - sed       (-e)
#   - sort      (-u | -f)


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ListWordsFromFile()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__LISTING_TEXT}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : Filepath   - REQUIRED | DEFAULT VAL : NULL     - DESC : File to process.

    #**** Code ****
    grep -o -E "(\w|')+" "${p_filepath}" | sed -e "s/'.*\$//" | sort -u -f || {
        local C="${?}"; BU.Main.Echo.Warning "Failed to get the list of each words from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

## ==============================================

## PRINTING TEXT
## DEBUG ID : "printing-text"

declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__PRINTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::printing-text";

# ················································
# Printing a single character or a string X times.

# Featured shell commands and their option(s) :
#   - printf

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()    -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.PrintCharXTimes()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String or single character to process.
    local p_nb=${2:-1};             # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Number of characters to print.
    local p_newline=${3:-false};    # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : false    - DESC : If true, prints a line break.

	#**** Variables ****
    local i;                        # VAR TYPE : Int    - DESC : Number of iterations.

	#**** Code ****
	for((i=0; i<p_nb; i++)); do
		printf "%s" "${p_str}";
	done

	if [ "${p_newline,,}" == 'true' ]; then BU.Main.Echo.Newstep; fi

	return 0;
}

## ==============================================

## REVERSING TEXT
## DEBUG ID : "reversing-text"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::reversing-text";

# ·························································
# Reverse words order of a string according to a delimiter.

# Examples with the '|' and '/' delimiter:
# animal | big | car | donut    --> donut | car | big | animal
# /home/user/Documents          --> Documents/user/home

# Featured shell commands and their option(s) :
#   - basename

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                                   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.ReverseStringWordsOrder()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};	    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_keepd=${3:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Keep or remove first or last delimiters, or both together, if they are the first and / or the last character of the string.
    local p_init=${4:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function which calls translated text for the main module (this function is called by the "BU.Main.Text.GetSubStringAfterDelim()" function, which is called in the "BU.ModuleInit.ParseCSVLang()" function).


    #**** Variables ****
    # Leave this variable empty, it will store the reversed string.
    local reversed="";
    local line;

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! \
            BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims \
            "${p_string}" \
            "${p_delim}" \
            "$(basename "${BASH_SOURCE[0]}")" \
            "${FUNCNAME[0]}" \
            "${LINENO}";
        then
            local C="${?}";

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return "${C}";
        fi
    fi

    # shellcheck disable=SC2219
    let x="${#line[@]}-1";

    while [ "${x}" -ge 0 ]; do
        if [ "${x}" -gt 1 ]; then reversed="${reversed}${line[x]}${p_delim}"; else reversed="${reversed}${line[x]}"; fi

        (( x-- ));
    done

    # Keeping the delimiter at the begining of the now-reversed string.
    if     [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))f?(irst) ]];              then reversed="${p_delim}${reversed}";

    # Keeping the delimiter at the end of the now-reversed string.
    elif   [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))l?(ast) ]];               then reversed="${reversed}${p_delim}";

    # Keeping the delimiter at the begining and the end of the now-reversed string.
    elif   [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))f?(irst)?(-)l?(ast) ]];   then reversed="${p_delim}${reversed}${p_delim}"; fi

    echo -e "${reversed}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ············································
# Reverse the order of characters in a string.

# Featured shell commands and their option(s) :
#   - rev

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.Text.ReverseCharactersOrder()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo "${p_string}" | rev;

    return 0;
}

## ==============================================

## TEXT PROCESSING WITH THE "$(sed)" COMMAND
## DEBUG ID : "text-processing-with-the-sed-command"

declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__TEXT_PROCESSING_WITH_THE_SED_COMMAND="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::text-processing-with-the-sed-command";

## ==============================================

## SPLITTING TEXT AND SPLITTED TEXT PROCESSING
## DEBUG ID : "splitting-text"

# shellcheck disable=SC2034
declare -r __BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::splitting-text";

# ······················
# String to words array.

# Pass a string as argument, and after calling this function, copy the content of the generated array into another array, like this : your_array_name=("${__BU_MAIN_TEXT_LIB__STR_TO_WORD_ARR[@]}")

# Featured shell commands and their option(s) :
#   - basename
#   - eval

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Text.StrToWordArray()   -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib

#   - BU.Main.Inputs.Sanitize()             -> Main -> Inputs.lib


# shellcheck disable=
function BU.Main.Text.StrToWordArray()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to convert in a word array.
    local p_varname=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the array to create.
    local p_delim=${3:-$'\0'};      # ARG TYPE : Char       - OPTIONAL | DEFAULT VAL : NULL     - DESC : Customized delimiter, as per ChatGPT, the "$(read)" command does not support custom delimiters, but only a blank space.

    #**** Code ****
    if ! BU.Main.Args__Text.StrToWordArray "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Before evaluating the user's input, it is essential to check if the input does not contains any characters that can be used to execute a command.
    if ! BU.Main.Inputs.Sanitize "${p_varname}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the user named the variable with empty spaces between each words, the blank spaces are removed from the string.

    # Declaring the array according to the name passed by the user.
    eval "${p_varname}=()";

    eval read -ra "${p_varname}" <<< "${p_string}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ······················
# Words array to string.

# Featured shell commands and their option(s) :
#   - basename

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Text.WordArrayToStr()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    # local p_array=${1:-$'\0'};

    #**** Code ****

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Splitting a string from a given delimiter, in order to store it in an array.
# function BU.Main.Text.SplitStringFromDelim()
# {
#     # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
#     BU.Main.Echo.Debug \
#        "main" \
#        "$(basename "${BASH_SOURCE[0]}")" \
#        "${FUNCNAME[0]}" \
#         "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
#         "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT}";
#
#     #**** Parameters ****
#     local p_string=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
#     local p_delim=${2:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
#     local p_order=${3:-$'\0'};        # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Splitting order (L|l = left to right, R|r = right to left).
#     local p_iterations=${4:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of delimiters to process.
#     local p_ignore_delim=${5:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of delimiters to ignore before splitting the string.
#
#     #**** Code ****
#     if [ -z "${p_iterations}" ] || [ "${p_iterations}" -eq 0 ]; then
#         p_iterations='1';
#     fi
#
#     # If the string has to be processed from left to right.
#     if [ "${p_order^^}" == 'L|l' ]; then
#         for ((i=0; i<{p_iterations}; i++)); do
#             if [ -z "${p_ignore_delim}" ] || [ "${p_ignore_delim}" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if the string has to be processed from right to left.
#     elif [ "${p_order^^}" == 'R|r' ]; then
#         for ((i=0; i<p_iterations; i++)); do
#             if [ -z "${p_ignore_delim}" ] || [ "${p_ignore_delim}" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if no value is passed to the order processer.
#     elif [ -z "${p_order}" ]; then
#         false
#
#     # Else, if an unsupported value is passed to the order processer.
#     else
#         false
#     fi
#
#     BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
# }

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : DevTools.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ----------------------
# SCRIPT'S DESCRIPTION :

# Tools used for debugging or specific tasks for the dev-tools executable scripts.


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

elif [[ "${LANG}" == id_* ]]; then
    echo -e "PERINGATAN !" >&2; echo >&2;
    echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
    echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

elif [[ "${LANG}" == uk_* ]]; then
    echo -e "УВАГА !" >&2; echo >&2;
    echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
    echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
    echo -e "Use only this script by including it in your project script." >&2;

fi; echo >&2; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DEBUG FUNCTIONS
#### DEBUG ID : "bu::main::devtools::debug-functions"

declare -r __BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS='bu::main::devtools::debug-functions';

## SHELLCHECK
## DEBUG ID : "shellcheck"

declare -r __BU_MAIN_DEVTOOLS_LIB__SUBCAT_DEBUG_ID__DEBUG_FUNCTIONS__SHELLCHECK="${__BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS}::shellcheck";

# ······························································
# Writing the error message if a Shellcheck verification failed.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.DevTools.ShellcheckVerifFailed()
{
    #**** Parameters ****
    local p_path=${1:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL  - DESC : Path of the file whose Shellcheck verification failed.

    #**** Code ****
    echo >&2;

    # shellcheck disable=SC2059
    printf "${__BU_COMPILE__SHELLCHECK__FAIL}" "${p_path}"; echo >&2; return 0;
}

# ·························································································
# Verifying for any programming errors in a Bash script file with the "shellcheck" command.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.DevTools.ShellcheckVerifFailed()  -> Main -> DevTools.lib (this file)

# shellcheck disable=
function BU.Main.DevTools.ShellcheckVerif()
({
    #**** Parameters ****
    local p_path=${1:-\$'0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to verify.
    local p_stable=${2:-NULL};  # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : If the file to be compiled is a stable version, the target file will be shellchecked, overriding the code's behavior about the "${__BU_SHELLCHECKED}" variable's value.

    #**** Variables ****
    local compiler_env;         # VAR TYPE : Filepath   - DESC : Cutting the path which precedes the "Bash-utils/" sub-string in order to unify the compilation environments by processing the relative path of a file instead of its absolute path (if someone else compiles a version of the framework stored in their home folder, instead of "/usr/local/lib/" for example).
    local existing_md5;         # VAR TYPE : CMD        - DESC : Storing the output of the "$(grep)" command used to get the current file's corresponding md5 checksum from the "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" file.
    local new_md5;              # VAR TYPE : CMD        - DESC : Storing the output of the "$(md5sum)" command used to calculate the current file's corresponding md5 checksum.
    local new_md5_tmp;          # VAR TYPE : CMD        - DESC : Storing the output of the "$(md5sum "${p_path}")" command in order to write only the relative path of the compiled file.
    local shchkOut;             # VAR TYPE : CMD        - DESC : Storing the output message of the "$(shellcheck)" command in order to display the "${__BU_COMPILE__SHELLCHECK__FAIL_STR}" string right after the "${__BU_COMPILE__SHELLCHECK__VERIFICATION}" message located at the same line.
    local shchkOutCode;         # VAR TYPE : Int        - DESC : Getting the output code of the "$(shellcheck)" command stored in the previous variable.

    #**** Code ****
    compiler_env="Bash-utils";
    compiler_env=${p_path#*"${compiler_env}"};
    compiler_env="Bash-utils${compiler_env}";

    function BU.Main.DevTools.ShellcheckVerif.Shellcheck()
    {
        # shellcheck disable=SC2059
        if [ "${__BU_SHELLCHECKED}" == 'false' ] || [ "${p_stable}" == 'compile-stable' ]; then
            shchkOut="$(shellcheck "${p_path}" 2>&1)";
            shchkOutCode="${?}";

            printf "${__BU_COMPILE__SHELLCHECK__VERIFICATION}" "${compiler_env}";

            if [ "${shchkOutCode}" -ne 0 ]; then
                printf "${__BU_COMPILE__SHELLCHECK__FAIL_STR}"; BU.Main.DevTools.ShellcheckVerifFailed "${compiler_env}";

                printf "${shchkOut}\n";

                return 1;
            fi

            printf "%s\n" "${__BU_COMPILE__SHELLCHECK__SUCCESS_STR}";

            # shellcheck disable=SC2059
            printf "${__BU_COMPILE__SHELLCHECK__SUCCESS}\n" "${compiler_env}";

            # Writing the compiled file's MD5 checksum and path into the "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" file.

            # Checking in the "${existing_md5}" variable is empty. If not, the output of the 
            # "$(md5sum "${compiler_env}")" command is written, else the current value is replaced.
            if [ -n "${existing_md5}" ]; then

                # awk_path (not used by Bash in any ways) : Storing the content of the "${compiler_env}" variable into a variable
                # which will be used by the AWK program in order to replace the former MD5 checksum of the currently compiled file.
                awk -v awk_path="${compiler_env}" -v new_md5="${new_md5}" '{
                    if ($2 == awk_path) {
                        $1 = new_md5
                    }
                    
                    print
                }' "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" > "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}.tmp" && {
                    mv "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}.tmp" "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" || {
                        echo "Unable to update the ${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST} file";

                        return 1;
                    };
                };
            else
                new_md5_tmp="$(md5sum "${p_path}")";

                echo "${new_md5_tmp}" >> "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}";
            fi

            echo;
        fi

        return 0;
    }

    # Checking if the "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" exists or not on the user's hard drive.
    if [ ! -f "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" ]; then 
        touch "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}";
    fi

    # Checking first if the file was already shellchecked by parsing the "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" file.
    if grep -qi "${compiler_env}" "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}"; then

        # Extracting the current file's corresponding MD5 checksum from the "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}".
        existing_md5=$(grep -i "${compiler_env}" "${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}" | awk '{print $1}');

        # Calculating the MD5 checksum of the current file.
        new_md5="$(md5sum "${p_path}" | awk '{print $1}')";

        # Checking if both checksums correspond to each other.
        if [ "${existing_md5}" != "${new_md5}" ]; then
            BU.Main.DevTools.ShellcheckVerif.Shellcheck || return 1;
        else
            # shellcheck disable=SC2059
            printf "${__BU_COMPILE__SHELLCHECK__SUCCESS_FILE_ALREADY_SHELLCHECKED}\n" "${compiler_env}";
        fi
    else
        BU.Main.DevTools.ShellcheckVerif.Shellcheck || return 1;
    fi

    return 0;
})

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : DevTools.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ----------------------
# SCRIPT'S DESCRIPTION :

# Tools used for debugging or specific tasks for the dev-tools executable scripts.


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

elif [[ "${LANG}" == hi_* ]]; then
    echo -e "चेतावनी!" >&2; echo >&2;
    echo -e "यह शेल स्क्रिप्ट (${BASH_SOURCE[0]}) सीधे निष्पादित करने के लिए नहीं है!" >&2; echo >&2;
    echo -e "इस स्क्रिप्ट को अपने प्रोजेक्ट स्क्रिप्ट में शामिल करके ही इस्तेमाल करें।" >&2;

elif [[ "${LANG}" == id_* ]]; then
    echo -e "PERINGATAN !" >&2; echo >&2;
    echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
    echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

elif [[ "${LANG}" == ja_* ]]; then
    echo -e "警告 ！" >&2; echo >&2;
    echo -e "このシェルスクリプト（${BASH_SOURCE[0]}）は、直接実行することはできません！" >&2; echo >&2;
    echo -e "このスクリプトは、プロジェクトスクリプトに含める必要があり、このスクリプトと一緒にしか使用できません。" >&2;

elif [[ "${LANG}" == ko_* ]]; then
    echo -e "경고 !" >&2; echo >&2;
    echo -e "이 셸 스크립트(${BASH_SOURCE[0]})는 직접 실행하도록 설계되지 않았습니다!" >&2; echo >&2;
    echo -e "프로젝트 스크립트에 포함하여 이 스크립트만 사용하십시오." >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

elif [[ "${LANG}" == tr_* ]]; then
    echo -e "UYARI!" >&2; echo >&2;
    echo -e "Bu kabuk betiği (${BASH_SOURCE[0]}) doğrudan çalıştırılmak üzere tasarlanmamıştır!" >&2; echo >&2;
    echo -e "Proje kodunuza dahil ederek yalnızca bu kodu kullanın." >&2;

elif [[ "${LANG}" == uk_* ]]; then
    echo -e "УВАГА !" >&2; echo >&2;
    echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
    echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

elif [[ "${LANG}" == zh_* ]]; then
    echo -e "警告 !" >&2; echo >&2;
    echo -e "这个shell脚本(${BASH_SOURCE[0]})是不能直接执行的!" >&2; echo >&2;
    echo -e "只使用这个脚本并将其纳入你的项目脚本。" >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
    echo -e "Use only this script by including it in your project script." >&2;

fi; echo >&2; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DEBUG FUNCTIONS
#### DEBUG ID : "bu::main::devtools::debug-functions"

declare -r __BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS='bu::main::devtools::debug-functions';

## SHELLCHECK
## DEBUG ID : "shellcheck"

declare -r __BU_MAIN_DEVTOOLS_LIB__SUBCAT_DEBUG_ID__DEBUG_FUNCTIONS__SHELLCHECK="${__BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS}::shellcheck";

## LIB-COMPILER VERSION

if [[ "${0##*/}" == [Ll][Ii][Bb]-[Cc][Oo][Mm][Pp][Ii][Ll][Ee][Rr][Vv]3.?([Bb][Aa])[Ss][Hh] ]]; then
    declare -g __BU_MAIN_DEVTOOLS_LIB__GLOBVAR__IS_COMPILER_VARIABLES_VALUES_COPIED_FOR_SHELLCHECKING='false';
fi

# ······························································
# Writing the error message if a Shellcheck verification failed.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - echo      |
#   - local     |
#   - printf    |

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.DevTools.ShellcheckVerifFailed()
{
    #**** Parameters ****
    local p_path=${1:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL  - DESC : Path of the file whose Shellcheck verification failed.

    #**** Code ****
    echo >&2;

    # shellcheck disable=SC2059
    printf "${__BU_COMPILE__SHELLCHECK__FAIL}" "${p_path}"; echo >&2; return 0;
}

# ·························································································
# Verifying for any programming errors in a Bash script file with the "shellcheck" command.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - awk       | (-v)
#   - echo      |
#   - grep      | (-i | -q)
#   - local     |
#   - md5sum    |
#   - mv        |
#   - printf    |
#   - touch     |

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.DevTools.ShellcheckVerifFailed()  -> Main -> DevTools.lib (this file)

# shellcheck disable=
function BU.Main.DevTools.ShellcheckVerif()
({
    #**** Parameters ****
    local p_path=${1:-\$'0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to verify.
    local p_stable=${2:-NULL};  # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : If the file to be compiled is a stable version, the target file will be shellchecked, overriding the code's behavior about the "${__BU__BIN__LIB_COMPILER_V4__BU_SHELLCHECKED}" variable's value.

    #**** Variables ****
    local compiler_env;         # VAR TYPE : Filepath   - DESC : Cutting the path which precedes the "Bash-utils/" sub-string in order to unify the compilation environments by processing the relative path of a file instead of its absolute path (if someone else compiles a version of the framework stored in their home folder, instead of "/usr/local/lib/" for example).
    local existing_md5;         # VAR TYPE : CMD        - DESC : Storing the output of the "$(grep)" command used to get the current file's corresponding md5 checksum from the "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" file.
    local new_md5;              # VAR TYPE : CMD        - DESC : Storing the output of the "$(md5sum)" command used to calculate the current file's corresponding md5 checksum.
    local shchkOut;             # VAR TYPE : CMD        - DESC : Storing the output message of the "$(shellcheck)" command in order to display the "${__BU_COMPILE__SHELLCHECK__FAIL_STR}" string right after the "${__BU_COMPILE__SHELLCHECK__VERIFICATION}" message located at the same line.
    local shchkOutCode;         # VAR TYPE : Int        - DESC : Getting the output code of the "$(shellcheck)" command stored in the previous variable.

    #**** Code ****
    compiler_env='Bash-utils';
    compiler_env="${p_path#*"${compiler_env}"}";
    compiler_env="Bash-utils${compiler_env}";

    # Support for the legacy "lib-compilerV3.sh" script and the future versions of the compiler.
    function BU.Main.DevTools.ShellcheckVerif.SupportLegacyVersions()
    {
        # Each of the original variables values are assigned to the ones whose name respect the naming conventions of the newer versions of the compiler.
        declare -g __BU__BIN__LIB_COMPILER_V4__BU_SHELLCHECKED="${__BU_SHELLCHECKED}";
        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_N__SHELLCHECK__VERIFICATION="${__BU_COMPILE__SHELLCHECK__VERIFICATION}";

        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_E__SHELLCHECK__FAIL="${__BU_COMPILE__SHELLCHECK__FAIL}";
        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_E__SHELLCHECK__FAIL_STR="${__BU_COMPILE__SHELLCHECK__FAIL_STR}";

        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS="${__BU_COMPILE__SHELLCHECK__SUCCESS}";
        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS_STR="${__BU_COMPILE__SHELLCHECK__SUCCESS_STR}";
        
        declare -g __BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS_FILE_ALREADY_SHELLCHECKED="${__BU_COMPILE__SHELLCHECK__SUCCESS_FILE_ALREADY_SHELLCHECKED}";

        declare -g __BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST="${__BU_LIB_COMPILER_RESOURCES__SHELLCHECKED_FILES_LIST}";

        return 0;
    }

    # Shellchecking the processed file.
    function BU.Main.DevTools.ShellcheckVerif.Shellcheck()
    {
        # shellcheck disable=SC2059
        if [ "${__BU__BIN__LIB_COMPILER_V4__BU_SHELLCHECKED}" == 'false' ] || [ "${p_stable}" == 'compile-stable' ]; then
            shchkOut="$(shellcheck "${p_path}" 2>&1)";

            shchkOutCode="${?}";

            printf "${__BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_N__SHELLCHECK__VERIFICATION}" "${compiler_env}";

            # Printing the error message to display if the "$(shellcheck)" command's execution failed.
            if [ "${shchkOutCode}" -ne 0 ]; then
                printf "${__BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_E__SHELLCHECK__FAIL_STR}";
                
                BU.Main.DevTools.ShellcheckVerifFailed "${compiler_env}";

                printf "${shchkOut}\n";

                return 1;
            fi

            printf "%s\n" "${__BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS_STR}";

            # shellcheck disable=SC2059
            printf "${__BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS}\n" "${compiler_env}";

            # Writing the compiled file's MD5 checksum and path into the "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" file.

            # Checking in the "${existing_md5}" variable is empty. If not, the output of the 
            # "$(md5sum "${compiler_env}")" command is written, else the current value is replaced.
            if [ -n "${existing_md5}" ]; then

                # awk_path (not used by Bash in any ways) : Storing the content of the "${compiler_env}" variable into a variable
                # which will be used by the AWK program in order to replace the former MD5 checksum of the currently compiled file.
                awk -v awk_path="${compiler_env}" -v new_md5="${new_md5}" '{
                    if ($2 == awk_path) {
                        $1 = new_md5
                    }
                    
                    print
                }' "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" > "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}.1.tmp" && {
                    mv "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}.1.tmp" "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" || {
                        echo "Warning : unable to update the ${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST} file";

                        return 1;
                    };
                };
            else
                md5sum "${p_path}" >> "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}";

                awk -v awk_path="${p_path}" -v compiler_env="${compiler_env}" '{
                    if ($2 == awk_path) {
                        $2 = compiler_env
                    }

                    print
                }' "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" > "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}.2.tmp" && {
                    mv "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}.2.tmp" "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" || {
                        echo "Warning : unable to update the ${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST} file";

                        return 1;
                    };
                };
            fi

            echo;
        fi

        return 0;
    }

    if [ "${__BU_MAIN_DEVTOOLS_LIB__GLOBVAR__IS_COMPILER_VARIABLES_VALUES_COPIED_FOR_SHELLCHECKING,,}" == 'false' ]; then
        BU.Main.DevTools.ShellcheckVerif.SupportLegacyVersions;

        __BU_MAIN_DEVTOOLS_LIB__GLOBVAR__IS_COMPILER_VARIABLES_VALUES_COPIED_FOR_SHELLCHECKING='true';
    fi
    
    # Checking if the "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" exists or not on the user's hard drive.
    if [ ! -f "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" ]; then 
        touch "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}";
    fi

    # Checking first if the file was already shellchecked by parsing the "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" file.
    if grep -qi "${compiler_env}" "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}"; then

        # Extracting the current file's corresponding MD5 checksum from the "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}".
        existing_md5=$(grep -i "${compiler_env}" "${__BU__BIN__LIB_COMPILER_V4__RESOURCES__SHELLCHECKED_FILES_LIST}" | awk '{print $1}');

        # Calculating the MD5 checksum of the current file.
        new_md5="$(md5sum "${p_path}" | awk '{print $1}')";

        # Checking if both checksums correspond to each other.
        if [ "${existing_md5}" != "${new_md5}" ]; then
            BU.Main.DevTools.ShellcheckVerif.Shellcheck || return 1;
        else
            # shellcheck disable=SC2059
            printf "${__BU__BIN__LIB_COMPILER_V4__GLOBVARS__MSG_S__SHELLCHECK__SUCCESS_FILE_ALREADY_SHELLCHECKED}\n" "${compiler_env}";
        fi
    else
        BU.Main.DevTools.ShellcheckVerif.Shellcheck || return 1;
    fi

    return 0;
})

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

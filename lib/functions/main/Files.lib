#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT FILES PROCESSING FUNCTIONS

# This function only repeats some parts of the following function.
function BU::Main::Files::__ProcessingFile()
{
    #**** Parameters ****
    p_output=$1
    p_name=$2
    p_char=$3

    #**** Code ****
    if [ "$p_output" = 'E' ]; then
        BU::EchoError "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";

    elif [ "$p_output" = 'S' ]; then
        BU::EchoSuccess "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$p_char")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";
    else
        BU::EchoWarning "";
    fi
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Files::ProcessingFile()
{
    #**** Parameters ****
    local p_function=$1;
    local p_name=$2;

    shift; local arr;
        arr=$("$@");

    #**** Variables ****
    local v_char="'";

    #**** Code ****
    # Arguments checking.
    BU::Main::CheckArgs__Files::ProcessingFile "$p_function";

	sleep "$__BU_MAIN_STAT_TIME_TXT";
    BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate';
    BU::EchoNewstep "Processing the $(BU::DechoHighlightPath "$p_name") file in the $(BU::DechoHighlightPath "$p_parent") parent directory.";
    BU::Newline;

    case "$p_function" in
        'BU::Main::Files::Make')
            if BU::Main::Files::Make "${arr[@]}"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
        'OverwriteFile')
            if BU::Main::Files::OverwriteFile "$arr"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
    esac
}

## OVERWRITING CONTENT

# Overwriting a file

# Featured functions and files from the "functions" folder :
#	- BU::EchoError			-> Main -> Echo.lib
#	- BU::EchoNewstep		-> Main -> Echo.lib
#	- BU::EchoSuccess		-> Main -> Echo.lib
#	- BU::Newline			-> Main -> Echo.lib
function BU::Main::Files::OverwriteFile()
{
    #**** Parameters ****
    local p_path=$1;
	local p_authorization=$2;

    #**** Code ****
    # Checking first if the awaited arguments are given
    BU::Main::CheckArgs__Files::OverwriteFile;

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$p_path";

    if [ "$p_authorization" = "true" ]; then
		BU::EchoNewstep "The $(BU::DechoHighlightPath "$p_path/") file already exists and is not empty.";
		BU::EchoNewstep "Overwriting data from file $(BU::DechoHighlightPath "$p_path/")";
		BU::Newline;

		true > "$p_path";
		BU::Main::Errors::HandleErrors "$?" "THE CONTENT OF THE $(BU::DechoHighlightPath "$p_path/") FILE HAD NOT BEEN OVERWRITTEN" "" "$p_path" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))";
		BU::EchoSuccess "The content of the $(BU::DechoS "$p_path/") file has been successfully overwritten";
		BU::Newline;
	else
		return 0;
	fi

	return 0;
}

# -----------------------------------------------

## FILE CREATION

# File creation function.
# LORS DE SON APPEL, LA SORTIE DE CETTE FONCTION DOIT ÊTRE REDIRIGÉE SOIT VERS LE TERMINAL ET LE FICHIER DE LOGS, SOIT VERS LE FICHIER DE LOGS UNIQUEMENT.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine       -> Main -> Headers.lib
#   - BU::EchoError                     -> Main -> Echo.lib
#   - BU::EchoNewstep                   -> Main -> Echo.lib
#   - BU::EchoSuccess                   -> Main -> Echo.lib
#   - BU::Main::Errors::HandleErrors    -> Main -> Handles.lib
function BU::Main::Files::Make()
{
	#**** Parameters ****
    local p_parent=$1;  # Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=$2;    # Name of the file to process (into its parent directory).

	#**** Variables ****
	local v_path="$p_parent/$p_name";	# Path of the file to process.

	#**** Code ****
	# Checking first if the awaited arguments are given
    BU::Main::CheckArgs__Files::Make "$p_parent" "$p_name";

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$v_path";

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$v_path" ]; then
        BU::EchoNewstep "Creating the $(BU::DechoHighlightPath "$p_name") file in the parent folder $(BU::DechoHighlightPath "$p_parent/").";

		touch "$v_path"; BU::Main::Checkings::CheckFilePathWasCreated "$v_path";

		# Testing if the file has been created by checking the return code of the "BU::Main::Checkings::CheckFilePathWasCreated" function via the "BU::Main::Errors::HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU::Main::Errors::HandleErrors "$?" "THE $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlightPath "$p_name")") FILE CANNOT BE CREATED IN THE $(BU::DechoHighlightPath "$p_parent/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-4 ))";

		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_name") file was successfully created in the $(BU::DechoHighlightPath "$p_parent") folder.";
        BU::Newline;

        return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$p_path" ] && [ -s "$p_path" ]; then
        if BU::Main::Files::OverwriteFile "$p_path"; then
            return 0;
        else
            return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$p_path" ] && [ ! -s "$p_path" ]; then
		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_path/") file already exists in the $(BU::DechoHighlightPath "$p_parent/") folder and is empty.";
		BU::Newline;

		return 0;
	fi
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.
function BU::Main::Files::CreateFileInMemory()
{
    #**** Parameters ****
    p_filename=$1;

    #**** Code ****


    return 0;
}

# Creating the project's log file.
function BU::Main::Files::CreateProjectLogFile()
{
    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "$$" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_LOG_FILE_PARENT" "$__BU_MAIN_PROJECT_LOG_FILE_NAME" 'f'; then BU::EchoError "UNABLE TO CREATE THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S LOG FILE"; BU::Main::Errors::ExitError '1'; fi

    BU::EchoSuccess "Successfully created the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.";

	if [ "$__BU_MAIN_STAT_DECHO" = 'true' ]; then	BU::Main:Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi
    if [ "$__BU_MAIN_STAT_ECHO"  = 'true' ]; then	BU::Main:Status::ChangeSTAT_ECHO  "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi

    # Redirecting the initializer's log file content into the log file.
    BU::HeaderBlue "INITIALIZATION PROCESS LOG OUTPUT";

    BU::EchoNewstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;
    BU::EchoNewstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;

	if (( "${#__BU_MODULE_UTILS_MSG_ARRAY[@]}" >= 1 )); then
		BU::EchoNewstep "Initialization log output :"; BU::Newline;

        for val in "${__BU_MODULE_UTILS_MSG_ARRAY[@]}"; do
            BU::CheckProjectLogStatus "$(CutDateFromString "$val")";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU::HeaderBlue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

	# Getting operating system name.
	BU::EchoNewstep "Operating system name : $(awk -F= '/^NAME/{print $2}' /etc/os-release)";
	BU::Newline;

    # Getting operating system family.
    BU::EchoNewstep "Operating system family : $(BU::DechoHighlight "$OSTYPE")";
    BU::Newline;

    # Gathering OS informations from the "/etc/os-release" file.
    BU::EchoNewstep "Operating system general informations :";
    if [ -f "/etc/os-release" ]; then BU::EchoMsg "$(cat "/etc/os-release")" "" "nodate"; else BU::EchoMsg 'No available informations ("/etc/os-release" file not found)'; fi
    BU::Newline;

	# Getting operating system extra informations (Windows Subsystem for Linux, etc...).
	BU::EchoNewstep "Operating system extra informations :";
	if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU::EchoMsg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
	BU::Newline;

	# Getting Bash language's version.
    BU::EchoNewstep "Bash version : $(BU::DechoHighlight "$BASH_VERSION")";
    BU::Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU::EchoNewstep "Terminal (emulator) version : $(BU::DechoHighlight "$v_terminfo_v")" || BU::EchoWarning "$(BU::DechoHighlight '$v_terminfo_v') : bad command call.";
    BU::Newline;

    BU::EchoSuccess "Successfully got the user's system's informations.";
    
    # Purging the "$__BU_MODULE_UTILS_MSG_ARRAY" variable from the logged messages, after writing its content in the project's log file.
    __BU_MODULE_UTILS_MSG_ARRAY='';
}

# -----------------------------------------------

## FILE SOURCING

# Sourcing dependencies files.
function BU::Main::Files::SourceFile()
{
    #**** Parameters ****
    local p_path=$1;

    #**** Code ****
    if [ -f "$p_path" ]; then
        # shellcheck disable=SC1090
        if source "$p_path"; then
            BU::EchoSuccess "Sourced file : $(BU::DechoHighlightPath "$p_path")";
        else
            BU::Main::Errors::HandleErrors "1" "UNABLE TO SOURCE THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please verify that the filepath passed as argument exists." "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))";
        fi
    else
        BU::Main::Errors::HandleErrors "1" "UNABLE TO FIND THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-8 ))";
    fi
}

# -----------------------------------------------

## TEXT FILES PARSING

# Getting a specific line from a text file.
function BU::Main::Files::GetLineFromTextFile()
{
    #**** Parameters ****
    local p_source=$1;          # File to parse
    local p_wanted_line=$2;     # Line to get in the file

    #**** Variables ****
    local i=0;                  # Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
    cat "$p_source" | while read -r line; do

        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ));

        # ... until it reaches the wanted line.
        if [ "$i" -eq "$p_wanted_line" ]; then

			# shellcheck disable=SC2034
            __BU_MAIN_TXT_STORE_LINE="$line";
        fi
    done
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS

## (UN)COMPRESSION FUNCTIONS

#

# Featured functions and files from the "functions" folder :
#   -
function BU::Main::Files::Compress()
{
    #**** Parameters ****
#     local cmd=$1      # Compression command.
#     local opts=$2     # Options of the compression command.
#     local p_path=$3     # Path to the file/folder to archivate.
#     local p_name=$4     # Archive's name (only used into displayed messages).

    #**** Code ****


    return 0;
}

# Uncompressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Errors::HandleErrors      -> Handles.lib
#   - BU::EchoSuccess       -> Echo.lib
#   - BU::Newline           -> Echo.lib
function BU::Main::Files::Uncompress()
{
#     #***** Paramètres *****
#     local p_cmd=$1      # Compression command.
#     # TODO : Vérifier si cette procédure est bonne
#     local p_opts=$2     # Options of the compression command. (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
#     local p_path=$3     # Path to the l'archive to uncompress.
#     local p_name=$4     # Archive's name (only used into displayed messages).
#
#     #**** Code ****
#     # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
#     "$cmd $opts $p_path"
#     BU::Main::Errors::HandleErrors "$?" "${FUNCNAME[0]} : LA DÉCOMPRESSION DE L'ARCHIVE $(BU::DechoHighlightPath "$p_name") A ÉCHOUÉE"
#     BU::EchoSuccess "La décompression de l'archive $(BU::DechoHighlightPath "$p_name") s'est effectuée avec brio."
#     BU::Newline;

    return 0;
}

#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ------------------
# FILE DESCRIPTION :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FILES PROCESSING FUNCTIONS
## DEBUG ID : files::files-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS="files::files-processing-functions";

## PROCESSING FUNCTIONS
## DEBUG ID : processing-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::files-processing-functions";

# This function only repeats some parts of the following function.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib
#   - BU.Main.Echo.Error()          -> Main -> Echo.lib
#   - BU.Main.Echo.Msg()            -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()        -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()        -> Main -> Echo.lib
function BU.Main.Files.__ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS}";

    #**** Parameters ****
    local p_output=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_name=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_char=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :

    #**** Code ****
    if [ "${p_output}" == 'E' ]; then
        BU.Main.Echo.Error "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}") file";
        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
        BU.Main.Echo.Newline;

        sleep "${__BU_MAIN_STAT_TIME_TXT}";

    elif [ "${p_output}" == 'S' ]; then
        BU.Main.Echo.Success "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}") file";
        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_char}" "${__COL_RESET}")" '-n' 'nodate';
        BU.Main.Echo.Newline;

        sleep "${__BU_MAIN_STAT_TIME_TXT}";
    else
        BU.Main.Echo.Warning "";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.ProcessingFile()  -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
#   - BU.Main.Echo.Msg()                    -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()         -> Main -> Headers.lib

#   - BU.Main.Files.__ProcessingFiles()     -> Main -> Files.lib
#   - BU.Main.Files.Make()                  -> Main -> Files.lib
#   - BU.Main.Files.OverwriteFile()         -> Main -> Files.lib

#   - BU.Main.Headers.DrawLine()            -> Main -> Headers.lib
function BU.Main.Files.ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS}";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String             - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_name=${2:-$'\0'};       # ARG TYPE : String             - REQUIRED | DEFAULT VAL : NULL    - DESC :

    shift; local pa_arr; pa_arr=$("${@}"); # ARG TYPE : String      - REQUIRED | DEFAULT VAL : NULL    - DESC :

    #**** Variables ****
    local v_char="'";   # VAR TYPE : Char   - DESC :

    #**** Code ****
    # Arguments checking.
    if ! BU.Main.Args__Files.ProcessingFile "${p_function}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi;

	sleep "${__BU_MAIN_STAT_TIME_TXT}";
    BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
    BU.Main.Echo.Newstep "Processing the $(BU.Main.Decho.Decho.Path "${p_name}") file in the $(BU.Main.Decho.Decho.Path "${p_parent}") parent directory.";
    BU.Main.Echo.Newline;

    case "${p_function}" in
        'BU.Main.Files.Make')
            if BU.Main.Files.Make "${pa_arr[@]}"; then
                BU.Main.Files.__ProcessingFile 'S' "${p_name}" "${p_char}";
            else
                BU.Main.Files.__ProcessingFile 'E' "${p_name}" "${p_char}";
            fi
            ;;
        'BU.Main.Files.OverwriteFile')
            if BU.Main.Files.OverwriteFile "${pa_arr[@]}"; then
                BU.Main.Files.__ProcessingFile 'S' "${p_name}" "${p_char}";
            else
                BU.Main.Files.__ProcessingFile 'E' "${p_name}" "${p_char}";
            fi
            ;;
    esac

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE CREATION FUNCTIONS
## DEBUG ID : file-creation-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-creation-functions";

# Overwriting a file

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.OverwriteFile()           -> Main -> Args.lib

#   - BU.Main.Directories.TriggerRootDirWarning()   -> Main -> Directories.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib
#	- BU.Main.Echo.Error()			                -> Main -> Echo.lib
#	- BU.Main.Echo.Newstep()		                -> Main -> Echo.lib
#	- BU.Main.Echo.Newline()		                -> Main -> Echo.lib
#	- BU.Main.Echo.Success()		                -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()                 -> Main -> Errors.lib
function BU.Main.Files.OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : Path   - REQUIRED | DEFAULT VAL : NULL     - DESC :
	local p_authorization=${2:-$'\0'};  # ARG TYPE : Bool   - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU.Main.Args__Files.OverwriteFile "${p_path}" "${p_authorization}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Checking second if the script is operating at the root directory.
    BU.Main.Directories.TriggerRootDirWarning "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    if [ "${p_authorization}" == "true" ]; then
		BU.Main.Echo.Newstep "The $(BU.Main.Decho.Decho.Path "${p_path}/") file already exists and is not empty.";
		BU.Main.Echo.Newstep "Overwriting data from file $(BU.Main.Decho.Decho.Path "${p_path}/")";
		BU.Main.Echo.Newline;

		true > "${p_path}";
		BU.Main.Errors.HandleErrors "${?}" "THE CONTENT OF THE $(BU.Main.Decho.Decho.Path "${p_path}/") FILE HAD NOT BEEN OVERWRITTEN" "" "${p_path}" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
		BU.Main.Echo.Success "The content of the $(BU.Main.Decho.S "${p_path}/") file has been successfully overwritten";
		BU.Main.Echo.Newline;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# File creation function, with the parent folder's path and the file's name as separated arguments.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.Make()                    -> Main -> Args.lib

#   - BU.Main.Checkings.CheckDiskUsedSpace()        -> Main -> Checkings.lib
#   - BU.Main.Checkings.CheckFilePathWasCreated()   -> Main -> Checkings.lib

#   - BU.Main.Decho.Decho.Path()                    -> Main -> Decho.lib

#   - BU.Main.Directories.TriggerRootDirWarning()   -> Main -> Directories.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                          -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()                        -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()                 -> Main -> Errors.lib

#   - BU.Main.Files.OverwriteFile()                 -> Main -> Files.lib (this file)

#   - BU.Main.Headers.DrawLine()                    -> Main -> Headers.lib
function BU.Main.Files.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

	#**** Parameters ****
    local p_parent=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to process (into its parent directory).

    shift 2;

    # shellcheck disable=SC2034
    pa_touchVals=("${@}");      # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : "$(touch)" command's options.

	#**** Variables ****
	local v_path="${p_parent}/${p_name}";	# Path of the file to process.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${v_path}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

	# Checking if the awaited arguments are given.
    if ! BU.Main.Args__Files.Make "${p_parent}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi;

    # Checking second if the script is operating at the root directory.
    BU.Main.Directories.TriggerRootDirWarning "${v_path}" || return 1;

	# If the file to create doesn't exists, ths script creates it with the help of the "$(touch)" command.
	if [ ! -f "${v_path}" ]; then
        BU.Main.Echo.Newstep "Creating the $(BU.Main.Decho.Decho.Path "${p_name}") file in the parent folder $(BU.Main.Decho.Decho.Path "${p_parent}/").";

		touch "${v_path}"; BU.Main.Checkings.CheckFilePathWasCreated "${v_path}";

		# Testing if the file has been created by checking the return code of the "BU.Main.Checkings.CheckFilePathWasCreated()" function via the "BU.Main.Errors.HandleErrors()" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU.Main.Errors.HandleErrors "${?}" "THE $(BU.Main.Decho.Decho.Path "${p_name}") FILE CANNOT BE CREATED IN THE $(BU.Main.Decho.Decho.Path "${p_parent}/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "${v_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

		BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_name}") file was successfully created in the $(BU.Main.Decho.Decho.Path "${p_parent}") folder.";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "${p_path}" ] && [ -s "${p_path}" ]; then
        if BU.Main.Files.OverwriteFile "${p_path}"; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "${p_path}" ] && [ ! -s "${p_path}" ]; then
		BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_path}/") file already exists in the $(BU.Main.Decho.Decho.Path "${p_parent}/") folder and is empty.";
		BU.Main.Echo.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi
}

# File creation function, with the parent folder's path and the file's name as unique argument.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.MakePath()            -> Main -> Args.lib

#   - BU.Main.Checkings.CheckDiskUsedSpace()    -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib

#   - BU.Main.Files.Make()                      -> Main -> Files.lib
function BU.Main.Files.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the file to create.

    #**** Variables ****
    local v_parent;
    local v_target;

    #**** Code ****
    v_parent="$(echo "${p_path}" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the file to create.
    v_target="$(echo "${p_path}" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the file to create.

	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" 'create' 'true';

    if ! BU.Main.Args__Files.MakePath "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    BU.Main.Files.Make "${v_parent}" "${v_target}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.MakeFileInMemory()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : name of the file to create in the computer's random access memory.

    #**** Code ****
    echo "${p_filename}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Creating the project's log file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.CheckDiskUsedSpace()        -> Main -> Checkings.lib
#   - BU.Main.Checkings.CheckProjectRelatedFile()   -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                          -> Main -> Echo.lib
#   - BU.Main.Echo.Msg()                            -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                        -> Main -> Echo.lib

#   - BU.Main.Headers.Header.Blue()                 -> Main -> Headers.lib

#   - BU.Main.OS.IsAndroidTermux()                  -> Main -> OS.lib
#   - BU.Main.OS.IsFreeBSD()                        -> Main -> OS.lib
#   - BU.Main.OS.IsHaiku()                          -> Main -> OS.lib
#   - BU.Main.OS.IsLinux()                          -> Main -> OS.lib
#   - BU.Main.OS.IsNetBSD()                         -> Main -> OS.lib
#   - BU.Main.OS.IsOpenBSD()                        -> Main -> OS.lib
#   - BU.Main.OS.IsOSX()                            -> Main -> OS.lib

#   - BU.Main.Status.ChangeSTAT_DECHO()             -> Main -> Status.lib
#   - BU.Main.Status.ChangeSTAT_ECHO()              -> Main -> Status.lib
#   - BU.Main.Status.CheckProjectLogStatus()        -> Main -> Status.lib
function BU.Main.Files.CreateProjectLogFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" 'create' 'true';

    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "${$}" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}" "${__BU_MAIN_PROJECT_LOG_FILE_NAME}" 'f'; then BU.Main.Echo.Error "UNABLE TO CREATE THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S LOG FILE"; BU.Main.Errors.Exit '1'; fi

    BU.Main.Echo.Success "Successfully created the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") file.";

    if [ "${__BU_MAIN_STAT_DECHO,,}" == 'true' ];    then BU.Main.Status.ChangeSTAT_DECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi
    if [ "${__BU_MAIN_STAT_ECHO,}"  == 'true' ];     then BU.Main.Status.ChangeSTAT_ECHO  "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    # Redirecting the initializer's log file content into the log file.
    BU.Main.Headers.Header.Blue "INITIALIZATION PROCESS LOG OUTPUT";

    BU.Main.Echo.Newstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU.Main.Echo.Msg "${val}"; done; BU.Main.Echo.Newline;
    BU.Main.Echo.Newstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU.Main.Echo.Msg "${val}"; done; BU.Main.Echo.Newline;

	if (( "${#__BU_MODULE_INIT_MSG_ARRAY[@]}" >= 1 )); then
		BU.Main.Echo.Newstep "Initialization log output :"; BU.Main.Echo.Newline;

        for val in "${__BU_MODULE_INIT_MSG_ARRAY[@]}"; do
            BU.Main.Status.CheckProjectLogStatus "${val}";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU.Main.Headers.Header.Blue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

    # Getting operating system family.
    BU.Main.Echo.Newstep "Operating system family : $(BU.Main.Decho.Decho.Highlight "${OSTYPE}")";
    BU.Main.Echo.Newline;

    # Getting operating system's informations (Android's Termux terminal emulator) :
    BU.Main.OS.IsAndroidTermux && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (FreeBSD) :
    BU.Main.OS.IsFreeBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (Haiku OS) :
    BU.Main.OS.IsHaiku && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : Haiku OS";
        BU.Main.Echo.Newline;

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (Linux platforms or Android without the Termux terminal emulator) :
    BU.Main.OS.IsLinux && {
        if [ -f "/etc/os-release" ]; then
            # Getting operating pretty system name.
            BU.Main.Echo.Newstep "Operating system pretty name : $(awk -F= '/PRETTY/ {print $2}' '/etc/os-release')";
            BU.Main.Echo.Newline;

            # Gathering OS informations from the "/etc/os-release" file.
            BU.Main.Echo.Newstep "Operating system general informations :";
            BU.Main.Echo.Msg "$(cat '/etc/os-release')" "" "nodate";
            BU.Main.Echo.Newline;
        else
            BU.Main.Echo.Warning "No available informations ($(BU.Main.Decho.Decho.Highlight '/etc/os-release') file not found)";
            BU.Main.Echo.Newline;
        fi

        # Getting operating system extra informations (Windows Subsystem for Linux, etc...).
        BU.Main.Echo.Newstep "Operating system extra informations :";
        if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU.Main.Echo.Msg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
        BU.Main.Echo.Newline;
    }

    # Getting operating system's informations (NetBSD) :
    BU.Main.OS.IsNetBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (OpenBSD) :
    BU.Main.OS.IsOpenBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (Mac OS) :
    BU.Main.OS.IsOSX && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

	# Getting Bash language's version.
    BU.Main.Echo.Newstep "Bash version : $(BU.Main.Decho.Decho.Highlight "${BASH_VERSION}")";
    BU.Main.Echo.Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU.Main.Echo.Newstep "Terminal (emulator) version : $(BU.Main.Decho.Decho.Highlight "${v_terminfo_v}")" || BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Highlight '$v_terminfo_v') : bad command call.";
    BU.Main.Echo.Newline;

    BU.Main.Echo.Success "Successfully got the user's system's informations.";

    # Purging the "${__BU_MODULE_INIT_MSG_ARRAY}" variable from the logged messages, after writing its content in the project's log file, in order to free up the computer's memory.
    __BU_MODULE_INIT_MSG_ARRAY=('');

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE DELETION FUNCTIONS
## DEBUG ID : file-deletion-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_DELETION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-deletion-functions";

# File deletion function.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.DeleteFile()  -> Main -> Args.lib
#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()     -> Main -> Errors.lib
function BU.Main.Files.DeleteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_DELETION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to delete.
    local p_security=${2:-no};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : no       - DESC : Preventing the file to be deleted automatically (default : "no" --> Ask the permission to the user).

    #**** Code ****
    if ! BU.Main.Args__Files.DeleteFile "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    rm "$(if [ "${p_security,,}" == 'yes' ]; then echo '-i'; fi)" "${p_path}";

    BU.Main.Errors.HandleErrors "${?}" "" "" "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CHECKING FILE INFORMATIONS
## DEBUG ID : checking-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::checking-file-informations";

# Checking if a file is in read-only mode.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsReadOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (! -w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is readable AND writable.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsRW()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (-w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is readable, writable and executable.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsRWX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (-w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is in readable AND executable.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsRX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (! -w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is writable only.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsWriteOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (-w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is writable AND executable.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.IsWX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (-w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is in executable only.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib
function BU.Main.Files.IsExecutableOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (! -w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## GETTING FILE INFORMATIONS
## DEBUG ID : getting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::getting-file-informations";

# Getting the size of a file in bytes.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.BasicMaths.BytesToHuman() -> Main -> BasicMaths.lib

#   - BU.Main.Checkings.IsInt()         -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()            -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()            -> Main -> Echo.lib
function BU.Main.Files.GetByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.
    local p_base=${2:-1000};        # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1000     - DESC : Byte measure unit base (binary prefix (eg : MiB) or metric prefix (eg : MB)).

    #**** Code ****
    if [ -z "${p_base}" ]; then
        wc --bytes < "${p_filepath}" || \
            { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

    # Else, if a value is passed to the "base" parameter AND this value is an integer.
    elif [ -n "${p_base}" ] && BU.Main.Checkings.IsInt "${p_base}"; then

        # Convert the size from plain number to human readable metric prefix.
        if [ "${p_base}" -ne 1024 ]; then
            BU.Main.BasicMaths.BytesToHuman "$(wc --bytes < "${p_filepath}")" "NULL" "${p_base}" "" || \
                { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

        # Convert the size from plain number to human readable binary prefix.
        else
            BU.Main.BasicMaths.BytesToHuman "$(wc --bytes < "${p_filepath}")" "NULL" "${p_base}" "" || \
                { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };
        fi
    else
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : The byte measure unit byte $(BU.Main.Decho.Decho.Highlight "${p_base}") is not an integer"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the file's creation date.

# PLEASE NOTE : Some file systems don't store the file's creation date. In this case, the "stat" command will return '0'.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetCreationDate()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if ! stat -c %W "${p_filepath}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the $(BU.Main.Decho.Decho.Path "${p_filepath}") file's creation date"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    elif [ "$(stat -c %W "${p_filepath}")" -eq 0 ]; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : This filesystem ($(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_FS_NAME}")) does not stores the files creation dates"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    else
        echo -ne "$(stat -c %W "${p_filepath}")";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --chars < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of characters in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's extension.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                -> Main -> Echo.lib

#   - BU.Main.Text.CutLastFieldAfterDelim() -> Main -> Text.lib
function BU.Main.Files.GetExtension()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    BU.Main.Text.CutLastFieldAfterDelim "${p_filepath}" '.' || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the $(BU.Main.Decho.Decho.Path "${p_filepath}") file's extension";  }

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's access date.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat "${p_filename}" | awk 'FNR == 5 { print $2 " " $3 }' || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the last access date from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's modification date.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetLastModification()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    date -r "${p_filename}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the last modification date from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's mime type.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetMIMEType()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    file --mime-type "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the MIME type of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";  };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of lines in a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetLinesNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --lines < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of lines in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the max line length in a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetMaxLineLength()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****last access date
    wc --max-line-length < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the max line length in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the owner of a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetOwnerName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat -c "%U" "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the name of the owner of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the group of the owner of a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetOwnerGroup()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat -c "%G" "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the group of the owner of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
function BU.Main.Files.GetWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --words < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of words in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## SETTING FILE INFORMATIONS
## DEBUG ID : setting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::setting-file-informations";

# Setting a fake last access date to a file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__FilesSetFileLastAccess()    -> Main -> Args.lib

#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib
function BU.Main.File.SetFileLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.
    local p_fakedate=${2:-$'\0'}; # ARG TYPE : Date     - REQUIRED | DEFAULT VAL : NULL     - DESC : New date to set as last access date.

    #**** Code ****
    if ! BU.Main.Args__FilesSetFileLastAccess "${p_filepath}" "${p_fakedate}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE SOURCING
## DEBUG ID : file-sourcing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-sourcing";

# Sourcing dependencies files.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()        -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()        -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors() -> Main -> Errors.lib
function BU.Main.Files.SourceFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [ -f "${p_filepath}" ]; then
		BU.Main.Echo.Newstep "Sourcing the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";
		BU.Main.Echo.Newline

        # shellcheck disable=SC1090
        if source "${p_filepath}"; then
            BU.Main.Echo.Success "Sourced file : $(BU.Main.Decho.Decho.Path "${p_filepath}")";
			BU.Main.Echo.Newline;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            local C="${?}";

            BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_NOT_PERMITTED}" "UNABLE TO SOURCE THIS FILE : $(BU.Main.Decho.Decho.Path "${p_filepath}")" "Please verify that the file's path passed as argument exists, and that you have read rights on this file." "${p_filepath}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 5 ))";

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
        fi
    else
        local C="${?}";

        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_NOT_PERMITTED}" "UNABLE TO FIND THIS FILE : $(BU.Main.Decho.Decho.Path "${p_filepath}")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi
}

# -----------------------------------------------

## TEXT FILE PARSING
## DEBUG ID : text-file-parsing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::text-file-parsing";

# Getting a specific line from a text file.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.GetLineFromTextFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING}";

    #**** Parameters ****
#    local p_source=${1:-$'\0'};        # String    - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to parse.
#    local p_wanted_line=${2:-$'\0'};   # Int       - REQUIRED | DEFAULT VAL : NULL     - DESC : Line to get in the file

    #**** Variables ****
#    local i=0;     # VAR TYPE : Int    # DESC : Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
#    cat "${p_source}" | while read -r line; do
#
#        # Incrementing the line incrementer variable's value...
#        i=$(( i + 1 ));

        # ... until it reaches the wanted line.
#        if [ "${i}" -eq "${p_wanted_line}" ]; then

			# shellcheck disable=SC2034
#            __BU_MAIN_TXT_STORE_LINE="${p_wanted_line}";
#        fi
#    done

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS
#### DEBUG ID : files::archive-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS="files::archive-processing-functions";

## (UN)COMPRESSION FUNCTIONS
## DEBUG ID : (un)compression-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}::(un)compression-functions";

# Adding files or folders into an archive.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__FilesCompress()     -> Main -> Args.lib
#   - BU.Main.Args.PrintBadOption()     -> Main -> Args.lib

#   - BU.Main.Checkings.IsArrayEmpty()  -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib
function BU.Main.Files.AddToArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.
    shift 3;

    local p_paths=("${@}");     # Array - Default : NULL    - Paths to the files / folders to add in the archive.

    #**** Code ****
    if BU.Main.Checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to add in the targeted archive (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__FilesCompress "${p_cmd}" "${p_opts}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ "${p_cmd}" == '7z' ]; then
        true;

    elif [ "${p_cmd}" == 'bzip2' ]; then true;

    elif [ "${p_cmd}" == '' ]; then true;

    elif [ "${p_cmd}" == 'gzip' ]; then true;

    elif [ "${p_cmd}" == 'zip' ]; then true;

    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the compression command.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib
function BU.Main.Files.CompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data.
    shift 4;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to archivate.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the used compression method.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args.PrintBadOption()         -> Main -> Args.lib
#   - BU.Main.Args__Files.CompressFormat()  -> Main -> Args.lib

#   - BU.Main.Checkings.IsArrayEmpty()  -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
function BU.Main.Files.CompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.

    shift 2;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to archivate.

    #**** Code ****
    if BU.Main.Checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to compress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__Files.CompressFormat "${p_cmd}" "${p_opts}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the 7-Zip compression format is wanted.
    if [ "${p_cmd}" == '7z' ]; then
        7z a "${p_opts}" "${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format 7-Zip.
            return 1;
        }

    # Else, if the BinHex compression format is wanted (works on Apple operating systems).
    elif [ "${p_cmd}" == 'binhex' ]; then
        binhex "${p_opts}" "${p_paths[@]}" > "${p_arch}"|| {
            # TODO : Gérer les cas d'erreur de compression au format BinHex.
            return 1;
        }

    # Else, if the Bzip2 compression format is wanted.
    elif [ "${p_cmd,,}" == 'bzip2' ]; then
        true;

    # Else, if the Bzip2 compression format is wanted for a Tar archive.
    elif [[ "${p_cmd^^}" == TBZ?(2) ]] || [[ "${p_cmd,,}" == tar?(.)bz?(2) ]]; then
        tar "-jcf${p_opts}" "" "" || {
            # TODO : Gérer les cas d'erreur de compression au format Bzip2.
            return 1;
        }

    # Else, if the Gzip compression format is wanted.
    elif [ "${p_cmd,,}" == 'gzip' ]; then
        true;

    # Else, if the Gzip compression format is wanted for a Tar archive.
    elif [ "${p_cmd^^}" == 'TGZ' ] || [[ "${p_cmd,,}" == tar?(.)gz ]]; then
        tar "-zcf${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the LZMA compression is wanted for a Tar archive.
    elif [ "${p_cmd^^}" == 'TXZ' ] || [[ "${p_cmd,,}" == tar?(.)xz ]]; then
        tar "JCxf${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the zip compression format is wanted.
    elif [ "${p_cmd,,}" == 'zip' ]; then
        zip "${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format zip.
            return 1;
        }
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Deleting a file or a folder stored in an archive.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args.PrintBadOption()     -> Main -> Args.lib

#   - BU.Main.Checkings.IsArrayEmpty()  -> Main -> Checkings.lib

#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib
function BU.Main.Files.DeleteInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Target archive's path.
    shift 3;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to delete in the archive.

    #**** Code ****
    if BU.Main.checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to delete from the target archive (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Searching for a file or a folder inside an archive.
function BU.Main.Files.SearchInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";
#   - BU.Main.Checkings.IsArrayEmpty()  -> Main -> Checkings.lib

    #**** Parameters ****
    local p_arch=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - Path to the target archive.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method AND the (un)compression command's name.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.UncompressCMD()   -> Main -> Args.lib

#   - BU.Main.CMDS.GetCommandPath()         -> Main -> CMDS.lib

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
#   - BU.Main.Echo.Success()                -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()         -> Main -> Errors.lib

#   - BU.Main.Files.DeleteFile()            -> Main -> Files.lib
function BU.Main.Files.UncompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data.
    local p_del=${5:-false};    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : false    - DESC : Delete the archive after extracting successfully its content.

    #**** Code ****
    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__Files.Uncompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!!!
    if ! BU.Main.Args__Files.UncompressCMD "${p_cmd}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the user wishes to use the "$(7z)" command in order to uncompress one of these supported formats : 7z, LZMA2, XZ, ZIP, Zip64, CAB, RAR (if the non-free p7zip-rar package is installed), ARJ, GZIP, BZIP2, TAR, CPIO, RPM, ISO.
    if      [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == '7z' ) && "$(BU.Main.CMDS.GetCommandPath '7z')" ]]; then
            7z x "" "" "" "" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to decode a BinHexed file (Apple's BinHex format)
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'hexbin' ) && "$(BU.Main.Files.GetExtension ".hqx")" && "$(BU.Main.CMDS.GetCommandPath 'hexbin')" ]]; then
            hexbin "${p_opts}" "${p_arch}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "$(p7zip)" command in order to uncompress ... .
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'p7zip' ) && "$(BU.Main.CMDS.GetCommandPath 'p7zip')" ]]; then
            p7zip "" "" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the data to extract is stored in a Microsoft cabinet archive (.cab).
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'cabextract' ) && "$(BU.Main.CMDS.GetCommandPath 'cabextract')" ]]; then
            cabextract "${p_opts}" "${p_arch}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "$(gzip)" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'zip' ) && "$(BU.Main.CMDS.GetCommandPath 'zip')" ]]; then
            gzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "$(gunzip)" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'gunzip' ) && "$(BU.Main.CMDS.GetCommandPath 'gunzip')" ]]; then
            gunzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "$(unzip)" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'unzip' ) && "$(BU.Main.CMDS.GetCommandPath 'unzip')" ]]; then
            unzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Files.UncompressFormat()    -> Main -> Args.lib

#   - BU.Main.CMDS.GetCommandPath()             -> Main -> CMDS.lib

#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib

#   - BU.Main.Errors.HandleSmallErrors()        -> Main -> Errors.lib

#   - BU.Main.Files.UncompressFormat.ErrorMsg   -> Main -> Files.lib (defined into this function, this file)
function BU.Main.Files.UncompressFormat()
({
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_form=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression format.
    local p_arch=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data (optional argument).

    #**** Code ****
    if ! BU.Main.Args__Files.UncompressFormat "${p_form}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Quick writing of the error message which tells that it's impossible to uncompress the target archive with the default or the specified command.

    # Featured function(s) and file(s) by module(s) and from the "functions" folder :
    #   - BU.Main.Echo.Newline()    -> Main -> Echo.lib
    #   - BU.Main.Echo.Warning()    -> Main -> Echo.lib
    function BU.Main.Files.UncompressFormat.ErrorMsg()
    {
        #**** Parameters ****
        local p_fmt=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
        local p_arc=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the target archive.
        local p_cmd=${3:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the command used to uncompress the targeted archive.

        #**** Code ****
        BU.Main.Errors.HandleSmallErrors 'W' "Unable to uncompress the $(BU.Main.Decho.Decho.Highlight "${p_fmt}") archive named $(BU.Main.Decho.Decho.Path "${p_arc}") with the $(BU.Main.Decho.Decho.CMD "${p_cmd}") command" 'R';
        BU.Main.Echo.Warning "Please check the permissions of the archive, or use another uncompression command which supports the targeted archive's format";
        BU.Main.Echo.Newline;

        return 1;
    }

    # If the archive to be decompressed is a 7-Zip archive format.
    if [[ "${p_form}" == ?(.)7?(-)[Zz]?([Ii][Pp]) ]]; then
        # If the '7z' command is found in the "${PATH}" environment variable.
        if      BU.Main.CMDS.GetCommandPath 7z; then
                7z x "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg '7-Zip' "${p_arch}" '7z'; return 1; };

        # Else, if the '7z' command is found in the "${PATH}" environment variable.
        elif    BU.Main.CMDS.GetCommandPath p7zip; then
                p7zip || { BU.Main.Files.UncompressFormat.ErrorMsg '7-Zip' "${p_arch}" 'p7zip'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for 7z uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is an Apple's BinHex file.
    elif [[ "${p_form}" == ?([Aa][Pp][Pp][Ll][Ee]?(\')?([Ss])[[:space:]])[Bb][Ii][Nn][Hh][Ee][Xx] ]]; then
        if      BU.Main.CMDS.GetCommandPath hexbin; then
                hexbin "${p_arch}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'BinHex' "${p_arch}" 'hexbin'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Apple BinHex files uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Microsoft cabinet archive (.cab).
    elif [[ "${p_form}" == ?([Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]?(\')?([Ss])?([[:space:]]))?(.)[Cc][Aa][Bb]?([Ii][Nn][Ee][Tt]) ]]; then
        if      BU.Main.CMDS.GetCommandPath cabextract; then
                cabextract || { BU.Main.Files.UncompressFormat.ErrorMsg 'Microsoft Cab' "$'p_arch'" 'cabextract'; return 1; };

        elif    BU.Main.CMDS.GetCommandPath 7z; then
                7z x "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Microsoft Cab' "${p_arch}" '7z'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Microsoft Cabinet archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Gzip archive format.
    elif [[ "${p_form}" == ?(.)[Gg][Zz]?([Ii][Pp]) ]]; then
        if      BU.Main.CMDS.GetCommandPath gunzip; then
                gunzip -v "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Gzip' "${p_arch}" 'gunzip'; return 1; };

        elif    BU.Main.CMDS.GetCommandPath gzip; then
                gzip -dv "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Gzip' "${p_arch}" 'gzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Gzip archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Tar archive compressed with the Gzip compression format.
    elif [[ "${p_form}" == ?(.)[Tt]?([Aa][Rr])?(.)[Gg][Zz] ]]; then
        true;

    # Else, if the archive to be decompressed is a Zip archive format.
    elif [[ "${p_form}" == ?(.)[Zz][Ii][Pp] ]]; then
        if      BU.Main.CMDS.GetCommandPath unzip; then
                unzip "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Zip' "${p_arch}" 'unzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Zip archives uncompression found on your system' 'R';
        fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
})

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

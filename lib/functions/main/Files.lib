#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FILES PROCESSING FUNCTIONS
## DEBUG ID : filesfiles-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS="filesfiles-processing-functions";

## PROCESSING FUNCTIONS
## DEBUG ID : processing-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONSprocessing-functions";

# This function only repeats some parts of the following function.
function BU.Main.Files__ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS";

    #**** Parameters ****
    local p_output=$1;
    local p_name=$2;
    local p_char=$3;

    #**** Code ****
    if [ "$p_output" = 'E' ]; then
        BU.EchoError "End of processing the $(BU.DechoHighlightPath "$p_name") file";
        BU.EchoMsg "$(BU.Main.HeadersDrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
        BU.Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";

    elif [ "$p_output" = 'S' ]; then
        BU.EchoSuccess "End of processing the $(BU.DechoHighlightPath "$p_name") file";
        BU.EchoMsg "$(BU.Main.HeadersDrawLine "$p_char" "$__COL_RESET")" '-n' 'nodate';
        BU.Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";
    else
        BU.EchoWarning "";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - BU.Main.HeadersDrawLine      -> Headers.lib
#   - BU.Main.Errors.HandleErrors  -> Headers.lib
function BU.Main.FilesProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS";

    #**** Parameters ****
    local p_function=$1;
    local p_name=$2;

    shift; local pa_arr; pa_arr=$("$@");

    #**** Variables ****
    local v_char="'";

    #**** Code ****
    # Arguments checking.
    if ! BU.Main.Args__FilesProcessingFile "$p_function" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi;

	sleep "$__BU_MAIN_STAT_TIME_TXT";
    BU.EchoMsg "$(BU.Main.HeadersDrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
    BU.EchoNewstep "Processing the $(BU.DechoHighlightPath "$p_name") file in the $(BU.DechoHighlightPath "$p_parent") parent directory.";
    BU.Newline;

    case "$p_function" in
        'BU.Main.FilesMake')
            if BU.Main.FilesMake "${pa_arr[@]}"; then
                BU.Main.Files__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU.Main.Files__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
        'OverwriteFile')
            if BU.Main.FilesOverwriteFile "${pa_arr[@]}"; then
                BU.Main.Files__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU.Main.Files__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
    esac
}

# -----------------------------------------------

## FILE CREATION FUNCTIONS
## DEBUG ID : file-creation-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONSfile-creation-functions";

# Overwriting a file

# Featured functions and files from the "functions" folder :
#	- BU.EchoError			-> Main -> Echo.lib
#	- BU.EchoNewstep		-> Main -> Echo.lib
#	- BU.EchoSuccess		-> Main -> Echo.lib
#	- BU.Newline			-> Main -> Echo.lib
function BU.Main.FilesOverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_path=$1;
	local p_authorization=$2;

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU.Main.Args__FilesOverwriteFile "$p_path" "$p_authorization" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    # Checking second if the script is operating at the root directory.
    BU.Main.DirectoriesTriggerRootDirWarning "$p_path" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    if [ "$p_authorization" = "true" ]; then
		BU.EchoNewstep "The $(BU.DechoHighlightPath "$p_path/") file already exists and is not empty.";
		BU.EchoNewstep "Overwriting data from file $(BU.DechoHighlightPath "$p_path/")";
		BU.Newline;

		true > "$p_path";
		BU.Main.Errors.HandleErrors "$?" "THE CONTENT OF THE $(BU.DechoHighlightPath "$p_path/") FILE HAD NOT BEEN OVERWRITTEN" "" "$p_path" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))";
		BU.EchoSuccess "The content of the $(BU.DechoS "$p_path/") file has been successfully overwritten";
		BU.Newline;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# File creation function, with the parent folder's path and the file's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Args__FilesMake                   -> Main -> Args.lib
#   - BU.Main.Checkings.CheckFilePathWasCreated  -> Main -> Checkings.lib
#   - BU.Main.DirectoriesTriggerRootDirWarning  -> Main -> Directories.lib
#   - BU.Main.Errors.HandleErrors                -> Main -> Errors.lib
#   - BU.Main.FilesOverwriteFile                -> Main -> Files.lib (this file)
#   - BU.Main.HeadersDrawLine                   -> Main -> Headers.lib

#   - BU.DechoHighlightPath            -> Main -> Decho.lib
#   - BU.EchoError                     -> Main -> Echo.lib
#   - BU.EchoNewstep                   -> Main -> Echo.lib
#   - BU.EchoSuccess                   -> Main -> Echo.lib
function BU.Main.FilesMake()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

	#**** Parameters ****
    local p_parent=$1;  # String    : Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=$2;    # String    : Name of the file to process (into its parent directory).

    shift 2;

    pa_touchVals=("$@");

	#**** Variables ****
	local v_path="$p_parent/$p_name";	# Path of the file to process.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "$v_path" 'create' 'true' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

	# Checking if the awaited arguments are given.
    if ! BU.Main.Args__FilesMake "$p_parent" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi;

    # Checking second if the script is operating at the root directory.
    BU.Main.DirectoriesTriggerRootDirWarning "$v_path" || return 1;

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$v_path" ]; then
        BU.EchoNewstep "Creating the $(BU.DechoHighlightPath "$p_name") file in the parent folder $(BU.DechoHighlightPath "$p_parent/").";

		touch "$v_path"; BU.Main.Checkings.CheckFilePathWasCreated "$v_path";

		# Testing if the file has been created by checking the return code of the "BU.Main.Checkings.CheckFilePathWasCreated" function via the "BU.Main.Errors.HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU.Main.Errors.HandleErrors "$?" "THE $(BU.DechoHighlightPath "$p_name") FILE CANNOT BE CREATED IN THE $(BU.DechoHighlightPath "$p_parent/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-4 ))";

		BU.EchoSuccess "The $(BU.DechoHighlightPath "$p_name") file was successfully created in the $(BU.DechoHighlightPath "$p_parent") folder.";
        BU.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$p_path" ] && [ -s "$p_path" ]; then
        if BU.Main.FilesOverwriteFile "$p_path"; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$p_path" ] && [ ! -s "$p_path" ]; then
		BU.EchoSuccess "The $(BU.DechoHighlightPath "$p_path/") file already exists in the $(BU.DechoHighlightPath "$p_parent/") folder and is empty.";
		BU.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi
}

# File creation function, with the parent folder's path and the file's name as unique argument.
function BU.Main.FilesMakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_path=$1;    # String : Full path of the file to create.

    #**** Variables ****
    local v_parent; v_parent="$(echo "$p_path" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the file to create.
    local v_target; v_target="$(echo "$p_path" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the file to create.

    #**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" 'create' 'true';

    if ! BU.Main.Args__FilesMakePath "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    BU.Main.FilesMake "$v_parent" "$v_target" || return 1;

    return 0;
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.
function BU.Main.FilesMakeFileInMemory()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_filename=$1;    # String :name of the file to create in the computer's random access memory.

    #**** Code ****
    echo "$p_filename";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Creating the project's log file.
function BU.Main.FilesCreateProjectLogFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "$__BU_MAIN_PROJECT_LOG_FILE_PATH" 'create' 'true';

    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "$$" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU.Main.Checkings.CheckProjectRelatedFile "$__BU_MAIN_PROJECT_LOG_FILE_PARENT" "$__BU_MAIN_PROJECT_LOG_FILE_NAME" 'f'; then BU.EchoError "UNABLE TO CREATE THE $(BU.DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S LOG FILE"; BU.Exit '1'; fi

    BU.EchoSuccess "Successfully created the $(BU.DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.";

    if [ "${__BU_MAIN_STAT_DECHO,,}" = 'true' ];    then BU.Main.Status.ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; }; fi
    if [ "${__BU_MAIN_STAT_ECHO,}"  = 'true' ];     then BU.Main.Status.ChangeSTAT_ECHO  "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; }; fi

    # Redirecting the initializer's log file content into the log file.
    BU.HeaderBlue "INITIALIZATION PROCESS LOG OUTPUT";

    BU.EchoNewstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU.EchoMsg "$val"; done; BU.Newline;
    BU.EchoNewstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU.EchoMsg "$val"; done; BU.Newline;

	if (( "${#__BU_MODULE_INIT_MSG_ARRAY[@]}" >= 1 )); then
		BU.EchoNewstep "Initialization log output :"; BU.Newline;

        for val in "${__BU_MODULE_INIT_MSG_ARRAY[@]}"; do
            BU.CheckProjectLogStatus "$val";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU.HeaderBlue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

    # Getting operating system family.
    BU.EchoNewstep "Operating system family : $(BU.DechoHighlight "$OSTYPE")";
    BU.Newline;

    # Getting operating system's informations (Android's Termux terminal emulator) :
    BU.IsOSAndroidTermux && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (FreeBSD) :
    BU.IsOSFreeBSD && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (Linux platforms or Android without the Termux terminal emulator) :
    BU.IsOSLinux && {
        if [ -f "/etc/os-release" ]; then
            # Getting operating pretty system name.
            BU.EchoNewstep "Operating system pretty name : $(awk -F= '/PRETTY/ {print $2}' '/etc/os-release')";
            BU.Newline;

            # Gathering OS informations from the "/etc/os-release" file.
            BU.EchoNewstep "Operating system general informations :";
            BU.EchoMsg "$(cat '/etc/os-release')" "" "nodate";
            BU.Newline;
        else
            BU.EchoWarning "No available informations ($(BU.DechoHighlight '/etc/os-release') file not found)";
            BU.Newline;
        fi

        # Getting operating system extra informations (Windows Subsystem for Linux, etc...).
        BU.EchoNewstep "Operating system extra informations :";
        if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU.EchoMsg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
        BU.Newline;
    }

    # Getting operating system's informations (Haiku OS) :
    BU.IsOSHaiku && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : Haiku OS";
        BU.Newline;

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (OpenBSD) :
    BU.IsOSOpenBSD && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (NetBSD) :
    BU.IsOSNetBSD && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (Mac OS) :
    BU.IsOSX && {
        # Getting operating system pretty name.
        BU.EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.EchoNewstep "Operating system general informations :";
    }

	# Getting Bash language's version.
    BU.EchoNewstep "Bash version : $(BU.DechoHighlight "$BASH_VERSION")";
    BU.Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU.EchoNewstep "Terminal (emulator) version : $(BU.DechoHighlight "$v_terminfo_v")" || BU.EchoWarning "$(BU.DechoHighlight '$v_terminfo_v') : bad command call.";
    BU.Newline;

    BU.EchoSuccess "Successfully got the user's system's informations.";

    # Purging the "$__BU_MODULE_INIT_MSG_ARRAY" variable from the logged messages, after writing its content in the project's log file, in order to free memory.
    __BU_MODULE_INIT_MSG_ARRAY='';

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## GETTING FILE INFORMATIONS
## DEBUG ID : getting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONSgetting-file-informations";

# Getting the size of a file in bytes.
function BU.Main.FilesGetByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # # String    - Default : NULL    - Path to the file to process.
    local p_base=$2;        # Byte measure unit base (binary prefix (eg : MiB) or metric prefix (eg : MB)).

    #**** Code ****

    if [ -z "$p_base" ]; then
        wc --bytes < "$p_filepath" || \
            { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.DechoHighlightPath "$p_filepath") file"; BU.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

    # Else, if a value is passed to the "base" parameter AND this value is an integer.
    elif [ -n "$p_base" ] && BU.IsInt "$b_base"; then

        # Convert the size from plain number to human readable metric prefix.
        if [ "$p_base" -ne 1024 ]; then
            BU.Main.BasicMathsBytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.DechoHighlightPath "$p_filepath") file"; BU.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

        # Convert the size from plain number to human readable binary prefix.
        else
            BU.Main.BasicMathsBytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.DechoHighlightPath "$p_filepath") file"; BU.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };
        fi
    else
        BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : The byte measure unit byte $(BU.DechoHighlight "$p_base") is not an integer"; BU.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the file's creation date.

# Please note, some file systems don't store the file's creation date. In this case, the "stat" command will return '0'.
function BU.Main.FilesGetCreationDate()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path to the file to process.

    #**** Code ****
    if ! stat -c %W "$p_filepath"; then
        BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the $(BU.DechoHighlightPath "$p_filepath") file's creation date"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED";

    elif [ "$(stat -c %W "$p_filepath")" -eq 0 ]; then
        BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : This filesystem ($(BU.DechoHighlight "$__BU_MAIN_FS_NAME")) does not stores the files creation dates"; BU.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED";

    else
        echo -ne "$(stat -c %W "$p_filepath")";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU.Main.FilesGetCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    wc --chars < "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of characters in the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's extension.
function BU.Main.FilesGetExtension()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    BU.Main.Text.CutLastFieldAfterDelim "$p_filepath" '.' || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the $(BU.DechoHighlightPath "$p_filepath") file's extension";  }

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's access date.
function BU.Main.FilesGetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    stat "$p_filename" | awk 'FNR == 5 { print $2 " " $3 }' || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last access date from the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's modification date.
function BU.Main.FilesGetLastModification()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    date -r "$p_filename" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last modification date from the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's mime type.
function BU.Main.FilesGetMIMEType()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    file --mime-type "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the MIME type of the $(BU.DechoHighlightPath "$p_filepath") file";  };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of lines in a file.
function BU.Main.FilesGetLinesNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    wc --lines < "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of lines in the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the max line length in a file.
function BU.Main.FilesGetMaxLineLength()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****last access date
    wc --max-line-length < "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the max line length in the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the owner of a file.
function BU.Main.FilesGetOwnerName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    stat -c "%U" "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the name of the owner of the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the group of the owner of a file.
function BU.Main.FilesGetOwnerGroup()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    stat -c "%G" "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the group of the owner of the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU.Main.FilesGetWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    wc --words < "$p_filepath" || { BU.EchoWarning "$(BU.DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of words in the $(BU.DechoHighlightPath "$p_filepath") file"; BU.EchoWarning "Please check the permissions of this file"; BU.Newline; BU.SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## SETTING FILE INFORMATIONS
## DEBUG ID : setting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONSsetting-file-informations";

# Setting a fake last access date to a file.
function BU.Main.FileSetFileLastAccess
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Default : NULL    - Path of the file to process.
    local p_fakedate=$2;

    #**** Code ****
    if ! BU.Main.Args__FilesSetFileLastAccess "$p_filepath" "$p_fakedate" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE SOURCING
## DEBUG ID : file-sourcing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONSfile-sourcing";

# Sourcing dependencies files.
function BU.Main.FilesSourceFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING";

    #**** Parameters ****
    local p_path=$1;    # String    - Default : NULL    - Path of the file to process.

    #**** Code ****
    if [ -f "$p_path" ]; then
		BU.EchoNewstep "Sourcing the $(BU.DechoHighlightPath "$p_path") file";
		BU.Newline

        # shellcheck disable=SC1090
        if source "$p_path"; then
            BU.EchoSuccess "Sourced file : $(BU.DechoHighlightPath "$p_path")";
			BU.Newline;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            local C="$?";

            BU.Main.Errors.HandleErrors "$__BU_MAIN_EXIT_NOT_PERMITTED" "UNABLE TO SOURCE THIS FILE : $(BU.DechoHighlightPath "$p_path")" "Please verify that the file's path passed as argument exists, and that you have read rights on this file." "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))";

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C";
        fi
    else
        local C="$?";

        BU.Main.Errors.HandleErrors "$__BU_MAIN_EXIT_NOT_PERMITTED" "UNABLE TO FIND THIS FILE : $(BU.DechoHighlightPath "$p_path")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-8 ))";

		return "$C";
    fi
}

# -----------------------------------------------

## TEXT FILE PARSING
## DEBUG ID : text-file-parsing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONStext-file-parsing";

# Getting a specific line from a text file.
function BU.Main.FilesGetLineFromTextFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING";

    #**** Parameters ****
    local p_source=$1;          # String    - Default : NULL    - Path of the file to parse.
    local p_wanted_line=$2;     # Int       - Default : NULL    - Line to get in the file

    #**** Variables ****
    local i=0;                  # Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
    cat "$p_source" | while read -r line; do

        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ));

        # ... until it reaches the wanted line.
        if [ "$i" -eq "$p_wanted_line" ]; then

			# shellcheck disable=SC2034
            __BU_MAIN_TXT_STORE_LINE="$line";
        fi
    done

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS
#### DEBUG ID : filesarchive-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS="filesarchive-processing-functions";

## (UN)COMPRESSION FUNCTIONS
## DEBUG ID : (un)compression-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS(un)compression-functions";

# Adding files or folders into an archive.
function BU.Main.FilesAddToArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_cmd=$1;         # String    - Default : NULL    - Compression command.
    local p_opts=$2;        # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=$3;        # String    - Default : NULL    - Archive's name.
    shift 3;

    local p_paths=("$@");   # Array - Default : NULL    - Paths to the files / folders to add in the archive.

    #**** Code ****
    if BU.IsArrayEmpty "${p_paths[@]}"; then local lineno="$LINENO";
        BU.Main.ArgsPrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to add in the targeted archive (mandatory argument) [/|\] $(BU.Main.ArgsPrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "${p_paths[@]}" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # There is no need to pass the "$p_opts" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__FilesCompress "$cmd" "$opts" "$p_arch" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    if [ "$p_cmd" = '7z' ]; then
        true

    elif [ "$p_cmd" = 'bzip2' ]; then true;

    elif [ "$p_cmd" = '' ]; then true;

    elif [ "$p_cmd" = 'gzip' ]; then true;

    elif [ "$p_cmd" = 'zip' ]; then true;

    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the compression command
function BU.Main.FilesCompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_cmd=$1;         # String    - Default : NULL    - Compression command.
    local p_opts=$2;        # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=$3;        # String    - Default : NULL    - Path to the archive to uncompress.
    local p_dest=$4;        # String    - Default : NULL    - Folder destination of the uncompressed data.
    shift 4;

    local p_paths=("$@");   # Array - Default : NULL    - Paths to the files / folders to archivate.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   -
function BU.Main.FilesCompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_cmd=$1;             # String    - Default : NULL    - Compression command.
    local p_arch=$3;            # String    - Default : NULL    - Archive's name.
    shift 2;

    local p_paths=("$@");       # Array - Default : NULL    - Paths to the files / folders to archivate.

    #**** Code ****
    if BU.IsArrayEmpty "${p_paths[@]}"; then local lineno="$LINENO";
        BU.Main.ArgsPrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to compress (mandatory argument) [/|\] $(BU.Main.ArgsPrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "${p_paths[@]}" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # There is no need to pass the "$p_opts" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__FilesCompressFormat "$cmd" "$opts" "$p_arch" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    # If the 7-Zip compression format is wanted.
    if [ "$p_cmd" == '7z' ]; then
        7z a "$p_opts" "$p_opts" "$p_arch" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format 7-Zip.
            return 1;
        }

    # Else, if the BinHex compression format is wanted (works on Apple operating systems).
    elif [ "$p_cmd" == 'binhex' ]; then
        binhex "$p_opts" "${p_paths[@]}" > "$p_arch"|| {
            # TODO : Gérer les cas d'erreur de compression au format BinHex.
            return 1;
        }

    # Else, if the Bzip2 compression format is wanted.
    elif [ "${p_cmd,,}" = 'bzip2' ]; then
        true;

    # Else, if the Bzip2 compression format is wanted for a Tar archive.
    elif [[ "${p_cmd^^}" = TBZ?(2) ]] || [[ "${p_cmd,,}" = tar?(.)bz?(2) ]]; then
        tar "-jcf$p_opts" "" "" || {
            # TODO : Gérer les cas d'erreur de compression au format Bzip2.
            return 1;
        }

    # Else, if the Gzip compression format is wanted.
    elif [ "${p_cmd,,}" = 'gzip' ]; then
        true;

    # Else, if the Gzip compression format is wanted for a Tar archive.
    elif [ "${p_cmd^^}" = 'TGZ' ] || [[ "${p_cmd,,}" = tar?(.)gz ]]; then
        tar "-zcf$p_opts" "$p_arch" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the LZMA compression is wanted for a Tar archive.
    elif [ "${p_cmd^^}" = 'TXZ' ] || [[ "${p_cmd,,}" = tar?(.)xz ]]; then
        tar "JCxf$p_opts" "$p_arch" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the zip compression format is wanted.
    elif [ "$p_cmd" == 'zip' ]; then
        zip "$p_opts" "$p_arch" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format zip.
            return 1;
        }
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Deleting a file or a folder stored in an archive.
function BU.Main.FilesDeleteInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_cmd=$1;         # String    - Default : NULL    - Compression command.
    local p_opts=$2;        # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=$3;        # String    - Default : NULL    - Target archive's path.
    shift 3;

    local p_paths=("$@");   # Array - Default : NULL    - Paths to the files / folders to delete in the archive.

    #**** Code ****
    if BU.IsArrayEmpty "${p_paths[@]}"; then local lineno="$LINENO";
        BU.Main.ArgsPrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to delete from the target archive (mandatory argument) [/|\] $(BU.Main.ArgsPrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "${p_paths[@]}" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Searching for a file or a folder inside an archive.
function BU.Main.FilesSearchInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_arch=$1;    # String    - Default : NULL    - Path to the target archive.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method AND the (un)compression command's name.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Errors.HandleErrors      -> Handles.lib
#   - BU.EchoSuccess       -> Echo.lib
#   - BU.Newline           -> Echo.lib
function BU.Main.FilesUncompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_cmd=$1;     # String    - Default : NULL    - Compression command.
    local p_opts=$2;    # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=$3;    # String    - Default : NULL    - Path to the archive to uncompress.
    local p_dest=$4;    # String    - Default : NULL    - Folder destination of the uncompressed data.

    #**** Code ****
    # There is no need to pass the "$p_opts" parameter as argument for the "BU.Main.Args__FilesUncompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!!!
    if ! BU.Main.Args__FilesUncompressCMD "$cmd" "$p_arch" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    # If the user wishes to use the "7z" command in order to uncompress one of these supported formats : 7z, LZMA2, XZ, ZIP, Zip64, CAB, RAR (if the non-free p7zip-rar package is installed), ARJ, GZIP, BZIP2, TAR, CPIO, RPM, ISO.
    if      [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = '7z' ) && "$(BU.Main.CMDSGetCommandPath '7z')" ]]; then
            7z x "" "" "" "" || { return 1; };

    # Else, if the user wishes to decode a BinHexed file (Apple's BinHex format)
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'hexbin' ) && "$(BU.Main.FilesGetExtension ".hqx")" && "$(BU.Main.CMDSGetCommandPath 'hexbin')" ]]; then
            hexbin "$p_opts" "$p_arch" || { return 1; };

    # Else, if the user wishes to use the "p7zip" command in order to uncompress ... .
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'p7zip' ) && "$(BU.Main.CMDSGetCommandPath 'p7zip')" ]]; then
            p7zip "" "" || { return 1; };

    # Else, if the data to extract is stored in a Microsoft cabinet archive (.cab).
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'cabextract' ) && "$(BU.Main.CMDSGetCommandPath 'cabextract')" ]]; then
            cabextract "$p_opts" "$p_arch" || { return 1; };

    # Else, if the user wishes to use the "gzip" command in order to uncompress
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'zip' ) && "$(BU.Main.CMDSGetCommandPath 'zip')" ]]; then
            gzip "$p_opts" "$p_arch" "$p_dest" || { return 1; };

    # Else, if the user wishes to use the "gunzip" command in order to uncompress
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'gunzip' ) && "$(BU.Main.CMDSGetCommandPath 'gunzip')" ]]; then
            gunzip "$p_opts" "$p_arch" "$p_dest" || { return 1; };

    # Else, if the user wishes to use the "unzip" command in order to uncompress
    elif    [[ ( -n "$p_cmd" ) && ( "${p_cmd,,}" = 'unzip' ) && "$(BU.Main.CMDSGetCommandPath 'unzip')" ]]; then
            unzip "$p_opts" "$p_arch" "$p_dest" || { return 1; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method.
function BU.Main.FilesUncompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
    local p_form=$1;    # String    - Default : NULL    - Compression format.
    local p_arch=$2;    # String    - Default : NULL    - Path to the archive to uncompress.
    local p_dest=$3;    # String    - Default : NULL    - Folder destination of the uncompressed data (optional argument).

    #**** Code ****
    if ! BU.Main.Args__FilesUncompressFormat "$p_form" "$p_arch" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    # Quick writing of the error message which tells that it's impossible to uncompress the target archive with the default or the specified command.
    function BU.Main.FilesUncompressFormatErrorMsg()
    {
        #**** Parameters ****
        local p_fmt=$1;     # Archive format.
        local p_arc=$2;     # Name of the target archive.
        local p_cmd=$3;     # Name of the command used to uncompress the targeted archive.

        #**** Code ****
        BU.Main.Errors.HandleSmallErrors 'W' "Impossible to decompress the $(BU.DechoHighlight "$p_fmt") archive named $(BU.DechoHighlightPath "$p_arc") with the $(BU.DechoHighlightCMD "$p_cmd") command" 'R';
        BU.EchoWarning "Please check the permissions of the archive, or use another uncompression command which supports the targeted archive's format";
        BU.Newline;

        return 1;
    }

    # If the archive to be decompressed is a 7-Zip archive format.
    if [[ "$p_form" == ?(.)7?(-)[Zz]?([Ii][Pp]) ]]; then
        # If the '7z' command is found in the "$PATH" environment variable.
        if      BU.Main.CMDSGetCommandPath 7z; then
                7z x "$p_arch" "$p_dest" || { BU.Main.FilesUncompressFormatErrorMsg '7-Zip' "$p_arch" '7z'; return 1; };

        # Else, if the '7z' command is found in the "$PATH" environment variable.
        elif    BU.Main.CMDSGetCommandPath p7zip; then
                p7zip || { BU.Main.FilesUncompressFormatErrorMsg '7-Zip' "$p_arch" 'p7zip'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for 7z uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is an Apple's BinHex file.
    elif [[ "$p_form" == ?([Aa][Pp][Pp][Ll][Ee]?(\')?([Ss])[[:space:]])[Bb][Ii][Nn][Hh][Ee][Xx] ]]; then
        if      BU.Main.CMDSGetCommandPath hexbin; then
                hexbin "$p_arch" || { BU.Main.FilesUncompressFormatErrorMsg 'BinHex' "$p_arch" 'hexbin'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Apple BinHex files uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Microsoft cabinet archive (.cab).
    elif [[ "$p_form" == ?([Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]?(\')?([Ss])?([[:space:]]))?(.)[Cc][Aa][Bb]?([Ii][Nn][Ee][Tt]) ]]; then
        if      BU.Main.CMDSGetCommandPath cabextract; then
                cabextract || { BU.Main.FilesUncompressFormatErrorMsg 'Microsoft Cab' "$p_arch" 'cabextract'; return 1; };

        elif    BU.Main.CMDSGetCommandPath 7z; then
                7z x "$p_arch" "$p_dest" || { BU.Main.FilesUncompressFormatErrorMsg 'Microsoft Cab' "$p_arch" '7z'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Microsoft Cabinet archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Gzip archive format.
    elif [[ "$p_form" == ?(.)[Gg][Zz]?([Ii][Pp]) ]]; then
        if      BU.Main.CMDSGetCommandPath gunzip; then
                gunzip -v "$p_arch" "$p_dest" || { BU.Main.FilesUncompressFormatErrorMsg 'Gzip' "$p_arch" 'gunzip'; return 1; };

        elif    BU.Main.CMDSGetCommandPath gzip; then
                gzip -dv "$p_arch" "$p_dest" || { BU.Main.FilesUncompressFormatErrorMsg 'Gzip' "$p_arch" 'gzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Gzip archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Tar archive compressed with the Gzip compression format.
    elif [[ "$p_form" == ?(.)[Tt]?([Aa][Rr])?(.)[Gg][Zz] ]]; then
        true;

    # Else, if the archive to be decompressed is a Zip archive format.
    elif [[ "$p_form" == ?(.)[Zz][Ii][Pp] ]]; then
        if      BU.Main.CMDSGetCommandPath unzip; then
                unzip "$p_arch" "$p_dest" || { BU.Main.FilesUncompressFormatErrorMsg 'Zip' "$p_arch" 'unzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Zip archives uncompression found on your system' 'R';
        fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

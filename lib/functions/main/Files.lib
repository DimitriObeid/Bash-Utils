#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT FILES PROCESSING FUNCTIONS

## PROCESSING FUNCTIONS

# This function only repeats some parts of the following function.
function BU::Main::Files::__ProcessingFile()
{
    #**** Parameters ****
    p_output=$1
    p_name=$2
    p_char=$3

    #**** Code ****
    if [ "$p_output" = 'E' ]; then
        BU::EchoError "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";

    elif [ "$p_output" = 'S' ]; then
        BU::EchoSuccess "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$p_char" "$__COL_RESET")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";
    else
        BU::EchoWarning "";
    fi
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Files::ProcessingFile()
{
    #**** Parameters ****
    local p_function=$1;
    local p_name=$2;

    shift; local arr;
        arr=$("$@");

    #**** Variables ****
    local v_char="'";

    #**** Code ****
    # Arguments checking.
    BU::Main::Args__Files::ProcessingFile "$p_function";

	sleep "$__BU_MAIN_STAT_TIME_TXT";
    BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
    BU::EchoNewstep "Processing the $(BU::DechoHighlightPath "$p_name") file in the $(BU::DechoHighlightPath "$p_parent") parent directory.";
    BU::Newline;

    case "$p_function" in
        'BU::Main::Files::Make')
            if BU::Main::Files::Make "${arr[@]}"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
        'OverwriteFile')
            if BU::Main::Files::OverwriteFile "$arr"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
    esac
}

# -----------------------------------------------

## FILE CREATION FUNCTIONS

# Overwriting a file

# Featured functions and files from the "functions" folder :
#	- BU::EchoError			-> Main -> Echo.lib
#	- BU::EchoNewstep		-> Main -> Echo.lib
#	- BU::EchoSuccess		-> Main -> Echo.lib
#	- BU::Newline			-> Main -> Echo.lib
function BU::Main::Files::OverwriteFile()
{
    #**** Parameters ****
    local p_path=$1;
	local p_authorization=$2;

    #**** Code ****
    # Checking first if the awaited arguments are given
    BU::Main::Args__Files::OverwriteFile;

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$p_path";

    if [ "$p_authorization" = "true" ]; then
		BU::EchoNewstep "The $(BU::DechoHighlightPath "$p_path/") file already exists and is not empty.";
		BU::EchoNewstep "Overwriting data from file $(BU::DechoHighlightPath "$p_path/")";
		BU::Newline;

		true > "$p_path";
		BU::Main::Errors::HandleErrors "$?" "THE CONTENT OF THE $(BU::DechoHighlightPath "$p_path/") FILE HAD NOT BEEN OVERWRITTEN" "" "$p_path" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))";
		BU::EchoSuccess "The content of the $(BU::DechoS "$p_path/") file has been successfully overwritten";
		BU::Newline;
	else
		return 0;
	fi

	return 0;
}

# File creation function, with the parent folder's path and the file's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Args__Files::Make                   -> Main -> Args.lib
#   - BU::Main::Checkings::CheckFilePathWasCreated  -> Main -> Checkings.lib
#   - BU::Main::Directories::TriggerRootDirWarning  -> Main -> Directories.lib
#   - BU::Main::Errors::HandleErrors                -> Main -> Errors.lib
#   - BU::Main::Files::OverwriteFile                -> Main -> Files.lib (this file)
#   - BU::Main::Headers::DrawLine                   -> Main -> Headers.lib

#   - BU::DechoHighlightPath            -> Main -> Decho.lib
#   - BU::EchoError                     -> Main -> Echo.lib
#   - BU::EchoNewstep                   -> Main -> Echo.lib
#   - BU::EchoSuccess                   -> Main -> Echo.lib
function BU::Main::Files::Make()
{
	#**** Parameters ****
    local p_parent=$1;  # String    : Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=$2;    # String    : Name of the file to process (into its parent directory).

    shift 2;

    pa_touchVals=("$@");

	#**** Variables ****
	local v_path="$p_parent/$p_name";	# Path of the file to process.

	#**** Code ****
	# Checking first if the awaited arguments are given.
    BU::Main::Args__Files::Make "$p_parent" "$p_name";

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$v_path";

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$v_path" ]; then
        BU::EchoNewstep "Creating the $(BU::DechoHighlightPath "$p_name") file in the parent folder $(BU::DechoHighlightPath "$p_parent/").";

		touch "$v_path"; BU::Main::Checkings::CheckFilePathWasCreated "$v_path";

		# Testing if the file has been created by checking the return code of the "BU::Main::Checkings::CheckFilePathWasCreated" function via the "BU::Main::Errors::HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU::Main::Errors::HandleErrors "$?" "THE $(BU::DechoHighlightPath "$p_name") FILE CANNOT BE CREATED IN THE $(BU::DechoHighlightPath "$p_parent/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-4 ))";

		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_name") file was successfully created in the $(BU::DechoHighlightPath "$p_parent") folder.";
        BU::Newline;

        return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$p_path" ] && [ -s "$p_path" ]; then
        if BU::Main::Files::OverwriteFile "$p_path"; then
            return 0;
        else
            return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$p_path" ] && [ ! -s "$p_path" ]; then
		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_path/") file already exists in the $(BU::DechoHighlightPath "$p_parent/") folder and is empty.";
		BU::Newline;

		return 0;
	fi
}

# File creation function, with the parent folder's path and the file's name as unique argument.
function BU::Main::Files::MakePath()
{
    #**** Parameters ****
    local p_path=$1;    # String : Full path of the file to create.

    #**** Variables ****
    local v_parent; v_parent="$(echo "$p_path" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the file to create.
    local v_target; v_target="$(echo "$p_path" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the file to create.

    #**** Code ****
    if ! BU::Main::Args__Files::MakePath "$p_path"; then return 1; fi

    BU::Main::Files::Make "$v_parent" "$v_target" || return 1;

    return 0;
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.
function BU::Main::Files::MakeFileInMemory()
{
    #**** Parameters ****
    p_filename=$1;      # String :name of the file to create in the computer's random access memory.

    #**** Code ****
    echo "$p_filename";

    return 0;
}

# Creating the project's log file.
function BU::Main::Files::CreateProjectLogFile()
{
    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "$$" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_LOG_FILE_PARENT" "$__BU_MAIN_PROJECT_LOG_FILE_NAME" 'f'; then BU::EchoError "UNABLE TO CREATE THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S LOG FILE"; BU::Exit '1'; fi

    BU::EchoSuccess "Successfully created the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.";

	if [ "$__BU_MAIN_STAT_DECHO" = 'true' ]; then	BU::Main:Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi
    if [ "$__BU_MAIN_STAT_ECHO"  = 'true' ]; then	BU::Main:Status::ChangeSTAT_ECHO  "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi

    # Redirecting the initializer's log file content into the log file.
    BU::HeaderBlue "INITIALIZATION PROCESS LOG OUTPUT";

    BU::EchoNewstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;
    BU::EchoNewstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;

	if (( "${#__BU_MODULE_UTILS_MSG_ARRAY[@]}" >= 1 )); then
		BU::EchoNewstep "Initialization log output :"; BU::Newline;

        for val in "${__BU_MODULE_UTILS_MSG_ARRAY[@]}"; do
            BU::CheckProjectLogStatus "$(CutDateFromString "$val")";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU::HeaderBlue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

	# Getting operating system name.
	BU::EchoNewstep "Operating system name : $(awk -F= '/^NAME/{print $2}' /etc/os-release)";
	BU::Newline;

    # Getting operating system family.
    BU::EchoNewstep "Operating system family : $(BU::DechoHighlight "$OSTYPE")";
    BU::Newline;

    # Gathering OS informations from the "/etc/os-release" file.
    BU::EchoNewstep "Operating system general informations :";
    if [ -f "/etc/os-release" ]; then BU::EchoMsg "$(cat "/etc/os-release")" "" "nodate"; else BU::EchoMsg 'No available informations ("/etc/os-release" file not found)'; fi
    BU::Newline;

	# Getting operating system extra informations (Windows Subsystem for Linux, etc...).
	BU::EchoNewstep "Operating system extra informations :";
	if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU::EchoMsg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
	BU::Newline;

	# Getting Bash language's version.
    BU::EchoNewstep "Bash version : $(BU::DechoHighlight "$BASH_VERSION")";
    BU::Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU::EchoNewstep "Terminal (emulator) version : $(BU::DechoHighlight "$v_terminfo_v")" || BU::EchoWarning "$(BU::DechoHighlight '$v_terminfo_v') : bad command call.";
    BU::Newline;

    BU::EchoSuccess "Successfully got the user's system's informations.";

    # Purging the "$__BU_MODULE_UTILS_MSG_ARRAY" variable from the logged messages, after writing its content in the project's log file.
    __BU_MODULE_UTILS_MSG_ARRAY='';
}

# -----------------------------------------------

## GETTING FILE INFORMATIONS

# Getting the size of a file in bytes.
function BU::Main::File::GetFileByteSize()
{
    #**** Parameters ****
    local p_filepath=$1;    # Path to the file to process.
    local p_base=$2;        # Byte measure unit base (binary prefix (eg : MiB) or metric prefix (eg : MB)).

    #**** Code ****

    if [ -z "$p_base" ]; then
        wc --bytes < "$p_filepath" || \
            { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; return 1; };

    # Else, if a value is passed to the "base" parameter AND this value is an integer.
    elif [ -n "$p_base" ] && BU::IsInt "$b_base"; then

        # Convert the size from plain number to human readable metric prefix.
        if [ "$p_base" -ne 1024 ]; then
            BU::Main::BasicMaths::BytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; return 1; };

        # Convert the size from plain number to human readable binary prefix.
        else
            BU::Main::BasicMaths::BytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; return 1; };
        fi
    else
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : The byte measure unit byte $(BU::DechoHighlight "$p_base") is not an integer"; BU::Newline >&2; return 1;
    fi

    return 0;
}

# Getting the file's creation date.

# Please note, some file systems don't store the file's creation date. In this case, the "stat" command will return '0'.
function BU::Main::File::GetFileCreationDate()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    if ! stat -c %W "$p_filepath"; then
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the $(BU::DechoHighlightPath "$p_filepath") file's creation date"; BU::EchoWarning "Please check the permissions of this file"; return 1;

    elif [ "$(stat -c %W "$p_filepath")" -eq 0 ]; then
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : This filesystem ($(BU::DechoHighlight "$(df -Th . | awk 'FNR == 2 {print $2}')")) does not stores the files creation dates"; return 1;
    fi

    return 0;
}

# Getting the total number of characters in a file.
function BU::Main::File::GetFileCharactersNumber()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --chars < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of characters in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; }; return 0;
}

# Getting the last file's access date.
function BU::Main::File::GetFileLastAccess()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
     "$p_filename" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last access date from the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; };

    return 0;
}

# Getting the last file's modification date.
function BU::Main::File::GetFileLastModification()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    date -r "$p_filename" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last modification date from the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; };

    return 0;
}

# Getting the total number of lines in a file.
function BU::Main::File::GetFileLinesNumber()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --lines < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of lines in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; }; return 0;
}

# Getting the max line length in a file.
function BU::Main::File::GetFileMaxLineLength()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****last access date
    wc --max-line-length < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the max line length in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; }; return 0;
}

# Getting the owner of a file.
function BU::Main::File::GetFileOwnerName()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    stat -c "%U" "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the name of the owner of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; };

    return 0;
}

# Getting the group of the owner of a file.
function BU::Main::File::GetFileOwnerGroup()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    stat -c "%G" "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the group of the owner of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; };

    return 0;
}

# Getting the total number of characters in a file.
function BU::Main::File::GetFileWordsNumber()
{
    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --words < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of words in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; return 1; }; return 0;
}

# -----------------------------------------------

## SETTING FILE INFORMATIONS

# Setting a fake last access date to a file.
function BU::Main::File::SetFileLastAccess
{
    #**** Parameters ****
    local p_filepath=$1;
    local p_fakedate=$2;

    #**** Code ****


    return 0;
}

# -----------------------------------------------

## FILE SOURCING

# Sourcing dependencies files.
function BU::Main::Files::SourceFile()
{
    #**** Parameters ****
    local p_path=$1;

    #**** Code ****
    if [ -f "$p_path" ]; then
        # shellcheck disable=SC1090
        if source "$p_path"; then
            BU::EchoSuccess "Sourced file : $(BU::DechoHighlightPath "$p_path")";
        else
            BU::Main::Errors::HandleErrors "1" "UNABLE TO SOURCE THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please verify that the file's path passed as argument exists, and that you have read rights on this file." "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))";
        fi
    else
        BU::Main::Errors::HandleErrors "1" "UNABLE TO FIND THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-8 ))";
    fi
}

# -----------------------------------------------

## TEXT FILES PARSING

# Getting a specific line from a text file.
function BU::Main::Files::GetLineFromTextFile()
{
    #**** Parameters ****
    local p_source=$1;          # File to parse
    local p_wanted_line=$2;     # Line to get in the file

    #**** Variables ****
    local i=0;                  # Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
    cat "$p_source" | while read -r line; do

        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ));

        # ... until it reaches the wanted line.
        if [ "$i" -eq "$p_wanted_line" ]; then

			# shellcheck disable=SC2034
            __BU_MAIN_TXT_STORE_LINE="$line";
        fi
    done
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS

## (UN)COMPRESSION FUNCTIONS

#

# Featured functions and files from the "functions" folder :
#   -
function BU::Main::Files::Compress()
{
    #**** Parameters ****
#     local cmd=$1      # Compression command.
#     local opts=$2     # Options of the compression command.
#     local p_path=$3     # Path to the file/folder to archivate.
#     local p_name=$4     # Archive's name (only used into displayed messages).

    #**** Code ****


    return 0;
}

# Uncompressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Errors::HandleErrors      -> Handles.lib
#   - BU::EchoSuccess       -> Echo.lib
#   - BU::Newline           -> Echo.lib
function BU::Main::Files::Uncompress()
{
#     #***** Paramètres *****
#     local p_cmd=$1      # Compression command.
#     # TODO : Vérifier si cette procédure est bonne
#     local p_opts=$2     # Options of the compression command. (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
#     local p_path=$3     # Path to the l'archive to uncompress.
#     local p_name=$4     # Archive's name (only used into displayed messages).
#
#     #**** Code ****
#     # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
#     "$cmd $opts $p_path"
#     BU::Main::Errors::HandleErrors "$?" "${FUNCNAME[0]} : LA DÉCOMPRESSION DE L'ARCHIVE $(BU::DechoHighlightPath "$p_name") A ÉCHOUÉE"
#     BU::EchoSuccess "La décompression de l'archive $(BU::DechoHighlightPath "$p_name") s'est effectuée avec brio."
#     BU::Newline;

    return 0;
}

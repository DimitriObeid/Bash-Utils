#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FILES PROCESSING FUNCTIONS
## DEBUG ID : files::files-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS="files::files-processing-functions";

## PROCESSING FUNCTIONS
## DEBUG ID : processing-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::processing-functions";

# This function only repeats some parts of the following function.
function BU::Main::Files::__ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS";

    #**** Parameters ****
    local p_output=$1;
    local p_name=$2;
    local p_char=$3;

    #**** Code ****
    if [ "$p_output" = 'E' ]; then
        BU::EchoError "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";

    elif [ "$p_output" = 'S' ]; then
        BU::EchoSuccess "End of processing the $(BU::DechoHighlightPath "$p_name") file";
        BU::EchoMsg "$(BU::Main::Headers::DrawLine "$p_char" "$__COL_RESET")" '-n' 'nodate';
        BU::Newline;

        sleep "$__BU_MAIN_STAT_TIME_TXT";
    else
        BU::EchoWarning "";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Files::ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS";

    #**** Parameters ****
    local p_function=$1;
    local p_name=$2;

    shift; local pa_arr; pa_arr=$("$@");

    #**** Variables ****
    local v_char="'";

    #**** Code ****
    # Arguments checking.
    if ! BU::Main::Args__Files::ProcessingFile "$p_function" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi;

	sleep "$__BU_MAIN_STAT_TIME_TXT";
    BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
    BU::EchoNewstep "Processing the $(BU::DechoHighlightPath "$p_name") file in the $(BU::DechoHighlightPath "$p_parent") parent directory.";
    BU::Newline;

    case "$p_function" in
        'BU::Main::Files::Make')
            if BU::Main::Files::Make "${pa_arr[@]}"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
        'OverwriteFile')
            if BU::Main::Files::OverwriteFile "${pa_arr[@]}"; then
                BU::Main::Files::__ProcessingFile 'S' "$p_name" "$p_char";
            else
                BU::Main::Files::__ProcessingFile 'E' "$p_name" "$p_char";
            fi
            ;;
    esac
}

# -----------------------------------------------

## FILE CREATION FUNCTIONS
## DEBUG ID : file-creation-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::file-creation-functions";

# Overwriting a file

# Featured functions and files from the "functions" folder :
#	- BU::EchoError			-> Main -> Echo.lib
#	- BU::EchoNewstep		-> Main -> Echo.lib
#	- BU::EchoSuccess		-> Main -> Echo.lib
#	- BU::Newline			-> Main -> Echo.lib
function BU::Main::Files::OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_path=$1;
	local p_authorization=$2;

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU::Main::Args__Files::OverwriteFile "$p_path" "$p_authorization" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$p_path" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    if [ "$p_authorization" = "true" ]; then
		BU::EchoNewstep "The $(BU::DechoHighlightPath "$p_path/") file already exists and is not empty.";
		BU::EchoNewstep "Overwriting data from file $(BU::DechoHighlightPath "$p_path/")";
		BU::Newline;

		true > "$p_path";
		BU::Main::Errors::HandleErrors "$?" "THE CONTENT OF THE $(BU::DechoHighlightPath "$p_path/") FILE HAD NOT BEEN OVERWRITTEN" "" "$p_path" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))";
		BU::EchoSuccess "The content of the $(BU::DechoS "$p_path/") file has been successfully overwritten";
		BU::Newline;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# File creation function, with the parent folder's path and the file's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Args__Files::Make                   -> Main -> Args.lib
#   - BU::Main::Checkings::CheckFilePathWasCreated  -> Main -> Checkings.lib
#   - BU::Main::Directories::TriggerRootDirWarning  -> Main -> Directories.lib
#   - BU::Main::Errors::HandleErrors                -> Main -> Errors.lib
#   - BU::Main::Files::OverwriteFile                -> Main -> Files.lib (this file)
#   - BU::Main::Headers::DrawLine                   -> Main -> Headers.lib

#   - BU::DechoHighlightPath            -> Main -> Decho.lib
#   - BU::EchoError                     -> Main -> Echo.lib
#   - BU::EchoNewstep                   -> Main -> Echo.lib
#   - BU::EchoSuccess                   -> Main -> Echo.lib
function BU::Main::Files::Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

	#**** Parameters ****
    local p_parent=$1;  # String    : Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=$2;    # String    : Name of the file to process (into its parent directory).

    shift 2;

    pa_touchVals=("$@");

	#**** Variables ****
	local v_path="$p_parent/$p_name";	# Path of the file to process.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$v_path" 'true' || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

	# Checking if the awaited arguments are given.
    if ! BU::Main::Args__Files::Make "$p_parent" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi;

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$v_path" || return 1;

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$v_path" ]; then
        BU::EchoNewstep "Creating the $(BU::DechoHighlightPath "$p_name") file in the parent folder $(BU::DechoHighlightPath "$p_parent/").";

		touch "$v_path"; BU::Main::Checkings::CheckFilePathWasCreated "$v_path";

		# Testing if the file has been created by checking the return code of the "BU::Main::Checkings::CheckFilePathWasCreated" function via the "BU::Main::Errors::HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU::Main::Errors::HandleErrors "$?" "THE $(BU::DechoHighlightPath "$p_name") FILE CANNOT BE CREATED IN THE $(BU::DechoHighlightPath "$p_parent/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-4 ))";

		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_name") file was successfully created in the $(BU::DechoHighlightPath "$p_parent") folder.";
        BU::Newline;

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$p_path" ] && [ -s "$p_path" ]; then
        if BU::Main::Files::OverwriteFile "$p_path"; then
            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$p_path" ] && [ ! -s "$p_path" ]; then
		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_path/") file already exists in the $(BU::DechoHighlightPath "$p_parent/") folder and is empty.";
		BU::Newline;

		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	fi
}

# File creation function, with the parent folder's path and the file's name as unique argument.
function BU::Main::Files::MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_path=$1;    # String : Full path of the file to create.

    #**** Variables ****
    local v_parent; v_parent="$(echo "$p_path" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the file to create.
    local v_target; v_target="$(echo "$p_path" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the file to create.

    #**** Code ****
	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" 'true';

    if ! BU::Main::Args__Files::MakePath "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    BU::Main::Files::Make "$v_parent" "$v_target" || return 1;

    return 0;
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.
function BU::Main::Files::MakeFileInMemory()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

    #**** Parameters ****
    local p_filename=$1;    # String :name of the file to create in the computer's random access memory.

    #**** Code ****
    echo "$p_filename";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Creating the project's log file.
function BU::Main::Files::CreateProjectLogFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS";

	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_LOG_FILE_PATH" 'true';

    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "$$" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_LOG_FILE_PARENT" "$__BU_MAIN_PROJECT_LOG_FILE_NAME" 'f'; then BU::EchoError "UNABLE TO CREATE THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S LOG FILE"; BU::Exit '1'; fi

    BU::EchoSuccess "Successfully created the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.";

    if [ "${__BU_MAIN_STAT_DECHO,,}" = 'true' ];    then BU::Main::Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; fi
    if [ "${__BU_MAIN_STAT_ECHO,}"  = 'true' ];     then BU::Main::Status::ChangeSTAT_ECHO  "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; fi

    # Redirecting the initializer's log file content into the log file.
    BU::HeaderBlue "INITIALIZATION PROCESS LOG OUTPUT";

    BU::EchoNewstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;
    BU::EchoNewstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU::EchoMsg "$val"; done; BU::Newline;

	if (( "${#__BU_MODULE_INIT_MSG_ARRAY[@]}" >= 1 )); then
		BU::EchoNewstep "Initialization log output :"; BU::Newline;

        for val in "${__BU_MODULE_INIT_MSG_ARRAY[@]}"; do
            BU::CheckProjectLogStatus "$val";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU::HeaderBlue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

    # Getting operating system family.
    BU::EchoNewstep "Operating system family : $(BU::DechoHighlight "$OSTYPE")";
    BU::Newline;

    # Getting operating system's informations (Android's Termux terminal emulator) :
    BU::IsOSAndroidTermux && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (FreeBSD) :
    BU::IsOSFreeBSD && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (Linux platforms or Android without the Termux terminal emulator) :
    BU::IsOSLinux && {
        if [ -f "/etc/os-release" ]; then
            # Getting operating pretty system name.
            BU::EchoNewstep "Operating system pretty name : $(awk -F= '/PRETTY/ {print $2}' '/etc/os-release')";
            BU::Newline;

            # Gathering OS informations from the "/etc/os-release" file.
            BU::EchoNewstep "Operating system general informations :";
            BU::EchoMsg "$(cat '/etc/os-release')" "" "nodate";
            BU::Newline;
        else
            BU::EchoWarning "No available informations ($(BU::DechoHighlight '/etc/os-release') file not found)";
            BU::Newline;
        fi

        # Getting operating system extra informations (Windows Subsystem for Linux, etc...).
        BU::EchoNewstep "Operating system extra informations :";
        if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU::EchoMsg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
        BU::Newline;
    }

    # Getting operating system's informations (Haiku OS) :
    BU::IsOSHaiku && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : Haiku OS";
        BU::Newline;

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (OpenBSD) :
    BU::IsOSOpenBSD && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (NetBSD) :
    BU::IsOSNetBSD && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

    # Getting operating system's informations (Mac OS) :
    BU::IsOSx && {
        # Getting operating system pretty name.
        BU::EchoNewstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU::EchoNewstep "Operating system general informations :";
    }

	# Getting Bash language's version.
    BU::EchoNewstep "Bash version : $(BU::DechoHighlight "$BASH_VERSION")";
    BU::Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU::EchoNewstep "Terminal (emulator) version : $(BU::DechoHighlight "$v_terminfo_v")" || BU::EchoWarning "$(BU::DechoHighlight '$v_terminfo_v') : bad command call.";
    BU::Newline;

    BU::EchoSuccess "Successfully got the user's system's informations.";

    # Purging the "$__BU_MODULE_INIT_MSG_ARRAY" variable from the logged messages, after writing its content in the project's log file, in order to free memory.
    __BU_MODULE_INIT_MSG_ARRAY='';

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## GETTING FILE INFORMATIONS
## DEBUG ID : getting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::getting-file-informations";

# Getting the size of a file in bytes.
function BU::Main::Files::GetByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;    # Path to the file to process.
    local p_base=$2;        # Byte measure unit base (binary prefix (eg : MiB) or metric prefix (eg : MB)).

    #**** Code ****

    if [ -z "$p_base" ]; then
        wc --bytes < "$p_filepath" || \
            { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1; };

    # Else, if a value is passed to the "base" parameter AND this value is an integer.
    elif [ -n "$p_base" ] && BU::IsInt "$b_base"; then

        # Convert the size from plain number to human readable metric prefix.
        if [ "$p_base" -ne 1024 ]; then
            BU::Main::BasicMaths::BytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1; };

        # Convert the size from plain number to human readable binary prefix.
        else
            BU::Main::BasicMaths::BytesToHuman "$(wc --bytes < "$p_filepath")" "$p_base" || \
                { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1; };
        fi
    else
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : The byte measure unit byte $(BU::DechoHighlight "$p_base") is not an integer"; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the file's creation date.

# Please note, some file systems don't store the file's creation date. In this case, the "stat" command will return '0'.
function BU::Main::Files::GetCreationDate()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    if ! stat -c %W "$p_filepath"; then
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the $(BU::DechoHighlightPath "$p_filepath") file's creation date"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED";

    elif [ "$(stat -c %W "$p_filepath")" -eq 0 ]; then
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : This filesystem ($(BU::DechoHighlight "$__BU_MAIN_FS_NAME")) does not stores the files creation dates"; BU::Newline; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED";
    fi

	## TODO

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU::Main::Files::GetCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --chars < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of characters in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's access date.
function BU::Main::Files::GetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
     "$p_filename" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last access date from the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's modification date.
function BU::Main::Files::GetLastModification()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    date -r "$p_filename" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the last modification date from the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    return 0;
}

# Getting the total number of lines in a file.
function BU::Main::Files::GetLinesNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --lines < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of lines in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the max line length in a file.
function BU::Main::Files::GetMaxLineLength()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****last access date
    wc --max-line-length < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the max line length in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the owner of a file.
function BU::Main::Files::GetOwnerName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    stat -c "%U" "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the name of the owner of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the group of the owner of a file.
function BU::Main::Files::GetOwnerGroup()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    stat -c "%G" "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the group of the owner of the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU::Main::Files::GetWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;

    #**** Code ****
    wc --words < "$p_filepath" || { BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") : Unable to get the total number of words in the $(BU::DechoHighlightPath "$p_filepath") file"; BU::EchoWarning "Please check the permissions of this file"; BU::Newline; BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$__BU_MAIN_EXIT_NOT_PERMITTED"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## SETTING FILE INFORMATIONS
## DEBUG ID : setting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::setting-file-informations";

# Setting a fake last access date to a file.
function BU::Main::File::SetFileLastAccess
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS";

    #**** Parameters ****
    local p_filepath=$1;
    local p_fakedate=$2;

    #**** Code ****
    if ! BU::Main::Args__Files::SetFileLastAccess "$p_filepath" "$p_fakedate" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE SOURCING
## DEBUG ID : file-sourcing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::file-sourcing";

# Sourcing dependencies files.
function BU::Main::Files::SourceFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING";

    #**** Parameters ****
    local p_path=$1;

    #**** Code ****
    if [ -f "$p_path" ]; then
		BU::EchoNewstep "Sourcing the $(BU::DechoHighlightPath "$p_path") file";
		BU::Newline

        # shellcheck disable=SC1090
        if source "$p_path"; then
            BU::EchoSuccess "Sourced file : $(BU::DechoHighlightPath "$p_path")";
			BU::Newline;

			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            local C="$?";

            BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_NOT_PERMITTED" "UNABLE TO SOURCE THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please verify that the file's path passed as argument exists, and that you have read rights on this file." "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))";

			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
        fi
    else
        local C="$?";

        BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_NOT_PERMITTED" "UNABLE TO FIND THIS FILE : $(BU::DechoHighlightPath "$p_path")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-8 ))";

		return "$C";
    fi
}

# -----------------------------------------------

## TEXT FILE PARSING
## DEBUG ID : text-file-parsing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS::text-file-parsing";

# Getting a specific line from a text file.
function BU::Main::Files::GetLineFromTextFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING";

    #**** Parameters ****
    local p_source=$1;          # File to parse
    local p_wanted_line=$2;     # Line to get in the file

    #**** Variables ****
    local i=0;                  # Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
    cat "$p_source" | while read -r line; do

        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ));

        # ... until it reaches the wanted line.
        if [ "$i" -eq "$p_wanted_line" ]; then

			# shellcheck disable=SC2034
            __BU_MAIN_TXT_STORE_LINE="$line";
        fi
    done

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS
#### DEBUG ID : files::archive-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS="files::archive-processing-functions";

## (UN)COMPRESSION FUNCTIONS
## DEBUG ID : (un)compression-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS="$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS::(un)compression-functions";

#

# Featured functions and files from the "functions" folder :
#   -
function BU::Main::Files::Compress()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

    #**** Parameters ****
#     local cmd=$1      # Compression command.
#     local opts=$2     # Options of the compression command.
#     local p_path=$3     # Path to the file/folder to archivate.
#     local p_name=$4     # Archive's name (only used into displayed messages).

    #**** Code ****


    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Errors::HandleErrors      -> Handles.lib
#   - BU::EchoSuccess       -> Echo.lib
#   - BU::Newline           -> Echo.lib
function BU::Main::Files::Uncompress()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS" \
        "$__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS";

#     #***** Paramètres *****
#     local p_cmd=$1      # Compression command.
#     # TODO : Vérifier si cette procédure est bonne
#     local p_opts=$2     # Options of the compression command. (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
#     local p_path=$3     # Path to the l'archive to uncompress.
#     local p_name=$4     # Archive's name (only used into displayed messages).
#
#     #**** Code ****
#     # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
#     "$cmd $opts $p_path"
#     BU::Main::Errors::HandleErrors "$?" "${FUNCNAME[0]} : LA DÉCOMPRESSION DE L'ARCHIVE $(BU::DechoHighlightPath "$p_name") A ÉCHOUÉE"
#     BU::EchoSuccess "La décompression de l'archive $(BU::DechoHighlightPath "$p_name") s'est effectuée avec brio."
#     BU::Newline;

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT FILES PROCESSING FUNCTIONS

# This function only repeats some parts of the following function.
function __ProcessingFile()
{
    #***** Parameters *****
    p_output=$1
    p_name=$2
    p_char=$3

    #***** Code *****
    if [ "$p_output" = 'E' ]; then
        EchoError "End of processing the $(DechoHighlight "$p_name") file"
        EchoMsg "$(DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate'
        Newline
            
        sleep "$__BU_MAIN_STAT_TIME_TXT"

    elif [ "$p_output" = 'S' ]; then
        EchoSuccess "End of processing the $(DechoS "$p_name") file"
        EchoMsg "$(DrawLine "$__COL_RESET" "$p_char")" '-n' 'nodate'
        Newline
        
        sleep "$__BU_MAIN_STAT_TIME_TXT"
    else
        EchoWarning ""
    fi
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - DrawLine      -> Headers.lib
#   - HandleErrors  -> Headers.lib
function ProcessingFile()
{
    #***** Parameters *****
    local p_function=$1; shift
    local p_name=$2
    local arr; arr=$("$@")
    
    #***** Variables *****
    local v_char="'"
    
    #***** Code *****
    # Arguments checking.
    CheckArgs_ProcessingFile "$p_function"
    
	sleep "$__BU_MAIN_STAT_TIME_TXT"
    EchoMsg "$(DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate'
    EchoNewstep "Processing the $(DechoHighlight "$p_name") file in the $(DechoHighlight "$p_parent") parent directory."
    Newline
    
    case "$p_function" in
        'Makefile')
            if Makefile "${arr[@]}"; then
                __ProcessingFile 'S' "$p_name" "$p_char"
            else
                __ProcessingFile 'E' "$p_name" "$p_char"
            fi
            ;;
        'OverwriteFile')
            if OverwriteFile "$arr"; then
                __ProcessingFile 'S' "$p_name" "$p_char"
            else
                __ProcessingFile 'E' "$p_name" "$p_char"
            fi
            ;;
    esac
}

## OVERWRITING CONTENT

# Overwrite a file

# Featured functions and files from the "functions" folder :
#	- EchoError			-> Echo.lib
#	- EchoNewstep		-> Echo.lib
#	- EchoSuccess		-> Echo.lib
#	- Newline			-> Echo.lib
function OverwriteFile()
{
    #***** Parameters *****
    local p_path=$1
	local p_authorization=$2
    
    #***** Code *****
    # Checking first if the awaited arguments are given
    CheckArgs_OverwriteFile

    # Checking second if the script is operating at the root directory.
    TriggerRootDirWarning "$p_path"

    if [ "$p_authorization" = "true" ]; then
		EchoNewstep "The $(DechoHighlight "$p_path/") file already exists and is not empty."
		EchoNewstep "Overwriting data from file $(DechoHighlight "$p_path/")"
		Newline

		true > "$p_path"
		HandleErrors "$?" "THE CONTENT OF THE $(KeepFormatting "$(DechoHighlight "$p_path/")") FILE HAD NOT BEEN OVERWRITTEN" "" "$p_path" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))"
		EchoSuccess "The content of the $(DechoS "$p_path/") file has been successfully overwritten"
		Newline
	else
		return
	fi

	return 0
}

# -----------------------------------------------

## FILE CREATION

# File creation function.
# LORS DE SON APPEL, LA SORTIE DE CETTE FONCTION DOIT ÊTRE REDIRIGÉE SOIT VERS LE TERMINAL ET LE FICHIER DE LOGS, SOIT VERS LE FICHIER DE LOGS UNIQUEMENT.

# Featured functions and files from the "functions" folder :
#   - DrawLine          -> Headers.lib
#   - EchoError         -> Echo.lib
#   - EchoNewstep       -> Echo.lib
#   - EchoSuccess       -> Echo.lib
#   - HandleErrors      -> Handles.lib
function Makefile()
{
	#***** Parameters *****
	local p_parent=$1      # Emplacement of the currently processed file's parent folder from the root directory.
	local p_name=$2        # Name of the file to process (into its parent directory).

	#***** Variables *****
	local v_path="$p_parent/$p_name"	# Path of the file to process.

	#***** Code *****
	# Checking first if the awaited arguments are given
    CheckArgs_Makefile "$p_parent" "$p_name"

    # Checking second if the script is operating at the root directory.
    TriggerRootDirWarning "$v_path"

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$v_path" ]; then
        EchoNewstep "Creating the $(DechoHighlight "$p_name") file in the parent folder $(DechoHighlight "$p_parent/")."

		touch "$v_path"; CheckFilePathWasCreated "$v_path"

		# Testing if the file has been created by checking the return code of the "CheckFilePathWasCreated" function via the "HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		HandleErrors "$?" "THE $(KeepFormatting "$(DechoHighlight "$p_name")") FILE CANNOT BE CREATED IN THE $(KeepFormatting "$(DechoHighlight "$p_parent/")") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-4 ))"

		EchoSuccess "The $(DechoS "$p_name") file was successfully created in the $(DechoS "$p_parent") folder."
        Newline

        return 0

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$p_path" ] && [ -s "$p_path" ]; then
        if OverwriteFile "$p_path"; then
            return 0
        else
            return 1
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$p_path" ] && [ ! -s "$p_path" ]; then
		EchoSuccess "The $(DechoS "$p_path/") file already exists in the $(DechoS "$p_parent/") folder and is empty."
		Newline

		return 0
	fi
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive (safer for SSD drives and no permissions are needed).
function CreateFileInMemory()
{
    #***** Parameters *****
    p_filename=$1

    #***** Code *****
    
    return 0
}

# Creating the project's log file.
function CreateProjectLogFile()
{
    #***** Variables *****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "$$" -o ppid=)" o args=) -v)"

    #***** Code *****
    if ! CheckProjectRelatedFile "$__BU_MAIN_PROJECT_LOG_FILE_PARENT" "$__BU_MAIN_PROJECT_LOG_FILE_NAME" 'f'; then EchoError "UNABLE TO CREATE THE $(DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S LOG FILE"; ExitError '1'; fi

    EchoSuccess "Successfully created the $(DechoHighlight "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file."

    ChangeSTAT_TXT_FMT 'true' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$__BU_MAIN_STAT_DECHO" = 'true' ]; then	ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi
    if [ "$__BU_MAIN_STAT_ECHO"  = 'true' ]; then	ChangeSTAT_ECHO  "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";	fi

    # Redirecting the initializer's log file content into the log file.
    HeaderBlue "INITIALIZATION PROCESS LOG OUTPUT"

    EchoNewstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do EchoMsg "$val"; done; Newline
    EchoNewstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do EchoMsg "$val"; done; Newline

	if (( "${#__BU_MAIN_MODULE_STR_ARRAY_LOG_DATE[@]}" >= 1 )); then
		EchoNewstep "Initialization log output :"; Newline

        for val in "${__BU_MAIN_MODULE_STR_ARRAY_LOG_DATE[@]}"; do
            CheckProjectLogStatus "$(CutDateFromString "$val")"
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    HeaderBlue "GETTING INFORMATIONS ABOUT USER'S SYSTEM"

	# Getting operating system name.
	EchoNewstep "Operating system name : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"
	Newline

    # Getting operating system family.
    EchoNewstep "Operating system family : $(DechoHighlight "$OSTYPE")"
    Newline

    # Gathering OS informations from the "/etc/os-release" file.
    EchoNewstep "Operating system general informations :"
    if [ -f "/etc/os-release" ]; then EchoMsg "$(cat "/etc/os-release")" "" "nodate"; else EchoMsg 'No available informations ("/etc/os-release" file not found)'; fi
    Newline

	# Getting operating system extra informations (Windows Subsystem for Linux, etc...).
	EchoNewstep "Operating system extra informations :"
	if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then EchoMsg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
	Newline

	# Getting Bash language's version.
    EchoNewstep "Bash version : $(DechoHighlight "$BASH_VERSION")"
    Newline

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    EchoNewstep "Terminal (emulator) version : $(DechoHighlight "$v_terminfo_v")" || EchoWarning "$(DechoHighlight '$v_terminfo_v') : bad command call."
    Newline

    EchoSuccess "Successfully got the user's system's informations."
}

# -----------------------------------------------

## FILE SOURCING

# Sourcing dependencies files.
function SourceFile()
{
    #***** Parameters *****
    local p_path=$1

    #***** Code *****
    if [ -f "$p_path" ]; then
        # shellcheck disable=SC1090
        if source "$p_path"; then
            EchoSuccess "Sourced file : $(DechoHighlight "$p_path")"
        else
            HandleErrors "1" "UNABLE TO SOURCE THIS FILE ! $(KeepFormatting "$(DechoHighlight "$p_path")")" "Please verify that the filepath passed as argument exists." "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-5 ))"
        fi
    else
        HandleErrors "1" "UNABLE TO FIND THIS FILE : $(KeepFormatting "$(DechoHighlight "$p_path")")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-8 ))"
    fi
}

# -----------------------------------------------

## TEXT FILES PARSING

# Getting a specific line from a text file.
function GetLineFromTextFile()
{
    #***** Parameters *****
    local p_source=$1           # File to parse
    local p_wanted_line=$2      # Line to get in the file
    
    #***** Variables *****
    local i=0                   # Line incrementer
    
    #***** Code *****
	# shellcheck disable=SC2002
    cat "$p_source" | while read -r line; do
        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ))

        # ... until it reaches the wanted line.
        if [ "$i" -eq "$p_wanted_line" ]; then
			# shellcheck disable=SC2034
            __BU_MAIN_TXT_STORE_LINE="$line"
        fi
    done
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS

## (UN)COMPRESSION FUNCTIONS

# 

# Featured functions and files from the "functions" folder :
#   - 
function Compress()
{
    #***** Parameters *****
#     local cmd=$1      # Compression command.
#     local opts=$2     # Options of the compression command.
#     local p_path=$3     # Path to the file/folder to archivate.
#     local p_name=$4     # Archive's name (only used into displayed messages).
    
    #***** Code *****
    
    
    return 0
}

# Uncompressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   - HandleErrors      -> Handles.lib
#   - EchoSuccess       -> Echo.lib
#   - Newline           -> Echo.lib
function Uncompress()
{
#     #***** Paramètres *****
#     local p_cmd=$1      # Compression command.
#     # TODO : Vérifier si cette procédure est bonne
#     local p_opts=$2     # Options of the compression command. (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
#     local p_path=$3     # Path to the l'archive to uncompress.
#     local p_name=$4     # Archive's name (only used into displayed messages).
# 
#     #***** Code *****
#     # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
#     "$cmd $opts $p_path"
#     HandleErrors "$?" "${FUNCNAME[0]} : LA DÉCOMPRESSION DE L'ARCHIVE $(DechoHighlight "$p_name") A ÉCHOUÉE"
#     EchoSuccess "La décompression de l'archive $(DechoHighlight "$p_name") s'est effectuée avec brio."
#     Newline
    
    return 0
}

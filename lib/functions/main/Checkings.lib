#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Checkings.lib
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# DO NOT EXECUTE IT DIRECTLY, instead, just source it by calling the "__BASH_UTILS_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### VARIABLES VALUES CHECKING

## NUMBER VALUES

# Checking floating value.
function IsFloat()
{
    if [[ "$1" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking floating and integer value.
function IsFloatInt()
{
    if [[ "$1" =~ ^([0-9]+\.?|[0-9]*\.[0-9]+)$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking integer value.
function IsInt()
{
    if [[ "$1" =~ [0-9] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking integer value.
function IsInt2()
{
    if [[ "$1" =~ ^[+-]?[0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------

## STRING VALUES

# Checking if value is an alphabetic string (not any number allowed)
function IsAlpha()
{
    if [[ "$1" =~ [A-Z] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking if value is an aplhanumeric string.
function IsAlphaNum()
{
    if [[ "$1" =~ [^a-zA-Z0-9\ ] ]]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS

## CHECKING FOR IDENTIFIANTS

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - HandleErrors      --> From this file.
function CheckRootEUID()
{
    if [ "$EUID" -ne 0 ]; then
        HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))"

        return 1
    fi
}

# -----------------------------------------------

## INITIALIZATION CHECKINGS

# Checking if the library is into its initialization process.
function CheckIsInitializing()
{
    if [ "$__INIT_IS_INITIALIZING" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## DIRECTORIES PATHS CHECKING

# Checking for an existent directory path (for the "HandleErrors()" function mainly).
function CheckDirPathExists()
{
    #***** Parameters *****
    p_path=$1               # Path of the (in)existent directory.

    #***** Code *****
    if [ ! -f "$p_path" ]; then
        DechoHighlight "<missing directory path>"   # Since this function should be called into a string, it's better to use a formatting function.
    fi
}

# -----------------------------------------------

## FILES PATHS CHECKING

# Checking for an existent file path (for the "HandleErrors()" function mainly).
function CheckFilePathExists()
{
    #***** Parameters *****
    p_path=$1               # Path of the (in)existent file.

    #***** Code *****
    if [ ! -f "$p_path" ]; then
        DechoHighlight "<missing file path>"        # Since this function should be called into a string, it's better to use a formatting function.
    fi
}

# Checking for "$__BU_PROJECT_LOG_FILE_PATH"

# Required functions and files :
function CheckProjectLogPath()
{
    if [ -z "$__BU_PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__BU_COLOR_ERROR}IN $(DechoHighlight "$(basename "${BASH_SOURCE[0]}")"), function $(DechoHighlight "${FUNCNAME[0]}"), LINE $(DechoHighlight "$(( LINENO-1 ))") --> ${__BU_COLOR_RESET}" >&2
        echo -e "${__BU_COLOR_ERROR}FATAL ERROR : NO PATH PROVIDED INTO THE $(DechoHighlight "__BU_PROJECT_LOG_FILE_PATH") VARIABLE${__BU_COLOR_RESET}" >&2
        echo -e "${__BU_COLOR_ERROR}Please add the path as argument.${__BU_COLOR_RESET}" >&2; echo >&2
        ExitError

    elif [ ! -f "$__BU_PROJECT_LOG_FILE_PATH" ]; then
        echo -ne "${__BU_COLOR_ERROR}IN $(DechoHighlight "$(basename "${BASH_SOURCE[0]}")"), FUNCTION $(DechoHighlight "${FUNCNAME[0]}"), LINE $(DechoHighlight "$(( LINENO-1 ))") --> ${__BU_COLOR_RESET}" >&2
        echo -e "${__BU_COLOR_ERROR}FATAL ERROR : BAD PATH PROVIDED INTO THE $(DechoHighlight "__BU_PROJECT_LOG_FILE_PATH") VARIABLE${__BU_COLOR_RESET}" >&2
        echo -e "${__BU_COLOR_ERROR}Please correct the path passed as argument.${__BU_COLOR_RESET}" >&2; echo >&2
        ExitError

    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : "nodate", '<an empty string>'
function CheckProjectLogStatus()
{
    #***** Parameters *****
    local p_string=$1       # String to display.
    local p_option=$2       # "echo" command options.
    shift 2

    local pa_extraArgs=("$@")    # More processing arguments (like the processing of a whole line-long string).

    #***** Variables *****
	# WARNING : DO NOT call any "Echo<...>()" function from the "main/Echo.lib" file, as they all call the "CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same ""CheckProjectLogStatus() function.

    # If you need to call a function here, please verify if it doesn't calls the "CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "$__BU_STAT_CPLS" status CheckTxtFmt value to "true" BEFORE calling the wanted function.

    local v_redirectionError
		v_redirectionError="${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_ERROR} --> Error : unable to write into the ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_LOG_FILE_PATH${__BU_COLOR_ERROR} file.${__BU_COLOR_RESET}\n${__BU_COLOR_ERROR}Redirection option :${__BU_COLOR_RESET}"

	local v_warning_array_value
		v_warning_array_value="${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_WARNING} --> Warning : incorrect argument given as extra argument array in ${__BU_COLOR_HIGHLIGHT}${BASH_SOURCE[0]}${__BU_COLOR_WARNING}, function ${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}${__BU_COLOR_WARNING} --> $val${__BU_COLOR_RESET}"
    
    #**** Code *****
    if [ "$__BU_STAT_LOG" = "true" ]; then
        CheckProjectLogPath
    fi

    # Setting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to "true", in case an error occurs during a function call, where the "CheckProjectLogStatus()" function or any other function that calls it might be called.
    ChangeSTAT_CPLS "true"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    CheckSTAT_LOG           "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_LOG_REDIRECT  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_TIME_TXT      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    # If a log file exists AND if "$__BU_STAT_LOG" value is "false" AND if "$__BU_STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__BU_PROJECT_LOG_FILE_PATH" ] && [ "$__BU_STAT_LOG" = "true" ]; then

        # If messages must be redirected in the log file only ("$__BU_STAT_LOG_REDIRECT" value is equal to "log").
        if [ "$__BU_STAT_LOG_REDIRECT" = "log" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the "nodate" value is passed as argument.
                if [ "$val" = "nodate" ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$p_string")
                            else
                                echo -ne "$p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }                            
                            fi
                            ;;
                        '' | *)
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$p_string")
                            else
                                echo -e "$p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }                            
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ "$val" = '' ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                            else
                                echo -ne "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
                            fi
                            ;;
                        '' | *)
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                            else
                                echo -e "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
                            fi
                            ;;
                    esac
                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "log" option)).
                else
                    case "$p_option" in
                        '-n' | 'n')
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							else
                                echo -ne "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							fi
                            ;;
                        '' | *)
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							else
                                echo -e "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError log" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							fi
                            ;;
                    esac
                fi

            done

			# Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to false, since the "CheckProjectLogStatus()" function's execution is over.
			ChangeSTAT_CPLS "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
			return 0

        # Else, if messages must be redirected in the log file AND to the terminal ("$__BU_STAT_LOG_REDIRECT" value is equal to "tee")
        elif [ "$__BU_STAT_LOG_REDIRECT" = "tee" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the "nodate" value is passed as argument.
                if [ "$val" = "nodate" ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$p_string")
                            else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                            fi
                            ;;
                        '' | *)
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$p_string")
                            else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ "$val" = '' ]; then
                    case "$p_option" in
                    '-n' | 'n')
                        if CheckIsInitializing; then
                            __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                        else
                            echo -ne "$p_string"
                            echo -ne "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                        fi
                        ;;
                    '' | *)
                        if CheckIsInitializing; then
                            __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                        else
                            echo -e "$p_string"
                            echo -e "$__BU_TIME_DATE_DISPLAY $p_string" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                        fi
                        ;;
                    esac

                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "tee" option)).
                else
                    case "$p_option" in
                        '-n' | 'n')
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							fi
                            ;;
                        '' | *)
                            if CheckIsInitializing; then
                                __INIT_STR_ARRAY+=("$__BU_TIME_DATE_DISPLAY $p_string")
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
                                CheckProjectLogStatus "$v_warning_array_value" '-n' '' 2>&1 | tee -a "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; echo -e "$v_redirectionError tee" >&2; echo >&2; ExitError "1"; }
								CheckProjectLogStatus
							fi
                            ;;
                    esac
                fi
            done
            
            sleep "$__BU_STAT_TIME_TXT"
			
			# Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to false, since the "CheckProjectLogStatus()" function's execution is over.
			ChangeSTAT_CPLS "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
			return 0
        else
            case "$p_option" in
                '-n' | 'n')
                    if CheckIsInitializing; then
                        __INIT_STR_ARRAY+=("$p_string")
                    else
                        echo -ne "$p_string"
                    fi
                    ;;
                '' | *)
                    if CheckIsInitializing; then
                        __INIT_STR_ARRAY+=("$p_string")
                    else
                        echo -e "$p_string"
                    fi
                    ;;
            esac

        sleep "$__BU_STAT_TIME_TXT"

		# Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to false, since the "CheckProjectLogStatus()" function's execution is over.
		ChangeSTAT_CPLS "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
		return 0

        fi

    # Else, if no log file exists OR if "$__BU_STAT_LOG" value is "false" OR if "$__BU_STAT_LOG_REDIRECT" has no redirection value. 
    else
        case "$p_option" in
			'-n' | 'n')
				echo -ne "$p_string"
				;;
			'' | *)
				echo -e "$p_string"
				;;
		esac

        sleep "$__BU_STAT_TIME_TXT"
		
		# Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to false, since the "CheckProjectLogStatus()" function's execution is over.
		ChangeSTAT_CPLS "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
		return 0
	fi

	# Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt's value to false, since the "CheckProjectLogStatus()" function's execution is over.
	ChangeSTAT_CPLS "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	return 0
}

# Check project related file presence, or create this file.
function CheckProjectRelatedFile()
{
	#***** Parameters *****
	local p_parent=$1   # Name of the folder to process (into its parent directory).
	local p_child=$2  	# Name of the file or folder to process (into its parent directory).
	local p_type=$3		# Type of data to create (d = directory, f = file).

	#***** Variables *****
    local v_path="$p_parent/$p_child"

	#***** Code *****
	if ! CheckArgsMain_CheckProjectRelatedFile "$p_parent" "$p_child" "$p_type"; then return 1; fi

	if [ "$p_type" = 'f' ]; then
		if [ -f "$v_path" ]; then
			if [ -s "$v_path" ]; then
				true > "$v_path" || { echo >&2; echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_ERROR} --> Error : unable to overwrite this ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_NAME${__BU_COLOR_ERROR} project's file --> ${__BU_COLOR_HIGHLIGHT}$(CheckFilePathExists "$v_path")${__BU_COLOR_RESET}" >&2; echo >&2; ExitError "1"; }
			fi

			return 0
		else
			if [ ! -d "$p_parent" ]; then
				mkdir -p "$p_parent" || { echo >&2; echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_ERROR} --> Error : unable to create this ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_NAME${__BU_COLOR_ERROR} project's file's parent folder --> ${__BU_COLOR_HIGHLIGHT}$(CheckDirPathExists "$p_parent")${__BU_COLOR_RESET}" >&2; echo >&2; ExitError "1"; }
			fi

			touch "$v_path" || { echo >&2; echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_ERROR} --> Error : unable to create this ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_NAME${__BU_COLOR_ERROR} project's file --> ${__BU_COLOR_HIGHLIGHT}$(CheckFilePathExists "$v_path")${__BU_COLOR_RESET}" >&2; echo >&2; ExitError "1"; }

			return 0
		fi

    elif [ "$p_type" = 'd' ]; then
		if [ -d "$v_path" ]; then
			return 0
		else
			mkdir -p "$v_path" || { echo >&2; echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_ERROR} --> Error : unable to create this ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_NAME${__BU_COLOR_ERROR} project's folder --> ${__BU_COLOR_HIGHLIGHT}$(CheckDirPathExists "$v_path")${__BU_COLOR_RESET}" >&2; echo >&2; ExitError "1"; }

			return 0
		fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS

## FORMATTING CHECKINGS

# Checking if the project's color code file exists or not.
function CheckDecho()
{
    #***** Code *****
    if [ "$__BU_STAT_TXT_FMT" = "false" ]; then
        return 1
	fi
	
    if [ -f "$__BU_PROJECT_COLOR_CODE_FILE_PATH" ] && [ "$(cat "$__BU_PROJECT_COLOR_CODE_FILE_PATH")" = '' ]; then
        echo "$__BU_COLOR_RESET" > "$__BU_PROJECT_COLOR_CODE_FILE_PATH" || { echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_COLOR_WARNING} --> Warning : Unable to write any color code into the ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_COLOR_CODE_FILE_PATH${__BU_COLOR_WARNING} file.${__BU_COLOR_RESET}"; return 1; }

        return 0
    else
        return 0
	fi
}

# Check if the "$__STAT_CPLS" and / or "$__BU_STAT_ECHO" status values are set to "true".
function CheckEcho()
{
    if [ "$__BU_STAT_CPLS" = "true" ] || [ "$__BU_STAT_ECHO" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# Checking if the "$__BU_STAT_TXT_FMT" status value is set to "true".
function CheckTextFormat()
{
    #***** Parameters *****
    #   $1  -> "tput" command's text formatting option.
    #   $2  -> Corresponding ANSI escape sequence (useful if the "tput" command is not detected or unavailable).

    #***** Code *****
    if [ "$__BU_STAT_TXT_FMT" = "true" ]; then
        if [ -n "$1" ]; then
			if command -v "tput" &> /dev/null; then
				# Formatting text with the tput command or directly with the backslash escapes.
				tput "$1" || echo -ne "\e[$2m"

				return 0
			else
				echo -ne "\e[$2m"; return 0
			fi

        # In case there's no value passed as first argument (like if the wanted tput option is unknown), the script only echoes its ANSI escape sequence.
        else
            echo -ne "\e[$2m"

            return 0
        fi

    else
        return 1
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS

## EXIT HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function ExitError()
{
    if [[ "$1" =~ [0-9] ]]; then
        exit "$1"; kill "$$"
    else
        echo "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}()$__BU_COLOR_WARNING --> Warning : unexpected exit code passed as argument.${__BU_COLOR_RESET}"

        return 1
    fi
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   - 
function HandleErrors()
{
	#***** Paramètres *****
	local p_returnCode=$1      # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2     # Chaîne de caractères du type d'erreur à afficher.
	local p_adviceString=$3    # Chaîne de caractères affichants un conseil pour orienter l'utilisateur vers la meilleure solution en cas de problème.
    local p_badValue=$4        # Incorrect value which caused the error.
	local p_file=$5            # The name of the file where the error occured.
	local p_function=$6        # The name of the function where the error occured.
	local p_lineno=$7          # Ligne à laquelle le message d'erreur s'est produite.

    #***** Variables *****
    local v_hdrString
    local va_hdrString

	if [ -n "$p_file" ]; then
        va_hdrString+=("$(DechoHighlight "$p_file"), ")
	fi
	
	if [ -n "$p_function" ]; then
        va_hdrString+=("FUNCTION $(DechoHighlight "$p_function"), ")
	fi
	
	if [ -n "$p_lineno" ]; then
        va_hdrString+=("LINE $(DechoHighlight "$p_lineno" )")
	fi

	# TODO : print every values of the va_hdrString array.
	v_hdrString="$(echo -ne "IN ${va_hdrString[0]}${va_hdrString[1]}${va_hdrString[2]}-->")"

	# ***** Code *****
	CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$p_returnCode" -eq 0 ]; then
        return
    else
        # If the function needs to be called in the "CheckProjectLogStatus()" function,
        # this status CheckTxtFmt's value MUST be set at "true", or else the script will loop forever.

        # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

        if [ "$__BU_STAT_CPLS" = "true" ]; then
            __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(DrawLine "$__BU_TXT_PRINT_HEADER_LINE" "$__BU_COLOR_ERROR")")
            if [ -n "$__BU_STAT_ERROR" ] && [ "$__BU_STAT_ERROR" = "fatal" ]; then
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "${__BU_COLOR_HIGHLIGHT}A FATAL ERROR OCCURED DURING A TEST IN THE  'CheckProjectLogStatus'  FUNCTION !${__BU_COLOR_RESET}" >&2)")
            else
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "${__BU_COLOR_HIGHLIGHT}AN ERROR OCCURED DURING A TEST IN THE  'CheckProjectLogStatus'  FUNCTION !${__BU_COLOR_RESET}" >&2)")
            fi

            if [ -n "$__BU_STAT_ERROR" ] && [ "$__BU_STAT_ERROR" = "fatal" ]; then
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(DrawLine "$__BU_TXT_PRINT_HEADER_LINE" "$__BU_COLOR_ERROR" >&2)")
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}$v_hdrString FATAL ERROR : ${p_errorString^^}${__BU_COLOR_RESET}" >&2)")
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(DrawLine "$__BU_TXT_PRINT_HEADER_LINE" "$__BU_COLOR_ERROR" >&2)")
            else
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(DrawLine "$__BU_TXT_PRINT_HEADER_LINE" "$__BU_COLOR_ERROR" >&2)")
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}$v_hdrString ERROR : ${p_errorString^^}${__BU_COLOR_RESET}" >&2)")
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(DrawLine "$__BU_TXT_PRINT_HEADER_LINE" "$__BU_COLOR_ERROR" >&2)")
            fi

            if [ -z "$p_adviceString" ]; then
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}No advice to give.${__BU_COLOR_RESET}" >&2; echo >&2)")
            else
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}Advice : ${__BU_COLOR_HIGHLIGHT}$p_adviceString${__BU_COLOR_RESET}" >&2; echo >&2)")
            fi

            if [ -z "$p_badValue" ]; then
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}Value(s) that caused this error : $(DechoOrange 'no value') OR $(DechoOrange 'an unknown error')$__BU_COLOR_RESET" >&2; echo -e >&2)")
            else
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "$__BU_TIME_DATE_DISPLAY ${__BU_COLOR_ERROR}Value(s) that caused this error : $(DechoHighlight "$p_badValue")$__BU_COLOR_RESET" >&2; echo -e >&2)")
            fi

            if [ "$__BU_STAT_ERROR" = "fatal" ]; then
                __BU_TXT_STORE_ERROR_MESSAGES_ARRAY+=("$(echo -e "${__BU_COLOR_ERROR}Stopping the execution of $(DechoHighlight "$(basename "$0")")$__BU_COLOR_RESET." >&2; echo -e >&2)")

                # Displaying the content of the "$__BU_TXT_STORE_ERROR_MESSAGES_ARRAY" array.
                for val in "${__BU_TXT_STORE_ERROR_MESSAGES_ARRAY[@]}"; do
                    if [ "$__BU_STAT_LOG" = "true" ] && [ -f "$__BU_PROJECT_LOG_FILE_PATH" ]; then
                        if [ "$__BU_STAT_LOG_REDIRECT" = "log" ] || [ "$__BU_STAT_LOG_REDIRECT" = "tee" ]; then
                            CutDateFromString "$val"

                            echo -e "$val" > "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}() : ${__BU_COLOR_ERROR}Unable to write into the ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_LOG_FILE_PATH${__BU_COLOR_ERROR} file.${__BU_COLOR_RESET}" >&2; echo >&2; exit 1; kill "$$"; }

                        elif [ "$__BU_STAT_LOG_REDIRECT" = "" ]; then
                            CutDateFromString "$val"
                        fi
                    else
                        CutDateFromString "$val"
                    fi
                done

                exit 1; kill "$$"
            else

                # Displaying the content of the "$__BU_TXT_STORE_ERROR_MESSAGES_ARRAY" array.
                for val in "${__BU_TXT_STORE_ERROR_MESSAGES_ARRAY[@]}"; do
                    if [ "$__BU_STAT_LOG" = "true" ] && [ -f "$__BU_PROJECT_LOG_FILE_PATH" ]; then
                        if [ "$__BU_STAT_LOG_REDIRECT" = "log" ] || [ "$__BU_STAT_LOG_REDIRECT" = "tee" ]; then
                            CutDateFromString "$val"

                            echo -e "$val" >> "$__BU_PROJECT_LOG_FILE_PATH" || { echo >&2; "${__BU_COLOR_HIGHLIGHT}${FUNCNAME[0]}() : ${__BU_COLOR_ERROR}Unable to write into the ${__BU_COLOR_HIGHLIGHT}$__BU_PROJECT_LOG_FILE_PATH${__BU_COLOR_ERROR} file.${__BU_COLOR_RESET}" >&2; echo >&2; exit 1; kill "$$"; }

                        elif [ "$__BU_STAT_LOG_REDIRECT" = "" ]; then
                            CutDateFromString "$val"
                        fi
                    else
                        CutDateFromString "$val"
                    fi
                done

                # Calling the function that processes the given answer.
                CaseRead_HandleErrorsCPLS

                # Resetting the "$__BU_STAT_CPLS" status CheckTxtFmt.
                __BU_STAT_CPLS="false"; CheckSTAT_CPLS "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
            fi

        # Else, if the function doesn't need to be called in the "CheckProjectLogStatus()" function.
        else
            if [ "$__BU_STAT_LOG_REDIRECT" = "log" ]; then
                local v_log_old="true"; __BU_STAT_LOG_REDIRECT="tee"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
            fi

            if [ -n "$__BU_STAT_ERROR" ] && [ "$__BU_STAT_ERROR" = "fatal" ]; then
                HeaderRed "$v_hdrString FATAL ERROR : ${p_errorString^^}" >&2
            else
                HeaderRed "$v_hdrString ERROR : ${p_errorString^^}" >&2
            fi

            if [ -z "$p_adviceString" ]; then
                EchoError "No advice to give."; Newline >&2
            else
                EchoError "$(DechoHighlight "Advice") : $p_adviceString" >&2; Newline >&2
            fi
                
            if [ -z "$p_badValue" ]; then
                EchoError "Value(s) that caused this error : $(DechoOrange 'no value') OR $(DechoOrange 'an unknown error')"; Newline >&2
            else
                EchoError "Value(s) that caused this error : $(DechoHighlight "$p_badValue")"; Newline >&2
            fi

            if [ "$__BU_STAT_ERROR" = "fatal" ]; then
                EchoError "Stopping the execution of $(DechoHighlight "$(basename "$0")")."; Newline >&2
                ExitError "1"
            else
                # Calling the function that processes the given answer.
                CaseRead_HandleErrors
            fi
            
            if [ "$v_log_old" = "true" ]; then
                __BU_STAT_LOG_REDIRECT="log"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
            fi
        fi
    fi
}

# -----------------------------------------------

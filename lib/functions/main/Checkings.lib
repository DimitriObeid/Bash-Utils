#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Checkings.lib
# Module        : Main
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### VARIABLES VALUES CHECKING

## NUMBER VALUES

# Checking floating value.
function IsFloat()
{
    if [[ "$1" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking negative only floating value.
function IsNegativeFloat()
{
    if IsFloat "$1" && (( 1 < 0 )); then
        return 0
    else
        return 1
    fi
}

# Checking positive only floating value.
function IsPositiveFloat()
{
    if IsFloat "$1" && (( 1 >= 0 )); then
        return 0
    else
        return 1
    fi
}

# Checking integer value.
function IsInt()
{
    if [[ "$1" =~ ^[\-0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# Checking negative only integer value.
function IsNegativeInt()
{
	if IsInt "$1" && (( 1 < 0 )); then
		return 0
	else
		return 1
	fi
}

# Checking positive only integer value.
function IsPositiveInt()
{
	if IsInt "$1" && (( 1 >= 0 )); then
		return 0
	else
		return 1
	fi
}

# -----------------------------------------------

## STRING VALUES

# Checking if the value is an alphabetic character (not any number allowed).
function IsAlphaChar()
{
	if [[ "$1" = [a-zA-Z] ]]; then
		return 0
	else
		return 1
	fi
}

# Checking if the value is an alphabetic string (not any number allowed)
function IsAlphaString()
{
    if [[ "$1" = [^a-zA-Z\ ] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters AND not any number allowed).
function IsAlphaStringOnly()
{
	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"
	else
		if [[ "$1" = [^a-zA-Z\ ] ]]; then
			return 0
		else
    		return 1
		fi
	fi
}

# Checking if the value is a character.
function IsAlphaNumChar()
{
	if [[ "$1" = [a-zA-Z0-9] ]]; then
		return 0
	else
		return 1
	fi
}

# Checking if the value is an alphanumeric string.
function IsAlphaNumString()
{
    if [[ "$1" =~ [^a-zA-Z0-9\ ] ]]; then
        return 0
    else
        return 1
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters).
function IsAlphaNumStringOnly()
{
	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"
	else
		if [[ "$1" = [^a-zA-Z0-9\ ] ]]; then
			return 0
		else
    		return 1
		fi
	fi
}


# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS

## CHECKING FOR IDENTIFIANTS

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - BU::Main::Errors::HandleErrors      --> From this file.
function CheckRootEUID()
{
    if [ "$EUID" -ne 0 ]; then
        BU::Main::Errors::HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))"

        return 1
    fi
}

# -----------------------------------------------

## INITIALIZATION CHECKINGS



# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## DIRECTORIES PATHS CHECKING

# Checking for an existent directory path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function CheckDirPathExists()
{
    #**** Parameters ****
    p_path=$1               # Path of the (in)existent directory.

    #**** Code ****
    if [ ! -f "$p_path" ]; then
        BU::DechoHighlight "<missing directory path>"   # Since this function should be called into a string, it's better to use a formatting function.
    fi
}

# Checking if a directory was successfully created.
function CheckDirPathWasCreated()
{
	#**** Parameters ****
	p_path=$1

	#**** Code ****
	if [ -d "$p_path" ]; then
		return 0
	else
		return 1
	fi
}

# -----------------------------------------------

## FILES PATHS CHECKING

# Checking for an existent file path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function CheckFilePathExists()
{
    #**** Parameters ****
    p_path=$1               # Path of the (in)existent file.

    #**** Code ****
    if [ ! -f "$p_path" ]; then
        BU::DechoHighlight "<missing file path>"        # Since this function should be called into a string, it's better to use a formatting function.
    fi
}

# Checking if a file was successfully created.
function CheckFilePathWasCreated()
{
	#**** Parameters ****
	p_path=$1

	#**** Code ****
	if [ -f "$p_path" ]; then
		return 0
	else
		return 1
	fi
}

# Checking for "$__BU_MAIN_PROJECT_LOG_FILE_PATH"

# Required functions and files :
function CheckProjectLogPath()
{
    # Since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "CheckProjectLogStatus()" function
    # (the only one where the "CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
    if [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
		BU::EchoWarning "$(BU::DechoHighlight "${FUNCNAME[0]}") --> Warning : no existing log file"
		BU::EchoNewstep "Creating a log file for the $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project"

		if ! CreateProjectLogFile; then
			return 1
		else
			return 0
		fi

        # In case the "ExitError()" function doesn't stops the script's execution because the final user modified its behavior, it's safer to add a return value.
        ExitError; return 1

    # Remember : since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "CheckProjectLogStatus()" function
    # (the only one where the "CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
#     elif [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
#         echo "$__BU_MAIN_PROJECT_LOG_FILE_PATH"
#         BU::Main::Errors::HandleErrors "1" "BAD PATH PROVIDED INTO THE $(BU::DechoHighlight "__BU_MAIN_PROJECT_LOG_FILE_PATH") VARIABLE" \
#             "Please correct the path passed as argument, or redefine the variable if its value was modified somewhere" \
#             "$__BU_MAIN_PROJECT_LOG_FILE_PATH" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
# 
# 			return 1
    else
        return 0
    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : 'nodate', '<an empty string>'
function CheckProjectLogStatus()
{
    #**** Parameters ****
    local p_string=$1       # String to display.
    local p_option=$2       # "echo" command options.
    shift 2

    local pa_extraArgs=("$@")    # More processing arguments (like the processing of a whole line-long string).

    #**** Variables ****
	# WARNING : DO NOT call any "BU::Echo<...>()" function from the "main/Echo.lib" file, as they all call the "CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "BU::Main::Errors::HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same ""CheckProjectLogStatus() function.

    # If you need to call a function here, please verify if it doesn't calls the "CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "$__BU_MAIN_STAT_ECHO" status variable value to "true" BEFORE calling the wanted function.

    local v_bu_stat_decho_old="$__BU_MAIN_STAT_DECHO"; BU::Main:Status::ChangeSTAT_DECHO "restrict" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    # Setting the "$__BU_MAIN_STAT_ECHO" status variable's value to "true", in case an error occurs during a function call, where the "CheckProjectLogStatus()" function or any other function that calls it might be called.
    local v_bu_stat_echo_old="$__BU_MAIN_STAT_ECHO"; BU::Main:Status::ChangeSTAT_ECHO "true"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
        local v_redirectionError
            v_redirectionError="$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Error : unable to write into the $(BU::DechoHighlight "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.\nRedirection option --> "
    else
        local v_redirectionError
            v_redirectionError=""
    fi

    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
        local v_warning_array_value
            v_warning_array_value="$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Warning : incorrect argument given as extra argument array in $(BU::DechoHighlight "${BASH_SOURCE[0]}"), function $(BU::DechoHighlight "${FUNCNAME[0]}()").\nValue --> $(BU::DechoHighlight "$val")\nLine -->"
    else
        local v_warning_array_value
            v_warning_array_value=""
    fi

    #**** Code *****
    # This checking must be done before the long condition below, since it needs to know if the project's log file is present.
    if [ "$__BU_MAIN_STAT_LOG" = "true" ]; then
        CheckProjectLogPath || \
        {
            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "CheckProjectLogStatus()" function's execution is stopped.
            BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is stopped.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

            return 1
        }
    fi

    CheckSTAT_LOG           "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_LOG_REDIRECT  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    CheckSTAT_TIME_TXT      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

    # If a log file exists AND if "$__BU_MAIN_STAT_LOG" value is "false" AND if "$__BU_MAIN_STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ] && [ "$__BU_MAIN_STAT_LOG" = "true" ]; then

        # If messages must be redirected in the log file only ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "log").
        if [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "log" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$p_string" 'n'
                            else
                                echo -ne "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }                            
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$p_string"
                            else
                                echo -e "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }                            
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                            else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                            else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                            fi
                            ;;
                    esac
                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "log" option)).
                else
                    case "$p_option" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'

                                # Since the "$__BU_MAIN_STAT_ECHO" status variable's value is set to 'true', this "CheckProjectLogStatus()" function won't be called, only a minimalist substitute function.
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline
							else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							fi; BU::Newline
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							fi
                            ;;
                    esac
                fi

            done

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "CheckProjectLogStatus()" function's execution is over.
            BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
			return 0

        # Else, if messages must be redirected in the log file AND to the terminal ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "tee").
        elif [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "tee" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "$p_option" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$p_string" 'n'
                            else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$p_string"
                            else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "$p_option" in
                    '-n' | 'n')
                        if BU::Main::Status::CheckStatIsInitializing; then
                            InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                        else
                            echo -ne "$p_string"
                            echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                        fi
                        ;;
                    '' | *)
                        if BU::Main::Status::CheckStatIsInitializing; then
                            InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                        else
                            echo -e "$p_string"
                            echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                        fi
                        ;;
                    esac

                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "tee" option)).
                else
                    case "$p_option" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							fi; BU::Newline
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlight "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; ExitError "1"; }
							fi
                            ;;
                    esac
                fi
            done
            
            sleep "$__BU_MAIN_STAT_TIME_TXT"
			
			# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
			return 0
        else
            case "$p_option" in
                '-n' | 'n')
                    if BU::Main::Status::CheckStatIsInitializing; then
                        InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                    else
                        echo -ne "$p_string"
                    fi
                    ;;
                '' | *)
                    if BU::Main::Status::CheckStatIsInitializing; then
                        InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                    else
                        echo -e "$p_string"
                    fi
                    ;;
            esac

        sleep "$__BU_MAIN_STAT_TIME_TXT"

        # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "CheckProjectLogStatus()" function's execution is over.
        BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

		# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
		BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
		return 0

        fi

    # Else, if no log file exists OR if "$__BU_MAIN_STAT_LOG" value is "false" OR if "$__BU_MAIN_STAT_LOG_REDIRECT" has no redirection value. 
    else
        case "$p_option" in
            '-n' | 'n')
                if BU::Main::Status::CheckStatIsInitializing; then
                    InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                else
                    echo -ne "$p_string"
                fi
                ;;
            '' | *)
                if BU::Main::Status::CheckStatIsInitializing; then
                    InitializerAddInitStrArrayVal "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                else
                    echo -e "$p_string"
                fi
                ;;
        esac

        sleep "$__BU_MAIN_STAT_TIME_TXT"

        # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "CheckProjectLogStatus()" function's execution is over.
        BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

		# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
		BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
		
		return 0
	fi

	# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
	BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "CheckProjectLogStatus()" function's execution is over.
	BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	return 0
}

# Check project related file presence, or create this file.
function CheckProjectRelatedFile()
{
	#**** Parameters ****
	local p_parent=$1   # Name of the folder to process (into its parent directory).
	local p_child=$2  	# Name of the file or folder to process (into its parent directory).
	local p_type=$3		# Type of data to create (d = directory, f = file).

	#**** Variables ****
    local v_path="$p_parent/$p_child"

	#**** Code ****
	if ! BU::Main::CheckArgs__Checkings::CheckProjectRelatedFile "$p_parent" "$p_child" "$p_type"; then return 1; fi

	if [ "$p_type" = 'f' ]; then
		if [ -f "$v_path" ]; then
			if [ -s "$v_path" ]; then
				true > "$v_path" || { HandleSmallErrors 'E' "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Error : unable to overwrite this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::DechoHighlight "$(CheckFilePathExists "$v_path")")" 'E'; return 1; }
			fi

			return 0
		else
			if [ ! -d "$p_parent" ]; then
                mkdir -p "$p_parent" || { HandleSmallErrors 'E' "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file's parent folder --> $(BU::DechoHighlight "$(CheckDirPathExists "$p_parent")")" 'E'; return 1; }

				CheckDirPathWasCreated "$p_parent" || return 1
			fi

			touch "$v_path" || { HandleSmallErrors 'E' "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::DechoHighlight "$(CheckFilePathExists "$v_path")")" 'E'; return 1; }

			CheckFilePathWasCreated "$v_path" || return 1; return 0
		fi

    elif [ "$p_type" = 'd' ]; then
		if [ -d "$v_path" ]; then
			return 0
		else
			mkdir -p "$v_path" || { HandleSmallErrors 'E' "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's folder --> $(BU::DechoHighlight "$(CheckDirPathExists "$v_path")")" 'E'; return 1; }

			CheckDirPathWasCreated "$v_path" || return 1; return 0
		fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS

## FORMATTING CHECKINGS

# Checking if the project's color code file exists or not.

# WARNING ! DO NOT CALL ANY "Decho<...>()" FUNCTION HERE, OR THE SCRIPT WILL LOOP FOREVER !!!
function BU::Main::Checkings::CheckDecho()
{
    #**** Code ****
    # Creating the "colors.tmp" file in case it doesn't exists.
    if [ ! -f "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH" ]; then
        if ! CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_NAME" "f"; then
            HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH") file" 'E' 'CPLS'
        fi
    fi

    # If the , then the "Decho()" function will not decorate the targeted text, but put it between 
    if [ "$__BU_MAIN_STAT_TXT_FMT" = "false" ] || [ "$__BU_MAIN_STAT_DECHO" = 'forbid' ]; then
        return 1
	fi
	
    if [ -f "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH" ] && [ "$(cat "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH")" = '' ]; then
        echo "$__BU_MAIN_COLOR_RESET" > "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH" || \
        {
			# It's better to call the "BU::EchoMsg()" function, so that its redirection and debug process wil not have to be reprogrammed.
			# It's also better to not call the "HandleSmallErrors()" function here, so that there won't be any problem when this function calls the "Decho<...>()" functions.
            BU::EchoMsg "${__BU_MAIN_COLOR_HIGHLIGHT}${FUNCNAME[0]}()${__BU_MAIN_COLOR_WARNING}--> Warning : Unable to write any color code into the ${__BU_MAIN_COLOR_HIGHLIGHT}$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH${__BU_MAIN_COLOR_WARNING} file." 'R' ''

            return 1
        }

        return 0
    else
        return 0
	fi
}

# Check if the "$__BU_MAIN_STAT_ECHO" status variable's value is set to "true".
function BU::Main::Status::CheckEcho()
{
    if [ "$__BU_MAIN_STAT_ECHO" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# Checking if the "$__BU_MAIN_STAT_TXT_FMT" status value is set to "true".
function BU::Main::Status::CheckTextFormat()
{
    #**** Parameters ****
    #   $1  -> "tput" command's text formatting option.
    #   $2  -> Corresponding ANSI escape sequence (useful if the "tput" command is not detected or unavailable).

    #**** Code ****
    if [ "$__BU_MAIN_STAT_TXT_FMT" = "true" ]; then
        if [ -n "$1" ]; then
			if command -v "tput" &> /dev/null; then
				# Formatting text with the tput command or directly with the backslash escapes.
				tput "$1" || echo -ne "\e[$2m"

				return 0
			else
				echo -ne "\e[$2m"; return 0
			fi

        # In case there's no value passed as first argument (like if the wanted tput option is unknown), the script only echoes its ANSI escape sequence.
        else
            echo -ne "\e[$2m"

            return 0
        fi

    else
        return 0
    fi
}

# -----------------------------------------------

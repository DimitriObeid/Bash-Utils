#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : Checkings.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ----------------------
# SCRIPT'S DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154


# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    if [[ "${LANG}" == de_* ]]; then
        echo -e "ACHTUNG !" >&2; echo >&2;
        echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
        echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

    elif [[ "${LANG}" == es_* ]]; then
        echo -e "ATENCIÓN !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
        echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

    elif [[ "${LANG}" == fr_* ]]; then
        echo -e "ATTENTION !" >&2; echo >&2;
        echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
        echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

    elif [[ "${LANG}" == hi_* ]]; then
        echo -e "चेतावनी!" >&2; echo >&2;
        echo -e "यह शेल स्क्रिप्ट (${BASH_SOURCE[0]}) सीधे निष्पादित करने के लिए नहीं है!" >&2; echo >&2;
        echo -e "इस स्क्रिप्ट को अपने प्रोजेक्ट स्क्रिप्ट में शामिल करके ही इस्तेमाल करें।" >&2;

    elif [[ "${LANG}" == id_* ]]; then
        echo -e "PERINGATAN !" >&2; echo >&2;
        echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
        echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

    elif [[ "${LANG}" == ja_* ]]; then
        echo -e "警告 ！" >&2; echo >&2;
        echo -e "このシェルスクリプト（${BASH_SOURCE[0]}）は、直接実行することはできません！" >&2; echo >&2;
        echo -e "このスクリプトは、プロジェクトスクリプトに含める必要があり、このスクリプトと一緒にしか使用できません。" >&2;

    elif [[ "${LANG}" == ko_* ]]; then
        echo -e "경고 !" >&2; echo >&2;
        echo -e "이 셸 스크립트(${BASH_SOURCE[0]})는 직접 실행하도록 설계되지 않았습니다!" >&2; echo >&2;
        echo -e "프로젝트 스크립트에 포함하여 이 스크립트만 사용하십시오." >&2;

    elif [[ "${LANG}" == pt_* ]]; then
        echo -e "ATENÇÃO !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
        echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

    elif [[ "${LANG}" == ru_* ]]; then
        echo -e "ВНИМАНИЕ !" >&2; echo >&2;
        echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
        echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

    elif [[ "${LANG}" == sv_* ]]; then
        echo -e "VARNING!" >&2; echo >&2;
        echo -e "Detta skalskript (${BASH_SOURCE[0]}) är inte avsett att köras direkt!" >&2; echo >&2;
        echo -e "Använd endast detta skript genom att inkludera det i ditt projektskript." >&2;

    elif [[ "${LANG}" == tr_* ]]; then
        echo -e "UYARI!" >&2; echo >&2;
        echo -e "Bu kabuk betiği (${BASH_SOURCE[0]}) doğrudan çalıştırılmak üzere tasarlanmamıştır!" >&2; echo >&2;
        echo -e "Proje kodunuza dahil ederek yalnızca bu kodu kullanın." >&2;

    elif [[ "${LANG}" == uk_* ]]; then
        echo -e "УВАГА !" >&2; echo >&2;
        echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
        echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

    elif [[ "${LANG}" == zh_* ]]; then
        echo -e "警告 !" >&2; echo >&2;
        echo -e "这个shell脚本(${BASH_SOURCE[0]})是不能直接执行的!" >&2; echo >&2;
        echo -e "只使用这个脚本并将其纳入你的项目脚本。" >&2;

    else
        echo -e "WARNING !" >&2; echo >&2;
        echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
        echo -e "Use only this script by including it in your project script." >&2;

    fi;
    
    echo >&2; 
    
    exit 1; 
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### VARIABLES VALUES CHECKINGS
#### DEBUG ID : "bu::main::checkings::variable-values-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS="bu::main::checkings::variable-values-checkings";

## ARRAYS CHECKINGS
## DEBUG ID : "array-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::array-checkings";

# ·····································
# Checking if the variable is an array.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsArray()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    #**** Code ****
    if [[ -n ${1} ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ······························
# Checking if an array in empty.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsArrayEmpty()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    #**** Parameters ****
    local arr=("${@}")  # ARG TYPE : Array  - REQUIRED : DEFAULT VAL : NULL     - DESC : Array to process.

    #**** Code ****
    if [ ${#arr[@]} -eq 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ··································
# Checking if an array is not empty.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsArrayNotEmpty()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    #**** Parameters ****
    local arr=("${@}")  # ARG TYPE : Array  - REQUIRED : DEFAULT VAL : NULL     - DESC : Array to process.

    #**** Code ****
    if [ ${#arr[@]} -gt 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

## ==============================================

## COMMAND SUBSTITUTIONS
## DEBUG ID : "command-substitutions"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::command-substitutions";

# ················································
# Checking if the value is a command substitution.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.IsAlphaNumChar()    -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.IsAlphaNumString()  -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.IsFloat()           -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.IsInt()             -> Main -> Checkings.lib (this file)

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsCMD()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS}";

    #**** Code ****
    if  [ -n "${1}" ] && \
        ! BU.Main.Checkings.IsAlphaNumChar "${1}" && \
        ! BU.Main.Checkings.IsAlphaNumString "${1}" && \
        ! BU.Main.Checkings.IsInt "${1}" && \
        ! BU.Main.Checkings.IsFloat "${1}";
    then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# ····················································
# Checking if the value is not a command substitution.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.IsCMD() -> Main -> Checkings.lib (this file)

#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsNotCMD()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS}";

    #**** Code ****
    if BU.Main.Checkings.IsCMD "${1}"; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

## ==============================================

## DATE FORMAT
## DEBUG ID : "date-format"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::date-format";

# ··································································································
# Checking if a given hour is formatted in timestamp format, with separators, and in these formats :
#   - hh:mm:ss

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - date      | ("+%H:%M:%S")

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsDateHMS()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}";

    [[ "$(date "+%H:%M:%S" > /dev/null)" ]] || {
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return 1;
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# ··································································································
# Checking if a given date is formatted in timestamp format, with separators, and in these formats :
#   - YYYY-MM-DD
#   - DD-MM-YYYY
#   - YYYY/MM/DD
#   - DD/MM/YYYY
#   - YYYYMMDD
#   - DDMMYYYY

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - date      | ("+%d-%m-%Y")

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsDateYMD()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}";

    #**** Code ****
    [[ $(date "+%d-%m-%Y" -d "${1}" > /dev/null) ]] || {
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return 1;
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# ·································································································
# Checking if a given date is formatted in timestamp format, with separators, and in these formats.
#   - YYYY-MM-DD hh:mm:ss
#   - DD-MM-YYYY hh:mm:ss
#   - YYYY/MM/DD hh:mm:ss
#   - DD/MM/YYYY hh:mm:ss
#   - YYYYMMDD hh:mm:ss
#   - DDMMYYYY hh:mm:ss

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - cut       | (-d | -f2- | -f)
#   - date      | ("+%H:%M:%S" | -d)
#   - echo      |
#   - local     |
#   - rev       |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.IsDateYMD() -> Main -> Checkings.lib (this file)

#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()        -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()        -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsDateYMD_HMS()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}";

    #**** Variables ****
    local v_date;   # VAR TYPE : Date   - DESC : Getting the year, the month and the day.
    local v_hour;   # VAR TYPE : Date   - DESC : Getting the hour.

    #**** Code ****
    v_date="$(echo "${1}" | rev | cut -d ' ' -f2- | rev)";
    v_hour="$(echo "${1}" | rev | cut -d ' ' -f 1 | rev)";

    [[ $(BU.Main.Checkings.IsDateYMD "${v_date}" > /dev/null) ]] || \
    {
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")() --> Warning : the date is not formatted in a correct timestamp";
        BU.Main.Echo.Warning "Please use one of these formats :";
        BU.Main.Echo.Warning "YYYY-MM-DD";
        BU.Main.Echo.Warning "DD-MM-YYYY";
        BU.Main.Echo.Warning "YYYY/MM/DD";
        BU.Main.Echo.Warning "DD/MM/YYYY";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    date "+%H:%M:%S" -d "${v_hour}" || \
    {
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")() --> Warning : the hour is not formatted in a correct timestamp";
        BU.Main.Echo.Warning "Please use only this format : hh:mm:ss";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

## ==============================================

## NUMBER VALUES
## DEBUG ID : "number-values"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::number-values";

# ·····························
# Checking if a number is even.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsEven()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [ "$(( ${1:-$'\0'} % 2 ))" -eq 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ·······························
# Checking if a number is uneven.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.isOdd()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [ "$(( ${1:-$'\0'} % 2 ))" -ne 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

alias BU.Main.Checkings.IsUneven='BU.Main.Checkings.isOdd';

# ························
# Checking floating value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsFloat()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [[ "${1}" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ······································
# Checking negative only floating value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsNegativeFloat()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if BU.Main.Checkings.IsFloat "${1}" && (( 1 < 0 )); then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ······································
# Checking positive only floating value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsPositiveFloat()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if BU.Main.Checkings.IsFloat "${1}" && (( 1 >= 0 )); then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ·······················
# Checking integer value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsInt()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [[ "${1}" =~ ^[\-0-9]+$ ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ·····································
# Checking negative only integer value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsNegativeInt()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

	if BU.Main.Checkings.IsInt "${1}" && (( 1 < 0 )); then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# ·····································
# Checking positive only integer value.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsPositiveInt()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

	if BU.Main.Checkings.IsInt "${1}" && (( 1 >= 0 )); then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

## ==============================================

## CHARACTERS AND STRING VALUES
## DEBUG ID : "characters-and-string-values"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::characters-and-string-values";

# ··········································································
# Checking if the value is an alphabetic character (not any number allowed).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaChar()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [[ "${1}" == [a-zA-Z] ]]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# ·······································································
# Checking if the value is an alphabetic string (not any number allowed).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaString()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

    if [[ "${1}" == [^a-zA-Z\ ] ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ·············································································································
# Checking if the value is an alphabetic string only (not less than two characters AND not any number allowed).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaStringOnly()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "${1}" == [^a-zA-Z\ ] ]]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

# ·····································
# Checking if the value is a character.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaNumChar()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [[ "${1}" == [a-zA-Z0-9] ]]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# ················································
# Checking if the value is an alphanumeric string.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaNumString()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

    if [[ "${1}" =~ [^a-zA-Z0-9\ ] ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# ··················································································
# Checking if the value is an alphabetic string only (not less than two characters).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.IsAlphaNumStringOnly()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "${1}" == [^a-zA-Z0-9\ ] ]]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

## ==============================================

## OTHER VARIABLES CHECKINGS
## DEBUG ID : "other-variables-checkings"

# shellcheck disable=SC2034
declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__OTHER_VARIABLES_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::other-variables-checkings";

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS
#### DEBUG ID : "bu::main::checkings::different-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS="bu::main::checkings::different-checkings";

## CHECKING FOR IDENTIFIANTS
## DEBUG ID : "checking-for-identifiants"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}::checking-for-identifiants";

# ··················································································
# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()   -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.CheckRootEUID()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS}";

    if [ "${EUID}" -eq 0 ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else return 1; fi
}

alias BU.Main.Checkings.IsRoot='BU.Main.Checkings.CheckRootEUID';

## ==============================================

## BASIC HARDWARE CHECKINGS
## DEBUG ID : "basic-hardware-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}::basic-hardware-checkings";

# ································
# Check if the hard drive is full.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib

#   - BU.Main.Errors.Exit()                 -> Main -> Errors.lib
#   - BU.Main.Errors.HandleErrors()         -> Main -> Errors.lib

#   - BU.Main.Filesystem.IsPartitionFull()  -> Main -> Filesystem.lib

#   - BU.Main.Status.ChangeSTAT_ERROR()     -> Main -> Status.lib

#   - BU.ModuleInit.IsInScript()            -> Modules initializer script
#   - BU.ModuleInit.SetInitErrorMsg()       -> Modules initializer script
#   - BU.ModuleInit.UnsetInitErrorMsg()     -> Modules initializer script


# shellcheck disable=
function BU.Main.Checkings.CheckDiskUsedSpace()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS}";

	#**** Parameters ****
    local p_fileFS=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Target file's file system.
    local p_dirfile=${2:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Create the file with the directory if not exists, then erase it, in order to get the target file system.
    local p_authorization=${3:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to call the "BU.Main.Errors.HandleErrors()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and that "BU.__/Decho()" functions are called in the "BU.Main.Errors.HandleErrors()" function). Set this value to "false" to forbid this call.

    #**** Code ****

    # The function "BU.Main.Checkings.CheckProjectLogStatus()" function is called in each "Echo<...>()" functions if the "${__BU_MAIN_STAT_ECHO}" status global
    # variable's value is set to 'false', and the current function is called at the beginning of the "BU.Main.Checkings.CheckProjectLogStatus()" function.

    # Changing the "${__BU_MAIN_STAT_ECHO}" global status variable's value to 'true', in order to avoid an infinite
    # loop during the call of any function from the "Filesystem.lib" file, which call an "Echo<...>()" function.

    if [ "${__BU_MAIN_STAT_ECHO,,}" == 'false' ]; then
        local v_echoBackup="${__BU_MAIN_STAT_ECHO}";

        # There is no need to call the associated function "BU.Main.Status.ChangeSTAT_ECHO()", since no text have to be redirected to the log file afterwards, because the script has to definitely exit if the targeted partition of the hard disk is full.
        __BU_MAIN_STAT_ECHO="true";
    fi

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

    if [ "${p_dirfile,,}" == 'create' ]; then
            BU.Main.Filesystem.IsPartitionFull "${p_fileFS}" "${p_dirfile}"; local IsPartitionFullReturnCode="${?}";
    else    BU.Main.Filesystem.IsPartitionFull "${p_fileFS}"; fi

    # If the execution of the "BU.Main.Filesystem.IsPartitionFull()" function was successful.
    if [ "${IsPartitionFullReturnCode}" -eq 0 ]; then

        # Resetting the former "${__BU_MAIN_STAT_ECHO}" global status variable's value.
        if [ "${v_echoBackup,,}" == 'false' ]; then
            __BU_MAIN_STAT_ECHO="${v_echoBackup}";
        fi

        [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if no directory or file is passed as first argument for the "BU.Main.Filesystem.IsPartitionFull()" function.
    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" "NO DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" \
                "Please give a filepath in order to check if the target file system is full or not${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" \
                "Unknown file system size because of a missing path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        else
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : NO DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" >&2;
            echo "Please give a path in order to check if the target file system is full or not" >&2;
            echo >&2;

            echo "Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi

    # Else, if an invalid directory or file was passed as first argument for the "BU.Main.Filesystem.IsPartitionFull()" function.
    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" "INVALID DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" \
                "Please give a valid path in order to check if the target file system is full or not${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" \
                "Unknown file system size because of a missing file path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        else
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : INVALID DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" >&2;
            echo "Please give a valid path in order to check if the target file system is full or not" >&2;
            echo >&2;

            echo "Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi

    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_NO_SPACE_LEFT}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" \
                "NO SPACE LEFT ON THE TARGET FILE {SYSTEM} !!!" \
				"Please empty this file system (mounted on the « $(BU.Main.Filesystem.GetFSMountPoint "${p_fileFS}") » partition) before using it, or use another partition to write data in a file${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is full, the script has to be exited in order to avoid potential bugs" \
                "No space left on the target device's partition" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        elif [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : NO SPACE LEFT ON THE TARGET FILE SYSTEM !!!" >&2;
            echo "Please empty this file system (mounted on the « $(BU.Main.Filesystem.GetFSMountPoint "${p_fileFS}") » partition) before using it, or use another partition to write data in a file" >&2;
            echo >&2;

            echo "Since the file system's disk space is full, the script has to be exited" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi
    fi
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKINGS
#### DEBUG ID : "bu::main::checkings::paths-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS="bu::main::checkings::paths-checkings";

## DIRECTORIES PATHS CHECKINGS
## DEBUG ID : "directories-paths-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}::directories-paths-checkings";

# ··································································································
# Checking for an existent directory path (for the "BU.Main.Errors.HandleErrors()" function mainly).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Decho.Decho.Path()    -> Main -> Decho.lib

#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.CheckDirPathExists()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the (in)existent directory.
    local p_authorization=${2:-true};   # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : true     - DESC : Authorization to call the "BU.Main.Decho.Decho.Path()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and they are called in the "BU.Main.Decho.Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -d "${p_path}" ] && [ "${p_authorization,,}" == 'true' ]; then
        BU.Main.Decho.Decho.Path "<missing directory path>";  # Since this function should be called into a string, it's better to use a formatting function.

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -d "${p_path}" ] && [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
        printf "<missing directory path>"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# ·················································
# Checking if a directory was successfully created.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.CheckDirPathWasCreated()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the newly created directory.

	#**** Code ****
	if [ -d "${p_path}" ]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

## ==============================================

## FILES PATHS CHECKINGS
## DEBUG ID : "files-path-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}::files-paths-checkings";

# ·····························································································
# Checking for an existent file path (for the "BU.Main.Errors.HandleErrors()" function mainly).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |
#   - printf

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Decho.Decho.Path()    -> Main -> Decho.lib

#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.CheckFilePathExists()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the (in)existent file.
    local p_authorization=${2:-true};   # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : true     - DESC : Authorization to call the "BU.Main.Decho.Decho.Path()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and they are called in the "BU.Main.Decho.Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -f "${p_path}" ] && [ "${p_authorization,,}" == 'true' ]; then
        BU.Main.Decho.Decho.Path "<missing file path>";       # Since this function should be called into a string, it's better to use a formatting function.

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -f "${p_path}" ] && [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
        printf "<missing file path>"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# ············································
# Checking if a file was successfully created.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()       -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.Checkings.CheckFilePathWasCreated()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the newliy created file.

	#**** Code ****
	if [ -f "${p_path}" ]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# ······································································································································
# Checking for the presence of the project's log path, whose path is stored in the "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" global variable.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - declare   | (-i)
#   - echo      |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Decho.Decho.Function()        -> Main -> Decho.lib
#   - BU.Main.Decho.Decho.Highlight()       -> Main -> Decho.lib
#   - BU.Main.Decho.Decho.Path()            -> Main -> Decho.lib

#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()         -> Main -> Errors.lib

#   - BU.Main.Files.CreateProjectLogFile()  -> Main -> Files.lib

#   - BU.ModuleInit.SetInitErrorMsg()       -> Modules initializer script
#   - BU.ModuleInit.UnsetInitErrorMsg()     -> Modules initializer script


# shellcheck disable=
function BU.Main.Checkings.CheckProjectLogPath()
{
    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && declare -i VCheckProjectLogPath='1';

    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

    # Since the "${__BU_MAIN_STAT_DECHO}" and the "${__BU_MAIN_STAT_ECHO}" global status variables values are set to their safe mode in the "BU.Main.Status.CheckProjectLogStatus()" function
    # (the only one where the "BU.Main.Checkings.CheckProjectLogPath()" function can be called), it's safe to call an "BU.Echo<...>()" function, the "BU.Main.Errors.HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
    if [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
		BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : no existing log file";
		BU.Main.Echo.Newstep "Creating a log file for the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project";

		if ! BU.Main.Files.CreateProjectLogFile; then
			[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		else
			[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi

    # Remember : since the "$[__BU_MAIN_STAT_DECHO]" and the "$[__BU_MAIN_STAT_ECHO]" status variables values are set to their safe mode in the "BU.Main.Status.CheckProjectLogStatus()" function
    # (the only one where the "BU.Main.Checkings.CheckProjectLogPath()" function can be called), it's safe to call an "BU.Echo<...>()" function, the "BU.Main.Errors.HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
     elif [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
         echo "${__BU_MAIN_PROJECT_LOG_FILE_PATH}";

         BU.Main.Errors.HandleErrors "1" "BAD PATH PROVIDED INTO THE $(BU.Main.Decho.Decho.Path "__BU_MAIN_PROJECT_LOG_FILE_PATH") VARIABLE" \
             "Please correct the path passed as argument, or redefine the variable if its value was modified somewhere" \
             "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

 		[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    else
        [ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# ······································································································
# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : 'nodate', '<an empty string>'

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      | (-e | -n)
#   - local     |
#   - shift     |
#   - sleep     |
#   - tee       | (-a)

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.CheckDiskUsedSpace()    -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.CheckProjectLogPath()   -> Main -> Checkings.lib (this file)

#   - BU.Main.Decho.Decho.Function()            -> Main -> Decho.lib
#   - BU.Main.Decho.Decho.Highlight()           -> Main -> Decho.lib
#   - BU.Main.Decho.Decho.Path()                -> Main -> Decho.lib
#   - BU.Main.Decho.Decho.Var()                 -> Main -> Decho.lib

#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                      -> Main -> Echo.lib (NOTE : The "${__BU_MAIN_STAT_ECHO}" global status variable's value is set on 'true' at this point, so this function can safely be used)
#   - BU.Main.Echo.Newline()                    -> Main -> Echo.lib
#   - BU.Main.Echo.Warning()                    -> Main -> Echo.lib (NOTE : The "${__BU_MAIN_STAT_ECHO}" global status variable's value is set on 'true' at this point, so this function can safely be used)

#   - BU.Main.Errors.Exit()                     -> Main -> Errors.lib

#   - BU.Main.Status.ChangeSTAT_DECHO()         -> Main -> Status.lib
#   - BU.Main.Status.ChangeSTAT_ECHO()          -> Main -> Status.lib
#   - BU.Main.Status.ChangeSTAT_TIME_HEADER()   -> Main -> Status.lib
#   - BU.Main.Status.ChangeSTAT_TIME_NEWLINE()  -> Main -> Status.lib
#   - BU.Main.Status.ChangeSTAT_TIME_TXT()      -> Main -> Status.lib
#   - BU.Main.Status.CheckSTAT_LOG()            -> Main -> Status.lib
#   - BU.Main.Status.CheckSTAT_LOG_REDIRECT()   -> Main -> Status.lib
#   - BU.Main.Status.CheckSTAT_TIME_TXT()       -> Main -> Status.lib
#   - BU.Main.Status.CheckStatIsInitializing()  -> Main -> Status.lib

#   - BU.ModuleInit.Msg()                       -> Modules initializer script
#   - BU.ModuleInit.SetInitErrorMsg()           -> Modules initializer script
#   - BU.ModuleInit.UnsetInitErrorMsg()         -> Modules initializer script


# shellcheck disable=
function BU.Main.Status.CheckProjectLogStatus()
({
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : Any        - REQUIRED | DEFAULT VAL : NULL     - DESC : Text to display.
    local p_option=${2:-$'\0'};     # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command's options.
    shift 2;

    local pa_extraArgs=("${@}");    # ARG TYPE : Array      - OPTIONAL | DEFAULT VAL : NULL     - DESC :  More processing arguments (like the processing of a whole line-long string).

    #**** Variables ****
    local v_bu_stat_decho_old;      # VAR TYPE : String     - DESC :
    local v_bu_stat_echo_old;       # VAR TYPE : String     - DESC :
    local v_redirectionError;       # VAR TYPE : String     - DESC :
    local v_warning_array_value;    # VAR TYPE : String     - DESC :

    #**** Code ****

    # -------------------------------------------

	# WARNING : DO NOT call any "BU.Echo<...>()" function from the "main/Echo.lib" file, as they all call the "BU.Main.Status.CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "BU.Main.Errors.HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same "BU.Main.Status.CheckProjectLogStatus()" function.

    # If you need to call a function here, please verify if it doesn't calls the "BU.Main.Status.CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "${__BU_MAIN_STAT_ECHO value to "true" BEFORE calling the wanted function.

    # -------------------------------------------

    # ··································································································································
    # Formatting the "${p_string}" variable with the "Text.lib" functions adapted for the options passed in the "${pa_extraArgs}" array.

    # shellcheck disable=
    function BU.Main.Checkings.CheckProjectLogStatus.FormatString()
    {
        #**** Code ****
        for opt in "${pa_extraArgs[@]}"; do
            # If the "nodate" option is passed to the "${opt}" key (the current date must not be written before the string to print).
            if [ "${opt,,}" == 'nodate' ]; then
                p_string="$(BU.Main.Text.CutLogDateFromString "${p_string}")";
            else
                echo "${FUNCNAME[0]}() --> ${FUNCNAME[1]}() : ${opt} is not a supported option" >&2;

                # If the framework is still initializing when an error occurs.
#                 BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';
#
#                 case "${p_option,,}" in
#                     '-n' | 'n')
#                         if BU.Main.Status.CheckStatIsInitializing; then
#                             BU.ModuleInit.Msg "${p_string}" 'n';
#
#                             # Since the "${__BU_MAIN_STAT_ECHO}" global status variable's value is set to 'true', this "BU.Main.Status.CheckProjectLogStatus()" function won't be called, only a minimalist substitute function.
#                             BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline;
# 						else
#                             echo -ne "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
#                             BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
# 						fi; BU.Main.Echo.Newline;
#                     ;;
#                     '' | *)
#                         if BU.Main.Status.CheckStatIsInitializing; then
#                             BU.ModuleInit.Msg "${p_string}";
#                             BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
# 						else
#                             echo -e "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
#                             BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
# 						fi
#                     ;;
#                 esac
            fi
        done

        if [[ "${p_option}" == ?(-)n ]]; then
            echo -ne "${p_string}";
        else
            echo -e "${p_string}";
        fi

        return 0;
    }

    # ·············································
    # Handling the log redirection's error message.

    # shellcheck disable=
    function BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError()
    {
        BU.Main.Echo.Newline >&2;

        BU.Main.Echo.Error \
            "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" \
            "${p_option}" \
            'nodate';

        BU.Main.Echo.Newline >&2;

        v_loop_error='error';
    }

	# Checking first if the partition where the log file exists is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${C}"; return "${?}"; };

    # Setting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to 'restrict', in case an error occurs during a function call.

    # Also disabling a shellcheck warning, which is a false positive (saying that "${__BU_MAIN_STAT_DECHO}" may not be assigned, but "${__BU_MAIN_STAT_ECHO}" is (both of them are valid and working differently)).

    # shellcheck disable=SC2153
    v_bu_stat_decho_old="${__BU_MAIN_STAT_DECHO}";
    
    BU.Main.Status.ChangeSTAT_DECHO "restrict" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    }

    # Setting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to 'true', in case an error occurs during a function call, where the "BU.Main.Status.CheckProjectLogStatus()" function or any other function that calls it might be called.
    v_bu_stat_echo_old="${__BU_MAIN_STAT_ECHO}";
    
    BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    }

    #
    v_redirectionError="$(BU.Main.Decho.Decho.Function \
        "${FUNCNAME[0]}()") --> Error : unable to write into the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") file.\nRedirection option --> ";

    #
    v_warning_array_value="$(BU.Main.Decho.Decho.Function \
        "${FUNCNAME[0]}()") --> Warning : incorrect argument given as extra argument array in $(BU.Main.Decho.Decho.Path "${BASH_SOURCE[0]}"), function $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()").\nValue --> $(BU.Main.Decho.Decho.Highlight "${val}")\nLine -->";


    # This checking must be done before the long condition below, since it needs to know if the project's log file is present.
    if [ "${__BU_MAIN_STAT_LOG,,}" == "true" ]; then
        BU.Main.Checkings.CheckProjectLogPath || \
        {
            #**** Conditional variables ****
            local returnCode="${?}";

            #**** Conditional code ****
            # Resetting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is stopped.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

            # Resetting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is stopped.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

            return "${returnCode}";
        };
    fi

    BU.Main.Status.CheckSTAT_LOG             'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }
    BU.Main.Status.CheckSTAT_LOG_REDIRECT    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }
    BU.Main.Status.CheckSTAT_TIME_TXT        'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

    # If a log file exists AND if "${__BU_MAIN_STAT_LOG}" value is "false" AND if "${__BU_MAIN_STAT_LOG_REDIRECT}" has a redirection value.
    if [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ] && [ "${__BU_MAIN_STAT_LOG,,}" == "true" ]; then

        # If messages must be redirected in the log file only ("${__BU_MAIN_STAT_LOG_REDIRECT}" value is equal to "log").
        if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "log" ]; then

            #**** Conditional variables ****
            local v_stat_time_header="${__BU_MAIN_STAT_TIME_HEADER}";   # VAR TYPE : Int    - DESC : Backup of the current value of the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable.
            local v_stat_time_newline="${__BU_MAIN_STAT_TIME_NEWLINE}"; # VAR TYPE : Int    - DESC : Backup of the current value of the "${__BU_MAIN_STAT_TIME_NEWLINE}" global status variable.
            local v_stat_time_txt="${__BU_MAIN_STAT_TIME_TXT}";         # VAR TYPE : Int    - DESC : Backup of the current value of the "${__BU_MAIN_STAT_TIME_TXT}" global status variable.

            #**** Conditional code ****
            # Setting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            BU.Main.Status.ChangeSTAT_TIME_HEADER "0"   || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Setting the "${__BU_MAIN_STAT_TIME_NEWLINE}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            BU.Main.Status.ChangeSTAT_TIME_NEWLINE "0"  || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Setting the "${__BU_MAIN_STAT_TIME_TXT}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            BU.Main.Status.ChangeSTAT_TIME_TXT "0"      || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # If no arguments were passed into the "${pa_extraArgs[@]} extra arguments array.
            if [ "${#pa_extraArgs[@]}" -lt 1 ]; then
                case "${p_option,,}" in
                    '-n' | 'n')
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}" 'n';
                        else                        
                            echo -ne "$([ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ] && echo "${__BU_MAIN_TIME_DATE_DISPLAY}") ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                            {
                                # If the framework is still initializing when an error occurs.
                                BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                                BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;                                
                            };
                        fi
                    ;;
                    '' | *)
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}";
                        else
                            echo -e "$([ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ] && echo "${__BU_MAIN_TIME_DATE_DISPLAY}") ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                            {
                                # If the framework is still initializing when an error occurs.
                                BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                                BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;
                            };
                        fi
                    ;;
                esac
            else
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(BU.Main.Checkings.CheckProjectLogStatus.FormatString "${p_string}")" "$([[ "${p_option,,}" == ?(-)n ]] && echo 'n')";
                else
                    BU.Main.Checkings.CheckProjectLogStatus.FormatString "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                    {
                        # If the framework is still initializing when an error occurs.
                        BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                        BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;
                    };
                fi
            fi

            # Unsetting the  if the framework is still initializing when an error occurs.
            [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg;
        
            # Resetting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"        'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"          'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_HEADER "${v_stat_time_header}"   'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_NEWLINE "${v_stat_time_newline}" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_TXT}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_TXT "${v_stat_time_txt}"         'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            return 0;

        # Else, if messages must be redirected in the log file AND to the terminal ("${__BU_MAIN_STAT_LOG_REDIRECT}" value is equal to "tee").
        elif [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "tee" ]; then

            # If no arguments were passed into the "${pa_extraArgs[@]} extra arguments array.
            if [ "${#pa_extraArgs[@]}" -lt 1 ]; then
                case "${p_option,,}" in
                    '-n' | 'n')
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}" 'n';
                        else                        
                            echo -ne "$([ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ] && echo "${__BU_MAIN_TIME_DATE_DISPLAY}") ${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                            {
                                # If the framework is still initializing when an error occurs.
                                BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                                BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;                                
                            };
                        fi
                    ;;
                    '' | *)
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}";
                        else
                            echo -e "$([ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ] && echo "${__BU_MAIN_TIME_DATE_DISPLAY}") ${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                            {
                                # If the framework is still initializing when an error occurs.
                                BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                                BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;
                            };
                        fi
                    ;;
                esac
            else
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(BU.Main.Checkings.CheckProjectLogStatus.FormatString "${p_string}")" "$([[ "${p_option,,}" == ?(-)n ]] && echo 'n')";
                else
                    BU.Main.Checkings.CheckProjectLogStatus.FormatString "${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                    {
                        # If the framework is still initializing when an error occurs.
                        BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                        BU.Main.Checkings.CheckProjectLogStatus.HandleLogRedirectionError;
                    };
                fi
            fi

            # Unsetting the  if the framework is still initializing when an error occurs.
            [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            sleep "${__BU_MAIN_STAT_TIME_TXT}";

			# Resetting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
			BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"  'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

			# Resetting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
			BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

			return 0;

        # Else, if messages must not be redirected in the log file.
        else
            case "${p_option,,}" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}";
                    else
                        echo -ne "${p_string}";
                    fi
                ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}";
                    else
                        echo -e "${p_string}";
                    fi
                ;;
            esac

            sleep "${__BU_MAIN_STAT_TIME_TXT}";

            # Resetting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            return 0;

        fi

    # Else, if no log file exists OR if "${__BU_MAIN_STAT_LOG}" value is "false" OR if "${__BU_MAIN_STAT_LOG_REDIRECT}" has no redirection value.
    else
        case "${p_option,,}" in
            '-n' | 'n')
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" 'n';
                else
                    echo -ne "${p_string}";
                fi
                ;;
            '' | *)
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}";
                else
                    echo -e "${p_string}";
                fi
                ;;
        esac

        sleep "${__BU_MAIN_STAT_TIME_TXT}";

        # Resetting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
        BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

		# Resetting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
		BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

		return 0;
	fi
})

# ·························································
# Check project related file presence, or create this file.


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - echo      |
#   - local     |
#   - mkdir     | (-p)
#   - touch     |
#   - true      |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Args__Checkings.CheckProjectRelatedFile() -> Main -> Args.lib

#   - BU.Main.Checkings.CheckDirPathExists()            -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.CheckDirPathWasCreated()        -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.CheckDiskUsedSpace()            -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.CheckFilePathExists()           -> Main -> Checkings.lib (this file)
#   - BU.Main.Checkings.CheckFilePathWasCreated()       -> Main -> Checkings.lib (this file)

#   - BU.Main.Echo.Debug()                              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                           -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                              -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                            -> Main -> Echo.lib

#   - BU.Main.Errors.Exit()                             -> Main -> Errors.lib
#   - BU.Main.Errors.HandleSmallErrors()                -> Main -> Errors.lib

#   - BU.Main.TextFormat.SetBGColor()                   -> Main -> TextFormat.lib
#   - BU.Main.TextFormat.SetTextColor()                 -> Main -> TextFormat.lib


# shellcheck disable=
function BU.Main.Checkings.CheckProjectRelatedFile()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_parent=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to process (into its parent directory).
    local p_child=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file or folder to process (into its parent directory).
    local p_type=${3:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of data to create (d = directory, f = file).
    local p_decho=${4:-$'\0'};  # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC :

	#**** Variables ****
    local v_path="${p_parent}/${p_child}";  # VAR TYPE : Path   - DESC : Path to the file to check for its existence, or to create if it does not exists on the computer's hard drive.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${v_path}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit "${C}"; return "${?}"; };

	if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
        if ! BU.Main.Args__Checkings.CheckProjectRelatedFile "${p_parent}" "${p_child}" "${p_type}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi
    fi

	if [ "${p_type}" == 'f' ]; then
		if [ ! -f "${v_path}" ]; then
			if [ ! -d "${p_parent}" ]; then
                if [ "${p_parent}" == "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" ]; then echo TEST1; BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_BG_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

                elif [ "${p_parent}" == "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" ]; then echo TEST2; BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_TXT_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

                else
                    mkdir -p "${p_parent}" || {
                        local returnCode="${?}";

                        if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                            BU.Main.Errors.HandleSmallErrors 'E' \
                                "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file's parent folder --> $(BU.Main.Checkings.CheckDirPathExists "${p_parent}" 'true')" 'E';
                        else
                            BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to create this « ${__BU_MAIN_PROJECT_NAME} » project's file parent folder --> ${p_parent}";
                            BU.Main.Echo.Newline;
                        fi

                        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
                    }
                fi

				BU.Main.Checkings.CheckDirPathWasCreated "${p_parent}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
			fi

            if [ "${p_child}" == "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}" ]; then echo TEST3; BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_BG_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            elif [ "${p_child}" == "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}" ]; then echo TEST4; BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_TXT_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            else
                touch "${v_path}" || {
                    local returnCode="${?}";

                    if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                        BU.Main.Errors.HandleSmallErrors 'E' \
                            "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file --> $(BU.Main.Checkings.CheckFilePathExists "${v_path}" 'true')" 'E';
                    else
                        BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to overwrite this « ${__BU_MAIN_PROJECT_NAME} » project's file --> ${v_path}";
                        BU.Main.Echo.Newline;
                    fi

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
                }
            fi

			BU.Main.Checkings.CheckFilePathWasCreated "${v_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; return 0;
		else
			if [ -s "${v_path}" ]; then
				true > "${v_path}" || {
                    if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                        BU.Main.Errors.HandleSmallErrors 'E' \
                            "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to overwrite this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file --> $(BU.Main.Checkings.CheckFilePathExists "${v_path}" 'true')" 'E';
                    else
                        BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to overwrite this « ${__BU_MAIN_PROJECT_NAME} » project's file --> ${v_path}";
                        BU.Main.Echo.Newline;
                    fi

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                }
			fi

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi

    elif [ "${p_type}" == 'd' ]; then
		if [ -d "${v_path}" ]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
            mkdir -p "${v_path}" || {
                local returnCode="${?}";

                if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                    BU.Main.Errors.HandleSmallErrors 'E' \
                        "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's folder --> $(BU.Main.Checkings.CheckDirPathExists "${v_path}" 'true')" 'E';
                else
                    BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to create this « ${__BU_MAIN_PROJECT_NAME} » project's folder --> ${v_path}";
                    BU.Main.Echo.Newline;
                fi

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
            }
			BU.Main.Checkings.CheckDirPathWasCreated "${v_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
    fi
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS
#### DEBUG ID : "bu::main::checkings::text-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS="bu::main::checkings::text-checkings";

## FORMATTING CHECKINGS
## DEBUG ID : "formatting-checkings"

declare -r __BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS}::formatting-checkings";

# ························································
# Checking if the project's color code file exists or not.

# WARNING ! DO NOT CALL ANY "Decho<...>()" FUNCTION HERE, OR THE SCRIPT WILL LOOP FOREVER !!!

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - basename  |
#   - cat       |
#   - echo      |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Checkings.CheckProjectRelatedFile()   -> Main -> Checkings.lib (this file)

#   - BU.Main.Echo.Debug()                          -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                       -> Main -> Echo.lib
#   - BU.Main.Echo.Msg()                            -> Main -> Echo.lib

#   - BU.Main.Errors.HandleSmallErrors()            -> Main -> Errors.lib


# shellcheck disable=
function BU.Main.Checkings.CheckDecho()
{
    #**** Code ****
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS}";

    # If the text formatting is forbidden, then the "Decho()" function will not decorate the targeted text :
    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" == "false" ] || [ "${__BU_MAIN_STAT_DECHO,,}" == 'forbid' ]; then
        return 1;
    else
        # Creating the "fgcolor.tmp" (text color) file in case it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then
            if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}" 'f'; then
                BU.Main.Errors.HandleSmallErrors 'E' "Unable to create the $(BU.Main.Decho.Decho "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}") file" 'E' 'CPLS'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        # Creating the "bgcolor.tmp" (background color) file in case it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then
            if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}" 'f'; then
                BU.Main.Errors.HandleSmallErrors 'E' "Unable to create the $(BU.Main.Decho.Decho "${__BU_MAIN_PROJECT_COLOR_TEXT_BG_FILE_PATH}") file" 'E' 'CPLS'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        if [ -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ] && [ "$(cat "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")" == '' ]; then
            echo "${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" || \
            {
                # It's better to call the "BU.Main.Echo.Msg()" function, so that its redirection and debug process wil not have to be reprogrammed.
                # It's also better to not call the "BU.Main.Errors.HandleSmallErrors()" function here, so that there won't be any problem when this function calls the "Decho<...>()" functions.
                BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}()${__BU_MAIN_COLOR_TXT_WARNING}--> Warning : Unable to write any color code into the ${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}${__BU_MAIN_COLOR_TXT_WARNING} file." 'R' '';

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            }

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
	fi
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

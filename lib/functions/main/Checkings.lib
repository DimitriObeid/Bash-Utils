#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Checkings.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### OPERATING SYSTEM CHECKINGS
#### DEBUG ID : checkings::operating-system-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__OPERATING_SYSTEM_CHECKINGS="checkings::operating-system-checkings";

## OS TYPE CHECKINGS
## DEBUG ID : os-type-checkings

# shellcheck disable=SC2034
__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__OPERATING_SYSTEM_CHECKINGS__OS_TYPE_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__OPERATING_SYSTEM_CHECKINGS::os-type-checkings";

# Checking if current OS is Android, running with the Termux terminal emulator.
function BU::IsOSAndroidTermux()    { if [[ "$OSTYPE" == 'linux-android' ]];    then return 0; else return 1; fi }

# Checking if current OS is FreeBSD.
function BU::IsOSFreeBSD()          { if [[ "$OSTYPE" == 'FreeBSD' ]];          then return 0; else return 1; fi }

# Checking if current OS is Haiku OS.
function BU::IsOSHaiku()            { if [[ "$OSTYPE" == 'haiku' ]];            then return 0; else return 1; fi }

# Checking if current OS is OpenBSD.
function BU::IsOSOpenBSD()          { if [[ "$OSTYPE" == 'openbsd'* ]];         then return 0; else return 1; fi }

# Checking if current OS is Linux (or Android without the Termux terminal emulator).
function BU::IsOSLinux()            { if [[ "$OSTYPE" == 'linux'* ]];           then return 0; else return 1; fi }

# Checking if current OS is NetBSD.
function BU::IsOSNetBSD()           { if [[ "$OSTYPE" == 'netbsd' ]];           then return 0; else return 1; fi }

# Checking if current OS is OSx.
function BU::IsOSx()                { if [[ "$OSTYPE" == 'darwin'* ]];          then return 0; else return 1; fi }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### VARIABLES VALUES CHECKINGS
#### DEBUG ID : checkings::variable-values-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS="checkings::variable-values-checkings";

## ARRAYS CHECKINGS
## DEBUG ID : array-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS::array-checkings";

# Checking if the variable is an array.
function BU::IsArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS";

    if [[ -n ${1} ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if an array in empty.
function BU::IsArrayEmpty()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS";

    #**** Parameters ****
    local arr=("$@")

    #**** Code ****
    if [ ${#arr[@]} -eq 0 ]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}


function BU::IsArrayNotEmpty()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS";

    #**** Parameters ****
    local arr=("$@")

    #**** Code ****
    if [ ${#arr[@]} -gt 0 ]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## DATE FORMAT
## DEBUG ID : date-format

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS::date-format";

# Checking if a given hour is formatted in timestamp format, with separators, and in these formats :
#   - hh:mm:ss
function BU::IsDateHMS() { BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT"; [[ "$(date "+%H:%M:%S" > /dev/null)" ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats :
#   - YYYY-MM-DD
#   - DD-MM-YYYY
#   - YYYY/MM/DD
#   - DD/MM/YYYY
#   - YYYYMMDD
#   - DDMMYYYY
function BU::IsDateYMD() { BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT"; [[ $(date "+%d-%m-%Y" -d "$1" > /dev/null) ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats.
#   - YYYY-MM-DD hh:mm:ss
#   - DD-MM-YYYY hh:mm:ss
#   - YYYY/MM/DD hh:mm:ss
#   - DD/MM/YYYY hh:mm:ss
#   - YYYYMMDD hh:mm:ss
#   - DDMMYYYY hh:mm:ss
function BU::IsDateYMD_HMS()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT";

    #**** Variables ****
    local v_date; v_date="$(echo "$1" | rev | cut -d ' ' -f2- | rev)"; # Getting the year, the month and the day.
    local v_hour; v_hour="$(echo "$1" | rev | cut -d ' ' -f 1 | rev)"; # Getting the hour.

    #**** Code ****
    [[ $(BU::IsDateYMD "$v_date" > /dev/null) ]] || \
    {
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")() --> Warning : the date is not formatted in a correct timestamp";
        BU::EchoWarning "Please use one of these formats :";
        BU::EchoWarning "YYYY-MM-DD";
        BU::EchoWarning "DD-MM-YYYY";
        BU::EchoWarning "YYYY/MM/DD";
        BU::EchoWarning "DD/MM/YYYY";
        BU::Newline;

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    date "+%H:%M:%S" -d "$v_hour" || \
    {
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")() --> Warning : the hour is not formatted in a correct timestamp";
        BU::EchoWarning "Please use only this format : hh:mm:ss";
        BU::Newline;

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## NUMBER VALUES
## DEBUG ID : number-values

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS::number-values";

# Checking floating value.
function BU::IsFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

    if [[ "$1" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking negative only floating value.
function BU::IsNegativeFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

    if BU::IsFloat "$1" && (( 1 < 0 )); then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking positive only floating value.
function BU::IsPositiveFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

    if BU::IsFloat "$1" && (( 1 >= 0 )); then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking integer value.
function BU::IsInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

    if [[ "$1" =~ ^[\-0-9]+$ ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking negative only integer value.
function BU::IsNegativeInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

	if BU::IsInt "$1" && (( 1 < 0 )); then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking positive only integer value.
function BU::IsPositiveInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES";

	if BU::IsInt "$1" && (( 1 >= 0 )); then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# -----------------------------------------------

## CHARACTERS AND STRING VALUES
## DEBUG ID : characters-and-string-values

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS::characters-and-string-values";

# Checking if the value is an alphabetic character (not any number allowed).
function BU::IsAlphaChar()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

	if [[ "$1" = [a-zA-Z] ]]; then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking if the value is an alphabetic string (not any number allowed)
function BU::IsAlphaString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

    if [[ "$1" = [^a-zA-Z\ ] ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters AND not any number allowed).
function BU::IsAlphaStringOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "$1" = [^a-zA-Z\ ] ]]; then
			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

# Checking if the value is a character.
function BU::IsAlphaNumChar()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

	if [[ "$1" = [a-zA-Z0-9] ]]; then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking if the value is an alphanumeric string.
function BU::IsAlphaNumString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

    if [[ "$1" =~ [^a-zA-Z0-9\ ] ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters).
function BU::IsAlphaNumStringOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "$1" = [^a-zA-Z0-9\ ] ]]; then
			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

# -----------------------------------------------

## OTHER VARIABLES CHECKINGS
## DEBUG ID : other-variables-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__OTHER_VARIABLES_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS::other-variables-checkings";

# Checking if the variable is an array.
function BU::IsArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS" "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__OTHER_VARIABLES_CHECKINGS";

    if [[ -n ${1} ]]; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS
#### DEBUG ID : checkings::different-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS="checkings::different-checkings";

## CHECKING FOR IDENTIFIANTS
## DEBUG ID : checking-fort-identifiants

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS::checking-fort-identifiants";

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - BU::Main::Errors::HandleErrors      --> From this file.
function BU::Main::Checkings::CheckRootEUID()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS";

    if [ "$EUID" -ne 0 ]; then
        BU::Main::Errors::HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## BASIC HARDWARE CHECKINGS
## DEBUG ID : basic-hardware-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS::basic-hardware-checkings";

# Check if hard drive is full.
function BU::Main::Checkings::CheckDiskUsedSpace()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS";

	#**** Parameters ****
    local p_fileFS=$1;          # String    - Default : NULL    - Target file's file system.
    local p_authorization=$2;   # String    - Default : NULL    - Authorization to call the "BU::Main::Errors::HandleErrors()" function (since this function is called in the "BU::Main::Decho::SetBG/TextColor()" functions, and that "BU::__/Decho()" functions are called in the "BU::Main::Errors::HandleErrors()" function). Set this value to "false" to forbid this call.

	#**** Code ****

	# The function "BU::Main::Checkings::CheckProjectLogStatus()" function is called in each "Echo<...>()" functions if the "$__BU_MAIN_STAT_ECHO" status global
	# variable's value is set to 'false', and the current function is called at the beginning of the "BU::Main::Checkings::CheckProjectLogStatus()" function.

	# Changing the "$__BU_MAIN_STAT_ECHO" global status variable's value to 'true', in order to avoid an infinite
	# loop during the call of any function from the "Filesystem.lib" file, which call an "Echo<...>()" function.

	if [ "${__BU_MAIN_STAT_ECHO,,}" = 'false' ]; then
        local v_echoBackup="$__BU_MAIN_STAT_ECHO";

        # There is no need to call the associated function "BU::Main::Status::ChangeSTAT_ECHO", since no text have to be redirected to the log file afterwards, because the script has to definitely exit if the disk is full.
        __BU_MAIN_STAT_ECHO="true";
    fi

    BU::Main::Filesystem::IsPartitionFull "$p_fileFS";

    if [ "$?" -eq "$__BU_MAIN_EXIT_NO_SPACE_LEFT" ]; then

        local lineno="$(( LINENO -2 ))";

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU::Main::Status::ChangeSTAT_ERROR 'fatal' "${FUNCNAME[0]}" "$LINENO";

        if [ "${p_authorization,,}" = 'true' ]; then
            BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_CURRENT_CODE" \
                "NO SPACE LEFT ON THE TARGET FILE SYSTEM !!!" \
				"Please empty this file system (mounted on the « $(BU::Main::Filesystem::GetFSMountPoint "$p_fileFS") » partition) before using it, or use another partition to write data in a file [/|\] Since the file system's disk space is full, the script has to be exited in order to avoid potential bugs" \
                "No space left on the target device's partition" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; exit "$__BU_MAIN_EXIT_CURRENT_CODE";

        elif [ "${p_authorization,,}" = 'false' ] || [ -z "$p_authorization" ]; then
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : NO SPACE LEFT ON THE TARGET FILE SYSTEM !!!" >&2;
            echo "Please empty this file system (mounted on the « $(BU::Main::Filesystem::GetFSMountPoint "$p_fileFS") » partition) before using it, or use another partition to write data in a file" >&2;
            echo >&2;

            echo "Since the file system's disk space is full, the script has to be exited" >&2;
            echo >&2;

            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; exit "$__BU_MAIN_EXIT_CURRENT_CODE";
        fi
    fi

    # Resetting the former "$__BU_MAIN_STAT_ECHO" global status variable's value.
	if [ "${v_echoBackup,,}" = 'false' ]; then
        __BU_MAIN_STAT_ECHO="$v_echoBackup";
	fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKINGS
#### DEBUG ID : checkings::paths-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS="checkings::paths-checkings";

## DIRECTORIES PATHS CHECKINGS
## DEBUG ID : directories-paths-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS::directories-paths-checkings";

# Checking for an existent directory path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function BU::Main::Checkings::CheckDirPathExists()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS";

    #**** Parameters ****
    local p_path=$1;            # String    - Default : NULL    - Path of the (in)existent directory.
    local p_authorization=$2;   # String    - Default : NULL    - Authorization to call the "BU::__DechoHighlightPath()" function (since this function is called in the "BU::Main::Decho::SetBG/TextColor()" functions, and they are called in the "BU::__Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -d "$p_path" ] && [ "${p_authorization,,}" = 'true' ]; then
        BU::__DechoHighlightPath "<missing directory path>";  # Since this function should be called into a string, it's better to use a formatting function.

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -d "$p_path" ] && [ "${p_authorization,,}" = 'false' ] || [ -z "$p_authorization" ]; then
        printf "<missing directory path>"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking if a directory was successfully created.
function BU::Main::Checkings::CheckDirPathWasCreated()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS";

	#**** Parameters ****
    local p_path=$1;    # String - Path of the newly created directory.

	#**** Code ****
	if [ -d "$p_path" ]; then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# -----------------------------------------------

## FILES PATHS CHECKINGS
## DEBUG ID : files-path-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS::files-paths-checkings";

# Checking for an existent file path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function BU::Main::Checkings::CheckFilePathExists()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS";

    #**** Parameters ****
    local p_path=$1;            # String    - Default : NULL    - Path of the (in)existent file.
    local p_authorization=$2;   # String    - Default : NULL    - Authorization to call the "BU::__DechoHighlightPath()" function (since this function is called in the "BU::Main::Decho::SetBG/TextColor()" functions, and they are called in the "BU::__Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -f "$p_path" ] && [ "${p_authorization,,}" = 'true' ]; then
        BU::__DechoHighlightPath "<missing file path>";       # Since this function should be called into a string, it's better to use a formatting function.

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -f "$p_path" ] && [ "${p_authorization,,}" = 'false' ] || [ -z "$p_authorization" ]; then
        printf "<missing file path>"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Checking if a file was successfully created.
function BU::Main::Checkings::CheckFilePathWasCreated()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS";

	#**** Parameters ****
    local p_path=$1;    # String - Path of the newliy created file.

	#**** Code ****
	if [ -f "$p_path" ]; then
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking for "$__BU_MAIN_PROJECT_LOG_FILE_PATH"

# Required functions and files :
function BU::Main::Checkings::CheckProjectLogPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS";
 
    # Since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "BU::CheckProjectLogStatus()" function
    # (the only one where the "BU::Main::Checkings::CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
    if [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
		BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : no existing log file";
		BU::EchoNewstep "Creating a log file for the $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project";

		if ! BU::Main::Files::CreateProjectLogFile; then
			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
		else
			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		fi

    # Remember : since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "BU::CheckProjectLogStatus()" function
    # (the only one where the "BU::Main::Checkings::CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
     elif [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
         echo "$__BU_MAIN_PROJECT_LOG_FILE_PATH";

         BU::Main::Errors::HandleErrors "1" "BAD PATH PROVIDED INTO THE $(BU::DechoHighlightPath "__BU_MAIN_PROJECT_LOG_FILE_PATH") VARIABLE" \
             "Please correct the path passed as argument, or redefine the variable if its value was modified somewhere" \
             "$__BU_MAIN_PROJECT_LOG_FILE_PATH" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

 		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : 'nodate', '<an empty string>'
function BU::CheckProjectLogStatus()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS";

	# Checking first if the partition where the log file exists is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_LOG_FILE_PATH" 'true' || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; exit "$?"; };

    #**** Parameters ****
    local p_string=$1;      # Any       - Text to display.
    local p_option=$2;      # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");   # Array - More processing arguments (like the processing of a whole line-long string).

    #**** Variables ****
	# WARNING : DO NOT call any "BU::Echo<...>()" function from the "main/Echo.lib" file, as they all call the "BU::CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "BU::Main::Errors::HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same "BU::CheckProjectLogStatus()" function.

    # If you need to call a function here, please verify if it doesn't calls the "BU::CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "$__BU_MAIN_STAT_ECHO" status variable value to "true" BEFORE calling the wanted function.

    # -------------------------------------------

    # Setting the "$__BU_MAIN_STAT_DECHO" global status variable's value to 'restrict', in case an error occurs during a function call.

    # Also disabling a shellcheck warning, which is a false positive (saying that "$__BU_MAIN_STAT_DECHO" may not be assigned, but "$__BU_MAIN_STAT_ECHO" is (both of them are valid and working differently)).

    # shellcheck disable=SC2153
    local v_bu_stat_decho_old="$__BU_MAIN_STAT_DECHO"; BU::Main::Status::ChangeSTAT_DECHO "restrict" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || {
        local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

        return "$C";
    }

    # Setting the "$__BU_MAIN_STAT_ECHO" global status variable's value to 'true', in case an error occurs during a function call, where the "BU::CheckProjectLogStatus()" function or any other function that calls it might be called.
    local v_bu_stat_echo_old="$__BU_MAIN_STAT_ECHO"; BU::Main::Status::ChangeSTAT_ECHO "true"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { 
        local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

        return "$C";
    }

    local v_redirectionError;
        v_redirectionError="$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to write into the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.\nRedirection option --> ";

    local v_warning_array_value;
        v_warning_array_value="$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : incorrect argument given as extra argument array in $(BU::DechoHighlightPath "${BASH_SOURCE[0]}"), function $(BU::DechoHighlightFunction "${FUNCNAME[0]}()").\nValue --> $(BU::DechoHighlight "$val")\nLine -->";

    #**** Code ****
    # This checking must be done before the long condition below, since it needs to know if the project's log file is present.
    if [ "${__BU_MAIN_STAT_LOG,,}" = "true" ]; then
        BU::Main::Checkings::CheckProjectLogPath || \
        {
            local returnCode="$?";

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is stopped.
            BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }

            # Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is stopped.
            BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"     "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }

            return "$returnCode";
        };
    fi

    BU::Main::Status::CheckSTAT_LOG             "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }
    BU::Main::Status::CheckSTAT_LOG_REDIRECT    "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }
    BU::Main::Status::CheckSTAT_TIME_TXT        "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }

    # If a log file exists AND if "$__BU_MAIN_STAT_LOG" value is "false" AND if "$__BU_MAIN_STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ] && [ "${__BU_MAIN_STAT_LOG,,}" = "true" ]; then

        # If messages must be redirected in the log file only ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "log").
        if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" = "log" ]; then

            # Setting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_header="$__BU_MAIN_STAT_TIME_HEADER"; BU::Main::Status::ChangeSTAT_TIME_HEADER "0";

			# Setting the "$__BU_MAIN_STAT_TIME_NEWLINE" global status variable's value to 0 seconds, since no text is being displayed on the screen.
			local v_stat_time_newline="$__BU_MAIN_STAT_NEWLINE"; BU::Main::Status::ChangeSTAT_TIME_NEWLINE "0";

            # Setting the "$__BU_MAIN_STAT_TIME_TXT" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_txt="$__BU_MAIN_STAT_TIME_TXT"; BU::Main::Status::ChangeSTAT_TIME_TXT "0";

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }" 'n';
                            else
                                echo -ne "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }";
                            else
                                echo -e "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n';
                            else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                            else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                            fi
                            ;;
                    esac
                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "log" option)).
                else
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n';

                                # Since the "$__BU_MAIN_STAT_ECHO" status variable's value is set to 'true', this "BU::CheckProjectLogStatus()" function won't be called, only a minimalist substitute function.
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline;
							else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit 1; } && break;
							fi; BU::Newline;
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit 1; } && break;
							else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit 1; } && break;
							fi
                            ;;
                    esac
                fi
            done || return 1;

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            # Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"     "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            # Resetting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to the former timer.
            BU::Main::Status::ChangeSTAT_TIME_HEADER    "$v_stat_time_header"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            # Resetting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to the former timer.
            BU::Main::Status::ChangeSTAT_TIME_NEWLINE   "$v_stat_time_newline"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            # Resetting the "$__BU_MAIN_STAT_TIME_TXT" global status variable's value to the former timer.
            BU::Main::Status::ChangeSTAT_TIME_TXT       "$v_stat_time_txt"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            return 0;

        # Else, if messages must be redirected in the log file AND to the terminal ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "tee").
        elif [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" = "tee" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }" 'n';
                            else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }";
                            else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "${p_option,,}" in
                    '-n' | 'n')
                        if BU::Main::Status::CheckStatIsInitializing; then
                            BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n';
                        else
                            echo -ne "$p_string";
                            echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                        fi
                        ;;
                    '' | *)
                        if BU::Main::Status::CheckStatIsInitializing; then
                            BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                        else
                            echo -e "$p_string";
                            echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
                        fi
                        ;;
                    esac

                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "tee" option)).
                else
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
							else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
							fi; BU::Newline;
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
							else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; BU::Exit "1"; } && break;
							fi
                            ;;
                    esac
                fi
            done || return 1;

            sleep "$__BU_MAIN_STAT_TIME_TXT";

			# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
			BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
			BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

			return 0;

        # Else, if messages must not be redirected in the log file.
        else
            case "${p_option,,}" in
                '-n' | 'n')
                    if BU::Main::Status::CheckStatIsInitializing; then
                        BU::ModuleInit::Msg "$p_string";
                    else
                        echo -ne "$p_string";
                    fi
                    ;;
                '' | *)
                    if BU::Main::Status::CheckStatIsInitializing; then
                        BU::ModuleInit::Msg "$p_string";
                    else
                        echo -e "$p_string";
                    fi
                    ;;
            esac

            sleep "$__BU_MAIN_STAT_TIME_TXT";

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            # Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

            return 0;

        fi

    # Else, if no log file exists OR if "$__BU_MAIN_STAT_LOG" value is "false" OR if "$__BU_MAIN_STAT_LOG_REDIRECT" has no redirection value.
    else
        case "${p_option,,}" in
            '-n' | 'n')
                if BU::Main::Status::CheckStatIsInitializing; then
                    BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n';
                else
                    echo -ne "$p_string";
                fi
                ;;
            '' | *)
                if BU::Main::Status::CheckStatIsInitializing; then
                    BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                else
                    echo -e "$p_string";
                fi
                ;;
        esac

        sleep "$__BU_MAIN_STAT_TIME_TXT";

        # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
        BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

		# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
		BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

		return 0;
	fi

	# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
	BU::Main::Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

	# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
	BU::Main::Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Check project related file presence, or create this file.
function BU::Main::Checkings::CheckProjectRelatedFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS";

	#**** Parameters ****
    local p_parent=$1;  # String    - Default : NULL    - Name of the folder to process (into its parent directory).
    local p_child=$2;   # String    - Default : NULL    - Name of the file or folder to process (into its parent directory).
    local p_type=$3;    # Char      - Default : NULL    - Type of data to create (d = directory, f = file).
    local p_decho=$4;   # String    - Default : NULL    - 

	#**** Variables ****
    local v_path="$p_parent/$p_child";

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$v_path" 'true' || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; exit "$C"; };

	if [ -z "$p_decho" ] || [ -n "$p_decho" ] && [ "${p_decho,,}" = '--decho' ]; then
        if ! BU::Main::Args__Checkings::CheckProjectRelatedFile "$p_parent" "$p_child" "$p_type" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; fi
    fi

	if [ "$p_type" = 'f' ]; then
		if [ -f "$v_path" ]; then
			if [ -s "$v_path" ]; then
				true > "$v_path" || {
                    if [ -z "$p_decho" ] || [ -n "$p_decho" ] && [ "${p_decho,,}" = '--decho' ]; then
                        BU::Main::Errors::HandleSmallErrors 'E' \
                            "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to overwrite this $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::Main::Checkings::CheckFilePathExists "$v_path" 'true')" 'E';
                    else
                        BU::EchoError "${FUNCNAME[0]}() --> Error : unable to overwrite this « $__BU_MAIN_PROJECT_NAME » project's file --> $v_path";
                        BU::Newline;
                    fi

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
                }
			fi

			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		else
			if [ ! -d "$p_parent" ]; then
                mkdir -p "$p_parent" || {
                    local returnCode="$?";

                    if [ -z "$p_decho" ] || [ -n "$p_decho" ] && [ "${p_decho,,}" = '--decho' ]; then
                        BU::Main::Errors::HandleSmallErrors 'E' \
                            "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file's parent folder --> $(BU::Main::Checkings::CheckDirPathExists "$p_parent" 'true')" 'E';
                    else
                        BU::EchoError "${FUNCNAME[0]}() --> Error : unable to create this « $__BU_MAIN_PROJECT_NAME » project's file parent folder --> $p_parent";
                        BU::Newline;
                    fi

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$returnCode";
                }

				BU::Main::Checkings::CheckDirPathWasCreated "$p_parent" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
			fi

			touch "$v_path" || {
                local returnCode="$?";

                if [ -z "$p_decho" ] || [ -n "$p_decho" ] && [ "${p_decho,,}" = '--decho' ]; then
                    BU::Main::Errors::HandleSmallErrors 'E' \
                        "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::Main::Checkings::CheckFilePathExists "$v_path" 'true')" 'E';
                else
                    BU::EchoError "${FUNCNAME[0]}() --> Error : unable to overwrite this « $__BU_MAIN_PROJECT_NAME » project's file --> $v_path";
                    BU::Newline;
                fi

                BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$returnCode";
            }

			BU::Main::Checkings::CheckFilePathWasCreated "$v_path" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; return 0;
		fi

    elif [ "$p_type" = 'd' ]; then
		if [ -d "$v_path" ]; then
			BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		else
			mkdir -p "$v_path" || {
                local returnCode="$?";

                if [ -z "$p_decho" ] || [ -n "$p_decho" ] && [ "${p_decho,,}" = '--decho' ]; then
                    BU::Main::Errors::HandleSmallErrors 'E' \
                        "$(BU::__DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's folder --> $(BU::Main::Checkings::CheckDirPathExists "$v_path" 'true')" 'E';
                else
                    BU::EchoError "${FUNCNAME[0]}() --> Error : unable to create this « $__BU_MAIN_PROJECT_NAME » project's folder --> $v_path";
                    BU::Newline;
                fi

                BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$returnCode";
            }

			BU::Main::Checkings::CheckDirPathWasCreated "$v_path" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS
#### DEBUG ID : checkings::text-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS="checkings::text-checkings";

## FORMATTING CHECKINGS
## DEBUG ID : formatting-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS="$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS::formatting-checkings";

# Checking if the project's color code file exists or not.

# WARNING ! DO NOT CALL ANY "Decho<...>()" FUNCTION HERE, OR THE SCRIPT WILL LOOP FOREVER !!!
function BU::Main::Checkings::CheckDecho()
{
    #**** Code ****
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS";
 
    # If the text formatting is forbidden, then the "Decho()" function will not decorate the targeted text :
    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" = "false" ] || [ "${__BU_MAIN_STAT_DECHO,,}" = 'forbid' ]; then
        return 1;
    else
        # Creating the "fgcolors.tmp" (text color) file in case it doesn't exists.
        if [ ! -f "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" ]; then
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME" 'f'; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH") file" 'E' 'CPLS'; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        # Creating the "bgcolors.tmp" (background color) file in case it doesn't exists.
        if [ ! -f "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH" ]; then
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME" 'f'; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_TEXT_BG_FILE_PATH") file" 'E' 'CPLS'; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        if [ -f "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" ] && [ "$(cat "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH")" = '' ]; then
            echo "$__BU_MAIN_COLOR_TXT_RESET" > "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" || \
            {
                # It's better to call the "BU::EchoMsg()" function, so that its redirection and debug process wil not have to be reprogrammed.
                # It's also better to not call the "BU::Main::Errors::HandleSmallErrors()" function here, so that there won't be any problem when this function calls the "Decho<...>()" functions.
                BU::EchoMsg "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}()${__BU_MAIN_COLOR_TXT_WARNING}--> Warning : Unable to write any color code into the ${__BU_MAIN_COLOR_TXT_HIGHLIGHT}$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH${__BU_MAIN_COLOR_TXT_WARNING} file." 'R' '';

                BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            }

            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
	fi
}

# Checking if the "$__BU_MAIN_STAT_TXT_FMT" status value is set to "true".
function BU::Main::Checkings::CheckTextFormat()
{
    #**** Parameters ****
    #   $1  -> "tput" command's text formatting option.
    #   $2  -> Corresponding ANSI escape sequence (useful if the "tput" command is not detected or unavailable).

    #**** Code ****
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS" \
        "$__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS";

    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" = "true" ]; then
        if [ -n "$1" ]; then
			if command -v "tput" &> /dev/null; then

				# Formatting text with the tput command or directly with the backslash escapes.
				tput "$1" || echo -ne "\e[$2m";	# If the "tput" command fails, then the text is encoded with ANSI control sequences.

				BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
			else
				echo -ne "\e[$2m"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
			fi

        # In case there's no value passed as first argument (like if the wanted tput option is unknown), the script only echoes its ANSI escape sequence.
        else
            echo -ne "\e[$2m";

            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
        fi

    else
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# -----------------------------------------------

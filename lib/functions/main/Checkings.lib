#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Checkings.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### OPERATING SYSTEM CHECKINGS

## OS TYPE CHECKINGS

# Checking if current OS is Android, running with the Termux terminal emulator.
function BU::IsOSAndroidTermux()    { if [[ "$OSTYPE" == 'linux-android' ]];    then return 0; else return 1; fi }

# Checking if current OS is FreeBSD.
function BU::IsOSFreeBSD()          { if [[ "$OSTYPE" == 'FreeBSD' ]];          then return 0; else return 1; fi }

# Checking if current OS is Haiku OS.
function BU::IsOSHaiku()            { if [[ "$OSTYPE" == 'haiku' ]];            then return 0; else return 1; fi }

# Checking if current OS is OpenBSD.
function BU::IsOSOpenBSD()          { if [[ "$OSTYPE" == 'openbsd'* ]];         then return 0; else return 1; fi }

# Checking if current OS is Linux (or Android without the Termux terminal emulator).
function BU::IsOSLinux()            { if [[ "$OSTYPE" == 'linux'* ]];           then return 0; else return 1; fi }

# Checking if current OS is NetBSD.
function BU::IsOSNetBSD()           { if [[ "$OSTYPE" == 'netbsd' ]];           then return 0; else return 1; fi }

# Checking if current OS is OSx.
function BU::IsOSx()                { if [[ "$OSTYPE" == 'darwin'* ]];          then return 0; else return 1; fi }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### VARIABLES VALUES CHECKING

## ARRAYS CHECKINGS

# Checking if the variable is an array.
function BU::IsArray()
{
    if [[ -n ${1} ]]; then
        return 0;
    else
        return 1;
    fi
}

# Checking if an array in empty.
function BU::IsArrayEmpty()
{
    #**** Parameters ****
    local arr=("$@")

    #**** Code ****
    if [ ${#arr[@]} -eq 0 ]; then
        return 0;
    else
        return 1;
    fi
}


function BU::IsArrayNotEmpty()
{
    #**** Parameters ****
    local arr=("$@")

    #**** Code ****
    if [ ${#arr[@]} -gt 0 ]; then
        return 0;
    else
        return 1;
    fi
}

# -----------------------------------------------

## DATE FORMAT

# Checking if a given hour is formatted in timestamp format, with separators, and in these formats :
#   - hh:mm:ss
function BU::IsDateHMS() { [[ "$(date "+%H:%M:%S" > /dev/null)" ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats :
#   - YYYY-MM-DD
#   - DD-MM-YYYY
#   - YYYY/MM/DD
#   - DD/MM/YYYY
#   - YYYYMMDD
#   - DDMMYYYY
function BU::IsDateYMD() { [[ $(date "+%d-%m-%Y" -d "$1" > /dev/null) ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats.
#   - YYYY-MM-DD hh:mm:ss
#   - DD-MM-YYYY hh:mm:ss
#   - YYYY/MM/DD hh:mm:ss
#   - DD/MM/YYYY hh:mm:ss
#   - YYYYMMDD hh:mm:ss
#   - DDMMYYYY hh:mm:ss
function BU::IsDateYMD_HMS()
{
    #**** Variables ****
    local v_date; v_date="$(echo "$1" | rev | cut -d ' ' -f2- | rev)"; # Getting the year, the month and the day.
    local v_hour; v_hour="$(echo "$1" | rev | cut -d ' ' -f 1 | rev)"; # Getting the hour.

    #**** Code ****
    [[ $(BU::IsDateYMD "$v_date" > /dev/null) ]] || \
    {
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")() --> Warning : the date is not formatted in a correct timestamp";
        BU::EchoWarning "Please use one of these formats :";
        BU::EchoWarning "YYYY-MM-DD";
        BU::EchoWarning "DD-MM-YYYY";
        BU::EchoWarning "YYYY/MM/DD";
        BU::EchoWarning "DD/MM/YYYY";
        BU::Newline;

        return 1;
    };

    date "+%H:%M:%S" -d "$v_hour" || \
    {
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")() --> Warning : the hour is not formatted in a correct timestamp";
        BU::EchoWarning "Please use only this format : hh:mm:ss";
        BU::Newline;

        return 1;
    };

    return 0;
}

# -----------------------------------------------

## NUMBER VALUES

# Checking floating value.
function BU::IsFloat()
{
    if [[ "$1" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        return 0;
    else
        return 1;
    fi
}

# Checking negative only floating value.
function BU::IsNegativeFloat()
{
    if BU::IsFloat "$1" && (( 1 < 0 )); then
        return 0;
    else
        return 1;
    fi
}

# Checking positive only floating value.
function BU::IsPositiveFloat()
{
    if BU::IsFloat "$1" && (( 1 >= 0 )); then
        return 0;
    else
        return 1;
    fi
}

# Checking integer value.
function BU::IsInt()
{
    if [[ "$1" =~ ^[\-0-9]+$ ]]; then
        return 0;
    else
        return 1;
    fi
}

# Checking negative only integer value.
function BU::IsNegativeInt()
{
	if BU::IsInt "$1" && (( 1 < 0 )); then
		return 0;
	else
		return 1;
	fi
}

# Checking positive only integer value.
function BU::IsPositiveInt()
{
	if BU::IsInt "$1" && (( 1 >= 0 )); then
		return 0;
	else
		return 1;
	fi
}

# -----------------------------------------------

## CHARACTERS AND STRING VALUES

# Checking if the value is an alphabetic character (not any number allowed).
function BU::IsAlphaChar()
{
	if [[ "$1" = [a-zA-Z] ]]; then
		return 0;
	else
		return 1;
	fi
}

# Checking if the value is an alphabetic string (not any number allowed)
function BU::IsAlphaString()
{
    if [[ "$1" = [^a-zA-Z\ ] ]]; then
        return 0;
    else
        return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters AND not any number allowed).
function BU::IsAlphaStringOnly()
{
	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "$1" = [^a-zA-Z\ ] ]]; then
			return 0;
		else
    		return 1;
		fi
	fi
}

# Checking if the value is a character.
function BU::IsAlphaNumChar()
{
	if [[ "$1" = [a-zA-Z0-9] ]]; then
		return 0;
	else
		return 1;
	fi
}

# Checking if the value is an alphanumeric string.
function BU::IsAlphaNumString()
{
    if [[ "$1" =~ [^a-zA-Z0-9\ ] ]]; then
        return 0;
    else
        return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters).
function BU::IsAlphaNumStringOnly()
{
	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "$1" = [^a-zA-Z0-9\ ] ]]; then
			return 0;
		else
    		return 1;
		fi
	fi
}

# -----------------------------------------------

## OTHER VARIABLES CHECKINGS

# Checking if the variable is an array.
function BU::IsArray()
{
    if [[ -n ${1} ]]; then
        return 0;
    else
        return 1;
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS

## CHECKING FOR IDENTIFIANTS

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - BU::Main::Errors::HandleErrors      --> From this file.
function BU::Main::Checkings::CheckRootEUID()
{
    if [ "$EUID" -ne 0 ]; then
        BU::Main::Errors::HandleErrors "1" "YOU NEED ROOT USER'S PRIVILEGES TO PERFORM THIS ACTION !" "Please launch your script with super-user privileges." \
            "EUID = 0" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

        return 1;
    fi
}

# -----------------------------------------------

## BASIC HARDWARE CHECKINGS

# Check if hard drive is full.
function BU::Main::Checkings::CheckDiskUsedSpace()
{
	#**** Parameters ****
	local p_fileFS=$1;	# Target file's file system.

	#**** Code ****

	# The function "BU::Main::Checkings::CheckProjectLogStatus()" function is called in each "Echo<...>()" functions if the "$__BU_MAIN_STAT_ECHO" status global
	# variable's value is set to 'false', and the current function is called at the beginning of the "BU::Main::Checkings::CheckProjectLogStatus()" function.

	# Changing the "$__BU_MAIN_STAT_ECHO" global status variable's value to 'true', in order to avoid an infinite
	# loop during the call of any function from the "Filesystem.lib" file, which call an "Echo<...>()" function.

	if [ "$__BU_MAIN_STAT_ECHO" = 'false' ]; then
        local v_echoBackup="$__BU_MAIN_STAT_ECHO";

        # There is no need to call the associated function "BU::Main::Status::ChangeSTAT_ECHO", since no text have to be redirected to the log file afterwards, because the script has to definitely exit if the disk is full.
        __BU_MAIN_STAT_ECHO="true";
    fi

    BU::Main::Filesystem::IsPartitionFull "$p_fileFS";

    if [ "$?" -eq "$__BU_MAIN_EXIT_NO_SPACE_LEFT" ]; then

        local lineno="$LINENO";

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU::Main::Status::ChangeSTAT_ERROR 'fatal' "${FUNCNAME[0]}" "$LINENO";

        HandleErrors "$__BU_MAIN_EXIT_CURRENT_CODE" \
            "NO SPACE LEFT ON THE TARGET FILE SYSTEM !!!" \
            "Please empty this file system (mounted on the « $(BU::Main::Filesystem::GetFSMountPoint "$p_fileFS") » partition) before using it, or use another partition to write data on a file [/|\] Since the file system's disk space is full, the script has to be exited" \
            "No space left on the target device's partition" "$(basneame "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno";

            exit "$__BU_MAIN_EXIT_CURRENT_CODE";
    fi

    # Resetting the former "$__BU_MAIN_STAT_ECHO" global status variable's value.
	if [ "$v_echoBackup" = 'false' ]; then
        __BU_MAIN_STAT_ECHO="$v_echoBackup";
	fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKING

## DIRECTORIES PATHS CHECKING

# Checking for an existent directory path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function BU::Main::Checkings::CheckDirPathExists()
{
    #**** Parameters ****
    local p_path=$1;    # String - Path of the (in)existent directory.

    #**** Code ****
    if [ ! -d "$p_path" ]; then
        BU::DechoHighlightPath "<missing directory path>";  # Since this function should be called into a string, it's better to use a formatting function.

        return 1;
    fi

    return 0;
}

# Checking if a directory was successfully created.
function BU::Main::Checkings::CheckDirPathWasCreated()
{
	#**** Parameters ****
    local p_path=$1;    # String - Path of the newly created directory.

	#**** Code ****
	if [ -d "$p_path" ]; then
		return 0;
	else
		return 1;
	fi
}

# -----------------------------------------------

## FILES PATHS CHECKING

# Checking for an existent file path (for the "BU::Main::Errors::HandleErrors()" function mainly).
function BU::Main::Checkings::CheckFilePathExists()
{
    #**** Parameters ****
    local p_path=$1;    # String - Path of the (in)existent file.

    #**** Code ****
    if [ ! -f "$p_path" ]; then
        BU::DechoHighlightPath "<missing file path>";       # Since this function should be called into a string, it's better to use a formatting function.

        return 1;
    fi

    return 0;
}

# Checking if a file was successfully created.
function BU::Main::Checkings::CheckFilePathWasCreated()
{
	#**** Parameters ****
    local p_path=$1;    # String - Path of the newliy created file.

	#**** Code ****
	if [ -f "$p_path" ]; then
		return 0;
	else
		return 1;
	fi
}

# Checking for "$__BU_MAIN_PROJECT_LOG_FILE_PATH"

# Required functions and files :
function BU::Main::Checkings::CheckProjectLogPath()
{
    # Since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "BU::CheckProjectLogStatus()" function
    # (the only one where the "BU::Main::Checkings::CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
    if [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
		BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : no existing log file";
		BU::EchoNewstep "Creating a log file for the $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project";

		if ! BU::Main::Files::CreateProjectLogFile; then
			return 1;
		else
			return 0;
		fi

        # In case the "BU::Exit()" function doesn't stops the script's execution because the final user modified its behavior, it's safer to add a return value.
        BU::Exit; return 1;

    # Remember : since the "$__BU_MAIN_STAT_DECHO" and the "$__BU_MAIN_STAT_ECHO" status variables values are set to their safe mode in the "BU::CheckProjectLogStatus()" function
    # (the only one where the "BU::Main::Checkings::CheckProjectLogPath()" function can be called), it's safe to call an "BU::Echo<...>()" function, the "BU::Main::Errors::HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
     elif [ ! -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
         echo "$__BU_MAIN_PROJECT_LOG_FILE_PATH";

         BU::Main::Errors::HandleErrors "1" "BAD PATH PROVIDED INTO THE $(BU::DechoHighlightPath "__BU_MAIN_PROJECT_LOG_FILE_PATH") VARIABLE" \
             "Please correct the path passed as argument, or redefine the variable if its value was modified somewhere" \
             "$__BU_MAIN_PROJECT_LOG_FILE_PATH" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

 		return 1;
    else
        return 0;
    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : 'nodate', '<an empty string>'
function BU::CheckProjectLogStatus()
{
	# Checking first if the partition where the log file exists is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_LOG_FILE_PATH";

    #**** Parameters ****
    local p_string=$1;      # Any       - Text to display.
    local p_option=$2;      # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");   # Array - More processing arguments (like the processing of a whole line-long string).

    #**** Variables ****
	# WARNING : DO NOT call any "BU::Echo<...>()" function from the "main/Echo.lib" file, as they all call the "BU::CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "BU::Main::Errors::HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same "BU::CheckProjectLogStatus()" function.

    # If you need to call a function here, please verify if it doesn't calls the "BU::CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "$__BU_MAIN_STAT_ECHO" status variable value to "true" BEFORE calling the wanted function.

    # -------------------------------------------

    # Setting the "$__BU_MAIN_STAT_DECHO" global status variable's value to 'restrict', in case an error occurs during a function call.

    # Also disabling a shellcheck warning, which is a false positive (saying that "$__BU_MAIN_STAT_DECHO" may not be assigned, but "$__BU_MAIN_STAT_ECHO" is (both of them are valid and working differently)).
    
    # shellcheck disable=SC2153
    local v_bu_stat_decho_old="$__BU_MAIN_STAT_DECHO"; BU::Main:Status::ChangeSTAT_DECHO "restrict" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

    # Setting the "$__BU_MAIN_STAT_ECHO" global status variable's value to 'true', in case an error occurs during a function call, where the "BU::CheckProjectLogStatus()" function or any other function that calls it might be called.
    local v_bu_stat_echo_old="$__BU_MAIN_STAT_ECHO"; BU::Main:Status::ChangeSTAT_ECHO "true"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

    local v_redirectionError;
        v_redirectionError="$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to write into the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") file.\nRedirection option --> ";

    local v_warning_array_value;
        v_warning_array_value="$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : incorrect argument given as extra argument array in $(BU::DechoHighlightPath "${BASH_SOURCE[0]}"), function $(BU::DechoHighlightFunction "${FUNCNAME[0]}()").\nValue --> $(BU::DechoHighlight "$val")\nLine -->";

    #**** Code *****
    # This checking must be done before the long condition below, since it needs to know if the project's log file is present.
    if [ "$__BU_MAIN_STAT_LOG" = "true" ]; then
        BU::Main::Checkings::CheckProjectLogPath || \
        {
            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is stopped.
            BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is stopped.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

            return 1;
        };
    fi

    BU::Main::Status::CheckSTAT_LOG             "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
    BU::Main::Status::CheckSTAT_LOG_REDIRECT    "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
    BU::Main::Status::CheckSTAT_TIME_TXT        "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

    # If a log file exists AND if "$__BU_MAIN_STAT_LOG" value is "false" AND if "$__BU_MAIN_STAT_LOG_REDIRECT" has a redirection value.
    if [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ] && [ "$__BU_MAIN_STAT_LOG" = "true" ]; then

        # If messages must be redirected in the log file only ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "log").
        if [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "log" ]; then

            # Setting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_header="$__BU_MAIN_STAT_TIME_HEADER"; BU::Main:Status::ChangeSTAT_TIME_HEADER "0";

			# Setting the "$__BU_MAIN_STAT_TIME_NEWLINE" global status variable's value to 0 seconds, since no text is being displayed on the screen.
			local v_stat_time_newline="$__BU_MAIN_STAT_NEWLINE"; BU::Main::Status::ChangeSTAT_TIME_NEWLINE "0";

            # Setting the "$__BU_MAIN_STAT_TIME_TXT" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_txt="$__BU_MAIN_STAT_TIME_TXT"; BU::Main:Status::ChangeSTAT_TIME_TXT "0";

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }" 'n'
                            else
                                echo -ne "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }"
                            else
                                echo -e "$p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                            else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                            else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                    esac
                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "log" option)).
                else
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'

                                # Since the "$__BU_MAIN_STAT_ECHO" status variable's value is set to 'true', this "BU::CheckProjectLogStatus()" function won't be called, only a minimalist substitute function.
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline;
							else
                                echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							fi; BU::Newline;
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							else
                                echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "log")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							fi
                            ;;
                    esac
                fi

            done

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

			# Resetting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to the former timer.
			BU::Main:Status::ChangeSTAT_TIME_HEADER  "$v_stat_time_header";

			# Resetting the "$__BU_MAIN_STAT_TIME_HEADER" global status variable's value to the former timer.
			BU::Main::Status::ChangeSTAT_TIME_NEWLINE "$v_stat_time_newline";

			# Resetting the "$__BU_MAIN_STAT_TIME_TXT" global status variable's value to the former timer.
			BU::Main:Status::ChangeSTAT_TIME_TXT     "$v_stat_time_txt";

			return 0;

        # Else, if messages must be redirected in the log file AND to the terminal ("$__BU_MAIN_STAT_LOG_REDIRECT" value is equal to "tee").
        elif [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "tee" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" = 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }" 'n'
                            else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "${p_string#* ] }"
                            else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                            fi
                            ;;
                    esac

                # Else, if no argument is passed in "$pa_extraArgs" parameter array.
                elif [ -z "$val" ]; then
                    case "${p_option,,}" in
                    '-n' | 'n')
                        if BU::Main::Status::CheckStatIsInitializing; then
                            BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                        else
                            echo -ne "$p_string";
                            echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                        fi
                        ;;
                    '' | *)
                        if BU::Main::Status::CheckStatIsInitializing; then
                            BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                        else
                            echo -e "$p_string";
                            echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                        fi
                        ;;
                    esac

                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "tee" option)).
                else
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							else
                                echo -ne "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							fi; BU::Newline;
                            ;;
                        '' | *)
                            if BU::Main::Status::CheckStatIsInitializing; then
                                BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							else
                                echo -e "$p_string" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
                                BU::EchoWarning "$v_warning_array_value $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate' 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU::Newline >&2; BU::EchoError "$v_redirectionError $(BU::DechoHighlightVar "tee")\nLine --> $(BU::DechoHighlight "$LINENO")" "$p_option" 'nodate'; BU::Newline >&2; BU::Exit "1"; }
							fi
                            ;;
                    esac
                fi
            done

            sleep "$__BU_MAIN_STAT_TIME_TXT";

			# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"  "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
			BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			return 0;

        # Else, if messages must not be redirected in the log file.
        else
            case "${p_option,,}" in
                '-n' | 'n')
                    if BU::Main::Status::CheckStatIsInitializing; then
                        BU::ModuleInit::Msg "$p_string";
                    else
                        echo -ne "$p_string";
                    fi
                    ;;
                '' | *)
                    if BU::Main::Status::CheckStatIsInitializing; then
                        BU::ModuleInit::Msg "$p_string";
                    else
                        echo -e "$p_string";
                    fi
                    ;;
            esac

            sleep "$__BU_MAIN_STAT_TIME_TXT";

            # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

            # Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
            BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

            return 0;

        fi

    # Else, if no log file exists OR if "$__BU_MAIN_STAT_LOG" value is "false" OR if "$__BU_MAIN_STAT_LOG_REDIRECT" has no redirection value.
    else
        case "${p_option,,}" in
            '-n' | 'n')
                if BU::Main::Status::CheckStatIsInitializing; then
                    BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string" 'n'
                else
                    echo -ne "$p_string";
                fi
                ;;
            '' | *)
                if BU::Main::Status::CheckStatIsInitializing; then
                    BU::ModuleInit::Msg "$__BU_MAIN_TIME_DATE_DISPLAY $p_string"
                else
                    echo -e "$p_string";
                fi
                ;;
        esac

        sleep "$__BU_MAIN_STAT_TIME_TXT";

        # Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value, since the "BU::CheckProjectLogStatus()" function's execution is over.
        BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

		# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
		BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"   "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

		return 0;
	fi

	# Resetting the "$__BU_MAIN_STAT_DECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
	BU::Main:Status::ChangeSTAT_DECHO "$v_bu_stat_decho_old"    "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

	# Resetting the "$__BU_MAIN_STAT_ECHO" status variable's value to its former value if it was "false", since the "BU::CheckProjectLogStatus()" function's execution is over.
	BU::Main:Status::ChangeSTAT_ECHO "$v_bu_stat_echo_old"      "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

	return 0;
}

# Check project related file presence, or create this file.
function BU::Main::Checkings::CheckProjectRelatedFile()
{
	#**** Parameters ****
    local p_parent=$1;  # String    - Name of the folder to process (into its parent directory).
    local p_child=$2;   # String    - Name of the file or folder to process (into its parent directory).
    local p_type=$3;    # Char      - Type of data to create (d = directory, f = file).

	#**** Variables ****
    local v_path="$p_parent/$p_child";

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$v_path";

	if ! BU::Main::Args__Checkings::CheckProjectRelatedFile "$p_parent" "$p_child" "$p_type" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then exit 1; fi

	if [ "$p_type" = 'f' ]; then
		if [ -f "$v_path" ]; then
			if [ -s "$v_path" ]; then
				true > "$v_path" || { BU::Main::Errors::HandleSmallErrors 'E' "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to overwrite this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::DechoHighlightPath "$(BU::Main::Checkings::CheckFilePathExists "$v_path")")" 'E'; return 1; }
			fi

			return 0;
		else
			if [ ! -d "$p_parent" ]; then
                mkdir -p "$p_parent" || { BU::Main::Errors::HandleSmallErrors 'E' "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file's parent folder --> $(BU::DechoHighlightPath "$(BU::Main::Checkings::CheckDirPathExists "$p_parent")")" 'E'; return 1; }

				BU::Main::Checkings::CheckDirPathWasCreated "$p_parent" || return 1;
			fi

			touch "$v_path" || { BU::Main::Errors::HandleSmallErrors 'E' "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's file --> $(BU::DechoHighlightPath "$(BU::Main::Checkings::CheckFilePathExists "$v_path")")" 'E'; return 1; }

			BU::Main::Checkings::CheckFilePathWasCreated "$v_path" || return 1; return 0;
		fi

    elif [ "$p_type" = 'd' ]; then
		if [ -d "$v_path" ]; then
			return 0;
		else
			mkdir -p "$v_path" || { BU::Main::Errors::HandleSmallErrors 'E' "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : unable to create this $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME") project's folder --> $(BU::DechoHighlight "$(BU::Main::Checkings::CheckDirPathExists "$v_path")")" 'E'; return 1; }

			BU::Main::Checkings::CheckDirPathWasCreated "$v_path" || return 1; return 0;
		fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS

## FORMATTING CHECKINGS

# Checking if the project's color code file exists or not.

# WARNING ! DO NOT CALL ANY "Decho<...>()" FUNCTION HERE, OR THE SCRIPT WILL LOOP FOREVER !!!
function BU::Main::Checkings::CheckDecho()
{
    #**** Code ****
    # If the text formatting is forbidden, then the "Decho()" function will not decorate the targeted text :
    if [ "$__BU_MAIN_STAT_TXT_FMT" = "false" ] || [ "$__BU_MAIN_STAT_DECHO" = 'forbid' ]; then
        return 1;
    else
        # Creating the "fgcolors.tmp" (text color) file in case it doesn't exists.
        if [ ! -f "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" ]; then
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME" 'f'; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH") file" 'E' 'CPLS'; return 1;
            fi
        fi

        # Creating the "bgcolors.tmp" (background color) file in case it doesn't exists.
        if [ ! -f "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH" ]; then
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME" 'f'; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_TEXT_BG_FILE_PATH") file" 'E' 'CPLS'; return 1;
            fi
        fi

        if [ -f "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" ] && [ "$(cat "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH")" = '' ]; then
            echo "$__BU_MAIN_COLOR_TXT_RESET" > "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH" || \
            {
                # It's better to call the "BU::EchoMsg()" function, so that its redirection and debug process wil not have to be reprogrammed.
                # It's also better to not call the "BU::Main::Errors::HandleSmallErrors()" function here, so that there won't be any problem when this function calls the "Decho<...>()" functions.
                BU::EchoMsg "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}()${__BU_MAIN_COLOR_TXT_WARNING}--> Warning : Unable to write any color code into the ${__BU_MAIN_COLOR_TXT_HIGHLIGHT}$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH${__BU_MAIN_COLOR_TXT_WARNING} file." 'R' ''

                return 1;
            }

            return 0;
        else
            return 0;
        fi
	fi
}

# Checking if the "$__BU_MAIN_STAT_TXT_FMT" status value is set to "true".
function BU::Main::Checkings::CheckTextFormat()
{
    #**** Parameters ****
    #   $1  -> "tput" command's text formatting option.
    #   $2  -> Corresponding ANSI escape sequence (useful if the "tput" command is not detected or unavailable).

    #**** Code ****
    if [ "$__BU_MAIN_STAT_TXT_FMT" = "true" ]; then
        if [ -n "$1" ]; then
			if command -v "tput" &> /dev/null; then

				# Formatting text with the tput command or directly with the backslash escapes.
				tput "$1" || echo -ne "\e[$2m";	# If the "tput" command fails, then the text is encoded with ANSI control sequences.

				return 0;
			else
				echo -ne "\e[$2m"; return 0;
			fi

        # In case there's no value passed as first argument (like if the wanted tput option is unknown), the script only echoes its ANSI escape sequence.
        else
            echo -ne "\e[$2m"

            return 0;
        fi

    else
        return 0;
    fi
}

# -----------------------------------------------

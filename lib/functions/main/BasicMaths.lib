#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : BasicMaths.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# -----------------
# FILE DSCRIPTION :

#


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154


# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    if [[ "${LANG}" == de_* ]]; then
        echo -e "ACHTUNG !" >&2; echo >&2;
        echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
        echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

    elif [[ "${LANG}" == es_* ]]; then
        echo -e "ATENCIÓN !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
        echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

    elif [[ "${LANG}" == fr_* ]]; then
        echo -e "ATTENTION !" >&2; echo >&2;
        echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
        echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

    elif [[ "${LANG}" == hi_* ]]; then
        echo -e "चेतावनी!" >&2; echo >&2;
        echo -e "यह शेल स्क्रिप्ट (${BASH_SOURCE[0]}) सीधे निष्पादित करने के लिए नहीं है!" >&2; echo >&2;
        echo -e "इस स्क्रिप्ट को अपने प्रोजेक्ट स्क्रिप्ट में शामिल करके ही इस्तेमाल करें।" >&2;

    elif [[ "${LANG}" == id_* ]]; then
        echo -e "PERINGATAN !" >&2; echo >&2;
        echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
        echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

    elif [[ "${LANG}" == ja_* ]]; then
        echo -e "警告 ！" >&2; echo >&2;
        echo -e "このシェルスクリプト（${BASH_SOURCE[0]}）は、直接実行することはできません！" >&2; echo >&2;
        echo -e "このスクリプトは、プロジェクトスクリプトに含める必要があり、このスクリプトと一緒にしか使用できません。" >&2;

    elif [[ "${LANG}" == ko_* ]]; then
        echo -e "경고 !" >&2; echo >&2;
        echo -e "이 셸 스크립트(${BASH_SOURCE[0]})는 직접 실행하도록 설계되지 않았습니다!" >&2; echo >&2;
        echo -e "프로젝트 스크립트에 포함하여 이 스크립트만 사용하십시오." >&2;

    elif [[ "${LANG}" == pt_* ]]; then
        echo -e "ATENÇÃO !" >&2; echo >&2;
        echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
        echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

    elif [[ "${LANG}" == ru_* ]]; then
        echo -e "ВНИМАНИЕ !" >&2; echo >&2;
        echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
        echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

    elif [[ "${LANG}" == sv_* ]]; then
        echo -e "VARNING!" >&2; echo >&2;
        echo -e "Detta skalskript (${BASH_SOURCE[0]}) är inte avsett att köras direkt!" >&2; echo >&2;
        echo -e "Använd endast detta skript genom att inkludera det i ditt projektskript." >&2;

    elif [[ "${LANG}" == tr_* ]]; then
        echo -e "UYARI!" >&2; echo >&2;
        echo -e "Bu kabuk betiği (${BASH_SOURCE[0]}) doğrudan çalıştırılmak üzere tasarlanmamıştır!" >&2; echo >&2;
        echo -e "Proje kodunuza dahil ederek yalnızca bu kodu kullanın." >&2;

    elif [[ "${LANG}" == uk_* ]]; then
        echo -e "УВАГА !" >&2; echo >&2;
        echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
        echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

    elif [[ "${LANG}" == zh_* ]]; then
        echo -e "警告 !" >&2; echo >&2;
        echo -e "这个shell脚本(${BASH_SOURCE[0]})是不能直接执行的!" >&2; echo >&2;
        echo -e "只使用这个脚本并将其纳入你的项目脚本。" >&2;

    else
        echo -e "WARNING !" >&2; echo >&2;
        echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
        echo -e "Use only this script by including it in your project script." >&2;

    fi;
    
    echo >&2; 
    
    exit 1; 
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CONVERSIONS
#### DEBUG ID : "bu::main::basicmaths::conversions"

declare -r __BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS="bu::main::basicmaths::conversions";

## NUMERIC CONVERSIONS
## DEBUG ID : "numeric-conversions"

declare -r __BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMERIC_CONVERSIONS="${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}::numeric-conversions";

# ··············································································································
# Converts a byte count to a human readable format in IEC binary notation (base-1024 (eg : GiB)), rounded to two
# decimal places for anything larger than a byte. Switchable to padded format and base-1000 (eg : MB) if desired.

# Initial source of this AWK script (since it's not mine, plus I added more informations as comments, as well as the localization) :
# https://unix.stackexchange.com/questions/44040/a-standard-tool-to-convert-a-byte-count-into-human-kib-mib-etc-like-du-ls1/98790#98790

# My Wayback Machine snapshot (from Feb. 29th of 2024 - 22h 07m 08s), in case the the web page linked above no longer exists :
# https://web.archive.org/web/20240229220708/https://unix.stackexchange.com/questions/44040/a-standard-tool-to-convert-a-byte-count-into-human-kib-mib-etc-like-du-ls1/98790#98790


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - awk       | (-v)
#   - basename  |
#   - local     |
#   - printf    |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()              -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()           -> Main -> Echo.lib
#   - BU.Main.Echo.Msg()                -> Main -> Echo.lib


# shellcheck disable=
function BU.Main.BasicMaths.BytesToHuman()
{
    # This function call makes it easier for the user to find the current function and its executed
    # content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug \
        "main" \
        "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" \
        "${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}" \
        "${__BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMERIC_CONVERSIONS}";

    #**** Parameters ****
    local L_BYTES="${1:-0}"     # ARG TYPE : Int                - REQUIRED | DEFAULT VAL : 0        - DESC : Raw size in bytes.
    local L_PAD="${2:-no}"      # ARG TYPE : String             - REQUIRED | DEFAULT VAL : no       - DESC : Allow result display padding.
    local L_BASE="${3:-1024}"   # ARG TYPE : Int                - REQUIRED | DEFAULT VAL : 1024     - DESC : Base (1000 (metric) or 1024 (binary notation))
    local V_LANG="${4:-en}";    # ARG TYPE : ISO 639-1 code     - REQUIRED | DEFAULT VAL : en       - DESC : Localization of the byte count (default language : English).

    #**** Variables ****
    local BYTESTOHUMAN_RESULT;  # VAR TYPE : CMD                - DESC : This command stores the output of the executed "$(awk)" command.

    #**** Code ****
    if [[ "${L_PAD^^}" == N?(I|U)L?(L) ]]; then L_PAD='no'; fi

    # Creating a command substitution to calculate the byte count according to the values passed as arguments, with an AWK script.
    BYTESTOHUMAN_RESULT=$(awk -v bytes="${L_BYTES}" -v pad="${L_PAD}" -v base="${L_BASE}" -v lang="${V_LANG}" 'function human(x, pad, base, lang) {

        # If the desired base format is not the binary prefix, then the base format used will be the metric one.
        if(base!=1024)base=1000

        # Setting the prefixes list (K = kilo, M = mega, G = giga, T = tera, P = peta, E = exa, Z = zeta, Y = yotta), and corrected the inversion of the Exa with Peta, and Zeta with Yotta.
        if (lang == "fr") {
            # Condition ternaire : si le format de base utilise le préfixe binaire, cette unité "io" ([préfixe]bioctet) est affichée après la valeur. Sinon, cette unité "o" ([préfixe]octet) est affichée après la valeur.
            basesuf=(base==1024)?"io":"o"

            s="oKMGTPEZY"
        } else {
            # Ternary condition : if the base format uses the binary prefix, then the "iB" ([prefix]bibyte) unit is displayed after the value. Else the "[prefix]byte" unit is displayed after the value.
            basesuf=(base==1024)?"iB":"B"

            s="BKMGTPEZY"
        }

        # While the "x" ("human" function first parameter value) is superior or equal to the "base" (human function third parameter value) AND
        while (x>=base && length(s)>1)
               {x/=base; s=substr(s,2)}
        s=substr(s,1,1)

        if (lang == "fr") {
            xf=(pad=="yes") ? ((s=="o")?"%5d   ":"%8.2f") : ((s=="o")?"%d":"%.2f")
            s=(s!="o") ? (s basesuf) : ((pad=="no") ? s : ((basesuf=="io")?(s "  "):(s " ")))
        } else {
            xf=(pad=="yes") ? ((s=="B")?"%5d   ":"%8.2f") : ((s=="B")?"%d":"%.2f")
            s=(s!="B") ? (s basesuf) : ((pad=="no") ? s : ((basesuf=="iB")?(s "  "):(s " ")))
        }

        return sprintf( (xf " %s\n"), x, s)
    }

    BEGIN{print human(bytes, pad, base, lang)}')

    printf "%s" "${BYTESTOHUMAN_RESULT}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# ·································································
# Negative number (float or int) to positive number (float or int).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.BasicMaths.NegativeToPositive()
{
    #**** Parameters ****
    local x=${1:-$'\0'}; # ARG TYPE : Number    - REQUIRED | DEFAULT VAL : NULL     - Value to convert.

    #**** Code ****
    echo "$(( x = x < 0 ? x * -1 : x ))";

    return 0;
}

# ·································································
# Positive number (float or int) to negative number (float or int).


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.BasicMaths.PositiveToNegative()
{
    #**** Parameters ****
    local x=${1:-$'\0'}; # ARG TYPE  : Number   - REQUIRED | DEFAULT VAL : NULL     - Value to convert.

    #**** Code ****
    echo "$(( x = x > 0 ? x * -1 : x ))";

    return 0;
}

## ==============================================

## NUMBER FORMATTING
## DEBUG ID : "number-formatting"

declare -r __BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMBER_FORMATTING="${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}::number-formatting";

#
#


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured shell commands and their options(s) :
#   - echo      |
#   - local     |


# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - Feel free to call a function if it is needed for your contribution.

# shellcheck disable=
function BU.Main.BasicMaths.SeparateNumberEveryXDigits()
{
    if ! BU.DevBin.LibCompiler.Function.IsCompiler; then
        # This function call makes it easier for the user to find the current function and its executed
        # content if it is called during the execution of the main script with the "$(bash -x)" command.
        BU.Main.Echo.Debug \
            "main" \
            "$(basename "${BASH_SOURCE[0]}")" \
            "${FUNCNAME[0]}" \
            "${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}" \
            "${__BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMERIC_CONVERSIONS}";
    fi

    #**** Parameters ****
    local num=${1};            # ARG TYPE : Float   - REQUIRED | DEFAULT VAL : NULL - DESC : Number to format.
    local separator=${2:-','}; # ARG TYPE : Char    - OPTIONAL | DEFAULT VAL : ,    - DESC : Separator to add between the groups.
    local group_size=${3:-3};  # ARG TYPE : Int     - OPTIONAL | DEFAULT VAL : 3    - DESC : Number of digits per group.

    #**** Variables ****
    local integer_part;        # VAR TYPE : String  - DESC : Integer part of the number to process.
    local decimal_part;        # VAR TYPE : String  - DESC : Decimal part of the number to process (if it is a decimal number).
    local formatted_integer;   # VAR TYPE : String  - DESC : String that stores the integer part of the number being formatted.

    declare -i count;          # VAR TYPE : Int     - DESC : Counter of digits into a group.
    declare -i i;              # VAR TYPE : Int     - DESC : Number of digits making up the number transmitted as a value for the "${num}" argument.

    #**** Code ****
    # If the separator is longer than a single character, then only the first character is kept.
    if [ "${#separator}" -ge 1 ]; then
        separator="${separator:0:1}";
    fi

    # If the separator is a number, then the separator is replaced by the default character : a coma.
    if [[ "${separator}" == [0-9] ]]; then
        separator=',';
    fi

    # Calling the "BU.Main.Text.GetSubStringOccurences()" function in order to avoid storing the integer part in the unecessary "${decimal_part}" variable.
    if BU.Main.Text.GetSubStringOccurences "${num}" '.' > /dev/null; then
        # Extracting the integer part.
        integer_part="${num}";
    else
        # Extracting the integer part and the decimal part.
        integer_part=$(echo "${num}" | cut -d '.' -f 1);
        decimal_part=$(echo "${num}" | cut -d '.' -f 2);
    fi

    # \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    # Formatting the whole part into groups of X digits.

    # Initialization of the counter of digits into a group.
    count=0;

    # Getting the number of digits making up the number transmitted as a value for the "${num}" argument.
    i=$(( ${#integer_part} - 1 ));

    # While the main number's first digit is not processed yet, every digit composing the aforementioned number will be grouped.
    while [ "${i}" -ge 0 ]; do

        # Storing the newly reformatted integer part of the number being formatted.
        formatted_integer="${integer_part:$i:1}$formatted_integer";
        count=$((count + 1));

        # If the number of digits in a group is equal to the number set by the value of the "${group_size}" argument AND if the first number's digit is not reached yet,
        if [ "${count}" -eq "${group_size}" ] && [ "${i}" -ne 0 ]; then
            formatted_integer="${separator}${formatted_integer}";

            # Reinitializing the counter of digits into a group, so that the next group can be created.
            count=0;
        fi

        # Moving to the next main number's digit to process.
        i=$((i - 1));
    done

    # Add the decimal part if it exists.
    if [ -n "${decimal_part}" ]; then
        formatted_number="${formatted_integer}.${decimal_part}";
    else
        formatted_number="${formatted_integer}";
    fi

    echo "${formatted_number}";

    ! BU.DevBin.LibCompiler.Function.IsCompiler && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Filesystem.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### HARD DRIVE'S FILE SYSTEM PROCESSING

## GETTING FILE SYSTEM'S INFORMATIONS

# Getting the file system path.
function BU::Main::Filesystem::GetFSDevice()
{
    #**** Parameters ****
    local p_path=$1;    # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's device";

    BU::IsOSHaiku && local v_cmd="df \"$p_path\"        | awk 'FNR == 5 {print \$2}' || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$1}' || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    eval "$v_cmd";

    return "$v_code";
}

# Getting the total size in bytes allocated to a given file system.
function BU::Main::Filesystem::GetFSTotalSize()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's total size in bytes";

    BU::IsOSHaiku && local v_cmd="df \"$p_path\"        | awk 'FNR == 9 {print \$3\" \"\$4}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$3}'            || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    eval "$v_cmd";

    return "$v_code";
}

# Getting the mounted partition of a given file system.
function BU::Main::Filesystem::GetFSMountPoint()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's mount point";

    BU::IsOSHaiku && local v_cmd="df \"$p_path\"        | awk 'FNR == 2 {print \$3}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$7}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    eval "$v_cmd";

    return "$v_code";
}

# Getting the used size in bytes of a given file system.
function BU::Main::Filesystem::GetFSUsedSizeBytes()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's used size in bytes";

    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$4}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    # Since no used size in bytes is provided by the "df" command on Haiku, it's necessary to check it manually.
    BU::IsOSHaiku && {
        # Getting the file system's total size in bytes.
        local v_totalSize="$(BU::Main::Filesystem::GetFSTotalSize "$p_path" || return "$__BU_MAIN_EXIT_CURRENT_CODE")";

        # Getting the file system's available size in bytes.
        local v_availableSize="$(BU::Main::Filesystem::GetFSAvailableSize "$p_path" || return "$__BU_MAIN_EXIT_CURRENT_CODE")";

        # Getting the used size by substracting the available size from the total size.
        local v_usedSize="$(( v_totalSize - v_availableSize ))";

        BU::EchoMsg "$v_usedSize" '-n' 'nodate';

        return "$v_code";
    }

    eval "$v_cmd";

    return "$v_code";
}

# Getting the percentage of the used space of a given file system.
function BU::Main::Filesystem::GetFSUsedSizePercent()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's used size percentage";

    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$6}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    # Since no used partition size percentage is provided by the "df" command on Haiku, it's necessary to check it manually.
    BU::IsOSHaiku && {
        # Getting the file system's total size in bytes.
        local v_totalSize="$(BU::Main::Filesystem::GetFSTotalSize "$p_path" || return "$__BU_MAIN_EXIT_CURRENT_CODE")";

        # Getting the file system's available size in bytes.
        local v_availableSize="$(BU::Main::Filesystem::GetFSAvailableSize "$p_path" || return "$__BU_MAIN_EXIT_CURRENT_CODE")";

        # Getting the used percentage.
        local v_usedSize="$(( v_totalSize * v_availableSize / 100 ))";

        BU::EchoMsg "$v_usedSize%" '-n' 'nodate';

        return "$v_code";
    }

    eval "$v_cmd";

    return "$v_code";
}


# Getting the available size in bytes of a given file system.
function BU::Main::Filesystem::GetFSAvailableSize()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's available size in bytes";

    BU::IsOSHaiku && local v_cmd="df \"$p_path\"        | awk 'FNR == 10 {print \$3}'       || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$5}'        || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    eval "$v_cmd";

    return "$v_code";
}

# Getting the type of the file system of a directory or a file.
function BU::Main::Filesystem::GetFSType()
{
    #**** Parameters ****
    local p_path=$1     # String    - Path of the file or the folder to process.

    #**** Variables ****
    local v_code=0;     # Int       -  Return code to modify in the "$v_cmd" string.

    local v_warn; v_warn="$(BU::DechoHighlightFunction "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU::DechoHighlightPath "$p_path") file system's type";

    BU::IsOSHaiku && local v_cmd="df \"$p_path\"        | awk 'FNR == 4 {print \$3}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU::IsOSLinux && local v_cmd="df -Th \"$p_path\"    | awk 'FNR == 2 {print \$2}'    || { BU::EchoWarning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU::Main::CMDS::GetCommandReturnOutputValue "$v_cmd"; then return 1; fi

    eval "$v_cmd";

    return "$v_code";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PERMISSION AND OWNERSHIP PROCESSING

## RECURSIVE PERMISSION AND OWNERSHIP PROCESSING

# Calling the "chown" command to change recursively directory ownership

# Required functions and files into the "Bash-Utils/src/functions" folder :
#	- BU::Main::Checkings::CheckRootEUID		-> Checkings.lib
#	- BU::EchoError			-> Echo.lib
#	- BU::EchoNewstep		-> Echo.lib
#	- BU::EchoSuccess		-> Echo.lib
#	- BU::Newline			-> Echo.lib
#	- BU::Main::Errors::HandleErrors		-> Headers.lib
function BU::Main::Permissions::ChownRec()
{
    #**** Paramètres ****
    local p_currentOwner=$1;   # This parameter is used in the messages.
    local p_newOwner=$2;
    local p_path=$3;

    #**** Code ****
    # The "chown" command has to be used with super-user privileges,
    BU::Main::Checkings::CheckRootEUID;

    # If the path passed as argument doesn't exists.
    if [ ! -d "$p_path" ]; then
        BU::Main::Errors::HandleErrors "1" "" "" "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";
    fi

    BU::EchoNewstep "Recursive change of the ownership rights of the new folder $(BU::DechoHighlightPath "$p_path/") from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner")";
	BU::Newline;

    # On change les droits du fichier créé par le script.
	# Comme il est exécuté en mode super-utilisateur, tout dossier ou fichier créé appartient à l'utilisateur root.
	# Pour attribuer les droits de lecture, d'écriture et d'exécution (rwx) à l'utilisateur normal, on appelle
	# la commande chown avec pour arguments :
	#		- Le nom de l'utilisateur à qui donner les droits.
	#		- Le chemin du dossier cible.
	if chown -Rv "$p_newOwner" "$p_path"; then
		BU::EchoSuccess "The rights of the $(BU::DechoHighlightPath "$p_path/") folder have been successfully changed from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner")";
		BU::Newline;

		return 0;
	else
        BU::EchoError "Unable to change the rights of the $(BU::DechoHighlightPath "$p_path/") folder";
		BU::Newline;

		return 1;
    fi
}

# -----------------------------------------------

## NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING

# Fonctions d'attribution de propriété de fichier à l'utilisateur.

# Required functions and files into the "Bash-Utils/src/functions" folder :
#   - BU::Main::Checkings::CheckRootEUID -> Checkings.lib
#   - BU::EchoError     -> Echo.lib
#   - BU::EchoNewstep   -> Echo.lib
#   - BU::EchoSuccess   -> Echo.lib
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Permissions::Chown()
{
    #**** Parameters ****
    p_currentOwner=$1;  # This parameter is used in the translated messages, stored into their own variables.
    p_newOwner=$2;      # New owner of the directory / file.
    p_path=$3;          # Path of the directory / file to process.
    p_option=$4;        # Recursive swapping or not.

    #**** Code ****
    # The "chown" command has to be used with super-user privileges,
    BU::Main::Checkings::CheckRootEUID;

    # If the path passed as argument doesn't exists.
    if [ -d "$p_path" ]; then
        BU::EchoNewstep "Changing the ownership rights of the  $(BU::DechoHighlightPath "$p_path/") folder from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner").";
        BU::Newline;

        # Changing ownership recursively.
        case "$p_option" in
            'R')
                if chown -Rv "$p_newOwner" "$p_path"; then
                    BU::EchoSuccess "The rights of the $(BU::DechoHighlightPath "$p_path") folder have been successfully changed from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner")";
                    BU::Newline;

                    return 0;
                else
                    BU::Main::Errors::HandleErrors "1" "Unable to change the rights of the $(BU::DechoHighlight "$p_path/") folder" "" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-7 ))";
                    BU::Newline;

                    return 1
                fi
                ;;
            '')
                # Changing ownership non-recursively.
                if chown -v "$p_newOwner" "$p_path"; then
                    BU::EchoSuccess "The rights of the $(BU::DechoHighlightPath "$p_path") folder have been successfully changed from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner")";
                    BU::Newline;

                    return 0;

                else
                    BU::Main::Errors::HandleErrors "1" "UNABLE TO CHANGE THE RIGHTS OF THE $(BU::DechoHighlightPath "$p_path/") FOLDER" \
                        "Please run the script with the command $(BU::DechoHighlight "bash -x $PROJECT_NAME") to check what happened" \
                        "$p_option" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-11 ))";
                    BU::Newline;

                    return 1
                fi
                ;;
            *)
                BU::Main::Errors::HandleErrors "1" "THE $(BU::DechoHighlightFunction "${FUNCNAME[0]}")'S FUNCTION $(BU::DechoHighlightPath "$p_option") OPTION PASSED AS 4TH ARGUMENT IS NOT SUPPORTED" \
                    "The supported options for directory processing are :" "$p_option" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-2 ))";
                ;;
        esac


    else
        # Checking first if the path is a filepath. If not, then no correct path is passed as argument.
        if [ -f "$p_path" ]; then
            BU::EchoNewstep "Changing the ownership rights of the  $(BU::DechoHighlightPath "$p_path/") file from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner").";
            BU::Newline;

            # Changing ownership
            if chown -v "$p_newOwner" "$p_path"; then
                BU::EchoSuccess "The rights of the $(BU::DechoHighlightPath "$p_path") file have been successfully changed from $(BU::DechoHighlight "$p_currentOwner") to $(BU::DechoHighlight "$p_newOwner").";
                BU::Newline;

                return 0;
            else
                BU::Main::Errors::HandleErrors "$?" "Unable to change the rights of the $(BU::DechoHighlightPath "$p_path") file !";
                BU::Newline;

                return 1
            fi
        else
            BU::Main::Errors::HandleErrors "1" "THE $(BU::DechoHighlightPath "$p_path") FILE DOESN'T EXISTS" && return 1;
        fi
    fi
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

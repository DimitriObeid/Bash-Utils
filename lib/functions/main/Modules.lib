#!/usr/bin/env bash

# ---------------------
# FILE'S INFORMATIONS :

# Name          : Modules.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ----------------------
# SCRIPT'S DESCRIPTION :

# This modules manager script provides functions used for managing the new modules to include after the initialization of the Bash Utils framework.


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the "$(shellcheck)" command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2;

elif [[ "${LANG}" == hi_* ]]; then
    echo -e "चेतावनी!" >&2; echo >&2;
    echo -e "यह शेल स्क्रिप्ट (${BASH_SOURCE[0]}) सीधे निष्पादित करने के लिए नहीं है!" >&2; echo >&2;
    echo -e "इस स्क्रिप्ट को अपने प्रोजेक्ट स्क्रिप्ट में शामिल करके ही इस्तेमाल करें।" >&2;

elif [[ "${LANG}" == id_* ]]; then
    echo -e "PERINGATAN !" >&2; echo >&2;
    echo -e "Skrip shell ini (${BASH_SOURCE[0]}) tidak dimaksudkan untuk dieksekusi secara langsung !" >&2; echo >&2;
    echo -e "Gunakan skrip ini hanya dengan memasukkannya ke dalam skrip proyek Anda." >&2;

elif [[ "${LANG}" == ja_* ]]; then
    echo -e "警告 ！" >&2; echo >&2;
    echo -e "このシェルスクリプト（${BASH_SOURCE[0]}）は、直接実行することはできません！" >&2; echo >&2;
    echo -e "このスクリプトは、プロジェクトスクリプトに含める必要があり、このスクリプトと一緒にしか使用できません。" >&2;

elif [[ "${LANG}" == ko_* ]]; then
    echo -e "경고 !" >&2; echo >&2;
    echo -e "이 셸 스크립트(${BASH_SOURCE[0]})는 직접 실행하도록 설계되지 않았습니다!" >&2; echo >&2;
    echo -e "프로젝트 스크립트에 포함하여 이 스크립트만 사용하십시오." >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2;

elif [[ "${LANG}" == tr_* ]]; then
    echo -e "UYARI!" >&2; echo >&2;
    echo -e "Bu kabuk betiği (${BASH_SOURCE[0]}) doğrudan çalıştırılmak üzere tasarlanmamıştır!" >&2; echo >&2;
    echo -e "Proje kodunuza dahil ederek yalnızca bu kodu kullanın." >&2;

elif [[ "${LANG}" == uk_* ]]; then
    echo -e "УВАГА !" >&2; echo >&2;
    echo -e "Цей скрипт оболонки (${BASH_SOURCE[0]}) не призначений для безпосереднього виконання !" >&2; echo >&2;
    echo -e "Використовуйте тільки цей скрипт, включивши його в скрипт вашого проекту." >&2;

elif [[ "${LANG}" == zh_* ]]; then
    echo -e "警告 !" >&2; echo >&2;
    echo -e "这个shell脚本(${BASH_SOURCE[0]})是不能直接执行的!" >&2; echo >&2;
    echo -e "只使用这个脚本并将其纳入你的项目脚本。" >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
    echo -e "Use only this script by including it in your project script." >&2;

fi; echo >&2; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### MODULES FILES
#### DEBUG ID : "bu::main::modules::modules-files"

declare -r __BU_MAIN_MODULES_LIB__CAT_DEBUG_ID__MODULES_FILES='bu::main::modules::modules-files';

## SHELLCHECK
## DEBUG ID : ""

declare -r __BU_MAIN_MODULES_LIB__SUBCAT_DEBUG_ID__MODULES_FILES_="${__BU_MAIN_MODULES_LIB__CAT_DEBUG_ID__MODULES_FILES}::";

## NOTE : At this point, the "${__BU_MODULE_INIT_MSG__}" variables values are deleted. Do not add message variables related to the following functions in the initializer file's languages files.

# ···························································································································································································································
# Initializing a single new module after the successful initialization of the main module, in case another module must be added later in the project's script, after the execution of the "BashUtils_InitModules()" function.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Errors.HandleErrors() -> Main -> Errors.lib

#   - BashUtils_InitModules._()     -> Main -> Modules initializer script.

# shellcheck disable=
function BU.Main.Modules.InitNewModule()
{
    #**** Parameters ****
    local p_newmodule=${1:-$'\0'};  # String    - Default : NULL    - Name of the module to include.

    #**** Code ****
    # If no module name is passed as argument.
    if [ -z "${p_newmodule}" ]; then local lineno="${LINENO}";
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULE NAME PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass a module name when you call the « %s » module initialization function" "${FUNCNAME[0]}")" \
			"No new module name passed as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return 1;
    else
        BashUtils_InitModules._ "${p_newmodule}" || return 1;

        return 0;
    fi
}

# ································································································································································································································
# Initializing more than one new modules after the successful initialization of the main module, in case other modules must be added later in the project's script, after the execution of the "BashUtils_InitModules()" function.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Errors.Exit()                     -> Main -> Errors.lib
#   - BU.Main.Errors.HandleErrors()             -> Main -> Errors.lib

#   - BU.Main.Headers.Header.Aqua.Turquoise()   -> Main -> Headers.lib

#   - BU.Main.Modules.InitNewModule()           -> Main -> Modules.lib (this file)

#   - BashUtils_InitModules._()     -> Main -> Modules initializer script.

# shellcheck disable=
function BU.Main.Modules.InitNewModules()
{
	#**** Parameters ****
	local p_modules_list=("${@}"); # Array    - Default : NULL    - List of the new modules to init.

	#**** Variables (global) ****

	#**** Variables (local) ****
    # local v_index=0;    # Index of the currently processed module (incremented at each loop's iteration). ALWAYS BEGIN WITH THE '0' VALUE !!!
    local v_loop_error; # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

	#**** Code ****
	# Checking if the arguments array length is equal to zero (no arguments passed).
	if [ -z "${p_modules_list[*]}" ]; then local lineno="${LINENO}";
        # shellcheck disable=SC2059
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULES NAMES PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass one or more modules names when you call the « %s » modules initialization function" "${FUNCNAME[0]}")" \
			"No new module(s) name(s) passed as argument(s)" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

		return 1;
    else
        # At this point, the main module is initialized, so its functions can be called safely.
        BU.Main.Headers.Header.Aqua.Turquoise "";

        BashUtils_InitModules._ "${p_modules_list[@]}" || return 1;

        if [ "${v_loop_error}" == 'error' ]; then
            BU.Main.Errors.Exit 1;

            return "${?}";
        fi

        return 0;
	fi
}

# ···················································
# Sourcing a single aliases file for a single module.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   -

# shellcheck disable=
function BU.ModuleInit.SourceAliasesFile()
{
    return 0;
}

# ················································
# Sourcing multiple aliases files for each module.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.ModuleInit.SourceAliasFile() -> Modules initializer script (this file)

# shellcheck disable=
function BU.ModuleInit.SourceAliasesFiles()
{
    return 0;
}

# ·························
# Unsource a single module.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Newline()

#   - BU.Main.Errors.HandleErrors()     -> Main -> Errors.lib

#   - BU.Main.Headers.Newstep()         -> Main -> Headers.lib

#   - BU.UnsourceExceptionFunctions()   -> From the file processed by the function's major condition.
#   - BU.UnsourceExceptionVariables()   -> From the file processed by the function's major condition.

# shellcheck disable=
function BU.ModuleInit.UnsourceModule()
{
    #**** Parameters ****
    local p_module=${1:-$'\0'};  # String    - Default : NULL    - Name of the module to unsource.

    #**** Code ****
    # If no module name is passed as argument.
    if [ -z "${p_module}" ]; then local lineno="${LINENO}";
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULE NAME PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass a module name when you call the « %s » module unsourcing function" "${FUNCNAME[0]}")" \
			"No module name passed as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return 1;
    else
        # Checking if the main module is passed as argument, to prevent its unsourcing.
        if [[ "${p_module}" == [Mm][Aa][Ii][Nn] ]]; then
            BU.Main.Errors.HandleErrors '1' "$(printf "%s YOU TRIED TO UNSOURCE THE MAIN MODULE" "$(BU.Main.Decho.__Decho.Yellow "WARNING :")")" \
                "Calling the main module as argument would unsource every files related to the main module, thus making the main functions of the framework unusable" \
                "$(printf "Main module passed as argument to the %s function" "${FUNCNAME[0]}")" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";
        else
            BU.Main.Headers.Newstep "UNSOURCING THE ${p_module^^} MODULE";
            BU.Main.Echo.Newline;

            # Unsourcing functions whose names does not follow the advised Bash Utils coding style.
            if  [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.sh"                                           'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.sh"                                 'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.sh"                               'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.Unsource.sh"                      'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.UnsourceExceptions.sh"            'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.UnsourceExceptions.sh"  'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.Unsource.sh"                               'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.UnsourceExceptions.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.Unsource.${p_module}.sh"                   'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.UnsourceExceptions.${p_module}.sh"         'f' 'shut' 'unsourceexcept')" ]]; then

                    v_module_unsourceexcept_file_name="$(basename "$(cat "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.unsourceexcept.tmp")")";

                    # Sourcing the file to get every functions and variables names, in order to unset each of them.

                    # shellcheck disable=SC1090
                    source "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_unsourceexcept_file_name}" 'f')" || {
                        BU.Main.Errors.HandleErrors "1" \
                            "UNABLE TO SOURCE THE ${p_module} MODULE'S UNSOURCER FILE" \
                            "" "" \
                            "$(basename "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 1 ))")";
                    };

                    # Calling the "BU.UnsourceExceptionFunctions()" function (defined in the "${v_module_unsourceexcept_file_name}" file),
                    # which calls the "$(unset ${function})" command before each function name in order to unsource it.
                    BU.UnsourceExceptionFunctions;

                    # Calling the "BU.UnsourceExceptionVariables()" function (defined in the "${v_module_unsourceexcept_file_name}" file),
                    # which calls the "$(unset ${variable})" command before each variable name in order to unsource it.
                    BU.UnsourceExceptionVariables;

                    return 0;
            fi

            # Unsetting every functions from the target module (DO NOT QUOTE THE $(compgen -v ...) COMMAND SUBSTITUTION !!!).
            # unset -f $(compgen -c "BU.${p_module}.");

            # Unsetting every variables from the target module (DO NOT QUOTE THE $(compgen -v ...) COMMAND SUBSTITUTION !!!).
            # unset $(compgen -v "__BU_${p_module^^}_");

            return 0;
        fi
    fi
}

# ·····················································
# Unsourcing multiple modules at once from the project.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Errors.HandleErrors()             -> Main -> Errors.lib

#   - BU.Main.Headers.Header.Aqua.Turquoise()   -> Main -> Headers.lib

#   - BU.ModuleInit.Exit()                      -> Modules initializer script (this file)
#   - BU.ModuleInit.UnsourceModule()            -> Modules initializer script (this file)

# shellcheck disable=
function BU.ModuleInit.UnsourceModules()
{
    #**** Parameters ****
    local p_modules_list=("${@}");  # Array     - Default : NULL    - List of the modules to unsource.

    #**** Code ****
	# Checking if the arguments array length is equal to zero (no arguments passed).
	if [ -z "${p_modules_list[*]}" ]; then local lineno="${LINENO}";
        # shellcheck disable=SC2059
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULES NAMES PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass one or more module name when you call the « %s » modules unsourcing function" "${FUNCNAME[0]}")" \
			"No module(s) name(s) passed as argument(s)" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

		return 1;
    else
        # At this point, the main module is initialized, so its functions can be safely called.
        BU.Main.Headers.Header.Aqua.Turquoise "";

        for i in "${p_modules_list[@]}"; do
            BU.ModuleInit.UnsourceModule "${i}" || { v_loop_error='error'; break; };
        done

        if [ "${v_loop_error}" == 'error' ]; then BU.ModuleInit.Exit 1; return "${?}"; fi

        return 0;
	fi
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MODULES TRANSLATIONS

## MISC FUNCTIONS DEFINITION

# ·················································································································
# Remaking the "BU.Main.Errors.HandleErrors()" function in order to make it working for the initialization process.

# If the framework is not into its initialization process, then the classic "BU.Main.Errors.HandleErrors()" function is called.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Errors.HandleErrors() -> Main -> Errors.lib

#   - BU.ModuleInit.AskPrintLog()   -> Modules initializer script (this file)
#   - BU.ModuleInit.MsgTerminate()  -> Modules initializer script (this file)

# shellcheck disable=
function BU.ModuleInit.HandleErrors()
{
    #**** Parameters ****
    local p_returnCode=${1:-0}          # Int       - Default : NULL    - Return code of the last command or function called before the current function.
    local p_errorString=${2:-NULL};     # String    - Default : NULL    - String of the type of error to display.
    local p_adviceString=${3:-NLL};     # String    - Default : NULL    - String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=${4:-NULL};        # String    - Default : NULL    - Incorrect value which caused the error.
    local p_file=${5:-NULL};            # String    - Default : NULL    - The name of the file where the error occured.
    local p_function=${6:-NULL};        # String    - Default : NULL    - The name of the function where the error occured.
    local p_lineno=${7:-NULL};          # String    - Default : NULL    - Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "${LINENO}").

    #**** Code ****
    if [ "${p_returnCode}" -eq 0 ]; then return 0; else
        if [ -n "${__BU_MODULE_INIT_IS_SOURCED}" ] && [ "${__BU_MODULE_INIT_IS_SOURCED}" == 'sourced' ]; then
            BU.Main.Errors.HandleErrors "${p_returnCode}" "${p_errorString}" "${p_adviceString}" "${p_badValue}" "${p_file}" "${p_function}" "${p_lineno}"; return "${?}";

        else
            echo "IN ${p_file}, FUNCTION ${p_function}, LINE ${p_lineno} --> ERROR : ${p_errorString}" >&2;
            echo "Advice : ${p_adviceString}" >&2;
            echo >&2;

            echo "Value that caused this error : ${p_badValue}" >&2;

            BU.ModuleInit.MsgTerminate;

            BU.ModuleInit.AskPrintLog >&2 || return 1;

            return "${p_returnCode}";
        fi
    fi
}

## ==============================================

## PARSING THE TRANSLATION FILE OF THE CURRENTLY PROCESSED MODULE

# ················································
# Parsing the translation CSV file of each module.

# The "BU.ModuleInit.ParseCSVLang()" function MUST be called in the current module's initialization script.

# IMPORTANT : It MUST be called AFTER the "BU.Main.Initializer.SourceLibrary" and BEFORE the "BU.Main.Initializer.SourceConfig()"
# functions in the main module's initialization file, in the "STEP FOUR" sub-section, in order to get the main module's functions and
# to translate the global variables descriptions written with the "BU.ModuleInit.DisplayInitGlobalVarsInfos()" function.

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Headers.Header.Blue()                     -> Main -> Headers.lib

#   - BU.Main.Text.GetSubStringAfterDelim()             -> Main -> Text.lib
#   - BU.Main.Text.GetSubStringBeforeDelim()            -> Main -> Text.lib

#   - BU.ModuleInit.Exit()                              -> Modules initializer script (this file)
#   - BU.ModuleInit.HandleErrors()                      -> Modules initializer script (this file)
#   - BU.ModuleInit.IsFrameworkCompiledUnlocalized()    -> Modules initializer script (this file)
#   - BU.ModuleInit.Msg()                               -> Modules initializer script (this file)
#   - BU.ModuleInit.PrintLogError()                     -> Modules initializer script (this file)
#   - BU.ModuleInit.SourcingFailure()                   -> Modules initializer script (this file)

# shellcheck disable=SC1090
function BU.ModuleInit.ParseCSVLang()
{
    #**** Parameters ****
    local p_lang_ISO_639_1=${1:-${__BU_MODULE_INIT__USER_LANG}};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : ${__BU_MODULE_INIT__USER_LANG}   - DESC : Language to fetch.
    local p_delim=${2:-$'\0'};                                   	# ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL                             - DESC : CSV file delimiter.

    #**** Variables ****
    local v_outputFileName="${__BU_MODULE_INIT_MODULE_NAME}.${p_lang_ISO_639_1}.translate";
    local v_outputFileParent="${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}";
    local v_outputFilePath="${v_outputFileParent}/${v_outputFileName}";

    local v_filename="${__BU_MODULE_INIT_MODULE_NAME}-${p_lang_ISO_639_1}.csv";
    local v_CSVFirstColRow;

    # Getting the total number of columns.
    local x;

	# Gets the return code of the Perl script used to parse the translation file in CSV format.
	local v_perlScriptReturnCode;

	local v_perlScriptExecLineno;

    # Getting the wanted column (set to 0, and the value will be taken from a new assignation of the variable with the call of the "BU.Main.Text.GetSubStringAfterDelim" function as sub-shell).
#    local v_wantedColID=0;

    # Getting the string of values (gathered from the first row of the CSV file) after the nth delimiter.
#    local v_CSVFirstColRowAfterNthDelim;

    # Perl script return codes.
    local v_perlScriptNoCSVFileGivenAsArgErrorCode="10022";             # Do not change this return code.
    local v_perlScriptPathIsDirErrorCode="1";
    local v_perlScriptFileIsNotCSVFormatErrorCode="2";

    local v_perlScriptIndexColNotPassedAsSecondArgErrorCode="3";
    local v_perlScriptIndexColIsNotIntErrorCode="4";
    local v_perlScriptLangFileOutputNotPassedAsThirdArgErrorCode="5";

    local v_perlScriptCSVFileCannotBeReadErrorCode="6";
    local v_perlScriptOutputFileCannotBeCreatedErrorCode="7";
    local v_perlScriptNotEnoughDiskSpaceAvailableErrorCode="14";        # Do not change this return code.

    #**** Code ****
    # Note : if the file cannot be obtained, or if there is another error during the parsing of the current module's translations CSV file,
    # then the execution of the script MUST be stopped, or else no messages will be printed on the screen while the script is executed.

    # If the output file already exists, then it's not necessary to retranslate the module.
    if [ -f "${v_outputFilePath}" ] && [ -n "${v_outputFilePath}" ]; then
		BU.ModuleInit.Msg "The ${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH} translations CSV file already exists for this language : ${p_lang_ISO_639_1}";
		BU.ModuleInit.Msg;

		BU.ModuleInit.IsFrameworkCompiledUnlocalized && {
            source "${v_outputFilePath}" || {
                local C="${?}";

                local lineno="$(( LINENO - 3 ))";

                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNABLE_TO_SOURCE_TRANSL_OUT_FILE";

                BU.ModuleInit.HandleErrors "${C}" \
                    "$(printf "UNABLE TO SOURCE THE EXISTING « %s » TRANSLATIONS FILE" "${v_outputFilePath}")" \
                    "Please check what causes the script to not source the output file, which contains the target language's translations" \
                    "${v_outputFilePath}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

                return "${?}";
            }

            return 0;
		};
	fi

    # If no path to the module's translation CSV file is given.
    if [ -z "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__NO_PATH_TO_MOD_TRANSL_FILE";

        BU.ModuleInit.HandleErrors '1' "$(printf "NO PATH TO THE « %s » MODULE'S TRANSLATION FILE EXISTS" "${__BU_MODULE_INIT_MODULE_NAME}")" \
            "Please give a valid path to the current module's translations CSV file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    if [ -z "${v_filename}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" 'E_BUINIT__PARSECSVLANG__';

        return "${?}";
    fi

    # if a path to the module's translation CSV was given, but doesn't matches to a valid file path (the given path doesn't exists).
    if [ -n "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] && [ ! -f "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__INVALID_TRANSL_FILE_PATH";

        BU.ModuleInit.HandleErrors '1' "$(printf "THE PATH TO THE « %s » TRANSLATION FILE IS NOT VALID" "${__BU_MODULE_INIT_MODULE_NAME}")" \
            "Please give a valid path to the current module's translations CSV file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # If a path to the module's translation CSV was given AND the path exists AND the output file doesn't exists, but the exact file name doesn't matches with the defined name pattern.
    if [ -n "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] \
        && [ -f "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] \
        && [ ! -f "${v_outputFilePath}" ] \
        && [ "$(basename "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" != "${v_filename}" ]; then local lineno="${LINENO}";
            BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__TARGET_TRANSL_FILE_DOES_NOT_MATCHES_DEFINED_PATTERN";

            BU.ModuleInit.HandleErrors '1' "$(printf "THE NAME OF THE « %s » PROJECT'S TRANSLATION FILE DOESN'T MATCHES WITH THE DEFINED NAME PATTERN" "${__BU_MODULE_INIT_MODULE_NAME}")" \
                "Please give a valid name to the current module's translations CSV file. The pattern is (without single quotes) : '\$module_name'-'\$ISO_639-1_language_code'" \
				"${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

            return "${?}";
    fi

    # If no delimiter is given.
    if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNDEFINED_DELIM";

        BU.ModuleInit.HandleErrors '1' "NO DELIMITER WAS GIVEN FOR THE CSV FILE" \
            "Please give a « single unicode character » as CSV delimiter in order to get each wanted cell" \
            "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    if [ -n "${p_delim}" ] && [ "${#p_delim}" -gt 1 ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__DELIM_MUST_BE_UNICODE_CHAR";

        BU.ModuleInit.HandleErrors '1' "THE GIVEN DELIMITER MUST BE A SINGLE UNICODE CHARACTER" \
            "Please give a « single unicode character » as valid CSV delimiter in order to get each wanted cell" \
            "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # Begin parsing the CSV file.
    BU.Main.Headers.Header.Blue "$(printf "PARSING THE « %s » PROJECT'S  « %s » TRANSLATIONS CSV FILE" "${__BU_MAIN_PROJECT_NAME}" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";

    BU.ModuleInit.Msg "Finding the variables list column";
    BU.ModuleInit.Msg;

    # If the targeted CSV file cannot be read by the current user.
    if [ ! -r "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${lineno}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNABLE_TO_READ_FILE";

        BU.ModuleInit.HandleErrors '1' "$(printf "Unable to read the « %s » file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "Please check the permissions of this file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # Getting the first row and first column's cell.
    v_CSVFirstColRow="$(BU.Main.Text.GetSubStringBeforeDelim "$(awk 'NR == 1 {print $1}' "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" || {
        local C="${?}";

        local lineno="$(( LINENO - 3 ))";

        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__VARIABLE_VAL_UNABLE_TO_FIND";

        BU.ModuleInit.HandleErrors '1' \
            "$(printf "UNABLE TO FIND THE VALUE « VARIABLE » IN THE FIRST ROW AND FIRST COLUMN OF THE « %s » FILE" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "$(printf "Please check if the value mentioned above is present on this EXACT cell of the « %s » file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "${v_CSVFirstColRow}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    })" "${p_delim}" '--init')";

    if [ "${v_CSVFirstColRow}" != "VARIABLE" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__VARIABLE_VAL_NOT_FOUND";

        BU.ModuleInit.HandleErrors '1' \
            "$(printf "NO « VARIABLE » VALUE FOUND AT THE FIRST COLUMNN AND FIRST ROW OF THE « %s »" \
                "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "Make sure the current module's CSV translations file is correctly formatted. You can check the main module's CSV file to check how the formatting should be done" \
            "${v_CSVFirstColRow}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    else
        BU.ModuleInit.Msg "$(printf "Parsing the « %s » translations file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";
        BU.ModuleInit.Msg;

        BU.ModuleInit.Msg "$(printf "Getting the chosen language's row (targeted language : %s)" "${p_lang_ISO_639_1}")";
        BU.ModuleInit.Msg;

        # Getting the total number of columns.
        x="$(awk -F, '{ print NF; exit }' "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";

        # Getting the langage ISO 639-1 code from the first row.
#        v_CSVFirstColRowAfterNthDelim="$(BU.Main.Text.GetSubStringAfterDelim "${v_CSVFirstColRow}" "${p_delim}" "$(( x - 1 ))") '' '--init'";

        # Getting the wanted language's column.
        v_wantedColID="$(BU.Main.Text.GetSubStringAfterDelim "${v_CSVFirstColRow}" "${p_delim}" "$(( x - 1 ))" "count" '--init')";

        # The targeted column is acquired, the Perl script's parsing program SetMouduleLang.pl can finally be called.
		v_perlScriptExecLineno="${LINENO}"; perl "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "${v_filename}" "${v_wantedColID}" "${v_outputFilePath}";

        # Getting the return value of the last command.
		v_perlScriptReturnCode="${?}";

		# Checking the eventual errors returned by the parsing program.
		if [ "${v_perlScriptReturnCode}" -eq 0 ]; then
			BU.ModuleInit.Msg "$(printf "The « %s » translations CSV file was successfully parsed, and the « %s » language's translations output file « %s » was successfully created" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "${p_lang_ISO_639_1}" "${v_outputFilePath}")";
			BU.ModuleInit.Msg;

			__BU_MODULE_INIT__BU_BASE_IS_TRANSLATED='true';

			BU.ModuleInit.IsFrameworkCompiledUnlocalized && {
                source "${v_outputFilePath}" || {
                    local C="${?}"; BU.ModuleInit.SourcingFailure "${v_outputFilePath}" "${__BU_MODULE_INIT_MODULE_NAME}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                    return "${C}";
                };  return    0;
            };

		else
			# The CSV file was not passed as first argument.
			if		[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptNoCSVFileGivenAsArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_NOT_CSV_FILE";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "NO CSV FILE GIVEN AS FIRST ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations CSV file you want to process" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# A path was passed as first argument, but it's a directory path.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptPathIsDirErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_IS_DIR";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "THE PATH PASSED AS FIRST ARGUMENT FOR THE « %s » PERL SCRIPT IS A DIRECTORY PATH, AND NOT A CSV FILE PATH" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations CSV ${__BU_MAIN_TXT_FMT_ITALIC}>>> file <<<${__BU_MAIN_TXT_FMT_ITALIC_RESET} you want to process" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# A path was passed as first argument. It's a file, but not in CSV format.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptFileIsNotCSVFormatErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_FILE_IS_NOT_CSV";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "THE FILE PATH PASSED AS FIRST ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT IS NOT A CSV FILE PATH" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations ${__BU_MAIN_TXT_FMT_ITALIC}>>> CSV file <<<${__BU_MAIN_TXT_FMT_ITALIC_RESET} you want to process" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The column's index was not passed as second argument.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptIndexColNotPassedAsSecondArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_SEC_ARG_NO_COL_INDEX";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "NO COLUMN INDEX PASSED AS SECOND ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as second argument as the index of the column you want to process" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The column's index passed as second argument was not an integer.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptIndexColIsNotIntErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_SEC_ARG_NOT_INT";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf
                        "THE « %s » PERL TRANSLATION SCRIPT'S SECOND ARGUMENT IS NOT AN INTEGER" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass an integer as second argument, as the target column ID" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

            # The language file's output path was not passed as third argument.
            elif    [ "${v_perlScriptReturnCode}" -eq "${v_perlScriptLangFileOutputNotPassedAsThirdArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_THIRD_ARG_NO_OUT_FILEPATH";

                BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "NO LANGUAGE FILE'S OUTPUT PATH PASSED AS THIRD ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass a third argument as the output file path to create" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The CSV file cannot be read by the Perl script.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptCSVFileCannotBeReadErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_UNABLE_TO_READ_CSV_FILE";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "THE « %s » PERL TRANSLATION SCRIPT CANNOT READ THE TARGET « %s » CSV TRANSLATIONS FILE" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
                        "${v_filename}")" \
                    "Please check the permissions of the targeted CSV file, then relaunch the script" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The output file cannot be created by the Perl script.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptOutputFileCannotBeCreatedErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_UNABLE_TO_CREATE_OUT_FILE";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "THE « %s » LANGUAGE'S OUTPUT FILE CANNOT BE CREATED BY THE « %s » PERL TRANSLATION SCRIPT" \
                        "${v_outputFilePath}" \
                        "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please check the cause of this error, then relaunch the script" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

            # Not enough storage is available to complete this operation.
            elif    [ "${v_perlScriptReturnCode}" -eq "${v_perlScriptNotEnoughDiskSpaceAvailableErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_NO_SPACE_LEFT_ON_DEVICE";

				BU.ModuleInit.HandleErrors \
                    "${v_perlScriptReturnCode}" \
                    "$(printf \
                        "NO SPACE LEFT ON THE DEVICE FOR THE CREATION OF THE « %s » LANGUAGE'S OUTPUT FILE" \
                        "${v_outputFilePath}")" \
                    "Please free up some disk memory before using this script to translate the current module" \
                    "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" \
                    "${FUNCNAME[0]}" \
                    "${v_perlScriptExecLineno}";

                printf "Deleting the created language's output file « %s »\n" "${v_outputFilePath}" >&2;
                echo >&2;

                if rm -v "${v_outputFilePath}"; then
                    printf "The « %s » file was successfully erased\n" "${v_outputFilePath}" >&2;
                    echo >&2;

                else
                    printf "UNABLE TO DELETE THE LANGUAGE'S OUTPUT FILE « %s »\n" "${v_outputFilePath}" >&2;

                    echo "Please do so before relaunching this script after freeing some space on your hard drive, in order to avoid this script to consider the translations already done" >&2;
                    echo >&2;
                fi

                BU.ModuleInit.AskPrintLog >&2 || { BU.ModuleInit.Exit "${v_perlScriptReturnCode}"; return "${?}"; };

                BU.ModuleInit.Exit "${v_perlScriptReturnCode}"; return "${?}";
            fi
		fi
	fi
}

## ==============================================



# /////////////////////////////////////////////////////////////////////////////////////////////// #

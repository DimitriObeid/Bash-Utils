#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : BU::Decho.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2181

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## SETTING

# Writing the text zone's background color into a file, to be processed by any function which needs to know what is the current color.
function BU::Main::Decho::SetBGColor()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH";

	#**** Parameters ****
	# $1 --> Color code

	#**** Code ****
    # If the script is allowed to format text.
    if BU::Main::Status::CheckStatAllowFormatting; then
        if command -v tput &> /dev/null; then
            tput setab "$1" || { echo -ne "\e[" && return 0; }

            # Checking if the "bgcolors.tmp" (background color) file exists.
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME" "f"; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH") file" 'E' 'CPLS'
            fi

            # Redirecting the background's color code in its dedicated temporary file.
            echo "$1" > "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH";

            [ "$?" -ne 0 ] && {
                echo -e >&2; echo -e "The $(BU::Main::Checkings::CheckFilePathExists "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH") (bgcolors.tmp) file doesn't exists" >&2; echo -e >&2;

                exit 1;
            }
        else
            echo -ne "\e["; return 0;
        fi
    else
        return 1;
    fi
}

# Writing the text's color code into a file, to be processed by any function which needs to know what is the current text color.
function BU::Main::Decho::SetTextColor()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

	# Checking first if the target partition is not fully used.
	BU::Main::Checkings::CheckDiskUsedSpace "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH";

	#**** Parameters ****
	# $1 --> Color code

	#**** Code ****
    # If the script is allowed to format text.
	if BU::Main::Status::CheckStatAllowFormatting; then
        if command -v tput &> /dev/null; then
            tput setaf "$1" || { echo -ne "\e[38;5;$1m" && return 0; }

            # Checking if the "fgcolors.tmp" (foreground color) file exists.
            if ! BU::Main::Checkings::CheckProjectRelatedFile "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT" "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME" "f"; then
                BU::Main::Errors::HandleSmallErrors 'E' "Unable to create the $(BU::Decho "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH") file" 'E' 'CPLS'
            fi

            # Redirecting the text's color code in its dedicated temporary file.
            echo "$1" > "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH";

            [ "$?" -ne 0 ] && {
                echo -e >&2; echo -e "The $(BU::Main::Checkings::CheckFilePathExists "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH") (fgcolors.tmp) file doesn't exists" >&2; echo -e >&2;

                exit 1;
            }
        else
            echo -ne "\e[38;5;$1m"; return 0;
        fi
    else
        return 1;
    fi
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS

# Text's inside decoration/formatting procssing (light version, safe to use when the complete version cannot be called without provoking an infinite loop).
function BU::__Decho()
{
	#**** Parameters ****
	local p_string=$1;			# String	- Default : NULL	- String to display.
	local p_newTextColor=$2;	# CMD		- Default : NULL	- Color to apply on each string's characters.
	local p_oldTextColor=$3;	# CMD		- Default : NULL	- Color to apply in the text's background.

	#**** Code ****	
    printf "%s\n" "$p_newTextColor$p_string$p_oldTextColor";

    return 0;
}

# Text's inside decoration/formatting procssing (complete version).

# Featured functions and files from the "functions" folder :
#   - BU::Main::Checkings::CheckDecho
#   -
function BU::Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_string=$1;          # String	- Default : NULL	- String to display.
    local p_newTextColor=$2;    # Int       - Default : NULL	- Color to apply on each string's characters.
    local p_newBGColor=$3;      # Int       - Default : NULL	- Color to apply in the text's background.

    if [ -n "$p_string" ]; then
        if [ -z "$p_newTextColor" ] && [ -z "$p_newBGColor" ]; then
            shift 1; local pa_fmtArgs; pa_fmtArgs=$("$@");

            BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}";

        elif [ -n "$p_newTextColor" ] && [ -z "$p_newTextColor" ] || [ -n "$p_newTextColor" ] && [ -z "$p_newBGColor" ]; then
            shift 2; local pa_fmtArgs; pa_fmtArgs=$("$@");

            BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}";
        fi
   # else
    #    BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED" && return "$__BU_MAIN_EXIT_CURRENT_CODE";
    fi

	if ! BU::IsPositiveInt "$p_newTextColor"; then local lineno="$LINENO";
		# Changing the 
		if [ "${__BU_MAIN_STAT_DECHO,,}" != 'forbid' ]; then
			local __bu_main_stat_decho_backup="$__BU_MAIN_STAT_DECHO";

			BU::Main::Status::ChangeSTAT_DECHO "forbid" "$(basename "${BASH_SOURCE[0]}")" "LINENO";
		fi

        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as text color code, as second argument for the ${__BU_MAIN_COLOR_FUNCTION}$p_funcname$__BU_MAIN_COLOR_ERROR function (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newTextColor' "$p_newTextColor" "$p_filename" "$p_funcname" "$lineno";

		if [ -n "$__bu_main_stat_decho_backup" ]; then BU::Main::Status::ChangeSTAT_DECHO "$__bu_main_stat_decho_backup" "$(basename "${BASH_SOURCE[0]}")" "LINENO"; fi

		return "$?";
    fi

    if ! BU::IsPositiveInt "$p_newBGColor"; then local lineno="$LINENO";
		if [ "${__BU_MAIN_STAT_DECHO,,}" != 'forbid' ]; then
			local __bu_main_stat_decho_backup="$__BU_MAIN_STAT_DECHO";

			BU::Main::Status::ChangeSTAT_DECHO "forbid" "$(basename "${BASH_SOURCE[0]}")" "LINENO";
		fi

        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as background color code, as second argument for the ${__BU_MAIN_COLOR_FUNCTION}$p_funcname$__BU_MAIN_COLOR_ERROR function (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newBGColor' "$p_newBGColor" "$p_filename" "$p_funcname" "$p_lineno";

		if [ -n "$__bu_main_stat_decho_backup" ]; then BU::Main::Status::ChangeSTAT_DECHO "$__bu_main_stat_decho_backup" "$(basename "${BASH_SOURCE[0]}")" "LINENO"; fi

		return "$?";
	fi

    #**** Code ****
    if ! BU::Main::Args__Decho::Decho "$p_string" "$p_newTextColor" "$p_newTextColor" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return 1; fi

    BU::Main::Checkings::CheckDecho;

    if test "$?" -ne 0; then
        if [ "${__BU_MAIN_STAT_DECHO,,}" = 'forbid' ]; then

            # If the text formatting is forbidden, but the "$__BU_MAIN_STAT_TXT_FMT" global status variable's value is set to "true", the text to decorate will be put between French guillemets.
            if BU::Main::Status::CheckStatAllowFormatting; then
                echo -ne "« $p_string »";

            # Else, if the text formatting is forbidden, AND the "$__BU_MAIN_STAT_TXT_FMT" global status variable's value is set to "false", no decoration nor highlighting will be made.
            else
                echo -ne "$p_string";
            fi
        else
            echo -ne "« $p_string »";
        fi

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED" && return "$__BU_MAIN_EXIT_CURRENT_CODE";
    else
        local v_oldBGColor;
            v_oldBGColor="$(cat "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH")";

        local v_oldTextColor;
            v_oldTextColor="$(cat "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH")";
    fi

    # If both of the new colors are equal.
    if [ "$p_newBGColor" = "$p_newTextColor" ]; then
        p_newBGColor="$(( p_newBGColor+34 ))"
    fi

    # If the text color code's value is equal to it's former value.
    if [ "$p_newTextColor" = "$v_oldTextColor" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newTextColor="$(( p_newTextColor+38 ))";
    fi

    # If the background color code's value is equal to it's former value.
    if [ "$p_newBGColor" = "$v_oldBGColor" ]; then
		p_newBGColor="$(( p_newBGColor+38 ))";
	fi

    # Setting the new values in their color code temporary file.
    if [ -n "$p_newTextColor" ]; then BU::Main::Decho::SetTextColor "$p_newTextColor"; fi

    if [ -n "$p_newBGColor" ]; then BU::Main::Decho::SetBGColor "$p_newBGColor"; fi

    # Test code, to check the values from the command substitutes, and to test if a loop stops before exiting the script when the exit command is called.
    echo "STRING : $p_string";
    echo "TEXT COLOR : $p_newTextColor";
    echo "BG COLOR : $p_newBGColor";

    exit 0; return 1;

    # -----------------------------------------------

    ## APPLYING THE FORMATTINGS ON THE TEXT

	if [ "${__BU_MAIN_STAT_DECHO,,}" = 'restrict' ]; then
        printf "%s" "$p_newTextColor";
        printf "%s" "$p_newBGColor";
        printf "%s" "$p_string";
        printf "%s" "$v_oldBGColor";
        printf "%s" "$v_oldTextColor";
        printf "\n";

        return 0;
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}";;

                *)
                    # WARNING ! >>> DO NOT RESET <<< the "$__BU_MAIN_STAT_TXT_FMT" variable's value >>> to "true" <<<, or else the program will be stuck in an infinite loop.

                    # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT";

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
                    fi

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                        "Check if the value is supported in the first value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO";

                    BU::Main::Status::ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable, since it's possible to do so now.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val";
                    fi

                    return 1;
                    ;;
            esac
        done

        echo -e "$p_string$p_newTextColor$__BU_MAIN_COLOR_CODE_RESET";

        # -----------------------------------------------

        ## APPLYING THE FORMATTINGS ON THE TEXT

        # Resetting the text's color.
        if [ -n "$p_newTextColor" ]; then BU::Main::Decho::SetTextColor "$p_oldTextColor"; fi

        if [ -n "$p_newBGColor" ]; then BU::Main::Decho::SetBGColor "$p_oldBGColor"; fi

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}";;

                *)
                    # WARNING ! >>> DO NOT RESET <<< the "$__BU_MAIN_STAT_TXT_FMT" variable's value >>> to "true" <<<, or else the program will be stuck in an infinite loop.

                    # The function "BU::Main::Errors::HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_DECHO" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT";

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
                    fi

                    # shellcheck disable=SC2034
                    BU::Main::Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                    "Check if the value is supported in the second value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO";

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable, since it's possible to do so now.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val";
                    fi
                    ;;
            esac
        done
    fi

    return 0;
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(BU::Decho_FMT_BlinkBoldDISU "$(BU::DechoOrange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(BU::DechoOrange "$(BU::Decho_FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "BU::Decho()" function calls with colors.
function BU::DechoAqua              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_AQUA"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoBlack             { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_BLACK"     "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoBlue              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_BLUE"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoCyan              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_CYAN"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoFuchsia           { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_FUCHSIA"   "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoGray              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_GRAY"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoGreen             { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_GREEN"     "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoLime              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_LIME"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoMaroon            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_MAROON"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoNavy              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_NAVY"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoOlive             { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_OLIVE"     "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoOrange            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_ORANGE"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoPink              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_PINK"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoPurple            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_PURPLE"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoRed               { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_RED"       "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoSalmon            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_SALMON"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoSilver            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_SILVER"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoTan               { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_TAN"       "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoTeal              { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_TEAL"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoTurquoise         { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_TURQUOISE" "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoViolet            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_VIOLET"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoWhite             { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_WHITE"     "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoYellow            { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$v_str" "$__BU_MAIN_COLOR_CODE_YELLOW"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU::Decho()" function calls with specific text display colors.
function BU::DechoHighlight         { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho            "$v_str" "$__BU_MAIN_COLOR_CODE_HIGHLIGHT"  "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightCMD      { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_Bold   "$v_str" "$__BU_MAIN_COLOR_CODE_CMD"        "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightError    { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_BoldIU "$v_str" "$__BU_MAIN_COLOR_CODE_ERROR"      "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoHighlightFunction { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_Bold   "$v_str" "$__BU_MAIN_COLOR_CODE_FUNCTION"   "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightNewstep  { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_I      "$v_str" "$__BU_MAIN_COLOR_CODE_NEWSTEP"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightPath     { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_Bold   "$v_str" "$__BU_MAIN_COLOR_CODE_PATH"       "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

function BU::DechoHighlightSuccess  { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_I      "$v_str" "$__BU_MAIN_COLOR_CODE_SUCCESS"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightVar      { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_Bold   "$v_str" "$__BU_MAIN_COLOR_CODE_VAR"        "$v_bg" "${pa_arr[@]}" || return 1; return 0; }
function BU::DechoHighlightWarning  { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho_FMT_BoldIU "$v_str" "$__BU_MAIN_COLOR_CODE_WARNING"    "$v_bg" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU::Decho()" function calls with background color display.
function BU::DechoBGColor           { local v_str=$1; local v_bg=$2; shift 2; local pa_arr=("$@"); BU::Main::Args::GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs}"; BU::Decho "$1" "$2" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU::__Decho()" function calls with colors (note: here, the color defined by each function is the color to reset in the text).
function BU::__DechoAqua        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_AQUA";        }
function BU::__DechoBlack       { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_BLACK";       }
function BU::__DechoBlue        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_BLUE";        }

function BU::__DechoCyan        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_CYAN";        }
function BU::__DechoFuchsia     { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_FUCHSIA";     }
function BU::__DechoGray        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_GRAY";        }

function BU::__DechoGreen       { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_GREEN";       }
function BU::__DechoLime        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_LIME";        }
function BU::__DechoMaroon      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_MARRON";      }

function BU::__DechoNavy        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_NAVY";        }
function BU::__DechoOlive       { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_OLIVE";       }
function BU::__DechoOrange      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_ORANGE";      }

function BU::__DechoPink        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_PINK";        }
function BU::__DechoPurple      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_PURPLE";      }
function BU::__DechoRed         { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_RED";         }

function BU::__DechoSalmon      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_SALMON";      }
function BU::__DechoSilver      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_SILVER";      }
function BU::__DechoTan         { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_TAN";         }

function BU::__DechoTeal        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_TEAL";        }
function BU::__DechoTurquoise   { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_TURQUOISE";   }
function BU::__DechoViolet      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_VIOLET";      }

function BU::__DechoWhite       { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_WHITE";       }
function BU::__DechoYellow      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_YELLOW";      }

# Easy "BU::__Decho()" function calls with specific text display colors (note: here, the color defined by each function is the color to reset in the text).
function BU::__DechoHighlight           { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_HIGLIGHT";    }
function BU::__DechoHighlightCMD        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_CMD";         }
function BU::__DechoHighlightError      { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_ERROR";       }

function BU::__DechoHighlightFunction   { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_FUNCTION";    }
function BU::__DechoHighlightNewstep    { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_NEWSTEP";     }
function BU::__DechoHighlightPath       { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_PATH";        }

function BU::__DechoHighlightSuccess    { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_SUCCESS";     }
function BU::__DechoHighlightVar        { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_VAR";         }
function BU::__DechoHighlightWarning    { BU::__Decho "$1" "$2" "$__BU_MAIN_COLOR_WARNING";     }

# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU::Main::Decho::SetTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   $1  --> String to display.
#   $2  --> Text color to display.
#	$3	--> Background color display.

# Blink formatting.
function BU::Decho_FMT_Blink            { BU::Decho "$1" "$2" "$3" 'Blink'                          	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBold        { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold'                   	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldD       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDI      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIS     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'S'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDISU    { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'S' 'U'       || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDS      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDSU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldI       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIS      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldISU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldS       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'S'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldSU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'S' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldU       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'U'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkD           { BU::Decho "$1" "$2" "$3" 'Blink' 'D'                      	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDI          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDIS         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'S'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDISU        { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'S' 'U'          	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDIU         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDS          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'S'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDSU         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'S' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDU          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkI           { BU::Decho "$1" "$2" "$3" 'Blink' 'I'                          || return 1; return 0; }
function BU::Decho_FMT_BlinkIS          { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'S'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkISU         { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'S' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkIU          { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkS           { BU::Decho "$1" "$2" "$3" 'Blink' 'S'                      	|| return 1; return 0; }
function BU::Decho_FMT_BlinkSU          { BU::Decho "$1" "$2" "$3" 'Blink' 'S' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkU           { BU::Decho "$1" "$2" "$3" 'Blink' 'U'                          || return 1; return 0; }

# Bold formatting.
function BU::Decho_FMT_Bold     { BU::Decho "$1" "$2" "$3" 'Bold'                   	|| return 1; return 0; }
function BU::Decho_FMT_BoldD    { BU::Decho "$1" "$2" "$3" 'Bold' 'D'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldDI   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldDIS  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'S'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDISU { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'S' 'U'   	|| return 1; return 0; }
function BU::Decho_FMT_BoldDIU  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDS   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldDSU  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDU   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldI    { BU::Decho "$1" "$2" "$3" 'Bold' 'I'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldIS   { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldISU  { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldIU   { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldS    { BU::Decho "$1" "$2" "$3" 'Bold' 'S'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldSU   { BU::Decho "$1" "$2" "$3" 'Bold' 'S' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldU    { BU::Decho "$1" "$2" "$3" 'Bold' 'U'                   || return 1; return 0; }

# Dim formatting
function BU::Decho_FMT_D    { BU::Decho "$1" "$2" "$3" 'D'              	|| return 1; return 0; }
function BU::Decho_FMT_DI   { BU::Decho "$1" "$2" "$3" 'D' 'I'          	|| return 1; return 0; }
function BU::Decho_FMT_DIS  { BU::Decho "$1" "$2" "$3" 'D' 'I' 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_DISU { BU::Decho "$1" "$2" "$3" 'D' 'I' 'S' 'U'  	|| return 1; return 0; }
function BU::Decho_FMT_DIU  { BU::Decho "$1" "$2" "$3" 'D' 'I' 'U'      	|| return 1; return 0; }
function BU::Decho_FMT_DS   { BU::Decho "$1" "$2" "$3" 'D' 'S'          	|| return 1; return 0; }
function BU::Decho_FMT_DSU  { BU::Decho "$1" "$2" "$3" 'D' 'S' 'U'      	|| return 1; return 0; }
function BU::Decho_FMT_DU   { BU::Decho "$1" "$2" "$3" 'D' 'U'              || return 1; return 0; }

# Italic formatting.
function BU::Decho_FMT_I    { BU::Decho "$1" "$2" "$3" 'I'          	|| return 1; return 0; }
function BU::Decho_FMT_IS   { BU::Decho "$1" "$2" "$3" 'I' 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_ISU  { BU::Decho "$1" "$2" "$3" 'I' 'S' 'U'  	|| return 1; return 0; }
function BU::Decho_FMT_IU   { BU::Decho "$1" "$2" "$3" 'I' 'U'          || return 1; return 0; }

# Strikethrough formatting.
function BU::Decho_FMT_S    { BU::Decho "$1" "$2" "$3" 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_SU   { BU::Decho "$1" "$2" "$3" 'S' 'U'      || return 1; return 0; }

# Underline formatting.
function BU::Decho_FMT_U    { BU::Decho "$1" "$2" "$3" 'U'      || return 1; return 0; }

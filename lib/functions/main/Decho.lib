#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : BU::Decho.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS

# Quick multi commands execution for the below "Decho()" function.
function BU::__Decho { local v_oldColor=$1; tput setaf "$v_oldColor" && BU::IsInt "$v_oldColor" && echo -e "$v_oldColor" > "$__BU_MAIN_FILE_COLOR_CODE_PATH"; }

# Text's inside decoration/formatting procssing.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Checkings::CheckDecho
#   -
function BU::Decho()
{
    #**** Parameters ****
    local p_string=$1;
    local p_newColor=$2;
    shift 2;

    local pa_fmtArgs;
        pa_fmtArgs=$("$@");

    #**** Variables ****
    local v_oldColor

    #**** Code ****
    BU::Main::Checkings::CheckDecho

    if test "$?" -ne 0; then
        echo -ne "« $p_string »"

        return 1
    else
        local v_oldColor
            v_oldColor="$(cat "$__BU_MAIN_PROJECT_TEXT_COLOR_CODE_FILE_PATH")"
    fi

    if [ "$p_newColor" = "$v_oldColor" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newColor="$(( p_newColor+38 ))"
		tput setaf "$p_newColor"
	fi

	if [ "$__BU_MAIN_STAT_DECHO" = 'restrict' ]; then # || [ -z "${pa_fmtArgs[@]}" ]; then
        echo -e "$p_newColor$p_string$v_oldColor"; return 0;
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")")
                    return
                    ;;
                'BLINK')
                    echo -ne "${__BU_MAIN_TXT_FMT_BLINK}"
                    ;;
                'BOLD')
                    echo -ne "${__BU_MAIN_TXT_FMT_BOLD}"
                    ;;
                'D')
                    echo -ne "${__BU_MAIN_TXT_FMT_DIM}"
                    ;;
                'I')
                    echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}"
                    ;;
                'S')
                    echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}"
                    ;;
                'U')
                    echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}"
                    ;;
                *)
                    # WARNING ! >>> DO NOT RESET «< the "$__BU_MAIN_STAT_TXT_FMT" variable's value >>> to "true" «<, or else the program will be stuck in an infinite loop.

                    # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT"

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                    fi

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                        "Check if the value is supported in the first value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"

                    BU::Main::Status::ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val"
                    fi

                    return 1
                    ;;
            esac
        done

        echo -e "$p_string$p_newColor$__BU_MAIN_COLOR_RESET"

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")")
                    return
                    ;;
                'BLINK')
                    echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}"
                    ;;
                'BOLD')
                    echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}"
                    ;;
                'D')
                    echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}"
                    ;;
                'I')
                    echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}"
                    ;;
                'S')
                    echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}"
                    ;;
                'U')
                    echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}"
                    ;;
                *)
                    # WARNING ! Do not reset the "$__BU_MAIN_STAT_DECHO" variable's value  to "true", or else the program will be stuck in an infinite loop.

                    # The function "BU::Main::Errors::HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_DECHO" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT"

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                    fi

                    # shellcheck disable=SC2034
                    BU::Main:Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                    "Check if the value is supported in the second value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val"
                    fi
                    ;;
            esac
        done
    fi

    return 0;
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(BU::Decho_FMT_BlinkBoldDISU "$(BU::DechoOrange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(BU::DechoOrange "$(BU::Decho_FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "BU::Decho()" function calls with colors.
function BU::DechoAqua              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_AQUA"        || return 1; return 0; }
function BU::DechoBlack             { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_BLACK"       || return 1; return 0; }
function BU::DechoBlue              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_BLUE"        || return 1; return 0; }
function BU::DechoCyan              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_CYAN"        || return 1; return 0; }
function BU::DechoFuschia           { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_FUSCHIA"     || return 1; return 0; }
function BU::DechoGray              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_GRAY"        || return 1; return 0; }
function BU::DechoGreen             { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_GREEN"       || return 1; return 0; }
function BU::DechoLime              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_LIME"        || return 1; return 0; }
function BU::DechoMaroon            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_MAROON"      || return 1; return 0; }
function BU::DechoNavy              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_NAVY"        || return 1; return 0; }
function BU::DechoOlive             { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_OLIVE"       || return 1; return 0; }
function BU::DechoOrange            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_ORANGE"      || return 1; return 0; }
function BU::DechoPink              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_PINK"        || return 1; return 0; }
function BU::DechoPurple            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_PURPLE"      || return 1; return 0; }
function BU::DechoRed               { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_RED"         || return 1; return 0; }
function BU::DechoSalmon            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_SALMON"      || return 1; return 0; }
function BU::DechoSilver            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_SILVER"      || return 1; return 0; }
function BU::DechoTan               { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TAN"         || return 1; return 0; }
function BU::DechoTeal              { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TEAL"        || return 1; return 0; }
function BU::DechoTurquoise         { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TURQUOISE"   || return 1; return 0; }
function BU::DechoViolet            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_VIOLET"      || return 1; return 0; }
function BU::DechoWhite             { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_WHITE"       || return 1; return 0; }
function BU::DechoYellow            { BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_YELLOW"      || return 1; return 0; }

# Easy "BU::Decho()" function calls with specific text display colors.
function BU::DechoHighlight         { BU::Decho             "$1" "$__BU_MAIN_COLOR_HIGHLIGHT"   || return 1; return 0; }
function BU::DechoHighlightFunction { BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_FUNCTION"    || return 1; return 0; }
function BU::DechoHighlightPath     { BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_PATH"        || return 1; return 0; }
function BU::DechoHighlightVar      { BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_VAR"         || return 1; return 0; }


# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU::Main::ModConfig::Colors::CheckTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   $1  --> String to display
#   $2  --> Color to display

# Blink formatting.
function BU::Decho_FMT_Blink            { BU::Decho "$1" "$2" 'Blink'                           || return 1; return 0; }
function BU::Decho_FMT_BlinkBold        { BU::Decho "$1" "$2" 'Blink' 'Bold'                    || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldD       { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D'                || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDI      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIS     { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'S'        || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDISU    { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'S' 'U'    || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIU     { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDS      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'S'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDSU     { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'S' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDU      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'D' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldI       { BU::Decho "$1" "$2" 'Blink' 'Bold' 'I'                || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIS      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'I' 'S'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldISU     { BU::Decho "$1" "$2" 'Blink' 'Bold' 'I' 'S' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIU      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'I' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldS       { BU::Decho "$1" "$2" 'Blink' 'Bold' 'S'                || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldSU      { BU::Decho "$1" "$2" 'Blink' 'Bold' 'S' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldU       { BU::Decho "$1" "$2" 'Blink' 'Bold' 'U'                || return 1; return 0; }
function BU::Decho_FMT_BlinkD           { BU::Decho "$1" "$2" 'Blink' 'D'                       || return 1; return 0; }
function BU::Decho_FMT_BlinkDI          { BU::Decho "$1" "$2" 'Blink' 'D' 'I'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkDIS         { BU::Decho "$1" "$2" 'Blink' 'D' 'I' 'S'               || return 1; return 0; }
function BU::Decho_FMT_BlinkDISU        { BU::Decho "$1" "$2" 'Blink' 'D' 'I' 'S' 'U'           || return 1; return 0; }
function BU::Decho_FMT_BlinkDIU         { BU::Decho "$1" "$2" 'Blink' 'D' 'I' 'U'               || return 1; return 0; }
function BU::Decho_FMT_BlinkDS          { BU::Decho "$1" "$2" 'Blink' 'D' 'S'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkDSU         { BU::Decho "$1" "$2" 'Blink' 'D' 'S' 'U'               || return 1; return 0; }
function BU::Decho_FMT_BlinkDU          { BU::Decho "$1" "$2" 'Blink' 'D' 'U'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkI           { BU::Decho "$1" "$2" 'Blink' 'I'                       || return 1; return 0; }
function BU::Decho_FMT_BlinkIS          { BU::Decho "$1" "$2" 'Blink' 'I' 'S'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkISU         { BU::Decho "$1" "$2" 'Blink' 'I' 'S' 'U'               || return 1; return 0; }
function BU::Decho_FMT_BlinkIU          { BU::Decho "$1" "$2" 'Blink' 'I' 'U'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkS           { BU::Decho "$1" "$2" 'Blink' 'S'                       || return 1; return 0; }
function BU::Decho_FMT_BlinkSU          { BU::Decho "$1" "$2" 'Blink' 'S' 'U'                   || return 1; return 0; }
function BU::Decho_FMT_BlinkU           { BU::Decho "$1" "$2" 'Blink' 'U'                       || return 1; return 0; }

# Bold formatting.
function BU::Decho_FMT_Bold     { BU::Decho "$1" "$2" 'Bold'                    || return 1; return 0; }
function BU::Decho_FMT_BoldD    { BU::Decho "$1" "$2" 'Bold' 'D'                || return 1; return 0; }
function BU::Decho_FMT_BoldDI   { BU::Decho "$1" "$2" 'Bold' 'D' 'I'            || return 1; return 0; }
function BU::Decho_FMT_BoldDIS  { BU::Decho "$1" "$2" 'Bold' 'D' 'I' 'S'        || return 1; return 0; }
function BU::Decho_FMT_BoldDISU { BU::Decho "$1" "$2" 'Bold' 'D' 'I' 'S' 'U'    || return 1; return 0; }
function BU::Decho_FMT_BoldDIU  { BU::Decho "$1" "$2" 'Bold' 'D' 'I' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BoldDS   { BU::Decho "$1" "$2" 'Bold' 'D' 'S'            || return 1; return 0; }
function BU::Decho_FMT_BoldDSU  { BU::Decho "$1" "$2" 'Bold' 'D' 'S' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BoldDU   { BU::Decho "$1" "$2" 'Bold' 'D' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BoldI    { BU::Decho "$1" "$2" 'Bold' 'I'                || return 1; return 0; }
function BU::Decho_FMT_BoldIS   { BU::Decho "$1" "$2" 'Bold' 'I' 'S'            || return 1; return 0; }
function BU::Decho_FMT_BoldISU  { BU::Decho "$1" "$2" 'Bold' 'I' 'S' 'U'        || return 1; return 0; }
function BU::Decho_FMT_BoldIU   { BU::Decho "$1" "$2" 'Bold' 'I' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BoldS    { BU::Decho "$1" "$2" 'Bold' 'S'                || return 1; return 0; }
function BU::Decho_FMT_BoldSU   { BU::Decho "$1" "$2" 'Bold' 'S' 'U'            || return 1; return 0; }
function BU::Decho_FMT_BoldU    { BU::Decho "$1" "$2" 'Bold' 'U'                || return 1; return 0; }

# Dim formatting
function BU::Decho_FMT_D    { BU::Decho "$1" "$2" 'D'               || return 1; return 0; }
function BU::Decho_FMT_DI   { BU::Decho "$1" "$2" 'D' 'I'           || return 1; return 0; }
function BU::Decho_FMT_DIS  { BU::Decho "$1" "$2" 'D' 'I' 'S'       || return 1; return 0; }
function BU::Decho_FMT_DISU { BU::Decho "$1" "$2" 'D' 'I' 'S' 'U'   || return 1; return 0; }
function BU::Decho_FMT_DIU  { BU::Decho "$1" "$2" 'D' 'I' 'U'       || return 1; return 0; }
function BU::Decho_FMT_DS   { BU::Decho "$1" "$2" 'D' 'S'           || return 1; return 0; }
function BU::Decho_FMT_DSU  { BU::Decho "$1" "$2" 'D' 'S' 'U'       || return 1; return 0; }
function BU::Decho_FMT_DU   { BU::Decho "$1" "$2" 'D' 'U'           || return 1; return 0; }

# Italic formatting.
function BU::Decho_FMT_I    { BU::Decho "$1" "$2" 'I'           || return 1; return 0; }
function BU::Decho_FMT_IS   { BU::Decho "$1" "$2" 'I' 'S'       || return 1; return 0; }
function BU::Decho_FMT_ISU  { BU::Decho "$1" "$2" 'I' 'S' 'U'   || return 1; return 0; }
function BU::Decho_FMT_IU   { BU::Decho "$1" "$2" 'I' 'U'       || return 1; return 0; }

# Strikethrough formatting.
function BU::Decho_FMT_S    { BU::Decho "$1" "$2" 'S'       || return 1; return 0; }
function BU::Decho_FMT_SU   { BU::Decho "$1" "$2" 'S' 'U'   || return 1; return 0; }

# Underline formatting.
function BU::Decho_FMT_U    { BU::Decho "$1" "$2" 'U' || return 1; return 0; }

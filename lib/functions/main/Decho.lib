#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Decho.lib
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# DO NOT EXECUTE IT DIRECTLY, instead, just source it by calling the "__BASH_UTILS_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS

# Quick multi commands execution for the below "Decho()" function.
function __Decho { local v_oldColor=$1; tput setaf "$v_oldColor" && IsInt "$v_oldColor" && echo -e "$v_oldColor" > "$__BASH_UTILS_FILE_COLOR_CODE_PATH"; }

# Text's inside decoration/formatting procssing.

# Featured functions and files from the "functions" folder :
#   - CheckDecho                        --> This file.
#       - 
function Decho()
{
    #***** Parameters *****
    local p_string=$1
    local p_newColor=$2
    shift 2

    local pa_fmtArgs
        pa_fmtArgs=$("$@")

    #***** Variables *****
    local v_oldColor

    #***** Code *****
    CheckDecho

    if test "$?" -ne 0; then
        echo -e " ' $p_string ' "
        
        return 1
    else
        local v_oldColor
            v_oldColor="$__BU_PROJECT_COLOR_CODE"
    fi

    if [ "$p_newColor" = "$v_oldColor" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newColor="$(( p_newColor+38 ))"
		tput setaf "$p_newColor"
	fi

    # Setting every formattings.
    for val in "${pa_fmtArgs[@]^^}"; do
        case "$val" in
            'Blink')
                echo -ne "${__BU_TXT_FMT_BLINK}"
                ;;  
            'Bold')
                echo -ne "${__BU_TXT_FMT_BOLD}"
                ;; 
            'D')
                echo -ne "${__BU_TXT_FMT_DIM}"
                ;;
            'I')
                echo -ne "${__BU_TXT_FMT_ITALIC}"
                ;;
            'S')
                echo -ne "${__BU_TXT_FMT_STRIKETHROUGH}"
                ;;
            'U')
                echo -ne "${__BU_TXT_FMT_UNDERLINE}"
                ;;
            *)
                # WARNING ! >>> DO NOT RESET <<< the "$__BU_STAT_TXT_FMT" variable's value >>> to "true" <<<, or else the program will be stuck in an infinite loop.

                # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                # if the "$__BU_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                HandleErrors "1" "AT LEAST ONE OF THE $(KeepFormatting "$(DechoHighlight "${FUNCNAME[@]}")")'S ARRAY ARGUMENT VALUE IS INCORRECT" "" \
                    "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"
                echo -e "Invalid value"; exit 1

                ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                ;; 
        esac
    done

    echo -e "$p_string$p_newColor$__BU_COLOR_RESET"

    # Resetting every formattings.
    for val in "${pa_fmtArgs[@]^^}"; do
        case "$val" in
            'Blink')
                echo -ne "${__BU_TXT_FMT_BLINK_RESET}"
                ;;  
            'Bold')
                echo -ne "${__BU_TXT_FMT_BOLD_RESET}"
                ;; 
            'D')
                echo -ne "${__BU_TXT_FMT_DIM_RESET}"
                ;;
            'I')
                echo -ne "${__BU_TXT_FMT_ITALIC_RESET}"
                ;;
            'S')
                echo -ne "${__BU_TXT_FMT_STRIKETHROUGH_RESET}"
                ;;
            'U')
                echo -ne "${__BU_TXT_FMT_UNDERLINE_RESET}"
                ;;
            *)
                # WARNING ! Do not reset the "$__BU_STAT_TXT_FMT" variable's value  to "true", or else the program will be stuck in an infinite loop.

                # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                # if the "$__BU_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                # shellcheck disable=SC2034
                ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                
                HandleErrors "1" "AT LEAST ONE OF THE $(KeepFormatting "$(DechoHighlight "${FUNCNAME[@]}")")'S ARRAY ARGUMENT VALUE IS INCORRECT" "" \
                    "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"
                echo -e "Invalid value"; exit 1
                
                ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                ;;
        esac
    done
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(Decho_FMT_BlinkBoldDISU "$(DechoOrange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(DechoOrange "$(Decho_FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "Decho()" function calls with colors.
function DechoHighlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    ; }
function DechoBlack     { Decho "$1" "$__BU_COLOR_BLACK"        ; }
function DechoBlue      { Decho "$1" "$__BU_COLOR_BLUE"         ; }
function DechoCyan      { Decho "$1" "$__BU_COLOR_CYAN"         ; }
function DechoGray      { Decho "$1" "$__BU_COLOR_GRAY"         ; }
function DechoGreen     { Decho "$1" "$__BU_COLOR_GREEN"        ; }
function DechoOrange    { Decho "$1" "$__BU_COLOR_ORANGE"       ; }
function DechoPink      { Decho "$1" "$__BU_COLOR_PINK"         ; }
function DechoPurple    { Decho "$1" "$__BU_COLOR_PURPLE"       ; }
function DechoRed       { Decho "$1" "$__BU_COLOR_RED"          ; }
function DechoTurquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    ; }
function DechoWhite     { Decho "$1" "$__BU_COLOR_WHITE"        ; }
function DechoYellow    { Decho "$1" "$__BU_COLOR_YELLOW"       ; }

# Blink formatting.
function Decho_FMT_Blink            { Decho "$1" "" 'Blink'; }
function Decho_FMT_BlinkBold        { Decho "$1" "" 'Blink' 'Bold'; }
function Decho_FMT_BlinkBoldD       { Decho "$1" "" 'Blink' 'Bold' 'D'; }
function Decho_FMT_BlinkBoldDI      { Decho "$1" "" 'Blink' 'Bold' 'D' 'I'; }
function Decho_FMT_BlinkBoldDIS     { Decho "$1" "" 'Blink' 'Bold' 'D' 'I' 'S'; }
function Decho_FMT_BlinkBoldDISU    { Decho "$1" "" 'Blink' 'Bold' 'D' 'I' 'S' 'U'; }
function Decho_FMT_BlinkBoldDIU     { Decho "$1" "" 'Blink' 'Bold' 'D' 'I' 'U'; }
function Decho_FMT_BlinkBoldDS      { Decho "$1" "" 'Blink' 'Bold' 'D' 'S'; }
function Decho_FMT_BlinkBoldDSU     { Decho "$1" "" 'Blink' 'Bold' 'D' 'S' 'U'; }
function Decho_FMT_BlinkBoldDU      { Decho "$1" "" 'Blink' 'Bold' 'D' 'U'; }
function Decho_FMT_BlinkBoldI       { Decho "$1" "" 'Blink' 'Bold' 'I'; }
function Decho_FMT_BlinkBoldIS      { Decho "$1" "" 'Blink' 'Bold' 'I' 'S'; }
function Decho_FMT_BlinkBoldISU     { Decho "$1" "" 'Blink' 'Bold' 'I' 'S' 'U'; }
function Decho_FMT_BlinkBoldIU      { Decho "$1" "" 'Blink' 'Bold' 'I' 'U'; }
function Decho_FMT_BlinkBoldS       { Decho "$1" "" 'Blink' 'Bold' 'S'; }
function Decho_FMT_BlinkBoldSU      { Decho "$1" "" 'Blink' 'Bold' 'S' 'U'; }
function Decho_FMT_BlinkBoldU       { Decho "$1" "" 'Blink' 'Bold' 'U'; }
function Decho_FMT_BlinkD           { Decho "$1" "" 'Blink' 'D'; }
function Decho_FMT_BlinkDI          { Decho "$1" "" 'Blink' 'D' 'I'; }
function Decho_FMT_BlinkDIS         { Decho "$1" "" 'Blink' 'D' 'I' 'S'; }
function Decho_FMT_BlinkDISU        { Decho "$1" "" 'Blink' 'D' 'I' 'S' 'U'; }
function Decho_FMT_BlinkDIU         { Decho "$1" "" 'Blink' 'D' 'I' 'U'; }
function Decho_FMT_BlinkDS          { Decho "$1" "" 'Blink' 'D' 'S'; }
function Decho_FMT_BlinkDSU         { Decho "$1" "" 'Blink' 'D' 'S' 'U'; }
function Decho_FMT_BlinkDU          { Decho "$1" "" 'Blink' 'D' 'U'; }
function Decho_FMT_BlinkI           { Decho "$1" "" 'Blink' 'I'; }
function Decho_FMT_BlinkIS          { Decho "$1" "" 'Blink' 'I' 'S'; }
function Decho_FMT_BlinkISU         { Decho "$1" "" 'Blink' 'I' 'S' 'U'; }
function Decho_FMT_BlinkIU          { Decho "$1" "" 'Blink' 'I' 'U'; }
function Decho_FMT_BlinkS           { Decho "$1" "" 'Blink' 'S'; }
function Decho_FMT_BlinkSU          { Decho "$1" "" 'Blink' 'S' 'U'; }
function Decho_FMT_BlinkU           { Decho "$1" "" 'Blink' 'U'; }

# Bold formatting.
function Decho_FMT_Bold     { Decho "$1" "" 'Bold'; }
function Decho_FMT_BoldD    { Decho "$1" "" 'Bold' 'D'; }
function Decho_FMT_BoldDI   { Decho "$1" "" 'Bold' 'D' 'I'; }
function Decho_FMT_BoldDIS  { Decho "$1" "" 'Bold' 'D' 'I' 'S'; }
function Decho_FMT_BoldDISU { Decho "$1" "" 'Bold' 'D' 'I' 'S' 'U'; }
function Decho_FMT_BoldDIU  { Decho "$1" "" 'Bold' 'D' 'I' 'U'; }
function Decho_FMT_BoldDS   { Decho "$1" "" 'Bold' 'D' 'S'; }
function Decho_FMT_BoldDSU  { Decho "$1" "" 'Bold' 'D' 'S' 'U'; }
function Decho_FMT_BoldDU   { Decho "$1" "" 'Bold' 'D' 'U'; }
function Decho_FMT_BoldI    { Decho "$1" "" 'Bold' 'I'; }
function Decho_FMT_BoldIS   { Decho "$1" "" 'Bold' 'I' 'S'; }
function Decho_FMT_BoldISU  { Decho "$1" "" 'Bold' 'I' 'S' 'U'; }
function Decho_FMT_BoldIU   { Decho "$1" "" 'Bold' 'I' 'U'; }
function Decho_FMT_BoldS    { Decho "$1" "" 'Bold' 'S'; }
function Decho_FMT_BoldSU   { Decho "$1" "" 'Bold' 'S' 'U'; }
function Decho_FMT_BoldU    { Decho "$1" "" 'Bold' 'U'; }

# Dim formatting
function Decho_FMT_D    { Decho "$1" "" 'D'; }
function Decho_FMT_DI   { Decho "$1" "" 'D' 'I'; }
function Decho_FMT_DIS  { Decho "$1" "" 'D' 'I' 'S'; }
function Decho_FMT_DISU { Decho "$1" "" 'D' 'I' 'S' 'U'; }
function Decho_FMT_DIU  { Decho "$1" "" 'D' 'I' 'U'; }
function Decho_FMT_DS   { Decho "$1" "" 'D' 'S'; }
function Decho_FMT_DSU  { Decho "$1" "" 'D' 'S' 'U'; }
function Decho_FMT_DU   { Decho "$1" "" 'D' 'U'; }

# Italic formatting.
function Decho_FMT_I    { Decho "$1" "" 'I';    }
function Decho_FMT_IS   { Decho "$1" "" 'I' 'S'; }
function Decho_FMT_ISU  { Decho "$1" "" 'I' 'S' 'U'; }
function Decho_FMT_IU   { Decho "$1" "" 'I' 'U';   }

# Strikethrough formatting.
function Decho_FMT_S    { Decho "$1" "" 'S'; }
function Decho_FMT_SU   { Decho "$1" "" 'S' 'U'; }

# Underline formatting.
function Decho_FMT_U     { Decho "$1" "" 'U';    }

#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : BU::Decho.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS

# Quick multi commands execution for the below "Decho()" function.
function BU::__Decho { local v_oldTextColor=$1; tput setaf "$v_oldTextColor" && BU::IsInt "$v_oldTextColor" && echo -e "$v_oldTextColor" > "$__BU_MAIN_FILE_COLOR_CODE_PATH"; }

# Text's inside decoration/formatting procssing.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Checkings::CheckDecho
#   -
function BU::Decho()
{
    #**** Parameters ****
    local p_string=$1;          # String to display
    local p_newTextColor=$2;    # Color to apply on each string's characters.
    local p_newBGColor=$3;      # Color to apply in the text's background.

    shift 3;

    local pa_fmtArgs;
        pa_fmtArgs=$("$@");

        echo "STRING : $p_string"
    echo "TEXT COLOR : $p_newTextColor"
    echo "BG COLOR : $p_newBGColor"

    exit 0;
    #**** Code ****
    BU::Main::Checkings::CheckDecho;

    if test "$?" -ne 0; then
        echo -ne "« $p_string »";

        return 1;
    else
        local v_oldBGColor;
            v_oldBGColor="$(cat "$__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH")";

        local v_oldTextColor;
            v_oldTextColor="$(cat "$__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH")";
    fi

    # If both of the new colors are equal.
    if [ "$p_newBGColor" = "$p_newTextColor" ]; then
        p_newBGColor="$(( p_newBGColor+38 ))"
    fi

    # If the text color code's value is equal to it's former value.
    if [ "$p_newTextColor" = "$v_oldTextColor" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newTextColor="$(( p_newTextColor+38 ))";
		tput setaf "$p_newTextColor";
    fi

    # If the background color code's value is equal to it's former value.
    if [ "$p_newBGColor" = "$v_oldBGColor" ]; then
		p_newBGColor="$(( p_newBGColor+38 ))";
		tput setab "$p_newBGColor";
	fi

	if [ "$__BU_MAIN_STAT_DECHO" = 'restrict' ]; then
        printf "%s" "$p_newTextColor";
        printf "%s" "$p_newBGColor";
        printf "%s" "$p_string";
        printf "%s" "$v_oldBGColor";
        printf "%s" "$v_oldTextColor";
        printf "\n";

        return 0;
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}";;

                *)
                    # WARNING ! >>> DO NOT RESET «< the "$__BU_MAIN_STAT_TXT_FMT" variable's value >>> to "true" «<, or else the program will be stuck in an infinite loop.

                    # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT";

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
                    fi

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                        "Check if the value is supported in the first value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO";

                    BU::Main::Status::ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val";
                    fi

                    return 1;
                    ;;
            esac
        done

        echo -e "$p_string$p_newTextColor$__BU_MAIN_COLOR_TXT_RESET";

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU::IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}";;

                *)
                    # WARNING ! Do not reset the "$__BU_MAIN_STAT_DECHO" variable's value  to "true", or else the program will be stuck in an infinite loop.

                    # The function "BU::Main::Errors::HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_DECHO" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # Saving the "true" value from the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if BU::Main::Status::CheckStatAllowFormatting; then
                        local v_bu_main_stat_txt_fmt_old_val="$__BU_MAIN_STAT_TXT_FMT";

                        BU::Main::Status::ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
                    fi

                    # shellcheck disable=SC2034
                    BU::Main:Status::ChangeSTAT_DECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

                    BU::Main::Errors::HandleErrors "1" "AT LEAST ONE OF THE $(BU::DechoHighlightFunction "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                    "Check if the value is supported in the second value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO";

                    # Restoration of the "true" value in the "$__BU_MAIN_STAT_TXT_FMT" global status variable.
                    if [ "$v_bu_main_stat_txt_fmt_old_val" ]; then
                        __BU_MAIN_STAT_TXT_FMT="$v_bu_main_stat_txt_fmt_old_val";
                    fi
                    ;;
            esac
        done
    fi

    return 0;
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(BU::Decho_FMT_BlinkBoldDISU "$(BU::DechoOrange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(BU::DechoOrange "$(BU::Decho_FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "BU::Decho()" function calls with colors.
function BU::DechoAqua              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_AQUA"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoBlack             { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_BLACK"       "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoBlue              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_BLUE"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoCyan              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_CYAN"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoFuchsia           { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_FUCHSIA"     "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoGray              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_GRAY"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoGreen             { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_GREEN"       "$2"        "${pa_arr[@]}"  	|| return 1; return 0; }
function BU::DechoLime              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_LIME"        "$2"        "${pa_arr[@]}"  	|| return 1; return 0; }
function BU::DechoMaroon            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_MAROON"      "$2"        "${pa_arr[@]}"  	|| return 1; return 0; }
function BU::DechoNavy              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_NAVY"        "$2"        "${pa_arr[@]}"  	|| return 1; return 0; }
function BU::DechoOlive             { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_OLIVE"       "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoOrange            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_ORANGE"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoPink              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_PINK"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoPurple            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_PURPLE"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoRed               { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_RED"         "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoSalmon            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_SALMON"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoSilver            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_SILVER"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoTan               { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TAN"         "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoTeal              { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TEAL"        "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoTurquoise         { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_TURQUOISE"   "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoViolet            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_VIOLET"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoWhite             { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_WHITE"       "$2"        "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoYellow            { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$__BU_MAIN_COLOR_TXT_YELLOW"      "$2"        "${pa_arr[@]}"	|| return 1; return 0; }

# Easy "BU::Decho()" function calls with specific text display colors.
function BU::DechoHighlight         { shift 2; local pa_arr=("$@"); BU::Decho             "$__1" "$__BU_MAIN_COLOR_TXT_HIGHLIGHT" "$__2"	"${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightError    { shift 2; local pa_arr=("$@"); BU::Decho_FMT_BoldIU  "$1" "$__BU_MAIN_COLOR_TXT_ERROR"		"$2"	"${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightFunction { shift 2; local pa_arr=("$@"); BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_TXT_FUNCTION"	"$2"    "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightNewstep  { shift 2; local pa_arr=("$@"); BU::Decho_FMT_I       "$1" "$__BU_MAIN_COLOR_TXT_NEWSTEP"	"$2"    "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightPath     { shift 2; local pa_arr=("$@"); BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_TXT_PATH"		"$2"	"${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightSuccess  { shift 2; local pa_arr=("$@"); BU::Decho_FMT_I       "$1" "$__BU_MAIN_COLOR_TXT_SUCCESS"	"$2"    "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightVar      { shift 2; local pa_arr=("$@"); BU::Decho_FMT_Bold    "$1" "$__BU_MAIN_COLOR_TXT_VAR"		"$2"    "${pa_arr[@]}"	|| return 1; return 0; }
function BU::DechoHighlightWarning  { shift 2; local pa_arr=("$@"); BU::Decho_FMT_BoldIU  "$1" "$__BU_MAIN_COLOR_TXT_WARNING"	"$2"	"${pa_arr[@]}"	|| return 1; return 0; }

# Easy "BU::Decho()" function calls with background color display.
function BU::DechoBGColor           { shift 2; local pa_arr=("$@"); BU::Decho "$1" "$2" "${pa_arr[@]}"; }


# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU::Main::ModConfig::Colors::SetTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   $1  --> String to display
#   $2  --> Color to display

# Blink formatting.
function BU::Decho_FMT_Blink            { BU::Decho "$1" "$2" "$3" 'Blink'                          	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBold        { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold'                   	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldD       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDI      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIS     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'S'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDISU    { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'S' 'U'       || return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDIU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'I' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDS      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDSU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldDU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'D' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldI       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIS      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldISU     { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldIU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'I' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldS       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'S'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldSU      { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'S' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BlinkBoldU       { BU::Decho "$1" "$2" "$3" 'Blink' 'Bold' 'U'               	|| return 1; return 0; }
function BU::Decho_FMT_BlinkD           { BU::Decho "$1" "$2" "$3" 'Blink' 'D'                      	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDI          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDIS         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'S'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDISU        { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'S' 'U'          	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDIU         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'I' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDS          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'S'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDSU         { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'S' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkDU          { BU::Decho "$1" "$2" "$3" 'Blink' 'D' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkI           { BU::Decho "$1" "$2" "$3" 'Blink' 'I'                          || return 1; return 0; }
function BU::Decho_FMT_BlinkIS          { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'S'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkISU         { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'S' 'U'              	|| return 1; return 0; }
function BU::Decho_FMT_BlinkIU          { BU::Decho "$1" "$2" "$3" 'Blink' 'I' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkS           { BU::Decho "$1" "$2" "$3" 'Blink' 'S'                      	|| return 1; return 0; }
function BU::Decho_FMT_BlinkSU          { BU::Decho "$1" "$2" "$3" 'Blink' 'S' 'U'                  	|| return 1; return 0; }
function BU::Decho_FMT_BlinkU           { BU::Decho "$1" "$2" "$3" 'Blink' 'U'                          || return 1; return 0; }

# Bold formatting.
function BU::Decho_FMT_Bold     { BU::Decho "$1" "$2" "$3" 'Bold'                   	|| return 1; return 0; }
function BU::Decho_FMT_BoldD    { BU::Decho "$1" "$2" "$3" 'Bold' 'D'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldDI   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldDIS  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'S'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDISU { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'S' 'U'   	|| return 1; return 0; }
function BU::Decho_FMT_BoldDIU  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'I' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDS   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldDSU  { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldDU   { BU::Decho "$1" "$2" "$3" 'Bold' 'D' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldI    { BU::Decho "$1" "$2" "$3" 'Bold' 'I'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldIS   { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'S'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldISU  { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'S' 'U'       	|| return 1; return 0; }
function BU::Decho_FMT_BoldIU   { BU::Decho "$1" "$2" "$3" 'Bold' 'I' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldS    { BU::Decho "$1" "$2" "$3" 'Bold' 'S'               	|| return 1; return 0; }
function BU::Decho_FMT_BoldSU   { BU::Decho "$1" "$2" "$3" 'Bold' 'S' 'U'           	|| return 1; return 0; }
function BU::Decho_FMT_BoldU    { BU::Decho "$1" "$2" "$3" 'Bold' 'U'                   || return 1; return 0; }

# Dim formatting
function BU::Decho_FMT_D    { BU::Decho "$1" "$2" "$3" 'D'              	|| return 1; return 0; }
function BU::Decho_FMT_DI   { BU::Decho "$1" "$2" "$3" 'D' 'I'          	|| return 1; return 0; }
function BU::Decho_FMT_DIS  { BU::Decho "$1" "$2" "$3" 'D' 'I' 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_DISU { BU::Decho "$1" "$2" "$3" 'D' 'I' 'S' 'U'  	|| return 1; return 0; }
function BU::Decho_FMT_DIU  { BU::Decho "$1" "$2" "$3" 'D' 'I' 'U'      	|| return 1; return 0; }
function BU::Decho_FMT_DS   { BU::Decho "$1" "$2" "$3" 'D' 'S'          	|| return 1; return 0; }
function BU::Decho_FMT_DSU  { BU::Decho "$1" "$2" "$3" 'D' 'S' 'U'      	|| return 1; return 0; }
function BU::Decho_FMT_DU   { BU::Decho "$1" "$2" "$3" 'D' 'U'              || return 1; return 0; }

# Italic formatting.
function BU::Decho_FMT_I    { BU::Decho "$1" "$2" "$3" 'I'          	|| return 1; return 0; }
function BU::Decho_FMT_IS   { BU::Decho "$1" "$2" "$3" 'I' 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_ISU  { BU::Decho "$1" "$2" "$3" 'I' 'S' 'U'  	|| return 1; return 0; }
function BU::Decho_FMT_IU   { BU::Decho "$1" "$2" "$3" 'I' 'U'          || return 1; return 0; }

# Strikethrough formatting.
function BU::Decho_FMT_S    { BU::Decho "$1" "$2" "$3" 'S'      	|| return 1; return 0; }
function BU::Decho_FMT_SU   { BU::Decho "$1" "$2" "$3" 'S' 'U'      || return 1; return 0; }

# Underline formatting.
function BU::Decho_FMT_U    { BU::Decho "$1" "$2" "$3" 'U'      || return 1; return 0; }

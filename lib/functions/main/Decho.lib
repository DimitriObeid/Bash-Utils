#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : BU.Main.Decho.Decho.lib
# Module        : Main
# Author(s)     : Dimitri Obeid
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2181

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == en_* ]]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)
#### DEBUG ID : decho::text-writing-and-decoration-(formatting)

__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING="decho::text-writing-and-decoration-(formatting)";

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS
## DEBUG ID : writing-differently-cf-text-between-Text.basis

__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS="${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}::writing-differently-cf-text-between-Text.basis";

# Text's inside decoration/formatting procssing (light version, safe to use when the complete version cannot be called without provoking an infinite loop).
function BU.Main.Decho.__Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}" \
        "${__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS}";

	#**** Parameters ****
	local p_string=${1:-$'\0'};         # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
	local p_newTextColor=${2:-$'\0'};   # ARG TYPE : CMD		- OPTIONAL | DEFAULT VAL : NULL	    - DESC : Color to apply on each string's characters.
	local p_newBGColor=${3:-$'\0'};	    # ARG TYPE : CMD		- OPTIONAL | DEFAULT VAL : NULL	    - DESC : Color to apply in the text's background.

	#**** Code ****
    printf "%s\n" "${p_newTextColor}${p_string}${p_newBGColor}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Text's inside decoration/formatting procssing (complete version).

# Featured functions and files from the "functions" folder :
#   - BU.Main.Checkings.CheckDecho
#   -
function BU.Main.Decho.Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}" \
        "${__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};         # String	- Default : NULL	- String to display.
    local p_newTextColor=${2:-NULL};    # Int       - Default : NULL	- Color to apply on each string's characters.
    local p_newBGColor=${3:-NULL};      # Int       - Default : NULL	- Color to apply in the text's background.

    if [ "${p_newTextColor^^}"  == 'NULL' ]; then p_newTextColor=$'\0'; fi
    if [ "${p_newBGColor^^}"    == 'NULL' ]; then p_newBGColor=$'\0';   fi

    # Processing the arguments array.
    if [ -n "${p_string}" ]; then
        if [ -z "${p_newTextColor}" ] && [ -z "${p_newBGColor}" ]; then
            shift 1;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :

            BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}";

        elif [ -n "${p_newBGColor}" ] && [ -z "${p_newTextColor}" ] || [ -n "${p_newTextColor}" ] && [ -z "${p_newBGColor}" ]; then
            shift 2;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :

            BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}";
        else
            shift 3;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :
        fi
    fi

	#**** Variables ****
    local v_loop_error; # VAR TYPE : String     - DESC : This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #**** Code ****
    # If a string is provided as a color name, the corresponding color code is assigned to the variable.
    if BU.Main.Checkings.IsAlphaString "${p_newTextColor}";     then BU.Main.TextFormat.Atoi "${p_newTextColor}";   p_newTextColor="${__BU_MAIN_COLORS_ATOI_COLOR}";    fi
    if BU.Main.Checkings.IsAlphaString "${p_newBGColor}";       then BU.Main.TextFormat.Atoi "${p_newBGColor}";     p_newBGColor="${__BU_MAIN_COLORS_ATOI_COLOR}";      fi

    if ! BU.Main.Args__Decho.Decho "${p_string}" "${p_newTextColor}" "${p_newTextColor}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then return 1; fi

    BU.Main.Checkings.CheckDecho;

    if test "${?}" -ne 0; then
        if [ "${__BU_MAIN_STAT_DECHO,,}" == 'forbid' ]; then

            # If the text formatting is forbidden, but the "${__BU_MAIN_STAT_TXT_FMT}" global status variable's value is set to "true", the text to decorate will be put between French guillemets.
            if BU.Main.Status.CheckStatAllowFormatting; then
                echo -ne "« ${p_string} »"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            # Else, if the text formatting is forbidden, AND the "${__BU_MAIN_STAT_TXT_FMT}" global status variable's value is set to "false", no decoration nor highlighting will be made.
            else
                echo -ne "${p_string}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
            fi
        else
            echo -ne "« ${p_string} »"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi

        return "${__BU_MAIN_EXIT_NOT_PERMITTED}";
    else
        if [ -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then
            local v_oldBGColor;
                v_oldBGColor="$(cat "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}")"; fi

        if [ -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then
            local v_oldTextColor;
                v_oldTextColor="$(cat "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")"; fi
    fi

    # If both of the new colors are equal.
    if [ "${p_newBGColor}" == "${p_newTextColor}" ]; then
        p_newBGColor="$(( p_newBGColor + 34 ))"
    fi

    # If the text color code's value is equal to it's former value.
    if [ "${p_newTextColor}" == "${v_oldTextColor}" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newTextColor="$(( p_newTextColor + 38 ))";
    fi

    # If the background color code's value is equal to it's former value.
    if [ "${p_newBGColor}" == "${v_oldBGColor}" ]; then
		p_newBGColor="$(( p_newBGColor + 38 ))";
	fi

    # Setting the new values in their color code temporary file.
    if [ -n "${p_newTextColor}" ]; then BU.Main.TextFormat.SetTextColor "${p_newTextColor}"; fi

    if [ -n "${p_newBGColor}" ]; then BU.Main.TextFormat.SetBGColor "${p_newBGColor}"; fi

    # Test code, to check the values from the command substitutes.
    echo "STRING : ${p_string}";
    echo "TEXT COLOR : ${p_newTextColor}";
    echo "BG COLOR : ${p_newBGColor}";

    # -----------------------------------------------

    ## APPLYING THE FORMATTINGS ON THE TEXT

    # If the "${__BU_MAIN_STAT_DECHO}" status global variable is set to "restrict", then only basic formatting is applied.
	if [ "${__BU_MAIN_STAT_DECHO,,}" == 'restrict' ]; then
        printf "%s" "${p_newTextColor}";
        printf "%s" "${p_newBGColor}";
        printf "%s" "${p_string}";
        printf "%s" "${v_oldBGColor}";
        printf "%s" "${v_oldTextColor}";
        printf "\n";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU.Main.Checkings.IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}";;

                *)
                    printf "IN %s, FUNCTION %s, LINE %s --> ERROR : AT LEAST ONE OF THE ${FUNCNAME[0]}()'S ARRAY ARGUMENT VALUE IS INCORRECT\n\nCheck if the value is supported in the first value checking case" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                    BU.Main.Status.ChangeSTAT_TXT_FMT "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; v_loop_error='error'; break; };

                    local C="${__BU_MAIN_EXIT_NOT_PERMITTED}"; v_loop_error='error'; break;
                ;;
            esac
        done; if [ "${v_loop_error}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

        echo -e "${p_string}${p_newTextColor}${__BU_MAIN_COLOR_CODE_RESET}";

        # -----------------------------------------------

        ## APPLYING THE FORMATTINGS ON THE TEXT

        # Resetting the text's color.
        if [ -n "${p_newTextColor}" ]; then BU.Main.TextFormat.SetTextColor "${v_oldTextColor}"; fi

        if [ -n "${p_newBGColor}" ]; then BU.Main.TextFormat.SetBGColor "${v_oldBGColor}"; fi

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU.Main.Checkings.IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}";;

                *)
                    printf "IN %s, FUNCTION %s, LINE %s --> ERROR : AT LEAST ONE OF THE ${FUNCNAME[0]}()'S ARRAY ARGUMENT VALUE IS INCORRECT\n\nCheck if the value is supported in the first value checking case" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                    BU.Main.Status.ChangeSTAT_TXT_FMT "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; v_loop_error='error'; break; };

                    local C="${__BU_MAIN_EXIT_NOT_PERMITTED}"; v_loop_error='error'; break;
                ;;
            esac
        done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(BU.Main.Decho.Decho.FMT_BlinkBoldDISU "$(BU.Main.Decho.Orange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(BU.Main.Decho.Orange "$(BU.Main.Decho.Decho.FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "BU.Main.Decho.Decho()" function calls with colors.
function BU.Main.Decho.Decho.Aqua                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_AQUA}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Black                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_BLACK}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Blue                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_BLUE}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Cyan                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_CYAN}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Fuchsia                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Gray                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_GRAY}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Green                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_GREEN}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Lime                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_LIME}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Maroon                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_MAROON}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Navy                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_NAVY}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Olive                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_OLIVE}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Orange                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_ORANGE}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Pink                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_PINK}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Purple                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_PURPLE}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Red                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_RED}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Salmon                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_SALMON}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Silver                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_SILVER}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Tan                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TAN}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Teal                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TEAL}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Turquoise              { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"  "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Violet                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_VIOLET}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.White                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_WHITE}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Yellow                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_YELLOW}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.Decho()" function calls with specific text display colors.
function BU.Main.Decho.Decho.Highlight              { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}"  "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.CMD                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_CMD}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Error                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_BoldIU  "${v_str}" "${__BU_MAIN_COLOR_CODE_ERROR}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Function               { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_FUNCTION}"   "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Newstep                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_I       "${v_str}" "${__BU_MAIN_COLOR_CODE_NEWSTEP}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Path                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_PATH}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Success                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_I       "${v_str}" "${__BU_MAIN_COLOR_CODE_SUCCESS}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Var                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_VAR}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Warning                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_BoldIU  "${v_str}" "${__BU_MAIN_COLOR_CODE_WARNING}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.Decho()" function calls with background color display.
function BU.Main.Decho.BGColor                      { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}"                                      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.__Decho()" function calls with colors.
function BU.Main.Decho.__Decho.Aqua                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_AQUA}"        "${2}"; }
function BU.Main.Decho.__Decho.Black                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_BLACK}"       "${2}"; }
function BU.Main.Decho.__Decho.Blue                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_BLUE}"        "${2}"; }

function BU.Main.Decho.__Decho.Cyan                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_CYAN}"        "${2}"; }
function BU.Main.Decho.__Decho.Fuchsia              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_FUCHSIA}"     "${2}"; }
function BU.Main.Decho.__Decho.Gray                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_GRAY}"        "${2}"; }

function BU.Main.Decho.__Decho.Green                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_GREEN}"       "${2}"; }
function BU.Main.Decho.__Decho.Lime                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_LIME}"        "${2}"; }
function BU.Main.Decho.__Decho.Maroon               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_MARRON}"      "${2}"; }

function BU.Main.Decho.__Decho.Navy                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_NAVY}"        "${2}"; }
function BU.Main.Decho.__Decho.Olive                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_OLIVE}"       "${2}"; }
function BU.Main.Decho.__Decho.Orange               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_ORANGE}"      "${2}"; }

function BU.Main.Decho.__Decho.Pink                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PINK}"        "${2}"; }
function BU.Main.Decho.__Decho.Purple               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PURPLE}"      "${2}"; }
function BU.Main.Decho.__Decho.Red                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_RED}"         "${2}"; }

function BU.Main.Decho.__Decho.Salmon               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SALMON}"      "${2}"; }
function BU.Main.Decho.__Decho.Silver               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SILVER}"      "${2}"; }
function BU.Main.Decho.__Decho.Tan                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TAN}"         "${2}"; }

function BU.Main.Decho.__Decho.Teal                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TEAL}"        "${2}"; }
function BU.Main.Decho.__Decho.Turquoise            { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TURQUOISE}"   "${2}"; }
function BU.Main.Decho.__Decho.Violet               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_VIOLET}"      "${2}"; }

function BU.Main.Decho.__Decho.White                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_WHITE}"       "${2}"; }
function BU.Main.Decho.__Decho.Yellow               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_YELLOW}"      "${2}"; }

# Easy "BU.Main.Decho.__Decho()" function calls with specific text display colors.
function BU.Main.Decho.__Decho.Highlight            { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_HIGLIGHT}"    "${2}"; }
function BU.Main.Decho.__Decho.CMD                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_CMD}"         "${2}"; }
function BU.Main.Decho.__Decho.Error                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_ERROR}"       "${2}"; }

function BU.Main.Decho.__Decho.Function             { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_FUNCTION}"    "${2}"; }
function BU.Main.Decho.__Decho.Newstep              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_NEWSTEP}"     "${2}"; }
function BU.Main.Decho.__Decho.Path                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PATH}"        "${2}"; }

function BU.Main.Decho.__Decho.Success              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SUCCESS}"     "${2}"; }
function BU.Main.Decho.__Decho.Var                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_VAR}"         "${2}"; }
function BU.Main.Decho.__Decho.Warning              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_WARNING}"     "${2}"; }

# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   ${1}    --> String to display.
#   ${2}    --> Text color to display.
#	${3}	--> Background color display.

# Blink formatting.
function BU.Main.Decho.Decho.FMT_Blink              { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink'                         	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBold          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold'                  	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldD         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDI        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDIS       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'S'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDISU      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'S' 'U'   || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDIU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDSU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'S' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'S' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'S'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'S' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'U'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkD             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D'                     	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDI            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDIS           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'S'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDISU          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'S' 'U'         	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDIU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDS            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'S'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDSU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'S' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkI             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I'                      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkIS            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'S'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkISU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'S' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkIU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkS             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'S'                     	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkSU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'S' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkU             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'U'                      || return 1; return 0; }

# Bold formatting.
function BU.Main.Decho.Decho.FMT_Bold           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold'                  	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldD          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'S'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'S' 'U'   || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'S' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldI          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldIS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldISU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'S' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldIU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldS          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'S'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldSU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'S' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldU          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'U'               || return 1; return 0; }

# Dim formatting
function BU.Main.Decho.Decho.FMT_D          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D'              || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'S' 'U'  || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'U'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'S'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'S' 'U'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'U'          || return 1; return 0; }

# Italic formatting.
function BU.Main.Decho.Decho.FMT_I      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_IS     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_ISU    { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'S' 'U'  || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_IU     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'U'      || return 1; return 0; }

# Strikethrough formatting.
function BU.Main.Decho.Decho.FMT_S      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_SU     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'S' 'U'  || return 1; return 0; }

# Underline formatting.
function BU.Main.Decho.Decho.FMT_U      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'U'  || return 1; return 0; }

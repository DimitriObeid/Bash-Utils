#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Decho.lib
# Module        : Main
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS

# Quick multi commands execution for the below "Decho()" function.
function __Decho { local v_oldColor=$1; tput setaf "$v_oldColor" && IsInt "$v_oldColor" && echo -e "$v_oldColor" > "$__BU_MAIN_FILE_COLOR_CODE_PATH"; }

# Text's inside decoration/formatting procssing.

# Featured functions and files from the "functions" folder :
#   - CheckDecho                        --> This file.
#       - 
function Decho()
{
    #**** Parameters ****
    local p_string=$1
    local p_newColor=$2
    shift 2

    local pa_fmtArgs
        pa_fmtArgs=$("$@")

    #**** Variables ****
    local v_oldColor

    #**** Code ****
    CheckDecho

    if test "$?" -ne 0; then
        echo -ne "« $p_string »"
        
        return 1
    else
        local v_oldColor
            v_oldColor="$(cat "$__BU_MAIN_PROJECT_COLOR_CODE_FILE_PATH")"
    fi

    if [ "$p_newColor" = "$v_oldColor" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newColor="$(( p_newColor+38 ))"
		tput setaf "$p_newColor"
	fi

	if [ "$__BU_MAIN_STAT_DECHO" = 'restrict' ]; then # || [ -z "${pa_fmtArgs[@]}" ]; then
        echo -e "$p_string$p_newColor$__BU_MAIN_COLOR_RESET"; return 0
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(IsInt "${#val}")")
                    return
                    ;;
                'BLINK')
                    echo -ne "${__BU_MAIN_TXT_FMT_BLINK}"
                    ;;
                'BOLD')
                    echo -ne "${__BU_MAIN_TXT_FMT_BOLD}"
                    ;;
                'D')
                    echo -ne "${__BU_MAIN_TXT_FMT_DIM}"
                    ;;
                'I')
                    echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}"
                    ;;
                'S')
                    echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}"
                    ;;
                'U')
                    echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}"
                    ;;
                *)
                    # WARNING ! >>> DO NOT RESET «< the "$__BU_MAIN_STAT_TXT_FMT" variable's value >>> to "true" «<, or else the program will be stuck in an infinite loop.

                    # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                    ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                    HandleErrors "1" "AT LEAST ONE OF THE $(DechoHighlight "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                        "Check if the value is supported in the first value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"

                    ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                    return 1
                    ;; 
            esac
        done

        echo -e "$p_string$p_newColor$__BU_MAIN_COLOR_RESET"

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(IsInt "${#val}")")
                    return
                    ;;
                'BLINK')
                    echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}"
                    ;;
                'BOLD')
                    echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}"
                    ;;
                'D')
                    echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}"
                    ;;
                'I')
                    echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}"
                    ;;
                'S')
                    echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}"
                    ;;
                'U')
                    echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}"
                    ;;
                *)
                    # WARNING ! Do not reset the "$__BU_MAIN_STAT_TXT_FMT" variable's value  to "true", or else the program will be stuck in an infinite loop.

                    # The function "HandleErrors()" will call this "Decho()" function, but thanks to the verification of the "CheckDecho()"'s function return code,
                    # if the "$__BU_MAIN_STAT_TXT_FMT" status variable's value is set to "false", the script will not call the following function indefinitely.

                    # shellcheck disable=SC2034
                    ChangeSTAT_TXT_FMT "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                    
                    HandleErrors "1" "AT LEAST ONE OF THE $(DechoHighlight "${FUNCNAME[@]}")'S ARRAY ARGUMENT VALUE IS INCORRECT" \
                    "Check if the value is supported in the second value checking case" "${pa_fmtArgs[@]}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"

                    ChangeSTAT_TXT_FMT "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
                    ;;
            esac
        done
    fi

    return 0
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(Decho_FMT_BlinkBoldDISU "$(DechoOrange "dolor")") sit amet..."
# echo -e "Lorem ipsum $(DechoOrange "$(Decho_FMT_BlinkBoldDISU "dolor")") sit amet..."

# Easy "Decho()" function calls with colors.
function DechoHighlight { Decho "$1" "$__BU_MAIN_COLOR_HIGHLIGHT"   || return 1; return 0; }
function DechoAqua      { Decho "$1" "$__BU_MAIN_COLOR_AQUA"        || return 1; return 0; }
function DechoBlack     { Decho "$1" "$__BU_MAIN_COLOR_BLACK"       || return 1; return 0; }
function DechoBlue      { Decho "$1" "$__BU_MAIN_COLOR_BLUE"        || return 1; return 0; }
function DechoCyan      { Decho "$1" "$__BU_MAIN_COLOR_CYAN"        || return 1; return 0; }
function DechoFuschia   { Decho "$1" "$__BU_MAIN_COLOR_FUSCHIA"     || return 1; return 0; }
function DechoGray      { Decho "$1" "$__BU_MAIN_COLOR_GRAY"        || return 1; return 0; }
function DechoGreen     { Decho "$1" "$__BU_MAIN_COLOR_GREEN"       || return 1; return 0; }
function DechoLime      { Decho "$1" "$__BU_MAIN_COLOR_LIME"        || return 1; return 0; }
function DechoMaroon    { Decho "$1" "$__BU_MAIN_COLOR_MAROON"      || return 1; return 0; }
function DechoOrange    { Decho "$1" "$__BU_MAIN_COLOR_ORANGE"      || return 1; return 0; }
function DechoPink      { Decho "$1" "$__BU_MAIN_COLOR_PINK"        || return 1; return 0; }
function DechoPurple    { Decho "$1" "$__BU_MAIN_COLOR_PURPLE"      || return 1; return 0; }
function DechoRed       { Decho "$1" "$__BU_MAIN_COLOR_RED"         || return 1; return 0; }
function DechoSilver    { Decho "$1" "$__BU_MAIN_COLOR_SILVER"      || return 1; return 0; }
function DechoTeal      { Decho "$1" "$__BU_MAIN_COLOR_TEAL"        || return 1; return 0; }
function DechoTurquoise { Decho "$1" "$__BU_MAIN_COLOR_TURQUOISE"   || return 1; return 0; }
function DechoWhite     { Decho "$1" "$__BU_MAIN_COLOR_WHITE"       || return 1; return 0; }
function DechoYellow    { Decho "$1" "$__BU_MAIN_COLOR_YELLOW"      || return 1; return 0; }

# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "CheckTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   $1  --> String to display
#   $2  --> Color to display

# Blink formatting.
function Decho_FMT_Blink            { Decho "$1" "$2" 'Blink'                         || return 1; return 0; }
function Decho_FMT_BlinkBold        { Decho "$1" "$2" 'Blink' 'Bold'                  || return 1; return 0; }
function Decho_FMT_BlinkBoldD       { Decho "$1" "$2" 'Blink' 'Bold' 'D'              || return 1; return 0; }
function Decho_FMT_BlinkBoldDI      { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I'          || return 1; return 0; }
function Decho_FMT_BlinkBoldDIS     { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'S'      || return 1; return 0; }
function Decho_FMT_BlinkBoldDISU    { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'S' 'U'  || return 1; return 0; }
function Decho_FMT_BlinkBoldDIU     { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'I' 'U'      || return 1; return 0; }
function Decho_FMT_BlinkBoldDS      { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'S'          || return 1; return 0; }
function Decho_FMT_BlinkBoldDSU     { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'S' 'U'      || return 1; return 0; }
function Decho_FMT_BlinkBoldDU      { Decho "$1" "$2" 'Blink' 'Bold' 'D' 'U'          || return 1; return 0; }
function Decho_FMT_BlinkBoldI       { Decho "$1" "$2" 'Blink' 'Bold' 'I'              || return 1; return 0; }
function Decho_FMT_BlinkBoldIS      { Decho "$1" "$2" 'Blink' 'Bold' 'I' 'S'          || return 1; return 0; }
function Decho_FMT_BlinkBoldISU     { Decho "$1" "$2" 'Blink' 'Bold' 'I' 'S' 'U'      || return 1; return 0; }
function Decho_FMT_BlinkBoldIU      { Decho "$1" "$2" 'Blink' 'Bold' 'I' 'U'          || return 1; return 0; }
function Decho_FMT_BlinkBoldS       { Decho "$1" "$2" 'Blink' 'Bold' 'S'              || return 1; return 0; }
function Decho_FMT_BlinkBoldSU      { Decho "$1" "$2" 'Blink' 'Bold' 'S' 'U'          || return 1; return 0; }
function Decho_FMT_BlinkBoldU       { Decho "$1" "$2" 'Blink' 'Bold' 'U'              || return 1; return 0; }
function Decho_FMT_BlinkD           { Decho "$1" "$2" 'Blink' 'D'                     || return 1; return 0; }
function Decho_FMT_BlinkDI          { Decho "$1" "$2" 'Blink' 'D' 'I'                 || return 1; return 0; }
function Decho_FMT_BlinkDIS         { Decho "$1" "$2" 'Blink' 'D' 'I' 'S'             || return 1; return 0; }
function Decho_FMT_BlinkDISU        { Decho "$1" "$2" 'Blink' 'D' 'I' 'S' 'U'         || return 1; return 0; }
function Decho_FMT_BlinkDIU         { Decho "$1" "$2" 'Blink' 'D' 'I' 'U'             || return 1; return 0; }
function Decho_FMT_BlinkDS          { Decho "$1" "$2" 'Blink' 'D' 'S'                 || return 1; return 0; }
function Decho_FMT_BlinkDSU         { Decho "$1" "$2" 'Blink' 'D' 'S' 'U'             || return 1; return 0; }
function Decho_FMT_BlinkDU          { Decho "$1" "$2" 'Blink' 'D' 'U'                 || return 1; return 0; }
function Decho_FMT_BlinkI           { Decho "$1" "$2" 'Blink' 'I'                     || return 1; return 0; }
function Decho_FMT_BlinkIS          { Decho "$1" "$2" 'Blink' 'I' 'S'                 || return 1; return 0; }
function Decho_FMT_BlinkISU         { Decho "$1" "$2" 'Blink' 'I' 'S' 'U'             || return 1; return 0; }
function Decho_FMT_BlinkIU          { Decho "$1" "$2" 'Blink' 'I' 'U'                 || return 1; return 0; }
function Decho_FMT_BlinkS           { Decho "$1" "$2" 'Blink' 'S'                     || return 1; return 0; }
function Decho_FMT_BlinkSU          { Decho "$1" "$2" 'Blink' 'S' 'U'                 || return 1; return 0; }
function Decho_FMT_BlinkU           { Decho "$1" "$2" 'Blink' 'U'                     || return 1; return 0; }

# Bold formatting.
function Decho_FMT_Bold     { Decho "$1" "$2" 'Bold'                  || return 1; return 0; }
function Decho_FMT_BoldD    { Decho "$1" "$2" 'Bold' 'D'              || return 1; return 0; }
function Decho_FMT_BoldDI   { Decho "$1" "$2" 'Bold' 'D' 'I'          || return 1; return 0; }
function Decho_FMT_BoldDIS  { Decho "$1" "$2" 'Bold' 'D' 'I' 'S'      || return 1; return 0; }
function Decho_FMT_BoldDISU { Decho "$1" "$2" 'Bold' 'D' 'I' 'S' 'U'  || return 1; return 0; }
function Decho_FMT_BoldDIU  { Decho "$1" "$2" 'Bold' 'D' 'I' 'U'      || return 1; return 0; }
function Decho_FMT_BoldDS   { Decho "$1" "$2" 'Bold' 'D' 'S'          || return 1; return 0; }
function Decho_FMT_BoldDSU  { Decho "$1" "$2" 'Bold' 'D' 'S' 'U'      || return 1; return 0; }
function Decho_FMT_BoldDU   { Decho "$1" "$2" 'Bold' 'D' 'U'          || return 1; return 0; }
function Decho_FMT_BoldI    { Decho "$1" "$2" 'Bold' 'I'              || return 1; return 0; }
function Decho_FMT_BoldIS   { Decho "$1" "$2" 'Bold' 'I' 'S'          || return 1; return 0; }
function Decho_FMT_BoldISU  { Decho "$1" "$2" 'Bold' 'I' 'S' 'U'      || return 1; return 0; }
function Decho_FMT_BoldIU   { Decho "$1" "$2" 'Bold' 'I' 'U'          || return 1; return 0; }
function Decho_FMT_BoldS    { Decho "$1" "$2" 'Bold' 'S'              || return 1; return 0; }
function Decho_FMT_BoldSU   { Decho "$1" "$2" 'Bold' 'S' 'U'          || return 1; return 0; }
function Decho_FMT_BoldU    { Decho "$1" "$2" 'Bold' 'U'              || return 1; return 0; }

# Dim formatting
function Decho_FMT_D    { Decho "$1" "$2" 'D'             || return 1; return 0; }
function Decho_FMT_DI   { Decho "$1" "$2" 'D' 'I'         || return 1; return 0; }
function Decho_FMT_DIS  { Decho "$1" "$2" 'D' 'I' 'S'     || return 1; return 0; }
function Decho_FMT_DISU { Decho "$1" "$2" 'D' 'I' 'S' 'U' || return 1; return 0; }
function Decho_FMT_DIU  { Decho "$1" "$2" 'D' 'I' 'U'     || return 1; return 0; }
function Decho_FMT_DS   { Decho "$1" "$2" 'D' 'S'         || return 1; return 0; }
function Decho_FMT_DSU  { Decho "$1" "$2" 'D' 'S' 'U'     || return 1; return 0; }
function Decho_FMT_DU   { Decho "$1" "$2" 'D' 'U'         || return 1; return 0; }

# Italic formatting.
function Decho_FMT_I    { Decho "$1" "$2" 'I'         || return 1; return 0; }
function Decho_FMT_IS   { Decho "$1" "$2" 'I' 'S'     || return 1; return 0; }
function Decho_FMT_ISU  { Decho "$1" "$2" 'I' 'S' 'U' || return 1; return 0; }
function Decho_FMT_IU   { Decho "$1" "$2" 'I' 'U'     || return 1; return 0; }

# Strikethrough formatting.
function Decho_FMT_S    { Decho "$1" "$2" 'S'     || return 1; return 0; }
function Decho_FMT_SU   { Decho "$1" "$2" 'S' 'U' || return 1; return 0; }

# Underline formatting.
function Decho_FMT_U    { Decho "$1" "$2" 'U' || return 1; return 0; }

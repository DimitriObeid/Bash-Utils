#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Input.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ------------------
# FILE DESCRIPTION :

# These functions manage the user's inputs.


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT ADD A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE THE "$(shellcheck)" COMMAND WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2; echo >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2; echo >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2; echo >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2; echo >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2; echo >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2; echo >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### LIBRARY RESOURCES

## VARIABLES

# __BU_MAIN_INPUTS_INVALID_ANSWER="Please enter a valid answer ($(BU.Main.Decho.Decho.Highlight 'yes') or ($(BU.Main.Decho.Decho.Highlight 'no')) !";
#
# __BU_MAIN_INPUTS_ASK_CONTINUE_EXEC="Do you want to continue the script's execution ? (yes / no)";
#
# __BU_MAIN_INPUTS_ANSWER_PROMPT="Enter your answer : ";
#
# __BU_MAIN_INPUTS_RESUME_EXEC="Resuming the execution of the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") script.";
#
# __BU_MAIN_INPUTS_CANCEL_EXEC="Aborting the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'s execution.";

## ----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### READING CASE STATEMENTS BY FUNCTIONS
#### DEBUG ID : "inputs::reading-case-statements-by-functions"

declare -r __BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS="inputs::reading-case-statements-by-functions";

## "Directories.lib" FILE
## DEBUG ID : "directories.lib-file"

declare -r __BU_MAIN_INPUTS_LIB__SUBCAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE="${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS}::directories.lib-file";

# ·······················································
# "BU.Main.Directories.TriggerRootDirWarning()" function.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                  -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                -> Main -> Echo.lib
#   - BU.Main.Echo.Read()                   -> Main -> Echo.lib

#   - BU.Main.Inputs.Read_DirectoriesTriggerRootDirWarning() -> Main -> Inputs.lib (this function, this file)

#   - BU.ModuleInit.SetInitErrorMsg()       -> Modules initializer script
#   - BU.ModuleInit.UnsetInitErrorMsg()     -> Modules initializer script

function BU.Main.Inputs.Read_DirectoriesTriggerRootDirWarning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_INPUTS_LIB__SUBCAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE}";

    #**** Variables ****
    local __read_TriggerRootDirWarning; # VAR TYPE : String     - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VTriggerRootDirWarning='1';

    BU.Main.Echo.Newstep "${__BU_MAIN_INPUTS_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_INPUTS_ANSWER_PROMPT}" __read_TriggerRootDirWarning;
	BU.Main.Echo.Read "${__read_TriggerRootDirWarning}";
	BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_TriggerRootDirWarning,,}" in
		"yes")
            BU.Main.Echo.Newstep "${__BU_MAIN_INPUTS_RESUME_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
            BU.Main.Echo.Error "${__BU_MAIN_INPUTS_CANCEL_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_INPUTS_INVALID_ANSWER}";
			BU.Main.Inputs.Read_DirectoriesTriggerRootDirWarning;
			;;
	esac
}

## ----------------------------------------------

## "Errors.lib" FILE
## DEBUG ID : "errors.lib-file"

declare -r __BU_MAIN_INPUTS_LIB__SUBCAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE="${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS}::errors.lib-file";

# ··································································································
# "BU.Main.Errors.HandleErrors" function, with the "${__BU_MAIN_STAT_ECHO}" variable set to "false".

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                      -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()                   -> Main -> Echo.lib
#   - BU.Main.Echo.Error()                      -> Main -> Echo.lib
#   - BU.Main.Echo.Newline()                    -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                    -> Main -> Echo.lib
#   - BU.Main.Echo.Read()                       -> Main -> Echo.lib

#   - BU.Main.Inputs.Read_Errors.HandleErrors() -> Main -> Inputs.lib (this function, this file)

#   - BU.ModuleInit.SetInitErrorMsg()           -> Modules initializer script
#   - BU.ModuleInit.UnsetInitErrorMsg()         -> Modules initializer script

function BU.Main.Inputs.Read_Errors.HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_INPUTS_LIB__SUBCAT_DEBUG_ID__READING_INPUTS_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE}";

    #**** Variables ****
    local __read_HandleErrors; # VAR TYPE : String      - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VReadHandleErrors='1';

	BU.Main.Echo.Newstep "${__BU_MAIN_INPUTS_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_INPUTS_ANSWER_PROMPT}" __read_HandleErrors;
	BU.Main.Echo.Read "${__read_HandleErrors}";
    BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_HandleErrors,,}" in
		"yes")
			BU.Main.Echo.Newstep "${__BU_MAIN_INPUTS_RESUME_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
			BU.Main.Echo.Error "${__BU_MAIN_INPUTS_CANCEL_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			BU.Main.Errors.Exit "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_INPUTS_INVALID_ANSWER}";
			BU.Main.Inputs.Read_Errors.HandleErrors;
			;;
	esac
}

## ----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### READING USER'S INPUTS OUTSIDE "CASE" STATEMENTS
#### DEBUG ID : "inputs::reading-user's-inputs-outside-case-statements"

declare -r __BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_USER_INPUTS_OUTSIDE_CASE_STATEMENTS="inputs::reading-user's-inputs-outside-case-statements";

## SANITIZING USER'S INPUTS BEFORE EXECUTION
## DEBUG ID : "sanitizing-user-inputs-before-execution"

declare -r __BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_USER_INPUTS_OUTSIDE_CASE_STATEMENTS__SANITIZING_USER_INPUTS_BEFORE_EXECUTION="${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_USER_INPUTS_OUTSIDE_CASE_STATEMENTS}::sanitizing-user-inputs-before-execution";

# ·····································································
# Sanitizing a string before its evaluation with the "$(eval)" command.

# Featured function(s) and file(s) by module(s) and from the "functions" folder :
#   - BU.Main.Echo.Debug()                  -> Main -> Echo.lib
#   - BU.Main.Echo.DebugEnd()               -> Main -> Echo.lib

#   - BU.Main.Errors.HandleErrors()         -> Main -> Errors.lib

function BU.Main.Inputs.Sanitize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the "$(bash -x)" command.
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_USER_INPUTS_OUTSIDE_CASE_STATEMENTS}" \
        "${__BU_MAIN_INPUTS_LIB__CAT_DEBUG_ID__READING_USER_INPUTS_OUTSIDE_CASE_STATEMENTS__SANITIZING_USER_INPUTS_BEFORE_EXECUTION}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to convert in a word array.

    #**** Variables ****
    local v_dangerousChars=';|&|\||`|>|<|$|(|)|{|}';
    local v_dangerousCmds='rm|mv|cp|mkdir|rmdir|ssh|ftp|wget|curl|dd|shred|eval|sh|bash|dash|ksh|zsh|mkfs|unzip|uz|gunzip|7z|unrar';
    local v_specialChars='[^a-zA-Z0-9_\./-]';

    #**** Code ****
    # Checking if the value does not contain dangerous commands.
    if ! echo "${p_string}" | grep -E -q "${v_dangerousChars}"; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" \
            "THE $(BU.Main.Decho.Decho.Highlight "${p_string}") INPUT CONTAINS DANGEROUS COMMANDS AND THUS CANNOT BE EVALUATED !!!!!" \
            "Do not use any of these characters as input to be evaluated : ${v_dangerousChars}" "" "$(basename "${BASH_SOURCE[0]}")" \
            "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_INVALID_ARGUMENT}";
    fi

    # Checking if the value does not contain potentially dangerous keywords.
    if echo "${p_string}" | grep -E -q "${v_dangerousCmds}"; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" \
            "THE $(BU.Main.Decho.Decho.Highlight "${p_string}") INPUT CONTAINS POTENTIALLY DANGEROUS KEYWORDS AND THUS CANNOT BE EVALUATED !!!!!" \
            "Do not use any of these keywords as input to be evaluated : ${v_dangerousCmds}" "" "$(basename "${BASH_SOURCE[0]}")" \
            "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_INVALID_ARGUMENT}";
    fi

    # Checking if the value does not contain special characters.
    if echo "${p_string}" | grep -E -q "${v_specialChars}"; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" \
            "THE $(BU.Main.Decho.Decho.Highlight "${p_string}") INPUT CONTAINS SPECIAL CHARACTERS AND THUS CANNOT BE EVALUATED !!!!!" \
            "Do not use anything else than these characters as input to be evaluated :";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_INVALID_ARGUMENT}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

## ----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #
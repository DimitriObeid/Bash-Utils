#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Args.lib
# Module        : Main
# Description   : These functions act as argument checkers for several functions in the library, whose checking would make the code more difficult to read.
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2116

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### ARGUMENT VALUES CHECKING : UTILITES FUNCTIONS
#### DEBUG ID : args::argument-values-checking--utilities-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS="";

## PATH CHECKING FUNCTIONS
## DEBUG ID : path-checking-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__PATH_CHECKING_FUNCTIONS="$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS::path-checking-functions";

# -----------------------------------------------

## QUICK MESSAGE PRINTING
## DEBUG ID : quick-message-printing

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING="$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS::quick-message-printing";

# Print a message without the need to write the whole "BU::Main::Errors::HandleErrors()" function's second argument, and according to the test option which failed :
function BU::Main::Args::PrintBadOption()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING";

    #**** Parameters ****
    local p_option=$1;      # String    - Default : NULL    - Test option.
    local p_advice=$2;      # String    - Default : NULL    - "BU::Main::Errors::HandleErrors()"'s advice argument.
    local p_argname=$3;     # String    - Default : NULL    - Name of the parameter that stores the argument.

    local p_value=$4;       # Any       - Default : NULL    - "BU::Main::Errors::HandleErrors()"'s value argument.
    local p_filename=$5;	# String    - Default : NULL    - Name of the file where the error occured.
    local p_funcname=$6;    # String    - Default : NULL    - Name of the function where the test failed.

    local p_lineno=$7;      # Int       - Default : NULL    - Line where the test failed.

    #**** Variables ****
	# Changing the "$__BU_MAIN_STAT_ECHO" status variable's value to "true" in case this function is called during a .
	if [ "${__BU_MAIN_STAT_ECHO,,}" = "false" ]; then
		local v_STAT_ECHO_was_false="true";

		BU::Main::Status::ChangeSTAT_ECHO "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || {
            local C="$?";

            BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

            return "$C";
		}
	fi

	# Since this function can be called from the "Lang.lib" file, and eventually in other library files, it's better to include a support for an appropriated file name.
	if [ -n "$p_filename" ]; then
        local v_filename="$p_filename";
	else
        local v_filename; v_filename="$(BU::Main::Args::GetFileName)";
	fi

	if [ -n "$p_funcname" ]; then
        local v_funcname; v_funcname="$p_funcname";
	else
        local v_funcname; v_funcname="$(BU::Main::Args::GetFunctionName)";
	fi

	if [ -n "$p_lineno" ]; then
        local v_lineno; v_lineno="$p_lineno";
	else
        local v_lineno; v_lineno="$(BU::Main::Args::GetLineNumber)";
	fi

    #**** Code ****
	# Verifying that all the mandatory arguments are given.
	BU::Main::Args::Argc "$#" '6' "$v_filename" "$v_funcname" "$v_lineno" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; }

	# If no value is passed as argument.
    if [[ "$p_option" = [Z-z] ]]; then
		BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER HAS NO VALUE" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

    # Else, if the value passed as argument is not an alphabetic character.
    elif [ "${p_option,,}" = '!alphachar' ]; then
        BU::Main::Errors::HandleErrors '1' \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHABETIC CHARACTER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an alphabetic string.
    elif [ "${p_option,,}" = '!alphastr' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an alphabetic string OR character.
    elif [ "${p_option,,}" = '!alphastrchar' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING OR CHARACTER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an alphanumeric character.
    elif [ "${p_option,,}" = '!alphanumchar' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC CHARACTER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an alphanumeric string.
    elif [ "${p_option,,}" = '!alphanumstr' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an alphanumeric string OR character.
    elif [ "${p_option,,}" = '!alphanumstrchar' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING OR CHARACTER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

    # Else, if the value passed as argument is not a string, which is precisely the name of a command or any other executable file.
    elif [ "${p_option^^}" = '!CMDSTR' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A COMMAND OR EXECUTABLE FILE NAME" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

        return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a valid directory path (only directories accepted).
    elif [ "${p_option,,}" = '!d' ]; then
        BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A VALID DIRECTORY PATH" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_DIR";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a valid directory or file path (both are accepted).
    elif [ "${p_option,,}" = '!df' ]; then
        BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A VALID DIRECTORY OR FILE PATH" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a valid file path (only files accepted).
    elif [ "${p_option,,}" = '!f' ]; then
        BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A VALID FILE PATH" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a floating number.
    elif [ "${p_option,,}" = '!float' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A FLOAT" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

    # Else, if the value passed as argument is not a negative floating number.
    elif [ "${p_option,,}" = '!floatneg' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A NEGATIVE FLOAT" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return 1;

	# Else, if the value passed as argument is not a positive floating number.
    elif [ "${p_option,,}" = '!floatpos' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A POSITIVE FLOAT" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not an integer.
    elif [ "${p_option,,}" = '!int' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT AN INTEGER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a negative integer.
    elif [ "${p_option,,}" = '!intneg' ]; then

        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A NEGATIVE INTEGER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

        return "$__BU_MAIN_EXIT_CURRENT_CODE";

	# Else, if the value passed as argument is not a positive integer.
    elif [ "${p_option,,}" = '!intpos' ]; then
        BU::Main::Errors::HandleErrors "1" \
            "THE $(BU::__Decho "$v_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')$p_argname" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
            "$p_advice" "$p_value" "$v_filename" "$v_funcname" "$v_lineno";

        BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED";

        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

		return "$__BU_MAIN_EXIT_CURRENT_CODE";
    fi

	if [ "$v_STAT_ECHO_was_false" = "true" ]; then
		BU::Main::Status::ChangeSTAT_ECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
	fi

    BU::SetLastReturnValue 0;

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

    return "$__BU_MAIN_EXIT_CURRENT_CODE";
}

# -----------------------------------------------

## ARGUMENT PRESENCE CHECKING
## DEBUG ID = argument-presence-checking

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING="$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS::argument-presence-checking";

# Checking the values stored in the argument array of a function.
function BU::Main::Args::GetFuncArgsArrayValues()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_funcname=$1; shift 1;   # String    - Default : NULL    - Name of the function where the array was set.

    local pa_argsArray=("$@");      # Array     - Default : NULL    - Array of values to check and display.

    #**** Variables ****
    local v_index=0;    # Int   - Default : 0   - Initial value of the "for" loop's iterations counter.

    # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.
    local v_loop_error;

    #**** Code ****
    BU::Main::Status::CheckStatIsBackupEchoing || {
        local v_echo="$__BU_MAIN_STAT_ECHO";

        BU::Main::Status::ChangeSTAT_ECHO "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
    }

    BU::ModuleInit::CheckIsDebugging && {
        BU::EchoNewstep "Values stored in the $v_funcname function's array of arguments :";

        for i in "${pa_argsArray[@]}"; do
            BU::EchoMsg "Value [$v_index] : $i" || { local C="$?"; v_loop_error='error'; break; }

            # Line break every five lines, in order to keep the values list readable for a human.
            local v_value_line=$(( v_index + 1 ));

            if [ $(( v_value_line % 5 )) -eq 0 ]; then
                BU::Newline || { local C="$?"; v_loop_error='error'; break; };
            fi

            v_index=$(( v_index+1 ));
        done; if [ "${v_loop_error,,}" = 'error' ]; then BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; fi
    }

    if [ -n "$v_echo" ] && [ "${v_echo,,}" = 'false' ]; then
        BU::Main::Status::ChangeSTAT_ECHO "$v_echo" "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO-1 ))" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Checking a file's name passed as argument.
function BU::Main::Args::GetFileName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_filename=$1;    # String    - Default : NULL    - Name of the file to process.

    #**** Code ****
    # Checking if the file's name was specified, in order to print it.
    if [ -z "$p_filename" ]; then printf "« no file identified »"; else printf "« %s »" "$p_filename"; fi;

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a function's name passed argument.
function BU::Main::Args::GetFunctionName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_funcname=$1;    # String    - Default : NULL    - Name of the function to process.

    #**** Code ****
    # Checking if the function's name was specified, in order to print it.
    if [ -z "$p_funcname" ]; then printf "« no function identified »"; else printf "« %s »" "$p_filename"; fi;

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a file's name passed as argument.
function BU::Main::Args::GetLineNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_lineno=$1;  # Int   - Default : NULL    - Line number to process.

    #**** Code ****
    # Checking if the file's name was specified, in order to print it.
    if [ -z "$p_lineno" ]; then printf "« no line identified »"; else printf "« %s »" "$p_lineno"; fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the three informations simultaneously.
function BU::Main::Args::GetFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_filename=$1;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$2;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$3;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
    if [ -n "$p_filename" ] && [ -n "$p_funcname" ] && [ -n "$p_lineno" ] && BU::IsPositiveInt "$p_lineno"; then
        BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;

    else
        #**** Variables ****
        local v_missing_filename="« NULL (as GetFFL arg 1) »";
        local v_missing_funcname="« NULL (as GetFFL arg 2) »";
        local v_missing_lineno="« NULL (as GetFFL arg 3) | »";$

        if [ -z "$p_filename" ]; then

            if [ -n "$p_funcname" ] && [ -n "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "$(BU::Main::Args::PrintFFL "$v_missing_filename" "$v_missing_funcname" "$p_lineno") : " \
                    "Please give a  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_filename' "$v_missing_filename" "$p_funcname" "$p_lineno (as GetFFL arg3) | $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "$p_funcname" ] && [ -z "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "$(BU::Main::Args::PrintFFL "$v_missing_filename" "$p_funcname" "$v_missing_lineno") : " \
                    "Please give a  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_filename' "$v_missing_filename" "$p_funcname" "$v_missing_lineno $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "$p_funcname" ] && [ -n "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "$(BU::Main::Args::PrintFFL "$v_missing_filename" "$v_funcname" "$p_lineno") : " \
                    "Please give a  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_filename' "$v_missing_filename" "$v_missing_funcname" "$p_lineno (as GetFFL arg3) | $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "$p_funcname" ] && [ -z "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "$(BU::Main::Args::PrintFFL "$v_missing_filename" "$v_missing_funcname" "$v_missing_lineno") : " \
                    "Please give a  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_filename' "$v_missing_filename" "$v_missing_funcname" "$v_missing_lineno $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

        else
            if [ -n "$p_funcname" ] && [ -z "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "" \
                    "  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_funcname' "$p_filename" "$p_funcname" "$v_missing_lineno $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "$p_funcname" ] && [ -n "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    " " \
                    "  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_funcname' "$p_filename" "$v_missing_funcname" "$p_lineno (as GetFFL arg3) | $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "$p_funcname" ] && [ -z "$p_lineno" ]; then
                BU::Main::Errors::HandleErrors '1' \
                    "" \
                    "  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_lineno' "$p_filename" "$v_missing_funcname" "$v_missing_lineno $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "$p_lineno" ] && ! BU::IsPositiveInt "$p_lineno"; then
                BU::Main::Errors::HandleErrors '1' \
                    "" \
                    "  [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    'p_lineno' "$p_filename" "$p_funcname" "$p_lineno (as GetFFL arg3) | $(( LINENO-1 )) (actual file line)";

                    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi
    fi
}

# Printing the file, function and line.

# This function is called in the "BU::Main::Args::Argc()" and "BU::Main::Echo::__EchoOutput()" functions, for example.
function BU::Main::Args::PrintFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_filename=$1;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$2;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$3;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Variables ****
    local v_filename; v_filename="$(BU::Main::Args::GetFileName "$p_filename")";
    local v_funcname; v_funcname="$(BU::Main::Args::GetFunctionName "$p_funcname")";
    local v_lineno; v_lineno="$(BU::Main::Args::GetLineNumber "$p_lineno")";

    #**** Code ****
    echo -n "$v_filename file, function $v_funcname, line $v_lineno";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Printing the file, function and line.

# Please call this function after the advice given as second argument for the "BU::Main::Args::PrintBadOption()" function.
function BU::Main::Args::PrintFFLErrorOccured()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_target_f=$1;    # String    - Default : NULL    - Function where the checking happened.
    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.

    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Variables ****
    local v_filename; v_filename="$(BU::Main::Args::GetFileName "$p_filename")";
    local v_funcname; v_funcname="$(BU::Main::Args::GetFunctionName "$p_funcname")";
    local v_lineno; v_lineno="$(BU::Main::Args::GetLineNumber "$p_lineno")";

    #**** Code ****
    echo -n "The error occured in the $v_filename file, at function $v_funcname, on line $v_lineno, during the checking of the $(BU::__Decho "$p_target_f" "$__BU_MAIN_COLOR_HIGHLIGHT") function";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}";

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking if any mandatory arguments are provided for any function.

# This function is called in the "BU::Main::Args::PrintBadOption()" function, DO NOT call the "BU::Main::Args::PrintBadOption()" function here.
function BU::Main::Args::Argc()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    local p_argcount=$1;    # Int       - Default : NULL    - Number of arguments passed.
    local p_argawait=$2;    # Int       - Default : NULL    - Number of arguments awaited.

    local p_filename=$3;    # Path      - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Variables ****
    local v_funcname; v_funcname="$(BU::__Decho "$(BU::Main::Args::GetFunctionName "$p_funcname")" "$__BU_MAIN_COLOR_HIGHLIGHT" "$__BU_MAIN_COLOR_ERROR")";

    #**** Code ****
    # If both "$p_argcount" and "$p_argawait" arguments contain a value.
    if [ -n "$p_argcount" ] && [ -n "$p_argawait" ]; then

        # If both "$p_argcount" and "$p_argawait" argument values are integer.
        if BU::IsPositiveInt "$p_argcount" && BU::IsPositiveInt "$p_argawait"; then

            # If the correct number of arguments is given to the processed function.
            if [ "$p_argcount" -eq "$p_argawait" ] || [ "$p_argawait" -eq 0 ]; then
                BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;

            # Else, if an incorrect number of arguments is given to the processed function.
            else
                # If the function awaits only one argument AND no argument is given to the function.
                if [ "$p_argawait" -eq 1 ] && [ "$p_argcount" -lt "$p_argawait" ]; then
                    BU::Main::Errors::HandleErrors "1" "THE FUNCTION $v_funcname NEEDS AN ARGUMENT" \
                        "Please pass only one argument to the $v_funcname function [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                        "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND less arguments are passed to the function.
                elif [ "$p_argawait" -ge 1 ] && [ "$p_argcount" -eq 0 ]; then
                    BU::Main::Errors::HandleErrors "1" "THE FUNCTION $v_funcname NEEDS $(BU::__Decho "$p_argawait" "$__BU_MAIN_COLOR_HIGHLIGHT") ARGUMENTS" \
                        "Please pass $(BU::__Decho "$p_argawait" "$__BU_MAIN_COLOR_HIGHLIGHT") arguments to the $v_funcname function [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                        "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND not enough arguments are passed to the function.
                elif [ "$p_argcount" -gt 0 ] && [ "$p_argcount" -lt "$p_argawait" ]; then
                    BU::Main::Errors::HandleErrors "1" "THE FUNCTION $v_funcname HAS NOT ENOUGH ARGUMENTS" \
                        "Please pass $(BU::__Decho "$(( p_argawait-p_argcount ))" "$__BU_MAIN_COLOR_HIGHLIGHT") more arguments to the $v_funcname function [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                        "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if more arguments than expected are given to the function.
                elif [ "$p_argcount" -gt "$p_argawait" ]; then
                    BU::Main::Errors::HandleErrors "1" "THE FUNCTION $v_funcname HAS TOO MUCH ARGUMENTS" \
                        "Please remove $(BU::__Decho "$(( p_argcount-p_argawait ))" "$__BU_MAIN_COLOR_HIGHLIGHT") arguments to the $v_funcname function [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                        "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
                fi
            fi

        # Else, if "$p_argcount" AND / OR "$p_argawait" argument values are not integer.
        else
            if ! BU::IsPositiveInt "$p_argcount"; then local lineno="$LINENO";
                BU::Main::Errors::HandleErrors '1' \
                    "THE $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S ARGUMENT COUNTER $(BU::__Decho "$(echo -n '$')p_argcount" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION") first argument $(BU::__Decho 'p_argcount' "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR")'s value needs to be an integer, since it is an argument counter [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

            if ! BU::IsPositiveInt "$p_argawait"; then local lineno="$LINENO";
                BU::Main::Args::PrintBadOption '1' \
                    "THE $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S AWAITED ARGUMENTS COUNTER $(BU::__Decho "$(echo -n '$')p_argawait" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION") second argument $(BU::__Decho 'p_argawait' "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR")'s value needs to be an integer, since it is an argument limit [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                    "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

    # Else, if "$p_argcount" AND / OR "$p_argawait" argument values are empty.
    else
        if [ -z "$p_argcount" ]; then local lineno="$LINENO";
            BU::Main::Errors::HandleErrors '1' \
                "THE $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')p_argcount" "$__BU_MAIN_COLOR_CODE_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER HAS NO VALUE" \
                "The function $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") first argument $(BU::__Decho 'p_argcount' "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR")'s value needs to be an integer, since it is an argument counter [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

        if [ -z "$p_argawait" ]; then local lineno="$LINENO";
            BU::Main::Errors::HandleErrors '1' \
                "THE $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") FUNCTION'S $(BU::__Decho "$(echo -n '$')p_argawait" "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR") PARAMETER HAS NO VALUE" \
                "The function $(BU::__Decho "$p_funcname" "$__BU_MAIN_COLOR_FUNCTION" "$__BU_MAIN_COLOR_ERROR") second argument $(BU::__Decho 'p_argawait' "$__BU_MAIN_COLOR_VAR" "$__BU_MAIN_COLOR_ERROR")'s value needs to be an integer, since it is an argument limit [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                "$p_argcount" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 1;
        fi
    fi
}

# Checking if any mandatory arguments are provided for any function AND the file, function and line number
# informations simultaneously, by calling both the "BU::Main::Args::Argc" and "BU::Main::Args::GetFFL()" functions.
function BU::Main::Args::GetArgc-FFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS" \
        "$__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING";

    #**** Parameters ****
    #   $1  -> BU::Main::Args::Argc "$p_argcount" parameter.
    #   $2  -> BU::Main::Args::Argc "$p_argawait" parameter.

    #   $3  -> BU::Main::Args::Argc && BU::Main::Args::GetFFL "$p_filename" parameter.
    #   $4  -> BU::Main::Args::Argc && BU::Main::Args::GetFFL "$p_funcname" parameter.
    #   $5  -> BU::Main::Args::Argc && BU::Main::Args::GetFFL "$p_lineno" parameter.

    BU::Main::Args::Argc "$1" "$2" "$3" "$4" "$5"   || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    BU::Main::Args::GetFFL "$3" "$4" "$5"           || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Checkings.lib" FILE'S FUNCTIONS

## CATEGORY : FILES PATHS CHECKING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Checkings::CheckProjectRelatedFile()" function.
function BU::Main::Args__Checkings::CheckProjectRelatedFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_parent=$1;      # String    - Default : NULL    - Name of the folder to process (into its parent directory).
    local p_child=$2;       # String    - Default : NULL    - Name of the file or folder to process (into its parent directory).
    local p_type=$3;        # Char      - Default : NULL    - Type of data to create (d = directory, f = file).

    local p_filename=$4;    # Path      - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

	#**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

	if [ -z "$p_parent" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "The function $(BU::Main::Text::CutSubStringBeforeNthDelim "$(BU::DechoHighlightFunction "$p_funcname")") needs a function passed as first argument to work properly (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_parent' "$p_parent" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_child" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "The function $(BU::Main::Text::CutSubStringBeforeNthDelim "$(BU::DechoHighlightFunction "$p_funcname")") needs a function passed as second argument to work properly (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_child' "$p_child" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	if [ -z "$p_type" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "The function $(BU::Main::Text::CutSubStringBeforeNthDelim "$(BU::DechoHighlightFunction "$p_funcname")") needs a function passed as third argument to work properly (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_type' "$p_type" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	if [ "$p_type" != 'd' ] && [ "$p_type" != 'f' ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption '!df' \
            "You need to precise if what you want to create is a directory or a file (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_type' "$p_type" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"
	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "CMDS.lib" FILE'S FUNCTIONS

## CATEGORY : GET COMMAND OUTPUTS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::CMDS::GetCommandPath()" function.
function BU::Main::Args__CMDS::GetCommandPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=$1;         # String    - Default : NULL    - Command's name.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_cmd" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "You must specify the name of the command whose path you want to know (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_cmd' "$p_cmd" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Decho.lib" FILE'S FUNCTIONS

## CATEGORY : TEXT WRITING AND DECORATION (FORMATTING)
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Decho()" function.
function BU::Main::Args__Decho::Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_string=$1;          # String	- Default : NULL	- String to display.
    local p_newTextColor=$2;    # Int       - Default : NULL	- Color to apply on each string's characters.
    local p_newBGColor=$3;      # Int       - Default : NULL	- Color to apply in the text's background.

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

	#**** Code ****
	# If the text's color code is not an integer.
	if ! BU::IsPositiveInt "$p_newTextColor"; then local lineno="$LINENO";

		# Changing the
		if [ "${__BU_MAIN_STAT_DECHO,,}" != 'forbid' ]; then
			local __bu_main_stat_decho_backup="$__BU_MAIN_STAT_DECHO";

			BU::Main::Status::ChangeSTAT_DECHO "forbid" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };
		fi

        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as text color code, as second argument for the ${__BU_MAIN_COLOR_FUNCTION}$p_funcname$__BU_MAIN_COLOR_ERROR function (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newTextColor' "$p_newTextColor" "$p_filename" "$p_funcname" "$lineno";

        local C="$?";

		if [ -n "$__bu_main_stat_decho_backup" ]; then BU::Main::Status::ChangeSTAT_DECHO "$__bu_main_stat_decho_backup" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local D="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$D"; }; fi

		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # If the background's color code is not an integer.
    if ! BU::IsPositiveInt "$p_newBGColor"; then local lineno="$LINENO";
		if [ "${__BU_MAIN_STAT_DECHO,,}" != 'forbid' ]; then
			local __bu_main_stat_decho_backup="$__BU_MAIN_STAT_DECHO";

			BU::Main::Status::ChangeSTAT_DECHO "forbid" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"; };
		fi

        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as background color code, as second argument for the ${__BU_MAIN_COLOR_FUNCTION}$p_funcname$__BU_MAIN_COLOR_ERROR function (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newBGColor' "$p_newBGColor" "$p_filename" "$p_funcname" "$p_lineno";

        local C="$1";

		if [ -n "$__bu_main_stat_decho_backup" ]; then BU::Main::Status::ChangeSTAT_DECHO "$__bu_main_stat_decho_backup" "$(basename "${BASH_SOURCE[0]}")" "$LINENO" || { local D="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$D"; }; fi

		BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Directories.lib" FILE'S FUNCTION

## CATEGORY : MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PROCESSING FUNCTIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::ProcessingDir()" function.
function BU::Main::Args__Directories::ProcessingDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=$1;    # String    - Default : NULL    - Name of the function to process.
    local p_parent=$2;      # String    - Default : NULL    - Path of the target directory's parent.
    local p_name=$3;        # String    - Default : NULL    - name of the target directory.

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_function" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass a function's name as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_function' "$p_function" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"

		return 1;
    fi

    if [ -z "$p_parent" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass a valid parent directory path as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_parent' "$p_parent" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_name" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the name of the folder to process as third argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_name' "$p_name" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"
	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - FOLDER CREATION FUNCTIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Directories::OverwriteDir()" function.
function BU::Main::Args__Directories::OverwriteDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the directory to overwrite.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    # If the target folder path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the given folder path is incorrect.
    if [ ! -d "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Directories::Make()" function.
function BU::Main::Args__Directories::Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=$1;      # String    - Default : NULL    - Parent folder's path.
    local p_name=$2;        # String    - Default : NULL    - Name of the folder to create.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    # If the parent folder's path is missing (no path is given).
    if [ -z  "$p_parent" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the new directory's parent folder as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_parent' "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "$p_parent" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_parent' "$p_parent" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the folder's name is missing (no name is given).
    if [ -z "$p_name" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "Please pass the name of the directory to create as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_name' "$p_name" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Directories::MakePath()" function.
function BU::Main::Args__Directories::MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Full path of the directory to create.
    local p_overwrite=$2;   # String    - Default : NULL    - Authorization to overwrite the directory.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    # If the new folder's full path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	if [ -n "$p_overwrite" ] && [ "$p_overwrite" != "--rmdir" ]; then local lineno="$LINENO";
		BU::Main::Args::PrintBadOption '' \
			"Please pass the valid string $(BU::DechoHighlightVar "--rmdir") that allows overwriting the $(BU::DechoHighlightFunction "$p_path") directory (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_overwrite' "$p_overwrite" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"
	fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PATH PROCESSING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Directories::GetDirectoryName()" function.
function BU::Main::Args__Directories::GetDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the directory to process.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "The $(BU::Main::Text::CutSubStringBeforeNthDelim "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Directories::GetDirectoryPath()" function.
function BU::Main::Args__Directories::GetDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the directory to process.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "The $(BU::Main::Text::CutSubStringBeforeNthDelim "$(BU::DechoHighlightFunction "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Directories::GetParentDirectoryName()" function.
function BU::Main::Args__Directories::GetParentDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the directory to process.
    local p_iterations=$2;  # Int       - Default : NULL    - Number of iterations.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    # If the target folder path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Directories::GetParentDirectoryPath()" function.
function BU::Main::Args__Directories::GetParentDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the directory to process.
    local p_iterations=$2;  # Int       - Default : 1       - Number of iterations.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    # If the target folder path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_iterations" ] ! BU::IsPositiveInt "$p_iterations"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as number of iterations (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")"
            'p_iterations' "$p_iterations" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Errors.lib" FILE'S FUNCTIONS

## CATEGORY : EXIT AND RETURN CODES HANDLING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Errors::SetLastReturnValue()" function.
BU::Main::Args__Errors::SetLastReturnValue()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
	local p_code=$1;	# Int	- Default : 1	- Return value

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

	#**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

	# If no return value is passed to as 1st argument.
	if [ -z "$p_code" ]; then local lineno="$LINENO";
		BU::Main::Args::PrintBadOption 'z' \
			"Please pass a valid integer value, from $(BU::DechoHighlight '0') to $(BU::DechoHighlight '255'), as function return code (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_code' "$p_code" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"
	fi

	# If the return value is not an integer.
	if [ -n "$p_code" ] && ! BU::IsPositiveInt "$p_code"; then local lineno="$LINENO";
		BU::Main::Args::PrintBadOption '!intpos' \
			"Please pass a valid integer value, from $(BU::DechoHighlight '0') to $(BU::DechoHighlight '255'), as function return code (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
			'p_code' "$p_code" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C"
	fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Files.lib" FILE'S FUNCTIONS

## CATEGORY : TEXT FILE PROCESSING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Files::ProcessingFile()" function.
function BU::Main::Args__Files::ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=$1;    # Function to process.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_function" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "Please pass a valid file processing function as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_function' "$p_function" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Files::OverwriteFile()" function.
function BU::Main::Args__Files::OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #***** Parameters ****
    local p_path=$1             # String    - Default : NULL    - Path of the file to overwrite.
    local p_authorization=$2;   # String    - Default : NULL    - Authorization to overwrite the file.

    local p_filename=$3;        # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;        # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;          # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    # If the target file's path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the given file path is incorrect.
    if [ ! -d "$p_path" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if no authorization to overwrite the current file is given.
	if [ -z "$p_authorization" ]; then local lineno="$LINENO";
		 BU::Main::Args::PrintBadOption 'z' \
            "Please enter a valid value for the overwrite authorization as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_authorization' "$p_authorization" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Files::Make()" function's arguments.
function BU::Main::Args__Files::Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=$1;      # String    - Parent folder path of the file to create.
    local p_name=$2;        # String    - Name of the file to create.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    # If the parent folder's path is missing (no path is given).
    if [ -z "$p_parent" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the path of the new file's parent folder as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_parent' "$p_parent" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "$p_parent" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_parent' "$p_parent" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    # Else, if the file's name is missing (no name is given).
    if [ -z "$p_name" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass the name of the file to create as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_name' "$p_name" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

#     # Else, if the file's name is too long (usually with a string size greater than 255 bytes).
    if [ "$(echo "$p_name" | wc --bytes)" -gt "$__BU_MAIN_FS_MAX_FILE_SIZE" ]; then local lineno="$LINENO";
        BU::Main::Errors::HandleErrors "$__BU_MAIN_EXIT_FILENAME_TOO_LONG" \
            "THE FILE NAME IS TOO LONG FOR THIS FILESYSTEM" \
            "Please give a name length smaller than $(BU::DechoHighlight "$__BU_MAIN_FS_MAX_FILENAME_LENGTH") bytes [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_name' "$p_name" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Files::MakePath()" function.
function BU::Main::Args__Files::MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Full path of the file to create.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    # If the new file's full path is missing (no path is given).
    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : SETTING FILE INFORMATIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Files::SetLastAccess()" function.
function BU::Main::Args__Files::SetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_filepath=$1;    # String    - Path of the file to check its last access.
    local p_fakedate=$2;    # Date      - Access date to replace.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_filepath" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass as first argument the path of the file whose last access date you wish to change (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_filepath' "$p_filepath" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ ! -f "$p_filepath" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!f' \
            "Please pass a valid file path as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_filepath' "$p_filepath" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_fakedate" ]; then local lineno="$LINENO";
         BU::Main::Args::PrintBadOption 'z' \
            "Please pass a date in $(BU::DechoHighlight "[[CC]YY]MMDDhhmm[.ss]") format as second argument (like 20220221212020.22 | 2022 02 21 21h 20m 20s and 22 ms) (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_fakedate' "$p_fakedate" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : ARCHIVES PROCESSING FUNCTIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Files::Compress()" function.
function BU::Main::Args__Files::Compress()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=$1  # String    - Default : NULL    - Compression command.
    local p_opts=$2 # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_name=$3 # String    - Default : NULL    - Archive's name.

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

	if [ -z "$p_cmd" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass a compression command name as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_cmd' "$p_cmd" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

	# If the command line compression tool is not found.
    if ! command -v "$p_cmd"; then
        if  [ "${p_cmd^^}" = 'TGZ' ] \
        || [[ "${p_cmd,,}" = tar?(.)gz ]] \
        || [[ "${p_cmd,,}" = tar?(.)bz?(2) ]] \
        || [[ "${p_cmd^^}" = TBZ?(2) ]] \
        || [ "${p_cmd^^}" = 'TXZ' ] \
        || [[ "${p_cmd,,}" = tar?(.)xz ]]; then local lineno="$LINENO";

            BU::Main::Args::PrintBadOption '!CMDSTR' \
                "Please pass an existing / installed compression command name as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
                'p_cmd' "$p_cmd" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
        fi
    fi

	return 0;
}

# "BU::Main::Files::Uncompress()" function.
function BU::Main::Args__Files::Uncompress()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=$1  # String    - Default : NULL    - Compression command.
    local p_opts=$2 # String    - Default : NULL    - Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_path=$3 # String    - Default : NULL    - Path to the archive to uncompress.

    #**** Code ****
	if [ -z "$p_cmd" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass a(n) (un)compression command name as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_cmd' "$p_cmd" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

	if ! command -v "$p_cmd"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!CMDSTR' \
            "Please pass an existing / installed (un)compression command name as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_cmd' "$p_cmd" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass as fourth argument the path of the archive to uncompress (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Filesystem.lib" FILE'S FUNCTIONS

## CATEGORY : GETTING FILE SYSTEM'S INFORMATIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Filesystem::IsPartitionFull()" function.
function BU::Main::Args__Filesystem::IsPartitionFull()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_fileFS=$1;      # String    - Default : NULL    - Path of the file or folder's file system host.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
    BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_fileFS" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_fileFS' "$p_fileFS" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_fileFS" ] && [ ! -d "$p_fileFS" ] || [ ! -f "$p_fileFS" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_fileFS' "$p_fileFS" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : GETTING FILE SYSTEM'S INFORMATIONS
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Filesystem::GetFS<...>()" functions.
function BU::Main::Args__Filesystem::GetFSInfos()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=$1;        # String    - Default : NULL    - Path of the file or folder's file system host.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
    BU::Main::Args::GetArgc-FFL "$#" '4' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_path" ] && [ ! -d "$p_path" ] || [ ! -f "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_fileFS' "$p_fileFS" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Filesystem::Chown()" function.
function BU::Main::Args__Filesystem::Chown()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=$1;    # String    - Default : NULL    - Former owner of the directory or the file (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=$2;        # String    - Default : NULL    - New owner of the directory or the file.
    local p_path=$3;            # String    - Default : NULL    - Path of the directory or the file to process.

    local p_filename=$4;        # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;        # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;          # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
    BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_currentOwner" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the name of the former directory's or file's owner (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_currentOwner' "$p_currentOwner" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_newOwner" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the name of the new directory's or file's owner (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newOwner' "$p_newOwner" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the path to the directory or the file to process (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_path" ] && [ ! -d "$p_path" ] || [ ! -f "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!df' \
            "Please give a valid path for the directory or the file to process (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : RECURSIVE PERMISSION AND OWNERSHIP PROCESSING
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Filesystem::ChownRec()" function.
function BU::Main::Args__Filesystem::ChownRec()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=$1;    # String    - Default : NULL    - Former owner of the directory (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=$2;        # String    - Default : NULL    - New owner of the directory.
    local p_path=$3;            # String    - Default : NULL    - Path of the directory to process.

    local p_filename=$4;        # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;        # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;          # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
    BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_currentOwner" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the name of the former directory's owner (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_currentOwner' "$p_currentOwner" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_newOwner" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the name of the new directory's owner (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_newOwner' "$p_newOwner" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give the path to the directory to process (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_path" ] && [ ! -d "$p_path" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!d' \
            "Please give a valid path for the directory to process (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_path' "$p_path" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Text.lib" FILE'S FUNCTIONS

## MULTI-CATEGORY FUNCTIONS :
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# Functions :
#	- BU::Main::Text::CutFirstFieldBeforeDelim()
#	- BU::Main::Text::CutLastFieldAfterDelim()
#	- BU::Main::Text::GetFirstFieldBeforeDelim()
#	- BU::Main::Text::GetLastFieldAfterDelim()
function BU::Main::Args__Text::CutBeforeAndAfterFirstAndLastDelims()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1;      # String    - Default : NULL    - String to process.
    local p_delimiter=$2;   # Char      - Default : NULL    - Delimiter.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

	if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_delimiter" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_delimiter' "$p_delimiter" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : CUTTING TEXT
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Text::CutSubStringAfterNthDelim()" function.
function BU::Main::Args__Text::CutSubStringAfterNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1;      # String    - Default : NULL    - String to process.
    local p_delimiter=$2;   # Char      - Default : NULL    - Delimiter.
    local p_iterations=$3;  # Int       - Default : 1       - Iterations.

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_delimiter" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_delimiter' "$p_delimiter" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_iterations" ] && ! BU::IsPositiveInt "$p_iterations"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_iterations' "$p_iterations" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Text::CutSubStringBeforeNthDelim()" function.
function BU::Main::Args__Text::CutSubStringBeforeNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1;      # String    - Default : NULL    - String to process.
    local p_delimiter=$2;   # String	- Default : NULL    - Delimiter.
    local p_iterations=$3;  # Int       - Default : 1       - Iterations.

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_delimiter" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_delimiter' "$p_delimiter" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_iterations" ] && ! BU::IsPositiveInt "$p_iterations"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_iterations' "$p_iterations" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Text::DeleteLettersInString()" function
function BU::Main::Args__Text::DeleteLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1;      # String    - Default : NULL    - String to process.

    local p_filename=$2;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$3;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$4;      # Int       - Default : NULL    - Line where this argument processing function is called.
    shift;

    local p_char=("$@");    # String    - Default : NULL    - Letters and strings to remove.

    #**** Code ****
    
}

# -----------------------------------------------

## CATEGORY : GETTING TEXT
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU::Main::Text::GetCharacterOccurences()" function.
function BU::Main::Args__Text::GetCharacterOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1       # String    - Default : NULL  - String to process.
    local p_target=$2       # Char      - Default : NULL  - Targeted character.

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_target" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give any single character to process as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_target' "$p_target" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -n "$p_target" ] && [ "${#p_target}" -gt 1 ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!alphanumchar' \
            "Please give only a single character to process as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_target' "$p_target" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Args__Text::GetSubStringAfterDelim()" function.
function BU::Main::Args__Text::GetSubStringAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1;              # String    - Default : NULL    - String to process.
    local p_delim=$2;               # String	- Default : NULL    - Delimiter
    local p_iterations=${3:-1};     # Int       - Default : 1       - Iterations

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

	if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

	if [ -z "$p_delim" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")"
            'p_delim' "$p_delim" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

    if [ -n "$p_iterations" ] && ! BU::IsPositiveInt "$p_iterations"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_iterations' "$p_iterations" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Text::GetSubStringBeforeDelim()" function.
function BU::Main::Args__Text::GetSubStringBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1       # String    - Default : NULL	- String to process.
    local p_delim=$2        # String    - Default : NULL	- Delimiter
	local p_iterations=$3;	# Int		- Default : 1		- Iterations

    local p_filename=$4;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$5;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$6;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '6' "$p_filename" "$p_funcname" "$p_lineno";

	if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

	if [ -z "$p_delim" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")"
            'p_delim' "$p_delim" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
	fi

    if [ -n "$p_iterations" ] && ! BU::IsPositiveInt "$p_iterations"; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_iterations' "$p_iterations" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

	BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU::Main::Text::GetSubStringOccurences()" function.
function BU::Main::Args__Text::GetSubStringOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=$1       # String    - Default : NULL  - String to process.
    local p_target=$2       # String    - Default : NULL  - Targeted sub-string

    local p_filename=$3;    # String    - Default : NULL    - Path of the file in which the currently processed function is located.
    local p_funcname=$4;    # String    - Default : NULL    - Name of the currently processed function.
    local p_lineno=$5;      # Int       - Default : NULL    - Line where this argument processing function is called.

    #**** Code ****
	BU::Main::Args::GetArgc-FFL "$#" '5' "$p_filename" "$p_funcname" "$p_lineno";

    if [ -z "$p_string" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_string' "$p_string" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    if [ -z "$p_target" ]; then local lineno="$LINENO";
        BU::Main::Args::PrintBadOption 'z' \
            "Please give any sub-string to process as second argument (mandatory argument) [/|\] $(BU::Main::Args::PrintFFLErrorOccured "$p_funcname" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno")" \
            'p_target' "$p_target" "$p_filename" "$p_funcname" "$p_lineno"; local C="$?"; BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return "$C";
    fi

    BU::Main::Echo::DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

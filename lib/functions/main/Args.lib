#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Args.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# These functions act as argument checkers for several functions in the library, whose checking would make the code more difficult to read.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2116

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### ARGUMENT VALUES CHECKING : UTILITES FUNCTIONS
#### DEBUG ID : args::argument-values-checking--utilities-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS="args::argument-values-checking--utilities-functions";

## PATH CHECKING FUNCTIONS
## DEBUG ID : path-checking-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__PATH_CHECKING_FUNCTIONS="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::path-checking-functions";

# -----------------------------------------------

## QUICK MESSAGE PRINTING
## DEBUG ID : quick-message-printing

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::quick-message-printing";

# Print a message without the need to write the whole "BU.Main.Errors.HandleErrors()" function's second argument, and according to the test option which failed :
function BU.Main.Args.PrintBadOption()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING}";

    #**** Parameters ****
    local p_option=${1};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Test option.
    local p_advice=${2};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : "BU.Main.Errors.HandleErrors()"'s advice argument.
    local p_argname=${3};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the parameter that stores the argument.

    local p_value=${4};     # ARG TYPE : Any        - REQUIRED | DEFAULT VAL : NULL     - DESC : "BU.Main.Errors.HandleErrors()"'s value argument.
    local p_filename=${5};  # ARG TYPE : File       - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file where the error occured.
    local p_funcname=${6};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function where the test failed.

    local p_lineno=${7};    # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the test failed.

    #**** Variables ****
	# Changing the "${__BU_MAIN_STAT_ECHO}" status variable's value to "true" in case this function is called during a .
	if [ "${__BU_MAIN_STAT_ECHO,,}" == "false" ]; then
		local v_STAT_ECHO_was_false="true";     # VAR TYPE : Bool | DESC :

		BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
            local C="${?}";

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return "${C}";
		}
	fi

	# Since this function can be called from the "Lang.lib" file, and eventually in other library files, it's better to include a support for an appropriated file name.
	if [ -n "${p_filename}" ]; then
        local v_filename; # VAR TYPE : File | DESC :

        v_filename="${p_filename}";
	else
        local v_filename; # VAR TYPE : File | DESC :

        v_filename="$(BU.Main.Args.GetFileName)";
	fi

	if [ -n "${p_funcname}" ]; then
        local v_funcname; # VAR TYPE : String | DESC :

        v_funcname="${p_funcname}";
	else
        local v_funcname; # VAR TYPE : String | DESC :

        v_funcname="$(BU.Main.Args.GetFunctionName)";
	fi

	if [ -n "${p_lineno}" ]; then
        declare -i v_lineno; # VAR TYPE : Int | DESC :

        v_lineno="${p_lineno}";
	else
        declare -i v_lineno; # VAR TYPE : Int | DESC :

        v_lineno="$(BU.Main.Args.GetLineNumber)";
	fi

    #**** Code ****
	# Verifying that all the mandatory arguments are given.
	BU.Main.Args.Argc "${#}" '6' "${v_filename}" "${v_funcname}" "${v_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

	# If no value is passed as argument.
    if [[ "${p_option}" == [Z-z] ]]; then
		BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER HAS NO VALUE" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not an alphabetic character.
    elif [ "${p_option,,}" == '!alphachar' ]; then
        BU.Main.Errors.HandleErrors '1' \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphabetic string.
    elif [ "${p_option,,}" == '!alphastr' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphabetic string OR character.
    elif [ "${p_option,,}" == '!alphastrchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING OR CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric character.
    elif [ "${p_option,,}" == '!alphanumchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric string.
    elif [ "${p_option,,}" == '!alphanumstr' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric string OR character.
    elif [ "${p_option,,}" == '!alphanumstrchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING OR CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not a string, which is precisely the name of a command or any other executable file.
    elif [ "${p_option^^}" == '!CMDSTR' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A COMMAND OR EXECUTABLE FILE NAME" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a valid directory path (only directories accepted).
    elif [ "${p_option,,}" == '!d' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID DIRECTORY PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_DIR}";

	# Else, if the value passed as argument is not a valid directory or file path (both are accepted).
    elif [ "${p_option,,}" == '!df' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID DIRECTORY OR FILE PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}";

	# Else, if the value passed as argument is not a valid file path (only files accepted).
    elif [ "${p_option,,}" == '!f' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID FILE PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a floating number.
    elif [ "${p_option,,}" == '!float' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not a negative floating number.
    elif [ "${p_option,,}" == '!floatneg' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A NEGATIVE FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return 1;

	# Else, if the value passed as argument is not a positive floating number.
    elif [ "${p_option,,}" == '!floatpos' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A POSITIVE FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an integer.
    elif [ "${p_option,,}" == '!int' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a negative integer.
    elif [ "${p_option,,}" == '!intneg' ]; then

        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A NEGATIVE INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a positive integer.
    elif [ "${p_option,,}" == '!intpos' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";
    fi

	if [ "${v_STAT_ECHO_was_false}" == "true" ]; then
		BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# -----------------------------------------------

## ARGUMENT PRESENCE CHECKING
## DEBUG ID = argument-presence-checking

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::argument-presence-checking";

# Checking the values stored in the argument array of a function.
function BU.Main.Args.GetFuncArgsArrayValues()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_funcname=${1};          # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function where the array was set.
    local p_decorate=${2:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Special text processing for the "Decho()" function's "BU.Main.Args__Decho.Decho()" sub-fonction.
    shift 2;

    local pa_argsArray=("${@}");      # ARG TYPE : Array      - | DEFAULT VAL : NULL    - Array of values to check and display.

    #**** Variables ****
    local v_index=0;                # VAR TYPE : Int        - DESC : Initial value of the "for" loop's iterations counter.

    # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.
    local v_loop_error;             # VAR TYPE : String     - DESC :

    #**** Code ****
    BU.Main.Status.CheckStatIsBackupEchoing || {
        local v_echo="${__BU_MAIN_STAT_ECHO}";

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    }

    BU.ModuleInit.CheckIsDebugging && {
        BU.Main.Echo.Newstep "Values stored in the $(if [[ "${p_decorate,,}" == ?(-)?(-)d?(ec?(h)o) ]]; then BU.Main.Decho.Decho.Function "${p_funcname}"; else echo "« ${p_funcname} »"; fi) function's array of arguments :";

        for i in "${pa_argsArray[@]}"; do
            BU.Main.Echo.Msg "Value [${v_index}] : ${i}" || { local C="${?}"; v_loop_error='error'; break; }

            # Line break every five lines, in order to keep the values list readable for a human.
            local v_value_line=$(( v_index + 1 ));

            if [ $(( v_value_line % 5 )) -eq 0 ]; then
                BU.Main.Echo.Newline || { local C="${?}"; v_loop_error='error'; break; };
            fi

            v_index=$(( v_index + 1 ));
        done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    }

    if [ -n "${v_echo}" ] && [ "${v_echo,,}" == 'false' ]; then
        BU.Main.Status.ChangeSTAT_ECHO "${v_echo}" 'main' "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO - 1 ))" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Checking a file's name passed as argument.
function BU.Main.Args.GetFileName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        # Checking if the file's name was specified, in order to print it.
        if [ -z "${p_filename}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Path 'no file identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Path "${p_filename}")"; fi;
    else
        if [ -z "${p_filename}" ]; then printf "« no file identified »"; else printf "« %s »" "${p_filename}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a function's name passed argument.
function BU.Main.Args.GetFunctionName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_funcname=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate,,}" == ?(-?(-))d?(ec?(h)o) ]]; then
        # Checking if the function's name was specified, in order to print it.
        if [ -z "${p_funcname}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Function 'no function identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Function "${p_funcname}()")"; fi;
    else
        if [ -z "${p_funcname}" ]; then printf "« no line identified »"; else printf "« %s »" "${p_funcname}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a file's name passed as argument.
function BU.Main.Args.GetLineNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_lineno=${1:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line number to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        if [ -z "${p_lineno}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Highlight 'no line identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Highlight "${p_lineno}")"; fi;
    else
        # Checking if the file's name was specified, in order to print it.
        if [ -z "${p_lineno}" ]; then printf "« no line identified »"; else printf "« %s »" "${p_lineno}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the three informations simultaneously.
function BU.Main.Args.GetFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    if [ -n "${p_filename}" ] && [ -n "${p_funcname}" ] && [ -n "${p_lineno}" ] && BU.Main.Checkings.IsPositiveInt "${p_lineno}"; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    else
        #**** Variables ****
        local v_missing_filename="« NULL (as GetFFL arg 1) »";
        local v_missing_funcname="« NULL (as GetFFL arg 2) »";
        local v_missing_lineno="« NULL (as GetFFL arg 3) | »";

        if [ -z "${p_filename}" ]; then

            if [ -n "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_missing_funcname}" "${p_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${p_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${p_funcname}" "${v_missing_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${p_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_funcname}" "${p_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${v_missing_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_missing_funcname}" "${v_missing_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${v_missing_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

        else
            if [ -n "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_funcname' "${p_filename}" "${p_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    " " \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_funcname' "${p_filename}" "${v_missing_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_lineno' "${p_filename}" "${v_missing_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "${p_lineno}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_lineno}"; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_lineno' "${p_filename}" "${p_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi
    fi
}

# Printing the file, function and line.

# This function is called in the "BU.Main.Args.Argc()" and "BU.Main.Echo.__EchoOutput()" functions, for example.
function BU.Main.Args.PrintFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Variables ****
    local v_filename; v_filename="$(BU.Main.Args.GetFileName "${p_filename}")";
    local v_funcname; v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}")";
    local v_lineno; v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}")";

    #**** Code ****
    echo -n "${v_filename} file, function ${v_funcname}, line ${v_lineno}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Printing the file, function and line.

# Please call this function after the advice given as second argument for the "BU.Main.Args.PrintBadOption()" function.
function BU.Main.Args.PrintFFLErrorOccured()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_target_f=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function where the checking happened.
    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.

    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.
    local p_decorate=${5:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Variables ****
    local v_target_f;               # VAR TYPE : CMD        - DESC :
    local v_filename;               # VAR TYPE : CMD        - DESC :
    local v_funcname;               # VAR TYPE : CMD        - DESC :
    local v_lineno;                 # VAR TYPE : CMD        - DESC :

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        v_target_f="$(BU.Main.Decho.Decho.Function "${p_target_f}")";

        v_filename="$(BU.Main.Args.GetFileName "${p_filename}" '--decho')";
        v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}" '--decho')";
        v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}" '--decho')";
    else
        v_target_f="${p_target_f}";

        v_filename="$(BU.Main.Args.GetFileName "${p_filename}")";
        v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}")";
        v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}")";
    fi

    echo -n "The error occured in the ${v_filename} file, at function ${v_funcname}, on line ${v_lineno}, during the checking of the ${v_target_f}() function";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking if any mandatory arguments are provided for any function.

# This function is called in the "BU.Main.Args.PrintBadOption()" function, DO NOT call the "BU.Main.Args.PrintBadOption()" function here.
function BU.Main.Args.Argc()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_argcount=${1:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of arguments passed.
    local p_argawait=${2:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of arguments awaited.

    ## IMPORTANT NOTE ABOUT THE "${p_argawait}" ARGUMENT : It is not possible to automatically get the number of declared parameters inside a function, according to ChatGPT, so you will have to provide manually the number of declared parameters).

    local p_filename=${3:-$'\0'};   # ARG TYPE : File       - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Variables ****
    local v_funcname;       # VAR TYPE : CMD        - DESC :

    #**** Code ****
    v_funcname="$(BU.Main.Decho.Decho.Highlight "$(BU.Main.Args.GetFunctionName "${p_funcname}")")";

    # If both "${p_argcount}" and "${p_argawait}" arguments contain a value.
    if [ -n "${p_argcount}" ] && [ -n "${p_argawait}" ]; then

        # If both "${p_argcount}" and "${p_argawait}" argument values are integer.
        if BU.Main.Checkings.IsPositiveInt "${p_argcount}" && BU.Main.Checkings.IsPositiveInt "${p_argawait}"; then

            # If the correct number of arguments is given to the processed function.
            if [ "${p_argcount}" -eq "${p_argawait}" ] || [ "${p_argawait}" -eq 0 ]; then
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            # Else, if an incorrect number of arguments is given to the processed function.
            else
                # If the function awaits only one argument AND no argument is given to the function.
                if [ "${p_argawait}" -eq 1 ] && [ "${p_argcount}" -lt "${p_argawait}" ]; then
                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") NEEDS AN ARGUMENT" \
                        "Please pass only one argument to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND no arguments are passed to the function.
                elif [ "${p_argawait}" -ge 1 ] && [ "${p_argcount}" -eq 0 ]; then
                    local total="";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") NEEDS $(BU.Main.Decho.Decho.Highlight "${p_argawait}") ARGUMENTS" \
                        "Please pass $(BU.Main.Decho.Decho.Highlight "${p_argawait}") argument$(if [ "${p_argawait}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND not enough arguments are passed to the function.
                elif [ "${p_argcount}" -gt 0 ] && [ "${p_argcount}" -lt "${p_argawait}" ]; then
                    local total="$(( p_argawait-p_argcount ))";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") HAS NOT ENOUGH ARGUMENTS" \
                        "Please pass $(BU.Main.Decho.Decho.Highlight "${total}") more argument$(if [ "${total}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if more arguments than expected are given to the function.
                elif [ "${p_argcount}" -gt "${p_argawait}" ]; then
                    local total="$(( p_argcount - p_argawait ))";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") HAS TOO MUCH ARGUMENTS" \
                        "Please remove $(BU.Main.Decho.Decho.Highlight "${total}") argument$(if [ "${total}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                fi
            fi

        # Else, if "${p_argcount}" AND / OR "${p_argawait}" argument values are not integer.
        else
            if ! BU.Main.Checkings.IsPositiveInt "${p_argcount}"; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S ARGUMENT COUNTER $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argcount") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") first argument $(BU.Main.Decho.Decho.Var 'p_argcount')'s value needs to be an integer, since it is an argument counter${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

            if ! BU.Main.Checkings.IsPositiveInt "${p_argawait}"; then local lineno="${LINENO}";
                BU.Main.Args.PrintBadOption '1' \
                    "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S AWAITED ARGUMENTS COUNTER $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argawait") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") second argument $(BU.Main.Decho.Decho.Var 'p_argawait')'s value needs to be an integer, since it is an argument limit${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

    # Else, if "${p_argcount}" AND / OR "${p_argawait}" argument values are empty.
    else
        if [ -z "${p_argcount}" ]; then local lineno="${LINENO}";
            BU.Main.Errors.HandleErrors '1' \
                "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Highlight "$(echo -n '$')p_argcount") PARAMETER HAS NO VALUE" \
                "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") first argument $(BU.Main.Decho.Decho.Var 'p_argcount')'s value needs to be an integer, since it is an argument counter${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

        if [ -z "${p_argawait}" ]; then local lineno="${LINENO}";
            BU.Main.Errors.HandleErrors '1' \
                "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argawait") PARAMETER HAS NO VALUE" \
                "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") second argument $(BU.Main.Decho.Decho.Var 'p_argawait')'s value needs to be an integer, since it is an argument limit${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi
    fi
}

# Checking if any mandatory arguments are provided for any function AND the file, function and line number
# informations simultaneously, by calling both the "BU.Main.Args.Argc" and "BU.Main.Args.GetFFL()" functions.
function BU.Main.Args.GetArgc-FFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    #   ${1}    -> BU.Main.Args.Argc "${p_argcount}" parameter.
    #   ${2}    -> BU.Main.Args.Argc "${p_argawait}" parameter.

    #   ${3}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_filename}" parameter.
    #   ${4}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_funcname}" parameter.
    #   ${5}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_lineno}" parameter.

#    BU.Main.Args.Argc      "${1}" "${2}" "${3}" "${4}" "${5}"  || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
#    BU.Main.Args.GetFFL    "${3}" "${4}" "${5}"                || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Checkings.lib" FILE'S FUNCTIONS

## CATEGORY : "FILES PATHS CHECKING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Checkings.CheckProjectRelatedFile()" function.
function BU.Main.Args__Checkings.CheckProjectRelatedFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to process (into its parent directory).
    local p_child=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file or folder to process (into its parent directory).
    local p_type=${3:-$'\0'};       # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of data to create (d = directory, f = file).

    local p_filename=${4:-$'\0'};   # ARG TYPE : Path       - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

	#**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a folder path passed as first argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_child}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a file OR folder name passed as second argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_child' "${p_child}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ -z "${p_type}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a type of data ('d' or 'f') passed as third argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_type' "${p_type}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ "${p_type}" != 'd' ] && [ "${p_type}" != 'f' ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption '!df' \
            "You need to precise if what you want to create is a directory or a file (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_type' "${p_type}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "CMDS.lib" FILE'S FUNCTIONS

## CATEGORY : "GET COMMAND OUTPUTS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.CMDSGetCommandPath()" function.
function BU.Main.Args__CMDS.GetCommandPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Command's name.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "You must specify the name of the command whose path you want to know (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Decho.lib" FILE'S FUNCTIONS

## CATEGORY : "TEXT WRITING AND DECORATION (FORMATTING)"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Decho.Decho()" function.
function BU.Main.Args__Decho.Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_string=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL	    - DESC : String to display.
    local p_newTextColor=${2:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL	    - DESC : Color to apply on each string's characters.
    local p_newBGColor=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL	    - DESC : Color to apply in the text's background.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

	#**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	# If the text's color code is not an integer.
	if ! BU.Main.Checkings.IsPositiveInt "${p_newTextColor}"; then local lineno="${LINENO}";
        printf "IN « %s », FUNCTION « %s », LINE « %s » : WARNING : THE « p_newTextColor » PARAMETER VALUE IS NOT AN INTEGER\n\nPlease pass a positive integer as text color code, as second argument for the « %s » function (optional argument)\n${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}%s" "${p_filename}" "${p_funcname}" "${p_lineno}" "${__BU_MAIN_COLOR_FUNCTION}${p_funcname}${__BU_MAIN_COLOR_ERROR}" "$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    # If the background's color code is not an integer.
    if ! BU.Main.Checkings.IsPositiveInt "${p_newBGColor}"; then local lineno="${LINENO}";
        printf "IN « %s », FUNCTION « %s », LINE « %s » : WARNING : THE « p_newBGColor » PARAMETER VALUE IS NOT AN INTEGER\n\nPlease pass a positive integer as background color code, as third argument for the « %s » function (optional argument)\n${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}%s" "${p_filename}" "${p_funcname}" "${p_lineno}" "${__BU_MAIN_COLOR_FUNCTION}${p_funcname}${__BU_MAIN_COLOR_ERROR}" "$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')";
            "${p_newTextColor}" "" "${p_funcname}" "${lineno}";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Directories.lib" FILE'S FUNCTION

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PROCESSING FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.ProcessingDir()" function.
function BU.Main.Args__Directories.ProcessingDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function to process.
    local p_parent=${2:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the target directory's parent.
    local p_name=${3:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the target directory.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_function}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a function's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_function' "${p_function}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a valid parent directory path as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the folder to process as third argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - FOLDER CREATION FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Directories.OverwriteDir()" function.
function BU.Main.Args__Directories.OverwriteDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to overwrite.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the given folder path is incorrect.
    if [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.Make()" function.
function BU.Main.Args__Directories.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Parent folder's path.
    local p_name=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to create.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the parent folder's path is missing (no path is given).
    if [ -z  "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the new directory's parent folder as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the folder's name is missing (no name is given).
    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the directory to create as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.MakePath()" function.
function BU.Main.Args__Directories.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the directory to create.
    local p_overwrite=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the directory.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the new folder's full path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ -n "${p_overwrite}" ] && [ "${p_overwrite}" != "--rmdir" ]; then local lineno="${LINENO}";
		BU.Main.Args.PrintBadOption '' \
			"Please pass the valid string $(BU.Main.Decho.Decho.Var "--rmdir") that allows overwriting the $(BU.Main.Decho.Decho.Function "${p_path}") directory (optional argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_overwrite' "${p_overwrite}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PATH PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Directories.GetDirectoryName()" function.
function BU.Main.Args__Directories.GetDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "The $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetDirectoryPath()" function.
function BU.Main.Args__Directories.GetDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "The $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetParentDirectoryName()" function.
function BU.Main.Args__Directories.GetParentDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.
    local p_iterations=${2:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of iterations.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetParentDirectoryPath()" function.
function BU.Main.Args__Directories.GetParentDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.
    local p_iterations=${2:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Number of iterations.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] || ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as number of iterations (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Errors.lib" FILE'S FUNCTIONS

## CATEGORY : ""
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

#

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Files.lib" FILE'S FUNCTIONS

## CATEGORY : "TEXT FILE PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Files.ProcessingFile()" function.
function BU.Main.Args__Files.ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_function}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please pass a valid file processing function as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_function' "${p_function}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.OverwriteFile()" function.
function BU.Main.Args__Files.OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #***** Parameters ****
    local p_path=${1:-$'\0'}            # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to overwrite.
    local p_authorization=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the file.

    local p_filename=${3:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target file's path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the given file path is incorrect.
    if [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if no authorization to overwrite the current file is given.
	if [ -z "${p_authorization}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please enter a valid value for the overwrite authorization as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_authorization' "${p_authorization}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.Make()" function's arguments.
function BU.Main.Args__Files.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Parent folder path of the file to create.
    local p_name=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to create.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the parent folder's path is missing (no path is given).
    if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the new file's parent folder as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the file's name is missing (no name is given).
    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the file to create as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

#     # Else, if the file's name is too long (usually with a string size greater than 255 bytes).
    if [ "$(echo "${p_name}" | wc --bytes)" -gt "${__BU_MAIN_FS_MAX_FILE_SIZE}" ]; then local lineno="${LINENO}";
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_FILENAME_TOO_LONG}" \
            "THE FILE NAME IS TOO LONG FOR THIS FILESYSTEM" \
            "Please give a name length smaller than $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}") bytes${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.MakePath()" function.
function BU.Main.Args__Files.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the file to create.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the new file's full path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "SETTING FILE INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.FilesSetLastAccess()" function.
function BU.Main.Args__Files.SetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to check its last access.
    local p_fakedate=${2:-$'\0'};   # ARG TYPE : Date       - REQUIRED | DEFAULT VAL : NULL     - DESC : Access date to replace.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_filepath}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as first argument the path of the file whose last access date you wish to change (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_filepath' "${p_filepath}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ ! -f "${p_filepath}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!f' \
            "Please pass a valid file path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_filepath' "${p_filepath}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_fakedate}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a date in $(BU.Main.Decho.Decho.Highlight "[[CC]YY]MMDDhhmm[.ss]") format as second argument (like 20220221212020.22 | 2022 02 21 21h 20m 20s and 22 ms) (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fakedate' "${p_fakedate}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "ARCHIVES PROCESSING FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Files.CompressCMD()" function.
function BU.Main.Args__Files.CompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${2:-$'\0'}        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	# If the command line compression tool is not found.
    if ! command -v "${p_cmd}"; then
            BU.Main.Args.PrintBadOption '!CMDSTR' \
                "Please pass an existing / installed compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If no name of the archive to create is given (remember that the second parameter "${p_opts}" is optional here, so the "${p_arch}" parameter is the third parameter of the original function).
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as third argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.CompressFormat()" function.
function BU.Main.Args__Files.CompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${2:-$'\0'}        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    # If no name of the archive to create is given.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as second argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.SearchInArchive()" function.
function BU.Main.Args__Files.SearchInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_arch=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the target archive.

    local p_filename=${2}:-$'\0';   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If no archive path is provided as first argument.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as first argument the path to the archive to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If a bad archive path is provided as first argument.
    if [ ! -f "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!f' \
            "Please pass as first argument an existing path to find the archive to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.UncompressCMD()" function.
function BU.Main.Args__Files.UncompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
    local p_arch=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a(n) (un)compression command's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	# If the command line compression tool is not found.
    if ! command -v "${p_cmd}"; then local lineno="${LINENO}";
            BU.Main.Args.PrintBadOption '!CMDSTR' \
                "Please pass an existing / installed (un)compression command's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If no path to the archive to uncompress is given (remember that the second parameter "${p_opts}" is optional here, so the "${p_arch}" parameter is the third parameter of the original function).
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as third argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.UncompressFormat()" function.
function BU.Main.Args__Files.UncompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_form=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
    local p_arch=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_form}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass an archive format name (like 7z, Gzip, Cab, etc...) as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_form' "${p_form}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    # If no name / path to the archive to uncompress is given.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as second argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Filesystem.lib" FILE'S FUNCTIONS

## CATEGORY : "GETTING FILE SYSTEM'S INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.IsPartitionFull()" function.
function BU.Main.Args__Filesystem.IsPartitionFull()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_fileFS=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file or folder's file system host.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_fileFS}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fileFS' "${p_fileFS}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_fileFS}" ] && [ ! -d "${p_fileFS}" ] || [ ! -f "${p_fileFS}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fileFS' "${p_fileFS}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "GETTING FILE SYSTEM'S INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.GetFS<...>()" functions.
function BU.Main.Args__Filesystem.GetFSInfos()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file or folder's file system host.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ] || [ ! -f "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.Chown()" function.
function BU.Main.Args__Filesystem.Chown()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Former owner of the directory or the file (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New owner of the directory or the file.
    local p_path=${3:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory or the file to process.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_currentOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the former directory's or file's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_currentOwner' "${p_currentOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_newOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the new directory's or file's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_newOwner' "${p_newOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the path to the directory or the file to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ] || [ ! -f "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please give a valid path for the directory or the file to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.ChownRec()" function.
function BU.Main.Args__Filesystem.ChownRec()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Former owner of the directory (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New owner of the directory.
    local p_path=${3:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_currentOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the former directory's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_currentOwner' "${p_currentOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_newOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the new directory's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_newOwner' "${p_newOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the path to the directory to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!d' \
            "Please give a valid path for the directory to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Text.lib" FILE'S FUNCTIONS

## MULTI-CATEGORY FUNCTIONS :
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# Functions :
#	- BU.Main.Text.CutFirstFieldBeforeDelim()
#	- BU.Main.Text.CutLastFieldAfterDelim()
#	- BU.Main.Text.GetFirstFieldBeforeDelim()
#	- BU.Main.Text.GetLastFieldAfterDelim()
#   - BU.Main.Text.ReverseStringWordsOrder()
function BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "CUTTING TEXT"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Text.CutSubStringAfterNthDelim()" function.
function BU.Main.Args__Text.CutSubStringAfterNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.CutSubStringBeforeNthDelim()" function.
function BU.Main.Args__Text.CutSubStringBeforeNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.DeleteLettersInString()" function
function BU.Main.Args__Text.DeleteLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.
    shift;

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "GETTING TEXT"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Text.GetCharacterOccurences()" function.
function BU.Main.Args__Text.GetCharacterOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};     # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_target}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_target}" ] && [ "${#p_target}" -gt 1 ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!alphanumchar' \
            "Please give only a single character to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetFirstCharacter()" and "BU.Main.Text.GetLastCharacter()" functions.
function BU.Main.Args__Text.GetFirstLastCharacter()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Args__Text.GetSubStringAfterDelim()" function.
function BU.Main.Args__Text.GetSubStringAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_iterations=${3:-1};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delim' "${p_delim}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetSubStringBeforeDelim()" function.
function BU.Main.Args__Text.GetSubStringBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL	    - DESC : Delimiter
	local p_iterations=${3:-$'\0'};	# ARG TYPE : Int		- REQUIRED | DEFAULT VAL : 1		- DESC : Iterations

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delim' "${p_delim}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetSubStringOccurences()" function.
function BU.Main.Args__Text.GetSubStringOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted sub-string

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument). $(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_target}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any sub-string to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "SPLITTING TEXT AND SPLITTED TEXT PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

# "BU.Main.Text.StrToWordArray()" function.
function BU.Main.Args__Text.StrToWordArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to convert in an array of words.
    local p_varname=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the array to create.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'Z' \
            "Please give as first argument a string to convert in a word array (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_varname}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'Z' \
            "Please give as second argument a string to name the array (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_varname' "${p_varname}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

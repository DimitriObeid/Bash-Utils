#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Lang.lib
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# DO NOT EXECUTE IT DIRECTLY, instead, just source it by calling the "__BASH_UTILS_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TRANSLATIONS PROCESSING FUNCTIONS

## CHECKING FUNCTIONS

# Parsing a CSV file containing translations.
function CheckNotTranslated_ParseCSVLang()
{
    #***** Parameters *****
    local p_path=$1               # Path of the translations CSV file to parse.
    local p_lang=$2               # Language to fetch.
    local p_success_msg=$3        # Success message to display in the targeted language.
    local p_error_msg=$4          # Error message to display in the targeted language.

    #***** Code *****
    local lineno="$LINENO"; if [ -z "$p_path" ]; then
        __CheckArgsMain_PrintBadOption 'z' "Please pass the path of the directory to overwrite as first argument" 'p_path' "$p_path" "${FUNCNAME[0]}" "$lineno"

    local lineno="$LINENO"; elif [ ! -f "$p_path" ]; then
        __CheckArgsMain_PrintBadOption '!f' "Please pass the valid path of the directory to overwrite as first argument" 'p_path' "$p_path" "${FUNCNAME[0]}" "$lineno"

    local lineno="$LINENO"; elif [ -z "$p_lang" ]; then
        __CheckArgsMain_PrintBadOption 'z' "Please pass the <...> of the language to fetch as argument" 'p_lang' "$p_lang" "${FUNCNAME[0]}" "$lineno"

    ## TODO : Add a fail-safe if the targeted language is not found.

    local lineno="$LINENO"; elif [ -z "$p_success_msg" ]; then
        __CheckArgsMain_PrintBadOption 'z' "Please pass the success message of your language as third argument" 'p_success_msg' "$p_success_msg" "${FUNCNAME[0]}" "$lineno"

    local lineno="$LINENO"; elif [ -z "$p_error_msg" ]; then
        __CheckArgsMain_PrintBadOption 'z' "Please pass the error message of your language as forth argument" 'p_error_msg' "$p_error_msg" "${FUNCNAME[0]}" "$lineno"
    fi
}

# -----------------------------------------------

## PARSING FUNCTIONS

# Parsing a translations CSV file.
function ParseCSVLang()
{
    #***** Parameters *****
    p_path=$1               # Path of the translations CSV file to parse.
    p_lang=$2               # Language to fetch.
    p_success_msg=$3        # Success message to display in the targeted language.
    p_error_msg=$4          # Error message to display in the targeted language.

    #***** Code *****
    # If the library is already translated and a project's translation file needs to be called,
    # then it's not recommended to call a function that prints translated text, even if it only happens because of an error.
    if [ "$__STAT_TRANSLATED" = "false" ]; then
        CheckNotTranslated_ParseCSVLang "$p_path" "$p_lang" "$p_success_msg" "$p_error_msg"

    # Else, if the library is already translated and a project's translation file needs to be called,
    # Then it's OK to call a function that prints translated text.
    else
        CheckArgsMain_ParseCSVLang "$p_path" "$p_lang" "$p_success_msg" "$p_error_msg"

        HeaderCyan "PARSING THE $(DechoHighlight "$__BU_PROJECT_NAME")'S $(DechoHighlight "$p_path") TRANSLATIONS CSV FILE"

        EchoNewstep "Finding the variables list"
        Newline

        # for i in 
    fi
}

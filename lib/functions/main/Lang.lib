#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Lang.lib
# Module        : Main
# Description   : This file provides the needed functions to parse a translations CSV file.
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.
# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TRANSLATIONS PROCESSING FUNCTIONS

## CHECKING FUNCTIONS

# Rewriting the "CheckArgsMain.lib" file's "__CheckArgsMain_PrintBadOption()" function for the initialization process, since
function CheckNotTranslated_ParseCSVLang_PrintBadOption()
{
    #***** Parameters *****
    local p_option=$1   # Test option.
    local p_advice=$2   # "HandleErrors()"'s advice argument.
    local p_argname=$3  # Name of the parameter that stores the argument.
    local p_value=$4    # "HandleErrors()"'s value argument.
    local p_funcname=$5 # Name of the function where the test failed.
    local p_lineno=$6   # Line where the test failed.

    #***** Code *****
    # If no value is passed as argument.
    if [ "$p_option" = 'z' ]; then
        ChangeSTAT_ERROR 'fatal' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

		HandleErrors "1" "THE $p_funcname's $(DechoHighlight "$(ToLowercase "$(echo -n '$')$p_argname")") PARAMETER HAS NO VALUE" \
            "$p_advice" "$p_value" "$(basename "${BASH_SOURCE[0]}")" "$p_funcname" "$p_lineno"

		return 1

    elif [ "$p_option" = '!f' ]; then
        ChangeSTAT_ERROR 'fatal' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

        HandleErrors "1" "THE $p_funcname's $(DechoHighlight "$(ToLowercase "$(echo -n '$')$p_argname")") PARAMETER'S VALUE IS NOT A VALID FILE PATH" \
            "$p_advice" "$p_value" "$(basename "${BASH_SOURCE[0]}")" "$p_funcname" "$p_lineno"

		return 1
    fi

    return 0
}

# Parsing a CSV file containing translations, when the library is not translated yet.
function CheckNotTranslated_ParseCSVLang()
{
    #***** Parameters *****
    local p_path=$1               # Path of the translations CSV file to parse.
    local p_lang=$2               # Language to fetch.
    local p_success_msg=$3        # Success message to display in the targeted language.
    local p_error_msg=$4          # Error message to display in the targeted language.

    #***** Code *****
    local lineno="$LINENO"; if [ -z "$p_path" ]; then
        if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
            __CheckArgsMain_PrintBadOption 'z' "Please pass the path of the directory to overwrite as first argument" 'p_path' "$p_path" "${FUNCNAME[0]}" "$lineno" || return 1
        else
            CheckNotTranslated_ParseCSVLang_PrintBadOption 'z' "$__BU_MAIN_MSG_LANG_" 'p_path' "$_path " "${FUNCNAME[0]}" "$lineno" || return 1
        fi

    local lineno="$LINENO"; elif [ ! -f "$p_path" ]; then
        if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
            __CheckArgsMain_PrintBadOption '!f' "Please pass the valid path of the directory to overwrite as first argument" 'p_path' "$p_path" "${FUNCNAME[0]}" "$lineno" || return 1
        else
            CheckNotTranslated_ParseCSVLang_PrintBadOption '!f' "$__BU_MAIN_MSG_LANG_" 'p_path' "$p_path" "${FUNCNAME[0]}" "$lineno" || return 1
        fi

    local lineno="$LINENO"; elif [ -z "$p_lang" ]; then
        if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
            __CheckArgsMain_PrintBadOption 'z' "Please pass the ISO 639-1 language's code to fetch as second argument" 'p_lang' "$p_lang" "${FUNCNAME[0]}" "$lineno" || return 1
        else
            CheckNotTranslated_ParseCSVLang_PrintBadOption 'z' "$__BU_MAIN_MSG_LANG_" 'p_lang' "$p_lang" "${FUNCNAME[0]}" "$lineno" || return 1
        fi

    local lineno="$LINENO"; elif [ -z "$p_success_msg" ]; then
        if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
            __CheckArgsMain_PrintBadOption 'z' "Please pass the success message of your language as third argument" 'p_success_msg' "$p_success_msg" "${FUNCNAME[0]}" "$lineno" || return 1
        else
            CheckNotTranslated_ParseCSVLang_PrintBadOption 'z' "$__BU_MAIN_MSG_LANG_" 'p_success_msg' "$p_success_msg" "${FUNCNAME[0]}" "$lineno" || return 1
        fi

    local lineno="$LINENO"; elif [ -z "$p_error_msg" ]; then
        if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
            __CheckArgsMain_PrintBadOption 'z' "Please pass the error message of your language as forth argument" 'p_error_msg' "$p_error_msg" "${FUNCNAME[0]}" "$lineno" || return 1
        else
            CheckNotTranslated_ParseCSVLang_PrintBadOption 'z' "$__BU_MAIN_MSG_LANG_" 'p_error_msg' "$p_error_msg" "${FUNCNAME[0]}" "$lineno" || return 1
        fi
    fi

    return 0
}

# -----------------------------------------------

## PARSING FUNCTIONS

# Parsing a translations CSV file.
function ParseCSVLibLang()
{
    #***** Parameters *****
    p_path=$1               # Path of the translations CSV file to parse.
    p_lang=$2               # Language to fetch.
    p_success_msg=$3        # Success message to display in the targeted language.
    p_error_msg=$4          # Error message to display in the targeted language.

    #***** Variables *****
    v_num_row=0             # Row incrementer.
    v_num_col=0             # Column incrementer.

    #***** Code *****
    # If the library is already translated and a project's translation file needs to be called,
    # then it's not recommended to call a function that prints translated text, even if it only happens because of an error.
    if [ "$__BU_MAIN_STAT_TRANSLATED" = "false" ]; then
        CheckNotTranslated_ParseCSVLang "$p_path" "$p_lang" "$p_error_msg" "$p_success_msg" || return 1

    # Else, if the library is already translated and a project's translation file needs to be called,
    # Then it's OK to call a function that prints translated text.
    else
        CheckArgsMain_ParseCSVLang "$p_path" "$p_lang" "$p_error_msg" "$p_success_msg"

        HeaderCyan "PARSING THE $(DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S $(DechoHighlight "$p_path") TRANSLATIONS CSV FILE"

        EchoNewstep "Finding the variables list"
        Newline

        # First, getting the header informations.
        while read -r line; do
            if [ "$line" = "VARIABLE" ]; then
                echo "VAR"; exit 0
            else
                ChangeSTAT_ERROR "fatal" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

                HandleErrors '1' "UNABLE TO FIND THE \"VARIABLE\" OF THE $(DechoHighlight "$p_path") FILE'S FIRST COLUMN'S ROW" \
                    "Check if the \"VARIABLE\" row is located in the $(DechoHighlight "$p_path") file's first column's row, preferably in the first row."
            fi
        done < "$p_path"


        # Then, getting the CSV file's values.
#         while read line; do
            # if "$line" = '/'; then
            #   $((v_num_col++))
            # else
            # fi
#         done

#         for col_index in "${!col_values[@]}"; do
#             col_index_2=${col_values[$col_index]}
#             
#             if [ "$col_index" -eq 1 ]; then
#                 for row_index in "${!row_values[@]}"; do
#                     language_val=${row_values[$row_index]}
#                     echo "$language_val"
#                        
#                     if [ "$language_val" = "$LANG" ]; then
#                         echo "Row $row_index, LANGUE : $LANG"
#                        fi
#                 done
#             fi
#         done
    fi

    return 0
}


# Parsing the created translation file to add the arguments values of the function where the translated message's variable is called.
function _tr()
{
    #***** Parameters *****
    p_translated=$1; shift

    p_variables_array=("$@")

    #***** Code *****
    if [ ! -f "$__BU_MAIN_PROJECT_TR_FILE_NAME" ]; then
        echo -e "UNABLE TO FIND THE CREATED TRANSLATIONS FILE"; exit 1
    else
        # ALGORITHME :
        # Lire le fichier jusqu'à trouver le nom de la variable passée en argument.
        #   Si la variable n'est pas trouvée, alors retourner 1
        #   Sinon, lire chaque argument passé.
    
        return 0
    fi
}

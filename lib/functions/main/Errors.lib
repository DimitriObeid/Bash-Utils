#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Errors.lib
# Module        : Main
# Description   : Errors handling functions.
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS
#### DEBUG ID : errors::errors-handling-functions

__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS="errors::errors-handling-functions";

## CLASSIC ERRORS HANDLING
## DEBUG ID : classic-errors-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS="$__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS::classic-errors-handling";

# Saving time when displaying a newline, an error message and an exit or a return value.

# WARNING ! DO NOT CALL ANY FUNCTION THAT CALL THIS FUNCTION DIRECTLY OR INDIRECTLY HERE,
# OR THE SCRIPT WILL LOOP FOREVER IN CASE OF AN ERROR DURING THIS FUNCTION CALL !!!
function BU::Main::Errors::HandleSmallErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_type=$1;        # Type of message to display ('E' = BU::EchoError; 'W' = BU::EchoWarning)
    local p_string=$2;      # String to display.
    local p_return=$3;      # Exit or return status ('E' = exit; 'R' = return).
    local p_cpls=$4;        # Enable the safe text printing mode.

    #**** Variables ****
    if [ "${p_cpls^^}" = 'CPLS' ]; then
        if [ "${__BU_MAIN_STAT_ECHO,,}" = 'false' ]; then
            local v_BU_STAT_ECHO_old="$__BU_MAIN_STAT_ECHO"; BU::Main::Status::ChangeSTAT_ECHO 'true' "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
        fi
    fi

    #**** Code ****
    BU::Newline >&2;

    if      [ "${p_type^^}" = 'E' ];    then BU::EchoError      "$p_string" '' '';
    elif    [ "${p_type^^}" = 'W' ];    then BU::EchoWarning    "$p_string" '' '';

    # If no type of message to displays is passed as first argument, the script will choose between one of the accepted types.
    else
		local v_advise="Please don't forget to pass a type of message to display as first argument ('E' = BU::EchoError; 'W' = BU::EchoWarning)";

        if [ "$(( RANDOM%2 ))" = "0" ]; then
            BU::EchoError "$p_string    | ${__BU_MAIN_COLOR_TXT_RESET}$v_advise" '' '';
        else
            BU::EchoWarning "$p_string  | ${__BU_MAIN_COLOR_TXT_RESET}$v_advise" '' '';
        fi
    fi

    BU::Newline >&2

    # As the "BU::EchoWarning()" function will be called in case of a missing return or exit code (normally passed as second argument),
    # it's better to reset the value of the "$__BU_MAIN_STAT_ECHO" status variable condition per condition.
    if [ "${p_return^^}" = 'R' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then BU::Main::Status::ChangeSTAT_ECHO 'false' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"; fi

        BU::SetLastReturnValue 1;

        return "$__BU_MAIN_EXIT_CURRENT_CODE";

    elif [ "${p_return^^}" = 'E' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then BU::Main::Status::ChangeSTAT_ECHO 'false' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"; fi

        BU::Exit "$__BU_MAIN_EXIT_CURRENT_CODE";

    else
        BU::EchoWarning "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_TXT_WARNING} --> Warning : bad exit or return code given as second argument !"; BU::Exit "$__BU_MAIN_EXIT_CURRENT_CODE";
    fi

    if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

    BU::SetLastReturnValue 0;

    return "$__BU_MAIN_EXIT_CURRENT_CODE";
}

# -----------------------------------------------

## EXIT AND RETURN CODES HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function BU::Exit()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_exitcode=$1;    # Int   : Exit code.
    local p_behavior=$2;    # Char  : Use "exit" or "return" keywords.

    #**** Code ****
    if BU::IsPositiveInt "$p_exitcode"; then

        if [ "${p_behavior^^}" = 'E' ] || [ -z "$p_behavior" ]; then
            exit "$p_exitcode" || kill "$$";

        elif [ "${p_behavior^^}" = 'W' ]; then
            return "$p_exitcode";

        else
            # shellcheck disable=SC2034
            __BU_MAIN_STAT_DECHO='restrict';

            # shellcheck disable=SC2034
            __BU_MAIN_STAT_ECHO='true';

            BU::Newline 2 >&2;

            BU::EchoError "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Error : No valid character passed as second argument ('E' (exit) or 'W' (warning) expected)";
            BU::Newline >&2;

            exit "$p_exitcode"; kill "$__BU_MODULE_INIT_PROJECT_PID";
        fi
    else
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : unexpected exit code passed as argument";

        exit 1; kill "$__BU_MODULE_INIT_PROJECT_PID";
    fi
}

# Unsetting the last return value's variable value.
function BU::DeleteLastReturnValue() { unset __BU_MAIN_EXIT_CURRENT_CODE && return 0; }

# Setting the last function's return value in order to process it in another function.
function BU::SetLastReturnValue()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
	local p_code=${1:-1};		# Int	- Default : 1	- Return value.

	#**** Code ****
	if ! BU::Main::Args__Errors::SetLastReturnValue "$p_code" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then
        __BU_MAIN_EXIT_CURRENT_CODE="$__BU_MAIN_EXIT_NOT_PERMITTED";

        return "$__BU_MAIN_EXIT_NOT_PERMITTED";
    fi

	__BU_MAIN_EXIT_CURRENT_CODE="$p_code";

	return 0;
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# "BU::Main::Errors::HandleErrors()" function --> Handling file name presence.
function BU::Main::Errors::HandleErrors_File()        { if [ -z "$1" ]; then BU::DechoHighlightPath "<no specified file>"; else BU::DechoHighlightPath "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling function name presence.
function BU::Main::Errors::HandleErrors_Function()    { if [ -z "$1" ]; then BU::DechoHighlightFunction "<no specified function>"; else BU::DechoHighlightFunction "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling line number presence.
function BU::Main::Errors::HandleErrors_Line()        { if [ -z "$1" ]; then BU::DechoHighlight "<no specified line>"; else BU::DechoHighlight "$1"; fi; }

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   -
function BU::Main::Errors::HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
	local p_returnCode=$1;     # Int        - Default : NULL    - Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2;    # String     - Default : NULL    - String of the type of error to display.
	local p_adviceString=$3;   # String     - Default : NULL    - String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=$4;       # String     - Default : NULL    - Incorrect value which caused the error.
	local p_file=$5;           # String     - Default : NULL    - The name of the file where the error occured.
	local p_function=$6;       # String     - Default : NULL    - The name of the function where the error occured.
	local p_lineno=$7;         # String     - Default : NULL    - Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "$LINENO").

    #**** Variables ****
    local v_hdrString;
        v_hdrString="$(echo -ne "IN $(BU::Main::Errors::HandleErrors_File "$p_file") FILE, FUNCTION $(BU::Main::Errors::HandleErrors_Function "$p_function"), LINE $(BU::Main::Errors::HandleErrors_Line "$p_lineno") -->")";

	# ***** Code *****
	BU::Main::Status::CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

	if [ "$p_returnCode" -eq 0 ]; then
        return 0;
    else
        # -------- PART 1 : MANAGING THE CALL OF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IS CALLED IN A FUNCTION CALLED BY THIS "BU::Main::Errors::HandleErrors()" FUNCTION

        # If the function needs to be called in the "BU::CheckProjectLogStatus()" function, then
        # this status variable's value MUST be set at "true", or else the script will loop forever.

        # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

        if [ "${__BU_MAIN_STAT_ECHO,,}" = "true" ]; then

            if [ -n "$__BU_MAIN_STAT_ERROR" ] && [ "${__BU_MAIN_STAT_ERROR,,}" = "fatal" ]; then
                if [ "${__BU_MAIN_STAT_INITIALIZING,,}" = 'false' ]; then
                    BU::HeaderError "A FATAL ERROR OCCURED DURING A TEST IN THE $(BU::__DechoHighlightFunction "BU::CheckProjectLogStatus" "$__BU_MAIN_COLOR_ERROR") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                else
                    BU::HeaderError "A FATAL ERROR OCCURED DURING THE $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME" "$__BU_MAIN_COLOR_ERROR")'S PROJECT INITIALIZATION" 'strlen';
                fi
            else
                if [ "${__BU_MAIN_STAT_INITIALIZING,,}" = 'false' ]; then
                    BU::HeaderError "AN ERROR OCCURED DURING A TEST IN THE $(BU::__DechoHighlightFunction "BU::CheckProjectLogStatus" "$__BU_MAIN_COLOR_ERROR") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                else
                    BU::HeaderError "AN ERROR OCCURED DURING THE $(BU::__DechoHighlight "$__BU_MAIN_PROJECT_NAME" "$__BU_MAIN_COLOR_ERROR")'S PROJECT INITIALIZATION" 'strlen';
                fi
            fi
        fi


        # -------- PART 2 : PRINTING THE HEADER

        # Redirecting the log messages to the terminal, to show them to the user.
        if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" = "log" ]; then
            local v_log_old="true"; __BU_MAIN_STAT_LOG_REDIRECT="tee"; BU::Main::Status::CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
        fi

        if [ "${__BU_MAIN_STAT_ERROR,,}" = "fatal" ]; then
            BU::HeaderRed "$v_hdrString FATAL ERROR : $p_errorString" >&2;
        else
            BU::HeaderRed "$v_hdrString ERROR : $p_errorString" >&2;
        fi


        # -------- PART 3 : GIVING AN ADVICE ABOUT THE ORIGIN OF THE ERROR TO THE USER/DEVELOPPER

        if [ -z "$p_adviceString" ]; then
            BU::EchoError "No advice to give."; BU::Newline >&2;
        else
            # Checking if the ' [/|\] ' substring exists only once, as separator from the advice and another comment.

            # IMPORTANT : the second argument of the "BU::Main::Text::GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
            if [[ "$p_adviceString" == *" [/|\] "* ]] && [ "$(BU::Main::Text::GetSubStringOccurences "$p_advice" ' [/|\] ')" -eq 1 ]; then

                local v_string_part_1; v_string_part_1="$(echo "$1" | rev | cut -d ' [/|\] ' -f2- | rev)";   # Getting first sub-string.
                local v_string_part_2; v_string_part_2="$(echo "$1" | rev | cut -d ' [/|\] ' -f 1 | rev)";   # Getting second sub-string.

                BU::EchoError "$(BU::__DechoHighlight "Advice" "$__BU_MAIN_COLOR_ERROR") : $v_string_part_1" >&2;
                BU::Newline;

                BU::EchoError "$(BU::__DechoHighlight "Other comments" "$__BU_MAIN_COLOR_ERROR") : $v_string_part_2";

            # Checking if the ' [/|\] ' substring exists more than once, as separators from the advice and any other comments.

            # IMPORTANT : the second argument of the "BU::Main::Text::GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
            elif [[ "$p_adviceString" == *" [/|\] "* ]] && [ "$(BU::Main::Text::GetSubStringOccurences "$p_advice" " [/|\] ")" -gt 1 ]; then
                true;
            else
                BU::EchoError "$(BU::__DechoHighlight "Advice" "$__BU_MAIN_COLOR_ERROR") : $p_adviceString" >&2;
            fi
        fi

        BU::Newline;

        if [ -z "$p_badValue" ]; then
            BU::EchoError "Value(s) that caused this error : $(BU::__DechoOrange 'no value' "$__BU_MAIN_COLOR_ERROR") OR $(BU::DechoOrange 'an unknown error')"; BU::Newline >&2;
        else
            BU::EchoError "Value(s) that caused this error : $(BU::__DechoHighlightVar "$p_badValue" "$__BU_MAIN_COLOR_ERROR")"; BU::Newline >&2;
        fi

        if [ "${__BU_MAIN_STAT_ERROR,,}" = "fatal" ]; then
            BU::EchoError "Stopping the execution of $(BU::__DechoHighlight "$(basename "$0")" "$__BU_MAIN_COLOR_ERROR")."; BU::Newline >&2;

            BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"

            BU::Exit "$__BU_MAIN_EXIT_CURRENT_CODE";
        else
			if [ "${__BU_MAIN_STAT_ERROR,,}" == 'warning' ]; then
				# Calling the function that processes the given answer.
				BU::Main::Case::Read_Errors::HandleErrors;
			fi
		fi

        # -------- PART 4 : WRITING THE ERROR REPORT IN THE PROJECT'S LOG FILE IN CASE THE "$__BU_MAIN_STAT_ECHO" VARIABLE IS SET TO TRUE (SAFE MODE IF THE WRITING FUNCTIONS ARE CALLED FROM THE "BU::CheckProjectLogStatus()" FUNCTION).

        if [ "${__BU_MAIN_STAT_ECHO,,}" = "true" ] && [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
            BU::EchoWarning "" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ||
            {
                BU::Main::Errors::HandleSmallErrors "Unable to write in the $(BU::__DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH" "$__BU_MAIN_COLOR_WARNING") projectlog file from the $(BU::DechoHighlightFunction "${FUNCNAME[0]}()") function" 'R' 'CPLS';
            }
        fi

        if [ "$v_log_old" = "true" ]; then
            __BU_MAIN_STAT_LOG_REDIRECT="log"; BU::Main::Status::CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO";
        fi

        if BU::IsInt "$p_returnCode"; then
            BU::SetLastReturnValue "$p_returnCode"

            return "$p_returnCode";
        else
            BU::SetLastReturnValue "$__BU_MAIN_EXIT_NOT_PERMITTED"

            return "$__BU_MAIN_EXIT_CURRENT_CODE";
        fi
    fi
}

# -----------------------------------------------

#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Errors.lib
# Module        : Main
# Description   : Errors handling functions.
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS

## CLASSIC ERRORS HANDLING

# Saving time when displaying a newline, an error message and an exit or a return value.

# WARNING ! DO NOT CALL ANY FUNCTION THAT CALL THIS FUNCTION DIRECTLY OR INDIRECTLY HERE,
# OR THE SCRIPT WILL LOOP FOREVER IN CASE OF AN ERROR DURING THIS FUNCTION CALL !!!
function HandleSmallErrors()
{
    #**** Parameters ****
    local p_type=$1         # Type of message to display ('E' = BU::EchoError; 'W' = BU::EchoWarning)
    local p_string=$2       # String to display.
    local p_return=$3       # Exit or return status ('E' = exit; 'R' = return).
    local p_cpls=$4         # Enable the safe text printing mode.

    #**** Variables ****
    local v_advise="Please don't forget to pass a type of message to display as first argument ('E' = BU::EchoError; 'W' = BU::EchoWarning)"

    if [ "${p_cpls^^}" = 'CPLS' ]; then
        if [ "$__BU_MAIN_STAT_ECHO" = 'false' ]; then
            local v_BU_STAT_ECHO_old="$__BU_MAIN_STAT_ECHO"; BU::Main:Status::ChangeSTAT_ECHO 'true' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi

    #**** Code ****
    BU:Newline >&2;

    if      [ "$p_type" = 'E' ];    then BU::EchoError      "$p_string" '' ''
    elif    [ "$p_type" = 'W' ];    then BU::EchoWarning    "$p_string" '' ''

    # If no type of message to displays is passed as first argument, the script will choose between one of the accepted types.
    else
        if [ "$(( RANDOM%2 ))" = "0" ]; then
            BU::EchoError "$p_string    | ${__BU_MAIN_COLOR_RESET}$v_advise" '' ''
        else
            BU::EchoWarning "$p_string  | ${__BU_MAIN_COLOR_RESET}$v_advise" '' ''
        fi
    fi

    BU:Newline >&2

    # As the "BU::EchoWarning()" function will be called in case of a missing return or exit code (normally passed as second argument),
    # it's better to reset the value of the "$__BU_MAIN_STAT_ECHO" status variable condition per condition.
    if [ "${p_return^^}" = 'R' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

        return 1

    elif [ "${p_return^^}" = 'E' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

        ExitError '1'

    else 
        BU::EchoWarning "${__BU_MAIN_COLOR_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_WARNING} --> Warning : bad exit or return code given as second argument !"; ExitError '1'
    fi

    if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

}

# -----------------------------------------------

## EXIT HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function ExitError()
{
    if [[ "$1" =~ [0-9] ]]; then
        exit "$1"; kill "$$"
    else
        BU::EchoWarning "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Warning : unexpected exit code passed as argument."

        kill "$$"
    fi
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# "BU::Main::Errors::HandleErrors()" function --> Handling file name presence.
function BU::Main::Errors::HandleErrors_File()        { if [ -z "$1" ]; then if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::DechoHighlight "<no specified file>"; else BU::DechoHighlight "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_File_NO_FILE"; fi; else BU::DechoHighlight "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling function name presence.
function BU::Main::Errors::HandleErrors_Function()    { if [ -z "$1" ]; then if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::DechoHighlight "<no specified function>"; else BU::DechoHighlight "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_Function_NO_FUNCTION"; fi; else BU::DechoHighlight "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling line number presence.
function BU::Main::Errors::HandleErrors_Line()        { if [ -z "$1" ]; then if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::DechoHighlight "<no specified line>"; else BU::DechoHighlight "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_Line_NO_LINE"; fi; else BU::DechoHighlight "$1"; fi; }

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   - 
function BU::Main::Errors::HandleErrors()
{
	#**** Parameters ****
	local p_returnCode=$1      # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2     # String of the type of error to display.
	local p_adviceString=$3    # String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=$4        # Incorrect value which caused the error.
	local p_file=$5            # The name of the file where the error occured.
	local p_function=$6        # The name of the function where the error occured.
	local p_lineno=$7          # Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "$LINENO").

    #**** Variables ****
    if BU::Main::Status::CheckStatIsInitializing && ! BU::Main::Status::CheckStatIsPrintingInit; then
        local v_stat_print_init_log_old='false'; BU::Main:Status::ChangeSTAT_PRINT_INIT_LOG 'true' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
    fi

    if BU::Main::Status::CheckStatIsTranslated; then
        local v_hdrString;
            v_hdrString="$(echo -ne "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_HDR_STRING")"
    else
        local v_hdrString;
            v_hdrString="$(echo -ne "IN $(BU::Main::Errors::HandleErrors_File "$p_file") FILE, FUNCTION $(BU::Main::Errors::HandleErrors_Function "$p_function"), LINE $(BU::Main::Errors::HandleErrors_Line "$p_lineno") -->")"
    fi

	# ***** Code *****
	CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$p_returnCode" -eq 0 ]; then
        return 0
    else
        # -------- PART 1 : MANAGING THE CALL OF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IS CALLED IN A FUNCTION CALLED BY THIS "BU::Main::Errors::HandleErrors()" FUNCTION

        # If the function needs to be called in the "CheckProjectLogStatus()" function, then
        # this status variable's value MUST be set at "true", or else the script will loop forever.

        # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

        if [ "$__BU_MAIN_STAT_ECHO" = "true" ]; then

            # Drawing an extra line to differenciate the message below from the rest of the error messages.
            BU::EchoMsg "$(DrawLine "$__BU_MAIN_COLOR_ERROR" "$__BU_MAIN_TXT_PRINT_HEADER_LINE")" '' 'nodate'

            if [ -n "$__BU_MAIN_STAT_ERROR" ] && [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
                if [ "$__BU_MAIN_STAT_INITIALIZING" = 'false' ]; then
                    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "A FATAL ERROR OCCURED DURING A TEST IN THE $(BU::DechoHighlight "CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !"
                    else BU::EchoError "$__BU_MAIN_MSG_BU::Main::Errors::HandleErrors_FATAL_ERROR_OCCURED_SAFEMODE"; fi
                else
                    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "A FATAL ERROR OCCURED DURING THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S PROJECT INITIALIZATION"
                    else BU::EchoError "$__BU_MAIN_MSG_BU::Main::Errors::HandleErrors_FATAL_ERROR_OCCURED"; fi
                fi
            else
                if [ "$__BU_MAIN_STAT_INITIALIZING" = 'false' ]; then
                    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "AN ERROR OCCURED DURING A TEST IN THE $(BU::DechoHighlight "CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !"
                    else BU::EchoError "$__BU_MAIN_MSG_BU::Main::Errors::HandleErrors_ERROR_OCCURED_SAFEMODE"; fi
                else
                    if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "AN ERROR OCCURED DURING THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S PROJECT INITIALIZATION"
                    else BU::EchoError "$__BU_MAIN_MSG_BU::Main::Errors::HandleErrors_ERROR_OCCURED"; fi
                fi
            fi
        fi


        # -------- PART 2 : PRINTING THE HEADER

        # Redirecting the log messages to the terminal, to show them to the user. 
        if [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "log" ]; then
            local v_log_old="true"; __BU_MAIN_STAT_LOG_REDIRECT="tee"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi

        if [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then HeaderRed "$v_hdrString FATAL ERROR : $p_errorString" >&2
            else HeaderRed "$v_hdrString $__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_ : $p_errorString" >&2; fi
        else
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then HeaderRed "$v_hdrString ERROR : $p_errorString" >&2
            else HeaderRed "$v_hdrString $__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_ : $p_errorString" >&2; fi
        fi


        # -------- PART 3 : GIVING AN ADVICE ABOUT THE ORIGIN OF THE ERROR TO THE USER/DEVELOPPER

        if [ -z "$p_adviceString" ]; then
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "No advice to give."; BU:Newline >&2; else BU::EchoError "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_"; fi
        else
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "$(BU::DechoHighlight "Advice") : $p_adviceString" >&2; BU:Newline >&2; else BU::EchoError ""; fi
        fi

        if [ -z "$p_badValue" ]; then
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "Value(s) that caused this error : $(BU::DechoOrange 'no value') OR $(BU::DechoOrange 'an unknown error')"; BU:Newline >&2
            else BU::EchoError "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_"; fi
        else
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "Value(s) that caused this error : $(BU::DechoHighlight "$p_badValue")"; BU:Newline >&2; else BU::EchoError "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_"; fi
        fi

        if [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
            if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then BU::EchoError "Stopping the execution of $(BU::DechoHighlight "$(basename "$0")")."; BU:Newline >&2; else BU::EchoError "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_"; fi
            ExitError "1"
        else
            # Calling the function that processes the given answer.
            CaseRead_BU::Main::Errors::HandleErrors
        fi

        # -------- PART 4 : WRITING THE ERROR REPORT IN THE PROJECT'S LOG FILE IN CASE THE "$__BU_MAIN_STAT_ECHO" VARIABLE IS SET TO TRUE (SAFE MODE IF THE WRITING FUNCTIONS ARE CALLED FROM THE "CheckProjectLogStatus()" FUNCTION).

        if [ "$__BU_MAIN_STAT_ECHO" = "true" ] && [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
            BU::EchoWarning "" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ||
            {
                if [ "$__BU_MAIN_STAT_TRANSLATED" = 'false' ]; then
                    HandleSmallErrors "Unable to write in the $(BU::DechoHighlight "$__BU_MAIN_PROJECT_LOG_FILE_PATH") projectlog file from the $(BU::DechoHighlight "${FUNCNAME[0]}()") function" 'R' 'CPLS'
                else
                    HandleSmallErrors "$__BU_MAIN_MSG_ERRORS_BU::Main::Errors::HandleErrors_" 'R' 'CPLS'
                fi
            }
        fi

        if [ "$v_log_old" = "true" ]; then
            __BU_MAIN_STAT_LOG_REDIRECT="log"; CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi

    if BU::Main::Status::CheckStatIsInitializing && [ "$v_stat_print_init_log_old" = 'false' ]; then
        __BU_MAIN_STAT_PRINT_INIT_LOG="$v_stat_print_init_log_old"; v_stat_print_init_log_old=''    # Reassigning the "$v_stat_print_init_log_old" variable to an empty value.
    fi

    return 1
}

# -----------------------------------------------

#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Errors.lib
# Module        : Main
# Description   : Errors handling functions.
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS

## CLASSIC ERRORS HANDLING

# Saving time when displaying a newline, an error message and an exit or a return value.

# WARNING ! DO NOT CALL ANY FUNCTION THAT CALL THIS FUNCTION DIRECTLY OR INDIRECTLY HERE,
# OR THE SCRIPT WILL LOOP FOREVER IN CASE OF AN ERROR DURING THIS FUNCTION CALL !!!
function BU::Main::Errors::HandleSmallErrors()
{
    #**** Parameters ****
    local p_type=$1         # Type of message to display ('E' = BU::EchoError; 'W' = BU::EchoWarning)
    local p_string=$2       # String to display.
    local p_return=$3       # Exit or return status ('E' = exit; 'R' = return).
    local p_cpls=$4         # Enable the safe text printing mode.

    #**** Variables ****
    local v_advise="Please don't forget to pass a type of message to display as first argument ('E' = BU::EchoError; 'W' = BU::EchoWarning)"

    if [ "${p_cpls^^}" = 'CPLS' ]; then
        if [ "$__BU_MAIN_STAT_ECHO" = 'false' ]; then
            local v_BU_STAT_ECHO_old="$__BU_MAIN_STAT_ECHO"; BU::Main:Status::ChangeSTAT_ECHO 'true' "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi

    #**** Code ****
    BU::Newline >&2;

    if      [ "${p_type^^}" = 'E' ];    then BU::EchoError      "$p_string" '' ''
    elif    [ "${p_type^^}" = 'W' ];    then BU::EchoWarning    "$p_string" '' ''

    # If no type of message to displays is passed as first argument, the script will choose between one of the accepted types.
    else
        if [ "$(( RANDOM%2 ))" = "0" ]; then
            BU::EchoError "$p_string    | ${__BU_MAIN_COLOR_TXT_RESET}$v_advise" '' ''
        else
            BU::EchoWarning "$p_string  | ${__BU_MAIN_COLOR_TXT_RESET}$v_advise" '' ''
        fi
    fi

    BU::Newline >&2

    # As the "BU::EchoWarning()" function will be called in case of a missing return or exit code (normally passed as second argument),
    # it's better to reset the value of the "$__BU_MAIN_STAT_ECHO" status variable condition per condition.
    if [ "${p_return^^}" = 'R' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

        return 1

    elif [ "${p_return^^}" = 'E' ]; then
        if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

        BU::Exit '1'

    else
        BU::EchoWarning "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_TXT_WARNING} --> Warning : bad exit or return code given as second argument !"; BU::Exit '1'
    fi

    if [ "$v_BU_STAT_ECHO_old" = "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

}

# -----------------------------------------------

## EXIT HANDLING

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function BU::Exit()
{
    #**** Parameters ****
    local p_exitcode=$1;    # Int   : Exit code.
    local p_behavior=$2;    # Char  : Use "exit" or "return" keywords.

    #**** Code ****
    if BU::IsPositiveInt "$p_exitcode"; then

        if [ "${p_behavior^^}" = 'E' ] || [ -z "$p_behavior" ]; then
            exit "$p_exitcode" || kill "$$";

        elif [ "${p_behavior^^}" = 'W' ]; then
            return "$p_exitcode";

        else
            exit "$p_exitcode" || kill "$$";
        fi
    else
        BU::EchoWarning "$(BU::DechoHighlightFunction "${FUNCNAME[0]}()") --> Warning : unexpected exit code passed as argument";

        exit 1; kill "$$";
    fi
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING

# "BU::Main::Errors::HandleErrors()" function --> Handling file name presence.
function BU::Main::Errors::HandleErrors_File()        { if [ -z "$1" ]; then BU::DechoHighlightPath "<no specified file>"; else BU::DechoHighlightPath "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling function name presence.
function BU::Main::Errors::HandleErrors_Function()    { if [ -z "$1" ]; then BU::DechoHighlightFunction "<no specified function>"; else BU::DechoHighlightFunction "$1"; fi; }

# "BU::Main::Errors::HandleErrors()" function --> Handling line number presence.
function BU::Main::Errors::HandleErrors_Line()        { if [ -z "$1" ]; then BU::DechoHighlight "<no specified line>"; else BU::DechoHighlight "$1"; fi; }

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   -
function BU::Main::Errors::HandleErrors()
{
	#**** Parameters ****
	local p_returnCode=$1      # Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=$2     # String of the type of error to display.
	local p_adviceString=$3    # String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=$4        # Incorrect value which caused the error.
	local p_file=$5            # The name of the file where the error occured.
	local p_function=$6        # The name of the function where the error occured.
	local p_lineno=$7          # Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "$LINENO").

    #**** Variables ****
    local v_hdrString;
        v_hdrString="$(echo -ne "IN $(BU::Main::Errors::HandleErrors_File "$p_file") FILE, FUNCTION $(BU::Main::Errors::HandleErrors_Function "$p_function"), LINE $(BU::Main::Errors::HandleErrors_Line "$p_lineno") -->")"

	# ***** Code *****
	BU::CheckSTAT_ERROR "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

	if [ "$p_returnCode" -eq 0 ]; then
        return 0;
    else
        # -------- PART 1 : MANAGING THE CALL OF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IF THIS "BU::Main::Errors::HandleErrors()" FUNCTION IS CALLED IN A FUNCTION CALLED BY THIS "BU::Main::Errors::HandleErrors()" FUNCTION

        # If the function needs to be called in the "BU::CheckProjectLogStatus()" function, then
        # this status variable's value MUST be set at "true", or else the script will loop forever.

        # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

        if [ "$__BU_MAIN_STAT_ECHO" = "true" ]; then

            if [ -n "$__BU_MAIN_STAT_ERROR" ] && [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
                if [ "$__BU_MAIN_STAT_INITIALIZING" = 'false' ]; then
                    BU::HeaderError "A FATAL ERROR OCCURED DURING A TEST IN THE $(BU::DechoHighlightFunction "BU::CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen'
                else
                    BU::HeaderError "A FATAL ERROR OCCURED DURING THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S PROJECT INITIALIZATION" 'strlen'
                fi
            else
                if [ "$__BU_MAIN_STAT_INITIALIZING" = 'false' ]; then
                    BU::HeaderError "AN ERROR OCCURED DURING A TEST IN THE $(BU::DechoHighlightFunction "BU::CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen'
                else
                    BU::HeaderError "AN ERROR OCCURED DURING THE $(BU::DechoHighlight "$__BU_MAIN_PROJECT_NAME")'S PROJECT INITIALIZATION" 'strlen'
                fi
            fi
        fi


        # -------- PART 2 : PRINTING THE HEADER

        # Redirecting the log messages to the terminal, to show them to the user.
        if [ "$__BU_MAIN_STAT_LOG_REDIRECT" = "log" ]; then
            local v_log_old="true"; __BU_MAIN_STAT_LOG_REDIRECT="tee"; BU::Main::Status::CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi

        if [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
            BU::HeaderRed "$v_hdrString FATAL ERROR : $p_errorString" >&2
        else
            BU::HeaderRed "$v_hdrString ERROR : $p_errorString" >&2
        fi


        # -------- PART 3 : GIVING AN ADVICE ABOUT THE ORIGIN OF THE ERROR TO THE USER/DEVELOPPER

        if [ -z "$p_adviceString" ]; then
            BU::EchoError "No advice to give."; BU::Newline >&2
        else
            BU::EchoError "$(BU::DechoHighlight "Advice") : $p_adviceString" >&2
        fi

        if [ -z "$p_badValue" ]; then
            BU::EchoError "Value(s) that caused this error : $(BU::DechoOrange 'no value') OR $(BU::DechoOrange 'an unknown error')"; BU::Newline >&2
        else
            BU::EchoError "Value(s) that caused this error : $(BU::DechoHighlightVar "$p_badValue")"; BU::Newline >&2
        fi

        if [ "$__BU_MAIN_STAT_ERROR" = "fatal" ]; then
            BU::EchoError "Stopping the execution of $(BU::DechoHighlight "$(basename "$0")")."; BU::Newline >&2
            BU::Exit "1"
        else
            # Calling the function that processes the given answer.
            BU::Main::Case::Read_Errors::HandleErrors
        fi

        # -------- PART 4 : WRITING THE ERROR REPORT IN THE PROJECT'S LOG FILE IN CASE THE "$__BU_MAIN_STAT_ECHO" VARIABLE IS SET TO TRUE (SAFE MODE IF THE WRITING FUNCTIONS ARE CALLED FROM THE "BU::CheckProjectLogStatus()" FUNCTION).

        if [ "$__BU_MAIN_STAT_ECHO" = "true" ] && [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ]; then
            BU::EchoWarning "" 2>&1 | tee -a "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ||
            {
                BU::Main::Errors::HandleSmallErrors "Unable to write in the $(BU::DechoHighlightPath "$__BU_MAIN_PROJECT_LOG_FILE_PATH") projectlog file from the $(BU::DechoHighlightFunction "${FUNCNAME[0]}()") function" 'R' 'CPLS'
            }
        fi

        if [ "$v_log_old" = "true" ]; then
            __BU_MAIN_STAT_LOG_REDIRECT="log"; BU::Main::Status::CheckSTAT_LOG_REDIRECT "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
        fi
    fi

    return 1
}

# -----------------------------------------------

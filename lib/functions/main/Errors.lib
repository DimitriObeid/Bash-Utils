#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Errors.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :


# ------------------
# FILE DESCRIPTION :

# Errors handling functions.


# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as it is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS
#### DEBUG ID : errors::errors-handling-functions

__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS="errors::errors-handling-functions";

## CLASSIC ERRORS HANDLING
## DEBUG ID : classic-errors-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::classic-errors-handling";

# Saving time when displaying a newline, an error message and an exit or a return value.

# WARNING ! DO NOT CALL HERE ANY FUNCTION THAT CALL THIS FUNCTION DIRECTLY OR INDIRECTLY,
# OR THE SCRIPT WILL LOOP FOREVER IN CASE OF AN ERROR DURING THIS FUNCTION CALL !!!
function BU.Main.Errors.HandleSmallErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING}";

    #**** Parameters ****
    local p_type=${1:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of message to display ('E' = BU.Main.Echo.Error; 'W' = BU.Main.Echo.Warning)
    local p_string=${2:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to display.
    local p_return=${3:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Exit or return status ('E' = exit; 'R' = return).
    local p_cpls=${4:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Enable the safe text printing mode.

    #**** Variables ****
    if [ "${p_cpls^^}" == 'CPLS' ]; then
        if [ "${__BU_MAIN_STAT_ECHO,,}" == 'false' ]; then
            local v_BU_STAT_ECHO_old="${__BU_MAIN_STAT_ECHO}"; BU.Main.Status.ChangeSTAT_ECHO 'true' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        fi
    fi

    #**** Code ****
    BU.Main.Echo.Newline >&2;

    BU.ModuleInit.SetInitErrorMsg && local VHandleSmallErrors='1';

    if      [ "${p_type^^}" == 'E' ];    then BU.Main.Echo.Error      "${p_string}" '' '';
    elif    [ "${p_type^^}" == 'W' ];    then BU.Main.Echo.Warning    "${p_string}" '' '';

    # If no type of message to displays is passed as first argument, the script will choose between one of the accepted types.
    else
		local v_advice="Please don't forget to pass a type of message to display as first argument ('E' = BU.Main.Echo.Error; 'W' = BU.Main.Echo.Warning)";

        if [ "$(( RANDOM%2 ))" == "0" ]; then
            BU.Main.Echo.Error "${p_string}     | ${__BU_MAIN_COLOR_TXT_RESET}${v_advice}" '' '';
        else
            BU.Main.Echo.Warning "${p_string}   | ${__BU_MAIN_COLOR_TXT_RESET}${v_advice}" '' '';
        fi
    fi

    BU.Main.Echo.Newline >&2

    # As the "BU.Main.Echo.Warning()" function will be called in case of a missing return or exit code (normally passed as second argument),
    # it's better to reset the value of the "${__BU_MAIN_STAT_ECHO}" status variable condition per condition.
    if [ "${p_return^^}" == 'R' ]; then
        if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then BU.Main.Status.ChangeSTAT_ECHO 'false' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

        # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
        [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return 1;

    elif [ "${p_return^^}" == 'E' ]; then
        if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then BU.Main.Status.ChangeSTAT_ECHO 'false' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

        # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
        [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        BU.Main.Errors.Exit 1;

    else
        BU.Main.Echo.Warning "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_TXT_WARNING} --> Warning : bad exit or return code given as second argument !"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit 1;
    fi

    if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
    [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# -----------------------------------------------

## EXIT AND RETURN CODES HANDLING
## DEBUG ID : exit-and-return-codes-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::exit-and-return-codes-handling";

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function BU.Main.Errors.Exit()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING}";

    #**** Parameters ****
    local p_exitcode=${1:-$'\0'};   # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : NULL     - DESC : Exit code.
    local p_behavior=${2:-$'\0'};   # ARG TYPE : Char   - REQUIRED | DEFAULT VAL : NULL     - DESC : Use "exit" or "return" keywords.

    #**** Code ****
    if BU.Main.Checkings.IsPositiveInt "${p_exitcode}"; then

        if [ "${p_behavior^^}" == 'E' ] || [ -z "${p_behavior}" ]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi

        elif [ "${p_behavior^^}" == 'W' ]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${p_exitcode}";

        else
            # shellcheck disable=SC2034
            __BU_MAIN_STAT_DECHO='restrict';

            # shellcheck disable=SC2034
            __BU_MAIN_STAT_ECHO='true';

            BU.Main.Echo.Newline 2 >&2;

            BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : No valid character passed as second argument ('E' (exit) or 'W' (warning) expected)";
            BU.Main.Echo.Newline >&2;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi
        fi
    else
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : unexpected exit code passed as argument";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi
    fi
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING
## DEBUG ID : script-errors-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__SCRIPT_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::script-errors-handling";

# "BU.Main.Errors.HandleErrors()" function --> Handling file name presence.
function BU.Main.Errors.HandleErrors_File()        { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Path "<no specified file>"; else BU.Main.Decho.Decho.Path "${1}"; fi; }

# "BU.Main.Errors.HandleErrors()" function --> Handling function name presence.
function BU.Main.Errors.HandleErrors_Function()    { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Function "<no specified function>"; else BU.Main.Decho.Decho.Function "${1}"; fi; }

# "BU.Main.Errors.HandleErrors()" function --> Handling line number presence.
function BU.Main.Errors.HandleErrors_Line()        { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Highlight "<no specified line>"; else BU.Main.Decho.Decho.Highlight "${1}"; fi; }

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   -
function BU.Main.Errors.HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__SCRIPT_ERRORS_HANDLING}";

	#**** Parameters ****
	local p_returnCode=${1:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String of the type of error to display.
	local p_adviceString=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Incorrect value which caused the error.
	local p_file=${5:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : The name of the file where the error occured.
	local p_function=${6:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : The name of the function where the error occured.
	local p_lineno=${7:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "${LINENO}").

    #**** Variables ****
    local v_hdrString;                              # VAR TYPE : String     - DESC :
    local v_getSeparatorOccurencesfromAdviceStr;    # VAR TYPE : String     - DESC :
    local v_checkIfErrorStringIsNotNull;            # VAR TYPE : CMD        - DESC :

    # v_checkIfErrorStringIsNotNull="$(BU.Main.Decho.Decho.FMT_I "No string to display as $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()" 'NULL' 'BI') function's error string")";

	# ***** Code *****
	BU.Main.Status.CheckSTAT_ERROR 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

	if [ "${p_returnCode}" -eq 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    else
        if BU.Main.Status.CheckStatIsInitializing; then
            BU.ModuleInit.HandleErrors "${p_returnCode}" "${p_errorString}" "${p_adviceString}" "${p_badValue}" "${p_file}" "${p_function}" "${p_lineno}" || {

                local C="${?}";

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                return "${C}";
            };
        else

            # If the framework is still initializing when an error occurs.
            BU.ModuleInit.SetInitErrorMsg && local VHandleErrors='1';

            v_hdrString="$(echo -ne "IN $(BU.Main.Errors.HandleErrors_File "${p_file}") FILE, FUNCTION $(BU.Main.Errors.HandleErrors_Function "${p_function}"), LINE $(BU.Main.Errors.HandleErrors_Line "${p_lineno}") -->")";

            # -------- PART 1 : MANAGING THE CALL OF THIS "BU.Main.Errors.HandleErrors()" FUNCTION IF THIS "BU.Main.Errors.HandleErrors()" FUNCTION IS CALLED IN A FUNCTION CALLED BY THIS "BU.Main.Errors.HandleErrors()" FUNCTION

            # If the function needs to be called in the "BU.Main.Status.CheckProjectLogStatus()" function, then
            # this status variable's value MUST be set at "true", or else the script will loop forever.

            # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

            if [ "${__BU_MAIN_STAT_ECHO,,}" == "true" ]; then

                if [ -n "${__BU_MAIN_STAT_ERROR}" ] && [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                    if [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "A FATAL ERROR OCCURED DURING A TEST IN THE $(BU.Main.Decho.Decho.Function "BU.Main.Status.CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    else
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "A FATAL ERROR OCCURED DURING THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S PROJECT INITIALIZATION" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    fi
                else
                    if [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "AN ERROR OCCURED DURING A TEST IN THE $(BU.Main.Decho.Decho.Function "BU.Main.Status.CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    else
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "AN ERROR OCCURED DURING THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S PROJECT INITIALIZATION" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    fi
                fi
            fi


            # -------- PART 2 : PRINTING THE HEADER

            # Redirecting the log messages to the terminal, to show them to the user.
            if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "log" ]; then
                local v_log_old="true"; __BU_MAIN_STAT_LOG_REDIRECT="tee"; BU.Main.Status.CheckSTAT_LOG_REDIRECT 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
                    local C="${?}";

                    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                    [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                    return "${C}";
                };
            fi

            if [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                BU.Main.Headers.Header.Red "${v_hdrString} FATAL ERROR : $(if [ -n "${p_errorString}" ]; then echo "${p_errorString}"; else echo "${v_checkIfErrorStringIsNotNull}"; fi)" >&2;
            else
                BU.Main.Headers.Header.Red "${v_hdrString} ERROR : $(if [ -n "${p_errorString}" ]; then echo "${p_errorString}"; else echo "${v_checkIfErrorStringIsNotNull}"; fi)" >&2;
            fi


            # -------- PART 3 : GIVING AN ADVICE ABOUT THE ORIGIN OF THE ERROR TO THE USER/DEVELOPPER

            if [ -z "${p_adviceString}" ]; then
                BU.Main.Echo.Error "No advice to give."; BU.Main.Echo.Newline >&2;
            else
                v_getSeparatorOccurencesfromAdviceStr="$(BU.Main.Text.GetSubStringOccurences "${p_advice}" "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" '--init')";

                # Checking if the "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" substring composing the delimiter exists only once, as single separator from the advice substring and another comment substring.

                # IMPORTANT : the second argument of the "BU.Main.Text.GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
                if [ -n "${p_adviceString}" ] && [ "${v_getSeparatorOccurencesfromAdviceStr}" -eq 1 ] && [[ "${p_adviceString}" == *[[:space:]]'[/|\]'[[:space:]]* ]]; then

                    local v_string_part_1; v_string_part_1="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f2- | rev)";   # Getting the first sub-string before the delimiter.
                    local v_string_part_2; v_string_part_2="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f 1 | rev)";   # Getting the second sub-string after the delimiter.

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${v_string_part_1}";
                    BU.Main.Echo.Newline >&2;

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Other comments") : ${v_string_part_2}";

                # Checking if the "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" substring composing the delimiter exists more than once, as multiple separators from the advice and every other comments.

                # IMPORTANT : the second argument of the "BU.Main.Text.GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
                elif [ -n "${p_adviceString}" ] && [ "${v_getSeparatorOccurencesfromAdviceStr}" -gt 1 ] && [[ "${p_adviceString}" == *[[:space:]]'[/|\]'[[:space:]]* ]]; then

                    local v_string_part_1; v_string_part_1="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f2- | rev)";   # Getting the first sub-string.

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${v_string_part_1}";
                    BU.Main.Echo.Newline >&2;

                    for ((i=1; i>v_getSeparatorOccurencesfromAdviceStr; i++)); do
                        p_adviceString="$(BU.Main.Text.CutSubStringBeforeNthDelim "${p_adviceString}" "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" 1)";

                        BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice [$(( i + 1 ))]") : ${p_adviceString}";
                        BU.Main.Echo.Newline 2 >&2;
                    done
                else
                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${p_adviceString}";
                fi
            fi

            BU.Main.Echo.Newline >&2;

            if [ -z "${p_badValue}" ]; then
                BU.Main.Echo.Error "Value(s) that caused this error : $(BU.Main.Decho.Orange 'no value') OR $(BU.Main.Decho.Orange 'an unknown error')"; BU.Main.Echo.Newline >&2;
            else
                BU.Main.Echo.Error "Value(s) that caused this error : $(BU.Main.Decho.Decho.Var "${p_badValue}")"; BU.Main.Echo.Newline >&2;
            fi

            if [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                BU.Main.Echo.Error "Stopping the execution of $(BU.Main.Decho.Decho.Highlight "$(basename "${0}")")."; BU.Main.Echo.Newline >&2;

                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                exit "${__BU_MAIN_EXIT_NOT_PERMITTED}";
            else
                if [ "${__BU_MAIN_STAT_ERROR,,}" == 'warning' ]; then
                    # Calling the function that processes the given answer.
                    BU.Main.Inputs.Read_Errors.HandleErrors;
                fi
            fi

            # -------- PART 4 : WRITING THE ERROR REPORT IN THE PROJECT'S LOG FILE IN CASE THE "${__BU_MAIN_STAT_ECHO}" VARIABLE IS SET TO TRUE (SAFE MODE IF THE WRITING FUNCTIONS ARE CALLED FROM THE "BU.Main.Status.CheckProjectLogStatus()" FUNCTION).

            if [ "${__BU_MAIN_STAT_ECHO,,}" == "true" ] && [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
                BU.Main.Echo.Warning "" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ||
                {
                    BU.Main.Errors.HandleSmallErrors "Unable to write in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") projectlog file from the $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") function" 'R' 'CPLS';
                }
            fi

            if [ "${v_log_old}" == "true" ]; then
                __BU_MAIN_STAT_LOG_REDIRECT="log"; BU.Main.Status.CheckSTAT_LOG_REDIRECT 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
            fi

            if BU.Main.Checkings.IsInt "${p_returnCode}"; then

                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${p_returnCode}";
            else
                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";
            fi
        fi
    fi
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #
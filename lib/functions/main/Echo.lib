#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Echo.lib
# Module        : Main
# Description   : (Colored) text display functions.
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == en_* ]]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### PRINTING FORMATTED STRINGS
#### DEBUG ID : echo::printing-formatted-strings

__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS="echo::printing-formatted-strings";

## DEBUGGING
## DEBUG ID : debugging

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING="$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS::debugging";

# This function only serves as text printer for the " BU.Main.Echo.Debug()" function.
function BU.Main.Echo.__Debug()
{
    BU.ModuleInit.CheckIsDebugging && {
        BU.Main.Echo.__EchoVoid;

        echo "----------------------------------------";
        echo "DEBUGGING THE FUNCTION $1";

        echo; echo "Waiting for the two seconds timer for the $1() function to elapse"; echo;

        sleep 2;

     #   set -x;

        BU.Main.Echo.__EchoVoid;
    }
}

# This function only serves as text printer for the " BU.Main.Echo.Debug()" function.
function BU.Main.Echo.DebugEnd()
{
 #   set +x;

    BU.ModuleInit.CheckIsDebugging && {
        if [ "${__BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION,,}" == 'true' ]; then
            BU.Main.Echo.__EchoVoid;

            echo "---------------------------------------";
            echo "END OF THE DEBUGGING OF THE FUNCTION $1";

            BU.Main.Echo.__EchoVoid;

            __BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION='false';
        fi
    }
}

# Printing the name of the processed function if the main script is launched with the "bash -x" command.

## TODO : RÉFLÉCHIR À LA MISE EN PLACE DE L'AFFICHAGE DU NOM DE LA FONCTION CIBLE LORS DE LA PROCÉDURE DE DÉBOGUAGE AVEC LA COMMANDE "bash -x".
function BU.Main.Echo.Debug()
{
#     echo "DEBUG BASHX : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX[*]}";
#     echo "ARRAY CATEG : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[*]}";
#     echo "ARRAY FILES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[*]}";
#     echo "ARRAY FNCTS : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[*]}";
#     echo "ARRAY SBCAT : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[*]}";
#     echo;

    BU.ModuleInit.CheckIsDebugging && {
        #**** Parameters ****
        local p_modname=$1;     # String    - Default : NULL    - Module where the function currently processed is defined.
        local p_filename=$2;    # String    - Default : NULL    - File where the function currently processed is defined.
        local p_funcname=$3;    # String    - Default : NULL    - Print the name of the function currently processed, during the debug procedure.
        local p_category=$4;    # String    - Default : NULL    - Get the category of the targeted function.
        local p_subcateg=$5;    # String    - Default : NULL    - Get the sub-category of the targeted function.

        #**** Code ****
        [ -n "$__BU_MODULE_INIT_STAT_DEBUG_BASHX" ] &&
        {
            if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == cat?(eg?(ory)) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == cat?(eg?(orie))s ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'C' ]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "$p_funcname"; return 0;
                else
                    for targetCategory in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[@]}"; do
                        # If the "$targetCategory" value is found in the array, and the function which comes from the "$p_category" file matches with the "$targetCategory" variable's value.
                        [[ ${targetCategory,,} =~ ${p_category,,} ]] && { BU.Main.Echo__Debug "$p_funcname"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == file?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'F' ]; then
                local v_file="${p_filename%%.[Ll][Ii][Bb]*}";

                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "$p_funcname"; return 0;
                else
                    for targetFile in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[@]}"; do
                        # If the "$targetFile" value is found in the array, and the function which comes from the "$v_file" file matches with the "$targetFile" variable's value.
                        [[ ${targetFile,,} =~ ${v_file,,} ]] && { BU.Main.Echo.__Debug "$p_funcname"; break; };
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == function?(s) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == FNCT?(S) ]]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "$p_funcname"; return 0;
                else
                    for targetFunction in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[@]}"; do
                        # If the "$targetFunction" value is found in the array, and the function which comes from the "$p_funcname" file matches with the "$targetFunction" variable's value.
                        [[ ${targetFunction,,} =~ ${p_funcname,,} ]] && { BU.Main.Echo.__Debug "$p_funcname"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == m?(od?(ule?))?(s) ]]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "$p_modname"; return 0;
                else
                    for targetModule in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[@]}"; do
                        # If the "$targetModule" value is found in the array, and the function which comes from the "$p_modname" file matches with the "$targetModule" variable's value.
                        [[ ${targetModule,,} =~ ${p_modname,,} ]] && { BU.Main.Echo.__Debug "$p_funcname"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)cat?(eg?(ory)) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)?(c?(at?(eg?(orie))))s ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'S' ]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "$p_funcname"; return 0;
                else
                    for targetSubCategory in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[@]}"; do
                        # If the "$targetSubCategory" value is found in the array, and the function which comes from the "$p_subcateg" file matches with the "$targetSubCategory" variable's value.
                        [[ ${targetSubCategory,,} =~ ${p_subcateg,,} ]] && { BU.Main.Echo__Debug "$p_funcname"; break; }
                    done
                fi
            fi
        }

        __BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION='true';

    } > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH";

    return 0;
}

# Print void lines before and after calling a header.
function BU.Main.Echo.__EchoVoid()
{
printf "









" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" ||
    {
        echo >&2; echo "IN « ${BASH_SOURCE[0]} », LINE « $LINENO » --> WARNING --> UNABLE TO WRITE THE « ${FUNCNAME[0]} » IN THE « $__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH FILE »" >&2; echo >&2; exit 1;
    }
}

# "BU.Echo<...>()" functions debug output for a better view during a debug process.
# It's better to also execute the project's script with the "bash - x $project_name" command, instead of the "./$project_name" way.
function BU.Main.Echo.__EchoOutput()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING";

	#**** Parameters ****
	local p_string=$1;     # String    - String to display.
	local p_context=$2;    # String    - Begin or end of the debug process.
	local p_type=$3;       # Char      - Type of message (error 'E', Msg 'm', newstep 'N', success 'S' or warning 'W').

	#**** Variables ****
	local v_strlen="${#p_string}";

	#**** Code ****
	# If the "$p_type" argument is a string, then the first character is extracted.
	if ! BU.Main.Checkings.IsAlphaChar "$p_type"; then
        local v_type=${p_type:0:1};

        p_type="$v_type";
	fi

	if [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" == 'false' ]; then return 0;

	elif [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" == "true" ]; then
	    # Passing the "$__BU_MAIN_STAT_ECHO" global status variable's value from "false" to "true".
        if ! BU.Main.Status.CheckStatIsBackupEchoing; then
            local v_BU_MAIN_STAT_ECHO_val="$__BU_MAIN_STAT_ECHO"; BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "${BASH_SOURCE[0]}" "$LINENO";
        fi

		BU.Main.Checkings.CheckProjectRelatedFile "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT" "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME" "f" || { BU.Main.Echo.__EchoCPLS "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Unable to create the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME") debug log file" 'E' "CPLS"; exit 1; }

		BU.Main.Headers.DrawLine "$__BU_MAIN_TXT_CHAR_HEADER_LINE" '' "$(( 24 + v_strlen ))";

        if [ "${p_context,,}" == "begin" ]; then
            BU.Main.Echo.__EchoVoid;

            if [ "${p_type^^}" == "E" ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type,,}" == 'm' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'N' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'S' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'W' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            fi

            BU.Main.Headers.DrawLine "$__BU_MAIN_TXT_CHAR_HEADER_LINE" '' "$(( 24 + v_strlen ))";

            # Reassigning the "$__BU_MAIN_STAT_ECHO" global status variable's former value.
            if [ -n "$v_BU_MAIN_STAT_ECHO_val" ]; then
                __BU_MAIN_STAT_ECHO="$v_BU_MAIN_STAT_ECHO_val"; v_BU_MAIN_STAT_ECHO_val=''
            fi

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

        elif [ "${p_context,,}" == "end" ]; then
            if [ "${p_type^^}" == "E" ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type,,}" == 'm' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'N' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'S' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'W' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : $p_string${__BU_MAIN_COLOR_TXT_RESET}" > "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "$__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            fi

            BU.Main.Headers.DrawLine "$__BU_MAIN_TXT_CHAR_HEADER_LINE" '' "$(( 24 + v_strlen ))";

            # Reassigning the "$__BU_MAIN_STAT_ECHO" global status variable's former value.
            if [ -n "$v_BU_MAIN_STAT_ECHO_val" ]; then
                __BU_MAIN_STAT_ECHO="$v_BU_MAIN_STAT_ECHO_val"; v_BU_MAIN_STAT_ECHO_val='';
            fi

            BU.Main.Echo.__EchoVoid; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
    fi
}

# Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
function BU.Main.Echo.__EchoCPLS()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING";

    #**** Parameters ****
    local p_string=$1;  # Any       - Text to display.
    local p_option=$2;  # String    - "echo" command options.

    shift 2; pa_extraArgs=("$@");   # Array - More processing arguments (like the processing of a whole line-long string).

    #**** Code ****
    # DO NOT CALL THE "BU.Main.Args.GetFuncArgsArrayValues()" FUNCTION IN THIS FUNCTION, OR ELSE AN INFINITE LOOP WILL LIKELY OCCUR !!!!!

    for val in "${pa_extraArgs[@]}"; do
        if [ "$val" == 'nodate' ]; then
            case "$p_option" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "$p_string";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "$p_string";
                    fi
                    ;;
            esac
        elif [ -z "$val" ]; then
            case "$p_option" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                    fi
                    ;;
            esac
        else
            case "$p_option" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "$p_string" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "$__BU_MAIN_TIME_DATE_DISPLAY $p_string";
                    fi
                    ;;
            esac
        fi

		if [ -n "$__BU_MAIN_STAT_TIME_HEADER" ]   && (( $(echo "$__BU_MAIN_STAT_TIME_HEADER > 0"    | bc -l ) )); then sleep "0"; fi
		if [ -n "$__BU_MAIN_STAT_TIME_NEWLINE" ]  && (( $(echo "$__BU_MAIN_STAT_TIME_NEWLINE > 0"   | bc -l ) )); then sleep "0"; fi
		if [ -n "$__BU_MAIN_STAT_TIME_TXT" ]      && (( $(echo "$__BU_MAIN_STAT_TIME_TXT > 0"       | bc -l ) )); then sleep "0"; fi
    done
   # if (( $(echo "$num1 > $num2" |bc -l) ));

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT DISPLAYING
#### DEBUG ID : echo::text-displaying

__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING="echo::text-displaying";

## DISPLAYING A CONTEXT MESSAGE
## DEBUG ID : displaying-a-context-message

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE="$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING::displaying-a-context-message";

# --> DISPLAYING A COLORED CONTEXT MESSAGE WITH A PAUSE TIME DEPENDING ON THE "$__BU_MAIN_STAT_TIME_TXT" STATUS VARIABLE.

# Error message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus                      --> Checkings.lib
function BU.Main.Echo.Error()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

    #**** Parameters ****
    local p_string=$1;	# String	- Default : NULL	- String to print and / or redirect to the log file.
    local p_option=$2;	# String	- Default : NULL	- "echo" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).

    shift 2;

    local pa_extraArgs=("$@");  # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VEchoError='1';

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'E' || { local C="$?"; [ -n "$VEchoError" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_ERROR}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'E' || { local C="$?"; [ -n "$VEchoError" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'E' || { local C="$?"; [ -n "$VEchoError" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_ERROR}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'E' || { local C="$?"; [ -n "$VEchoError" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    # Restoring the former value of the "$__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable.
    [ -n "$VEchoError" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Normal message (without any extra color), with redirection checking.

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Msg()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

    #**** Parameters ****
    local p_string=$1;	# String	- Default : NULL	- String to print and / or redirect to the log file.
    local p_option=$2;	# String	- Default : NULL	- "echo" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("$@");  # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'm' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Status.CheckProjectLogStatus "$p_string" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'm' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'm' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Echo.__EchoCPLS "$p_string" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'm' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# New sub-step message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Newstep()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

    #**** Parameters ****
    local p_string=$1;	# String	- Default : NULL	- String to print and / or redirect to the log file.
    local p_option=$2;	# String	- Default : NULL	- "echo" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("$@");  # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'N' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_NEWSTEP}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'N' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'N' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_NEWSTEP}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'N' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Read input values

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#	- BU.Main.Status.CheckProjectLogStatus		--> Checkings.lib
function BU.Main.Echo.Read()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

	#**** Parameters ****
	local p_string=$1;     # User's keyboard input.

	#**** Code ****
	if [ -f "$__BU_MAIN_PROJECT_LOG_FILE_PATH" ] && [ "$__BU_MAIN_STAT_LOG" == "true" ] && [ -n "$__BU_MAIN_STAT_LOG_REDIRECT" ]; then
		echo -e "Keyboard input value : $(BU.Main.Decho.Decho.Var "$p_string")" >> "$__BU_MAIN_PROJECT_LOG_FILE_PATH" || { BU.Main.Echo.__EchoCPLS "" 'R' "CPLS"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
	fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Success message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Success()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

    #**** Parameters ****
    local p_string=$1;	# String	- Default : NULL	- String to print and / or redirect to the log file.
    local p_option=$2;	# String	- Default : NULL	- "echo" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("$@");  # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'S' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_SUCCESS}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'S' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'S' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_SUCCESS}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'S' || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Warning message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Warning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE";

    #**** Parameters ****
    local p_string=$1;	# String	- Default : NULL	- String to print and / or redirect to the log file.
    local p_option=$2;	# String	- Default : NULL	- "echo" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("$@");  # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VEchoWarning='1';

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'W' || { local C="$?"; [ -n "$VEchoWarning" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_WARNING}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'W' || { local C="$?"; [ -n "$VEchoWarning" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "$p_string" 'begin' 'W' || { local C="$?"; [ -n "$VEchoWarning" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_WARNING}$__BU_MAIN_TXT_PRINT_TAB$__BU_MAIN_TXT_PRINT_TAB $p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || { local C="$?"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };

        BU.Main.Echo.__EchoOutput "$p_string" 'end' 'W' || { local C="$?"; [ -n "$VEchoWarning" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "$C"; };
    fi

    # Restoring the former value of the "$__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable.
    [ -n "$VEchoWarning" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## DISPLAYING A COLORED MESSAGE

# --> DISPLAYING A COLORED MESSAGE WITH A PAUSE TIME DEPENDING ON THE "$__BU_MAIN_STAT_TIME_TXT" STATUS VARIABLE.

# Note : These function call the "BU.Main.Echo.Msg()" function in order to avoid rewriting tons of lines that would do the same thing.

# Aqua blue colored message.
function BU.Main.Echo.Aqua()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_AQUA}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Black colored message.
function BU.Main.Echo.Black()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_BLACK}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Blue colored message.
function BU.Main.Echo.Blue()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_BLUE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Cyan colored message.
function BU.Main.Echo.Cyan()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_CYAN}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Fuchsia colored message.
function BU.Main.Echo.Fuchsia()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_FUCHSIA}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Gray colored message.
function BU.Main.Echo.Gray()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_GRAY}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Green colored message.
function BU.Main.Echo.Green()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_GREEN}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Lime green colored message.
function BU.Main.Echo.Lime()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_LIME}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Maroon colored message.
function BU.Main.Echo.Maroon()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_MAROON}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Navy blue colored message.
function BU.Main.Echo.Navy()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_NAVY}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Olive green colored message.
function BU.Main.Echo.Olive()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_OLIVE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Orange colored message.
function BU.Main.Echo.Orange()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_ORANGE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Pink colored message.
function BU.Main.Echo.Pink()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_PINK}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Purple colored message.
function BU.Main.Echo.Purple()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_PURPLE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Red colored message.
function BU.Main.Echo.Red()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_RED}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Salmon colored message.
function BU.Main.Echo.Salmon()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_SALMON}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Silver colored message.
function BU.Main.Echo.Silver()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_SILVER}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Tan colored message.
function BU.Main.Echo.Tan()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TAN}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Teal colored message.
function BU.Main.Echo.Teal()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TEAL}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Turquoise colored message.
function BU.Main.Echo.Turquoise()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TURQUOISE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Violet colored message.
function BU.Main.Echo.Violet()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_VIOLET}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# White colored message.
function BU.Main.Echo.White()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_WHITE}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Yellow colored message.
function BU.Main.Echo.Yellow()
{
    #**** Parameters ****
    p_string=$1;        # Any       - String to display.
    p_option=$2;        # String    - "echo" command options.
    shift 2;

    local pa_extraArgs=("$@");      # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_YELLOW}$p_string${__BU_MAIN_COLOR_TXT_RESET}" "$p_option" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINE BREAKS
#### DEBUG ID : Echo.line-breaks

__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS="Echo::line-breaks";

## LINE BREAKS ACCORDING TO THE "$__BU_MAIN_PROJECT_LOG_FILE_PATH" VARIABLE VALUE
## DEBUG ID : line-breaks-according-to-the-project-log-file-var-val

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__LINE_BREAKS__LINE_BREAKS_ACCORDING_TO_THE_PROJECT_LOG_FILE_VAR_VAL="$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS::line-breaks-according-to-the-project-log-file-var-val":

# Redirecting the output of the "echo" command

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
#	- BU.Main.Errors.HandleErrors				--> Checkings.lib
function BU.Main.Echo.Newline()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "$__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS" \
        "$__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__LINE_BREAKS__LINE_BREAKS_ACCORDING_TO_THE_PROJECT_LOG_FILE_VAR_VAL";

    #**** Parameters ****
    local p_number=$1;

    #**** Code ****
    if [ -n "$p_number" ]; then
        if ! BU.Main.Checkings.IsPositiveInt "$p_number"; then
            BU.Main.Echo.Msg '' '' 'nodate';
            BU.Main.Echo.__EchoCPLS "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : the number of line breaks must be an integer" 'R';
            BU.Main.Echo.Msg '' '' 'nodate';
        else
            # Doing X line breaks according to the number passed as argument.
            for ((i=0; i<p_number; i++)); do
                BU.Main.Echo.Msg '' '' 'nodate';
            done
        fi
    else
        BU.Main.Echo.Msg '' '' 'nodate';
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

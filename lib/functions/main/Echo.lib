#!/usr/bin/env bash

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo "WARNING !"; echo
    echo "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !"
    echo "Use this script only by sourcing it in your project script."; echo

    exit 1
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT

#
function CheckDecho()
{
	if [ ! -f "$__PROJECT_COLOR_CODE_FILE_PATH" ]; then
        echo >&2; echo "THE COLOR CODE FILE DOESN'T EXISTS !" >&2; echo >&2; ExitError "1"
    
    elif [ -f "$__PROJECT_COLOR_CODE_FILE_PATH" ] && [ ! -s "$__PROJECT_COLOR_CODE_FILE_PATH" ]; then
        echo "$__BU_COLOR_RESET" > "$__PROJECT_COLOR_CODE_FILE_PATH"
	fi
}

# Quick multi commands execution for the below "Decho()" function.
function __Decho { local v_oldColor=$1; tput setaf "$v_oldColor" && IsInt "$v_oldColor" && echo "$v_oldColor" > "$__BASH_UTILS_FILE_COLOR_CODE_PATH"; }

# Text's inside decoration/formatting procssing.

# Usage :
#	Decho "${__BU_COLOR_<TO_DISPLAY>}" "$1" '<format code>'

# Featured functions and files from the "functions" folder : none
function Decho()
{
    #***** Parameters *****
    local p_string=$1
    local p_newColor=$2
    local p_formatting=$3

    #***** Variables *****
    local v_oldColor
        v_oldColor="$(CheckDecho && cat "$__PROJECT_COLOR_CODE_FILE_PATH")"

    #***** Code *****
    if [ -n "$p_newColor" ] && [ "$p_newColor" = "$v_oldColor" ]; then
        
        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newColor="$(( p_newColor+38 ))"
		tput setaf "$p_newColor"
	fi

	case "${p_formatting^^}" in
        'B')
            # Formatting : bold.
            echo -e "${__BU_TXT_BOLD}$p_string${__BU_TXT_RESET}"
            ;;
        'BC')
            # Formatting : bold + color.
            echo -e "${__BU_TXT_BOLD}$(tput setaf "$p_newColor")$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'BCI')
            # Formatting : bold + color + italic.
            echo -e "${__BU_TXT_BOLD}$(tput setaf "$p_newColor")${__BU_TXT_ITALIC}$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'BCIU')
            # Formatting : bold + color + italic + underline
            echo -e "${__BU_TXT_BOLD}$(tput setaf "$p_newColor")${__BU_TXT_ITALIC}${__BU_TXT_UNDERLINE}$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'C')
            # Formatting : color.
            echo -e "$(tput setaf "$p_newColor")$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;

        'CI')
            # Formatting : color + italic.
            echo -e "$(tput setaf "$p_newColor")${__BU_TXT_ITALIC}$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'CIU')
            # Formatting : color + italic + underline.
            echo -e "$(tput setaf "$p_newColor")${__BU_TXT_ITALIC}${__BU_TXT_UNDERLINE}$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'CU')
            # Formatting : color + underline.
            echo -e "$(tput setaf "$p_newColor")${__BU_TXT_UNDERLINE}$p_string${__BU_TXT_RESET}" && __Decho "$v_oldColor"
            ;;
        'I')
            # Formatting : italic.
            echo -e "${__BU_TXT_ITALIC}$p_string${__BU_TXT_RESET}"
            ;;
        'IU')
            # Formatting : italic + underline.
            echo -e "${__BU_TXT_ITALIC}${__BU_TXT_UNDERLINE}$p_string${__BU_TXT_RESET}"
            ;;
        'U')
            # Formatting : underline.
            echo -e "${__BU_TXT_UNDERLINE}$p_string${__BU_TXT_RESET}"
            ;;
        *)
            HandleErrors "1" "THE $(DechoHighlight "case condition") TEXT FORMATTING VALUE IS INCORRECT" \
                "Please specify a valid text formatting. The list and the descriptions are available into the aforementionned condition." \
                "$p_formatting" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
            ;;
    esac
}

# Bold formatting.
function Decho_FMT_B     { Decho "$1" "" 'B';    }
function Decho_FMT_BI    { Decho "$1" "" 'BI';   }
function Decho_FMT_BIU   { Decho "$1" "" 'BIU';  }
function Decho_FMT_BU    { Decho "$1" "" 'BU';   }

# Italic formatting.
function Decho_FMT_I     { Decho "$1" "" 'I';    }
function Decho_FMT_IU    { Decho "$1" "" 'IU';   }

# Underline formatting.
function Decho_FMT_U     { Decho "$1" "" 'U';    }

# Easy "Decho()" function calls.
function DechoHighlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'C'; }
function DechoBlack     { Decho "$1" "$__BU_COLOR_BLACK"        'C'; }
function DechoBlue      { Decho "$1" "$__BU_COLOR_BLUE"         'C'; }
function DechoCyan      { Decho "$1" "$__BU_COLOR_CYAN"         'C'; }
function DechoGray      { Decho "$1" "$__BU_COLOR_GRAY"         'C'; }
function DechoGreen     { Decho "$1" "$__BU_COLOR_GREEN"        'C'; }
function DechoOrange    { Decho "$1" "$__BU_COLOR_ORANGE"       'C'; }
function DechoPink      { Decho "$1" "$__BU_COLOR_PINK"         'C'; }
function DechoPurple    { Decho "$1" "$__BU_COLOR_PURPLE"       'C'; }
function DechoRed       { Decho "$1" "$__BU_COLOR_RED"          'C'; }
function DechoTurquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    'C'; }
function DechoWhite     { Decho "$1" "$__BU_COLOR_WHITE"        'C'; }
function DechoYellow    { Decho "$1" "$__BU_COLOR_YELLOW"       'C'; }

# Easy "DechoBold()" function calls with colors.
function Decho_FMT_BC_Highlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'BC'; }
function Decho_FMT_BC_Black     { Decho "$1" "$__BU_COLOR_BLACK"        'BC'; }
function Decho_FMT_BC_Blue      { Decho "$1" "$__BU_COLOR_BLUE"         'BC'; }
function Decho_FMT_BC_Cyan      { Decho "$1" "$__BU_COLOR_CYAN"         'BC'; }
function Decho_FMT_BC_Gray      { Decho "$1" "$__BU_COLOR_GRAY"         'BC'; }
function Decho_FMT_BC_Green     { Decho "$1" "$__BU_COLOR_GREEN"        'BC'; }
function Decho_FMT_BC_Orange    { Decho "$1" "$__BU_COLOR_ORANGE"       'BC'; }
function Decho_FMT_BC_Pink      { Decho "$1" "$__BU_COLOR_PINK"         'BC'; }
function Decho_FMT_BC_Purple    { Decho "$1" "$__BU_COLOR_PURPLE"       'BC'; }
function Decho_FMT_BC_Red       { Decho "$1" "$__BU_COLOR_RED"          'BC'; }
function Decho_FMT_BC_Turquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    'BC'; }
function Decho_FMT_BC_White     { Decho "$1" "$__BU_COLOR_WHITE"        'BC'; }
function Decho_FMT_BC_Yellow    { Decho "$1" "$__BU_COLOR_YELLOW"       'BC'; }

# Easy "DechoBoldItalic()" function calls with colors.
function Decho_FMT_BCI_Highlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'BCI'; }
function Decho_FMT_BCI_Black     { Decho "$1" "$__BU_COLOR_BLACK"        'BCI'; }
function Decho_FMT_BCI_Blue      { Decho "$1" "$__BU_COLOR_BLUE"         'BCI'; }
function Decho_FMT_BCI_Cyan      { Decho "$1" "$__BU_COLOR_CYAN"         'BCI'; }
function Decho_FMT_BCI_Gray      { Decho "$1" "$__BU_COLOR_GRAY"         'BCI'; }
function Decho_FMT_BCI_Green     { Decho "$1" "$__BU_COLOR_GREEN"        'BCI'; }
function Decho_FMT_BCI_Orange    { Decho "$1" "$__BU_COLOR_ORANGE"       'BCI'; }
function Decho_FMT_BCI_Pink      { Decho "$1" "$__BU_COLOR_PINK"         'BCI'; }
function Decho_FMT_BCI_Purple    { Decho "$1" "$__BU_COLOR_PURPLE"       'BCI'; }
function Decho_FMT_BCI_Red       { Decho "$1" "$__BU_COLOR_RED"          'BCI'; }
function Decho_FMT_BCI_Turquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    'BCI'; }
function Decho_FMT_BCI_White     { Decho "$1" "$__BU_COLOR_WHITE"        'BCI'; }
function Decho_FMT_BCI_Yellow    { Decho "$1" "$__BU_COLOR_YELLOW"       'BCI'; }

# Easy "DechoBoldItalicUnderline()" function calls with color.
function Decho_FMT_BCIU_Highlight   { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'BCIU'; }
function Decho_FMT_BCIU_Black       { Decho "$1" "$__BU_COLOR_BLACK"        'BCIU'; }
function Decho_FMT_BCIU_Blue        { Decho "$1" "$__BU_COLOR_BLUE"         'BCIU'; }
function Decho_FMT_BCIU_Cyan        { Decho "$1" "$__BU_COLOR_CYAN"         'BCIU'; }
function Decho_FMT_BCIU_Gray        { Decho "$1" "$__BU_COLOR_GRAY"         'BCIU'; }
function Decho_FMT_BCIU_Green       { Decho "$1" "$__BU_COLOR_GREEN"        'BCIU'; }
function Decho_FMT_BCIU_Orange      { Decho "$1" "$__BU_COLOR_ORANGE"       'BCIU'; }
function Decho_FMT_BCIU_Pink        { Decho "$1" "$__BU_COLOR_PINK"         'BCIU'; }
function Decho_FMT_BCIU_Purple      { Decho "$1" "$__BU_COLOR_PURPLE"       'BCIU'; }
function Decho_FMT_BCIU_Red         { Decho "$1" "$__BU_COLOR_RED"          'BCIU'; }
function Decho_FMT_BCIU_Turquoise   { Decho "$1" "$__BU_COLOR_TURQUOISE"    'BCIU'; }
function Decho_FMT_BCIU_Yellow      { Decho "$1" "$__BU_COLOR_YELLOW"       'BCIU'; }

# Easy "DechoItalic()" function calls with colors.
function Decho_FMT_CI_Highlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'CI'; }
function Decho_FMT_CI_Black     { Decho "$1" "$__BU_COLOR_BLACK"        'CI'; }
function Decho_FMT_CI_Blue      { Decho "$1" "$__BU_COLOR_BLUE"         'CI'; }
function Decho_FMT_CI_Cyan      { Decho "$1" "$__BU_COLOR_CYAN"         'CI'; }
function Decho_FMT_CI_Gray      { Decho "$1" "$__BU_COLOR_GRAY"         'CI'; }
function Decho_FMT_CI_Green     { Decho "$1" "$__BU_COLOR_GREEN"        'CI'; }
function Decho_FMT_CI_Orange    { Decho "$1" "$__BU_COLOR_ORANGE"       'CI'; }
function Decho_FMT_CI_Pink      { Decho "$1" "$__BU_COLOR_PINK"         'CI'; }
function Decho_FMT_CI_Purple    { Decho "$1" "$__BU_COLOR_PURPLE"       'CI'; }
function Decho_FMT_CI_Red       { Decho "$1" "$__BU_COLOR_RED"          'CI'; }
function Decho_FMT_CI_Turquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    'CI'; }
function Decho_FMT_CI_White     { Decho "$1" "$__BU_COLOR_WHITE"        'CI'; }
function Decho_FMT_CI_Yellow    { Decho "$1" "$__BU_COLOR_YELLOW"       'CI'; }

# Easy "DechoItalicUnderline()" function calls with colors.
function Decho_FMT_CIU_Highlight    { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'CIU'; }
function Decho_FMT_CIU_Black        { Decho "$1" "$__BU_COLOR_BLACK"        'CIU'; }
function Decho_FMT_CIU_Blue         { Decho "$1" "$__BU_COLOR_BLUE"         'CIU'; }
function Decho_FMT_CIU_Cyan         { Decho "$1" "$__BU_COLOR_CYAN"         'CIU'; }
function Decho_FMT_CIU_Gray         { Decho "$1" "$__BU_COLOR_GRAY"         'CIU'; }
function Decho_FMT_CIU_Green        { Decho "$1" "$__BU_COLOR_GREEN"        'CIU'; }
function Decho_FMT_CIU_Orange       { Decho "$1" "$__BU_COLOR_ORANGE"       'CIU'; }
function Decho_FMT_CIU_Pink         { Decho "$1" "$__BU_COLOR_PINK"         'CIU'; }
function Decho_FMT_CIU_Purple       { Decho "$1" "$__BU_COLOR_PURPLE"       'CIU'; }
function Decho_FMT_CIU_Red          { Decho "$1" "$__BU_COLOR_RED"          'CIU'; }
function Decho_FMT_CIU_Turquoise    { Decho "$1" "$__BU_COLOR_TURQUOISE"    'CIU'; }
function Decho_FMT_CIU_White        { Decho "$1" "$__BU_COLOR_WHITE"        'CIU'; }
function Decho_FMT_CIU_Yellow       { Decho "$1" "$__BU_COLOR_YELLOW"       'CIU'; }

# Easy "DechoUnderline()" function calls with colors.
function Decho_FMT_CU_Highlight { Decho "$1" "$__BU_COLOR_HIGHLIGHT"    'CU'; }
function Decho_FMT_CU_Black     { Decho "$1" "$__BU_COLOR_BLACK"        'CU'; }
function Decho_FMT_CU_Blue      { Decho "$1" "$__BU_COLOR_BLUE"         'CU'; }
function Decho_FMT_CU_Cyan      { Decho "$1" "$__BU_COLOR_CYAN"         'CU'; }
function Decho_FMT_CU_Gray      { Decho "$1" "$__BU_COLOR_GRAY"         'CU'; }
function Decho_FMT_CU_Green     { Decho "$1" "$__BU_COLOR_GREEN"        'CU'; }
function Decho_FMT_CU_Orange    { Decho "$1" "$__BU_COLOR_ORANGE"       'CU'; }
function Decho_FMT_CU_Pink      { Decho "$1" "$__BU_COLOR_PINK"         'CU'; }
function Decho_FMT_CU_Purple    { Decho "$1" "$__BU_COLOR_PURPLE"       'CU'; }
function Decho_FMT_CU_Red       { Decho "$1" "$__BU_COLOR_RED"          'CU'; }
function Decho_FMT_CU_Turquoise { Decho "$1" "$__BU_COLOR_TURQUOISE"    'CU'; }
function Decho_FMT_CU_White     { Decho "$1" "$__BU_COLOR_WHITE"        'CU'; }
function Decho_FMT_CU_Yellow    { Decho "$1" "$__BU_COLOR_YELLOW"       'CU'; }

# -----------------------------------------------

## DISPLAYING A COLORED MESSAGE WITH A PAUSE TIME DEPENDING ON THE "$__STAT_TIME_TXT" status variable.

# Error message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoError()
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_ERROR}$__BU_TXT_PRINT_TAB$__BU_TXT_PRINT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" >&2

    sleep "$__STAT_TIME_TXT"
}

# Normal message (without any extra color), with redirection checking.

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoMsg()
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "$p_string" "$p_option" "${p_arrExtraArgs[@]}"

    sleep "$__STAT_TIME_TXT"
}

# New sub-step message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoNewstep()
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_ORANGE}$__BU_TXT_PRINT_TAB$__BU_TXT_PRINT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}"

    sleep "$__STAT_TIME_TXT"
}

# Read input values

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#	- CheckProjectLogStatus		--> Checkings.lib
function EchoRead()
{
	#***** Parameters *****
	local p_string=$1
	
	#***** Code *****
	if [ -f "$__PROJECT_LOG_FILE_PATH" ] && [ "$__STAT_LOG" = "true" ] && [ -n "$__STAT_LOG_REDIRECT" ]; then
		echo "$p_string" >> "$__PROJECT_LOG_FILE_PATH"
	fi
}

# Success message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoSuccess()
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_SUCCESS}$__BU_TXT_PRINT_TAB$__BU_TXT_PRINT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" >&1

    sleep "$__STAT_TIME_TXT"
}

# Warning message

# Usage :
#	EchoError "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the CheckProjectLogStatus() function>"

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
function EchoWarning()
{
    #***** Parameters *****
    local p_string=$1
    local p_option=$2; shift 2
    local p_arrExtraArgs=("$@")

    #***** Code *****
    CheckProjectLogStatus "${__BU_COLOR_WARNING}$__BU_TXT_PRINT_TAB$__BU_TXT_PRINT_TAB $p_string${__BU_COLOR_RESET}" "$p_option" "${p_arrExtraArgs[@]}" 1>&2

    sleep "$__STAT_TIME_TXT"
}

# -----------------------------------------------

## TEXT FORMATTING

# Keep the same text format between lowercased or uppercased text printed by a formatting text function ("ToLowercase()" OR "ToUppercase()") or a parameter expansion.
# function KeepFormatting()
# {
# 	#***** Parameters *****
# 	p_string=$1
# 
# 	#***** Code *****
# 	echo "$p_string" | tr '[upper]' '[upper]'
# }

# Print a lowercased text.

# Usage :
#	ToLowercase "<Text to write>"
function ToLowercase()
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	echo "$p_string" | tr '[:upper:]' '[:lower:]'
}

# Print an uppercased text.

# Usage :
#	ToUppercase "<Text to write>"
function ToUppercase()
{
	#***** Parameters *****
	p_string=$1

	#***** Code *****
	echo "$p_string" | tr '[:lower:]' '[:upper:]'
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINE BREAKS

## LINE BREAKS ACCORDING TO THE "$MAIN_SCRIPT_LOG" VARIABLE VALUE.

# Redirecting the output of the "echo" command

# Featured functions and files from the "functions" folder :
#   - CheckProjectLogStatus     --> Checkings.lib
#	- HandleErrors				--> Checkings.lib
function Newline()
{
    #***** Parameters *****
    local number=$1

    #***** Code *****
    if [ -n "$number" ]; then
        if ! IsInt "$number"; then
            HandleErrors "1" "THE NUMBER OF LINE BREAKS MUST BE AN INTEGER" \
                "Check at the mentionned file in the 4th $(DechoHighlight "HandleErrors") function's argument" "$number" \
                "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
        else
            # Doing X line breaks according to the number passed as argument.
            for ((i=0; i<number; i++)); do
                CheckProjectLogStatus "" "" "nodate"
            done
        fi
    else
        CheckProjectLogStatus "" "" "nodate"
    fi
}

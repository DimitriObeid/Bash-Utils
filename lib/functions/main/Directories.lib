#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Directories.lib
# Module        : Main
# Description   :
# Author(s)     : Dimitri Obeid
# Version       :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# --------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DIRECTORIES FUNCTIONS

## PROCESSING FUNCTIONS

# Separate processing steps displays from the rest of the main script with a line.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Directories::ProcessingDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_function=$1
    local p_parent=$2
    local p_name=$3

    #**** Variables ****
    local v_char='"'
    local v_path="$p_parent/$p_name"

    #**** Code ****
    # Arguments checking.
	if ! BU::Main::Args__Directories::ProcessingDir "$p_function" "$p_parent" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

	sleep "$PROJECT_STATUS_SLEEP_LINE";

    BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
    BU::EchoNewstep "Processing the $(BU::DechoHighlightPath "$p_name") folder in the parent folder $(BU::DechoHighlightPath "$p_parent").";
    BU::Newline;

    if "$p_function"; then
        BU::EchoSuccess "End of processing the $(BU::DechoHighlightPath "$p_name/") folder.";
		BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
		sleep "$PROJECT_STATUS_SLEEP_LINE";
		BU::Newline;
    else
        BU::EchoError "End of processing the $(BU::DechoHighlightPath "$p_name/") folder.";
		BU::EchoMsg "$(BU::Main::Headers::DrawLine "$v_char" "$__COL_RESET")" '-n' 'nodate';
		sleep "$PROJECT_STATUS_SLEEP_LINE";
		BU::Newline;
    fi
}

# -----------------------------------------------

## FOLDER CREATION FUNCTIONS

# Overwriting an existing directory's content

# Featured functions and files from the "functions" folder :
#	- BU::EchoError			-> Echo.lib
#	- BU::EchoNewstep		-> Echo.lib
#	- BU::EchoSuccess		-> Echo.lib
#	- BU::Newline			-> Echo.lib
function BU::Main::Directories::OverwriteDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;
	local p_authorization=$2;

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU::Main::Args__Directories::OverwriteDir "$p_path" "$p_authorization" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$p_path";

    BU::EchoNewstep "A non-empty folder with exactly the same name ($(BU::DechoHighlightPath "$p_name")) is already in the target folder $(BU::DechoHighlightPath "$p_parent/")";
	BU::EchoNewstep "Deleting the contents of the $(BU::DechoHighlightPath "$v_path/") folder";
	BU::Newline;

	if [ "$p_authorization" = "--rmdir" ]; then
        # TODO : Si la variable n'est pas initialisÃ©e.
        if [ -n "${p_path+x}" ]; then
            # WARNING ! DO NOT MODIFY THE FOLLOWING COMMAND, UNLESS YOU KNOW >>> EXACTLY <<< WHAT YOU DO !!!
            # WARNING ! IF YOU MODIFY THE NAME OF THE VARIABLES, PLEASE CHECK THE NAME OF EVERY
            # VARIABLES INTO THIS FUNCTION, OR ELSE THIS PROGRAM COULD OPERATE FROM THE ROOT DIRECTORY !!!!!!!!!

            # Check this link for more informations about this command --> https://github.com/koalaman/shellcheck/wiki/SC2115
            rm -rfv "${v_path/:?}/"*;
            BU::Main::Errors::HandleErrors "$?" "UNABLE TO DELETE THE CONTENT OF THE $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlightPath "$v_path/")") FOLDER." \
                "Please check the permissions of the targeted directory" "$v_path" "$v_path" \
                "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

            BU::EchoSuccess "Deletion of the contents of the folder $(BU::DechoHighlightPath "$v_path/") performed successfully";
            BU::Newline;

			return 0;
        else
            BU::Main::Errors::HandleErrors "1" "" "" "" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";

			return 1;
        fi
	fi

    return 0;
}

# folder creation function, with the parent folder's path and the new folder's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Args__Directories::Make        -> Main -> Args.lib
#   - BU::Main::Checkings::CheckFilePathWasCreated  -> Main -> Checkings.lib
#   - BU::Main::Directories::OverwriteDir           -> Main -> Directories.lib (this file)
#   - BU::Main::Directories::TriggerRootDirWarning  -> Main -> Directories.lib (this file)
#   - BU::Main::Errors::HandleErrors                -> Main -> Errors.lib
#   - BU::Main::Headers::DrawLine                   -> Main -> Headers.lib

#   - BU::DechoHighlightPath            -> Main -> Decho.lib
#   - BU::EchoError                     -> Main -> Echo.lib
#   - BU::EchoNewstep                   -> Main -> Echo.lib
#   - BU::EchoSuccess                   -> Main -> Echo.lib
function BU::Main::Directories::Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

	#**** Parameters ****
	local p_parent=$1;	# String	- Emplacement of the currently processed directory's parent folder from the root directory.
	local p_name=$2;    # String	- Name of the folder to process (into its parent directory).
	local p_rm=$3;      # String	- Authorization to overwrite the targeted directory.

	#**** Variables ****
	local v_path="$p_parent/$p_name";	# String	- Path of the file to process.

	#**** Code ****
	# Checking first if the awaited arguments are given
    if ! BU::Main::Args__Directories::Make "$p_parent" "$p_name" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    # Checking second if the script is operating at the root directory.
    if ! BU::Main::Directories::TriggerRootDirWarning "$v_path"; then return 1; fi

	# If the folder to create doesn't exists, ths script creates it with the help of the "mkdir" command.
	if [ ! -d "$v_path" ]; then
		BU::EchoNewstep "Creating the $(BU::DechoHighlightPath "$p_name") folder in the parent folder $(BU::DechoHighlightPath "$p_parent/").";
		BU::Newline;

        mkdir -pv "$v_path"
        BU::Main::Errors::HandleErrors "$?" \
            "THE $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlightPath "$p_name/")") FOLDER CANNOT BE CREATED IN THE PARENT FOLDER $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlightPath "$p_parent/")") !" \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))";
        BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_name") folder was successfully created in the $(BU::DechoHighlightPath "$p_parent/") folder.";
        BU::Newline;

        return 0;

    # Else, if the folder to create already exists in its parent directory AND this folder already contains AT LEAST one file or folder.
	elif [ -d "$v_path" ] && [ "$(ls -A "$v_path")" ]; then

        if [ "$p_rm" = '--rmdir' ]; then
            BU::Main::Directories::OverwriteDir "$v_path" "$p_rm";

			if test "$?" -eq 0; then
                return 0;
            else
                return 1;
            fi
        fi

	# Else, if the folder to create already exists in its parent directory AND this folder is empty.
	elif [ -d "$v_path" ] && [ ! "$(ls -A "$v_path")" ]; then
		BU::EchoSuccess "The $(BU::DechoHighlightPath "$p_name/") folder already exists in the $(BU::DechoHighlightPath "$p_parent/") folder and is empty.";
		BU::Newline;

		return 0;
    fi
}

# Folder creation function, with the parent folder's path and the directory's name as unique argument.
function BU::Main::Directories::MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;		# String	- Full path of the directory to create.
    local p_overwrite=$2;	# String	- Authorization to overwrite the directory.

    #**** Variables ****
    local v_parent; v_parent="$(echo "$p_path" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the folder to create.
    local v_target; v_target="$(echo "$p_path" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the folder to create.

    #**** Code ****
    if ! BU::Main::Args__Directories::MakePath "$p_path" "$p_overwrite" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    if [ "$p_overwrite" != 'rmdir' ]; then
        BU::Main::Directories::Make "$v_parent" "$v_target" || return 1;
    else
        BU::Main::Directories::Make "$v_parent" "$v_target" '--rmdir';
    fi

    return 0;
}

# The function "CheckSTAT_LOG()" creates the log file and its path when the __BU_MAIN_STAT_LOG variable's value is "true",
# but in case the value is "false", it's necessary to check if the project's temporary folder exists anyway.
function BU::Main::Directories::MkTmpDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    local lineno="$LINENO"; if [ ! -d "$__BU_MAIN_PROJECT_TMP_DIR_PATH" ]; then
        mkdir -p "$__BU_MAIN_PROJECT_TMP_DIR_PATH" ||
		{
			BU::Main::Status::ChangeSTAT_ECHO "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

			BU::Main::Errors::HandleErrors "1" "THE $(BU::Main::Checkings::CheckDirPathExists "$__BU_MAIN_PROJECT_TMP_DIR_PATH" 'true') CANNOT BE CREATED !" \
				"Please check at the mentionned line in the mentionned file." "$__BU_MAIN_PROJECT_TMP_DIR_PATH" \
				"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno";

			BU::Main::Status::ChangeSTAT_ECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO";

			return 1;
		}

		return 0;
	fi

	return 0;
}

# -----------------------------------------------

## PATH PROCESSING

# Getting the name of a target directory without its path.
function BU::Main::Directories::GetDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;	# String	- Default : NULL	- Full path of the directory.

    #**** Code ****
    if ! BU::Main::Args__Directories::GetDirectoryName "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    if [ -d "$p_path" ]; then
        shopt -s extglob;           # enable +(...) glob syntax

        result=${p_path%%+(/)};     # trim however many trailing slashes exist
        result=${result##*/}:       # remove everything before the last / that still remains

        echo -e "$result";

		return 0;
    else
        BU::Main::Errors::HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Check if the provided path is correct." \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-6 ))";

		return 1;
    fi
}

# Checking if the directory's sub-folders paths passed as argument exists, then print its path.
function BU::Main::Directories::GetDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;    # String    - Default : NULL    - Path of the folder to get.

    #**** Code ****
    if ! BU::Main::Args__Directories::GetDirectoryPath "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    if [ -d "$p_path" ]; then
        echo -e "$p_path";

		return 0;
    else
        BU::Main::Errors::HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Please check if the provided path is correct." \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-3 ))";

		return 1;
    fi
}

# Getting parent folder's name only (without its full path from the root directory), then printing it.
function BU::Main::Directories::GetParentDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;            # String	- Default : NULL    - Path of the child file or folder.
    local p_iterations=${2-1};  # Int   	- Default : 1       - Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Code ****
    if ! BU::Main::Args__Directories::GetParentDirectoryName "$p_path" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$?"; fi

    for ((i=0; i<p_iterations; i++)); do
        local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
            || {
                BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                    "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; return 1;
            }; pwd -P )";

        p_path="$v_parent";
    done

    shopt -s extglob;       # enable +(...) glob syntax.
    result=${p_path%%+(/)};	# trim however many trailing slashes exist.
    result=${result##*/};   # remove everything before the last / that still remains.

    echo -e "$result";
}

# Getting parent folder's path from the root directory, then printing it
function BU::Main::Directories::GetParentDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

    #**** Parameters ****
    local p_path=$1;            # String   	- Default : NULL    - Path of the child file or folder.
    local p_iterations=${2-1};  # Int   	- Default : 1       - Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Code ****
    if ! BU::Main::Args__Directories::GetParentDirectoryPath "$p_path" "$p_iterations" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; then return "$__BU_MAIN_EXIT_CURRENT_CODE"; fi

    if [ "$p_iterations" -lt 1 ]; then
        p_iterations="$(echo "$(BU::Main::BasicMaths::NegativeToPositive "$p_iterations")")";
    fi

    if [ -d "$p_path" ]; then
        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
                || {
                    BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; BU::SetLastReturnValue "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND"; return "$__BU_MAIN_EXIT_CURRENT_CODE";
                }; pwd -P )";

            p_path="$v_parent";
        done

        shopt -s extglob;       # enable +(...) glob syntax.
        result=${p_path%%+(/)};	# trim however many trailing slashes exist.

        echo -e "$result";
    else
        local v_path_str="";
        local v_current_path="$p_path";

        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
                || {
                    BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; BU::SetLastReturnValue "$__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND"; return "$__BU_MAIN_EXIT_CURRENT_CODE";
                }; pwd -P )"

            local v_path_cut; v_path_cut="${v_parent##*/}";
            local v_path_str+="$v_path_cut/";

            # Removing the unnecessary folders.
            # WARNING !!!! USE THE "rmdir" COMMAND ONLY !!!!
            # DO NOT USE THE "rm -rf" COMMAND AT ALL, OR FILES AND FOLDERS COULD BE UNINTENTIONNALY ERASED !!!!
            rmdir "$v_current_path"; BU::Main::Errors::HandleErrors "$?" "UNABLE TO ERASE THE $(BU::DechoHighlightPath "$v_current_path") NEWLY CREATED FOLDER !";

            local v_current_path="$v_parent";
        done

        BU::Main::Text::ReverseStringWordsOrder "$v_path_str" '/';
    fi

	BU::SetLastReturnValue 0;

	return 0;
}

# Check if the script is about to work at the root directory ('/').
function BU::Main::Directories::TriggerRootDirWarning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU::Main::Echo::Debug "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}";

	#**** Parameters ****
	local p_path=$1;	# String	- Default : NULL	- Path of the folder to check.

	#**** Code ****
	# Checking if the given path points towards the root directory or one of its subfolders
	# TODO : detecting if path points to a root sub-folder (like [ if "$p_path" = "/" ] || [ "$p_path" | cut blablabla ]).
	if [ "$(pwd "$p_path")" = "/" ] || [ "$(BU::Main::Directories::GetParentDirectoryPath "$p_path")" = '/' ]; then
		if [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" = "forbidden" ]; then
			BU::HeaderError "WARNING !!!!!! READ THIS MESSAGE CAREFULLY !!!!!!" 'strlen';

			BU::EchoError "The script was trying to operate at the root directory (or one of its sub directories) without authorization";
			BU::EchoError "Given path : $(BU::DechoHighlightPath "$p_path")";
			BU::EchoError "Authorization : $__BU_MAIN_STAT_OPERATE_ROOT";
			BU::Newline;

			BU::SetLastReturnValue "$__BU_MAIN_EXIT_PERMISSION_DENIED";

			return "$__BU_MAIN_EXIT_CURRENT_CODE";

		elif [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" = "restricted" ]; then
            BU::HeaderWarning "WARNING !!!!!!! DO NOT SKIP THIS MESSAGE BEFORE READING IT CAREFULLY !!!!!!" 'strlen';

            BU::EchoWarning "You are about to operate at the root directory or one of its present sub-folders !";
			BU::EchoWarning "Given path : $(BU::DechoHighlightPath "$p_path")";
			BU::EchoWarning "Authorization : $__BU_MAIN_STAT_OPERATE_ROOT";
			BU::Newline;

			# Calling the function that processes the given answer.
			if BU::Main::Case::Read_Directories::TriggerRootDirWarning; then
				return "$__BU_MAIN_EXIT_CURRENT_CODE";
			else
				return "$__BU_MAIN_EXIT_CURRENT_CODE";
			fi
		fi
	fi

	return 0;
}

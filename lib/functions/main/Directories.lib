#!/usr/bin/env bash

# ----------------------
# SCRIPT'S INFORMATIONS

# Name          : Directories.lib
# Module        : Main
# Description   : 
# Author(s)     : Dimitri Obeid
# Version       : 

# ----------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# shellcheck disable=SC2154

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "$__BU_MAIN_FUNCTIONS_FILES_PATH" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use this script only by sourcing it in your project script." >&2; echo >&2;

    exit 1;
fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DIRECTORIES FUNCTIONS

## PROCESSING FUNCTIONS

# Separate processing steps displays from the rest of the main script with a line.

# Featured functions and files from the "functions" folder :
#   - BU::Main::Headers::DrawLine      -> Headers.lib
#   - BU::Main::Errors::HandleErrors  -> Headers.lib
function BU::Main::Directories::ProcessingDir()
{
    #**** Parameters ****
    local p_function=$1
    local p_parent=$2
    local p_name=$3
    
    #**** Variables ****
    local v_char='"'
    local v_path="$p_parent/$p_name"
    
    #**** Code ****
    # Arguments checking.
	BU::Main::CheckArgs__Directories::ProcessingDir "$p_function" "$p_parent" "$p_name"
    
	sleep "$PROJECT_STATUS_SLEEP_LINE"
    BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate'
    BU::EchoNewstep "Processing the $(BU::DechoHighlight "$p_name") folder in the parent folder $(BU::DechoHighlight "$p_parent")."
    BU::Newline
    
    if "$p_function"; then
        BU::EchoSuccess "End of processing the $(BU::DechoHighlight "$p_name/") folder."
		BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate'
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		BU::Newline
    else
        BU::EchoError "End of processing the $(BU::DechoHighlight "$p_name/") folder."
		BU::EchoMsg "$(BU::Main::Headers::DrawLine "$__COL_RESET" "$v_char")" '-n' 'nodate'
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		BU::Newline
    fi
}

# -----------------------------------------------

## FOLDER CREATION FUNCTIONS

# Overwriting an existing directory's content

# Featured functions and files from the "functions" folder :
#	- BU::EchoError			-> Echo.lib
#	- BU::EchoNewstep		-> Echo.lib
#	- BU::EchoSuccess		-> Echo.lib
#	- BU::Newline			-> Echo.lib
function BU::Main::Directories::OverwriteDir()
{
    #**** Parameters ****
    local p_path=$1
	local p_authorization=$2

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU::Main::CheckArgs__Directories::OverwriteDir "$p_path" "$p_authorization"; then return 1; fi
	
    # Checking second if the script is operating at the root directory.
    BU::Main::Directories::TriggerRootDirWarning "$p_path"

    BU::EchoNewstep "A non-empty folder with exactly the same name ($(BU::DechoHighlight "$p_name")) is already in the target folder $(BU::DechoHighlight "$p_parent/")"
	BU::EchoNewstep "Deleting the contents of the $(BU::DechoHighlight "$v_path/") folder"
	BU::Newline

	if [ "$p_authorization" = "true" ]; then
        # TODO : Si la variable n'est pas initialisÃ©e.
        if [ -n "${p_path+x}" ]; then
            # WARNING ! DO NOT MODIFY THE FOLLOWING COMMAND, UNLESS YOU KNOW >>> EXACTLY <<< WHAT YOU DO !!!
            # WARNING ! IF YOU MODIFY THE NAME OF THE VARIABLES, PLEASE CHECK THE NAME OF EVERY
            # VARIABLES INTO THIS FUNCTION, OR ELSE THIS PROGRAM COULD OPERATE FROM THE ROOT DIRECTORY !!!!!!!!!

            # Check this link for more informations about this command --> https://github.com/koalaman/shellcheck/wiki/SC2115
            rm -rfv "${v_path/:?}/"*
            BU::Main::Errors::HandleErrors "$?" "UNABLE TO DELETE THE CONTENT OF THE $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlight "$v_path/")") FOLDER." \
                "Please check the permissions of the targeted directory" "$v_path" "$v_path" \
                "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

            BU::EchoSuccess "Deletion of the contents of the folder $(BU::DechoHighlight "$v_path/") performed successfully"
            BU::Newline

			return 0
        else
            BU::Main::Errors::HandleErrors "1" "" "" "" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"

			return 1
        fi
	fi

    return 0
}



# Folder creation AND recursively assigning read and write rights to the user.
# When this function is called, if a log file is used in the project, the output of this function must be redirected either to the terminal AND the log file (2>&1 | tee -a "$FILE_LOG_PATH"), or to the log file only (>> "$FILE_LOG_PATH") after passing all the mandatory arguments. Otherwise, leave everything blank after passing the arguments.

# Featured functions and files from the "functions" folder :
#   - BU::Echo.sh       -> BU::EchoErrorTimer
#   - BU::Echo.sh       -> BU::EchoNewstepTimer
#   - BU::Echo.sh       -> BU::EchoSuccessTimer
#   - Headers.sh    -> BU::Main::Headers::DrawLine   
#   - Headers.sh    -> BU::Main::Errors::HandleErrors
function BU::Main::Directories::Make()
{
	#**** Parameters ****
	local p_parent=$1  # Emplacement of the currently processed directory's parent folder from the root directory.
	local p_name=$2    # Name of the folder to process (into its parent directory).

	#**** Variables ****
	local v_path="$p_parent/$p_name"	# Path of the file to process.

	#**** Code ****
	# Checking first if the awaited arguments are given
    if ! BU::Main::CheckArgs__Directories::Make "$p_parent" "$p_name"; then return 1; fi
    
    # Checking second if the script is operating at the root directory.
    if ! BU::Main::Directories::TriggerRootDirWarning "$v_path"; then return 1; fi
	
	# If the folder to create doesn't exists, ths script creates it with the help of the "mkdir" command.
	if [ ! -d "$v_path" ]; then
		BU::EchoNewstep "Creating the $(BU::DechoHighlight "$p_name") folder in the parent folder $(BU::DechoHighlight "$p_parent/")."
		BU::Newline

        mkdir -pv "$v_path"
        BU::Main::Errors::HandleErrors "$?" \
            "THE $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlight "$p_name/")") FOLDER CANNOT BE CREATED IN THE PARENT FOLDER $(BU::Main::Echo::KeepFormatting "$(BU::DechoHighlight "$p_parent/")") !" \
            "Please check the permissions of the targeted directory" "$v_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-1 ))"
        BU::EchoSuccess "The $(BU::DechoHighlight "$p_name") folder was successfully created in the $(BU::DechoHighlight "$p_parent/") folder."
        BU::Newline
        
        return 0

    # Else, if the folder to create already exists in its parent directory AND this folder already contains AT LEAST one file or folder.
	elif [ -d "$v_path" ] && [ "$(ls -A "$v_path")" ]; then
        BU::Main::Directories::OverwriteDir "$p_parent" "$p_name"
        if test "$?" -eq 0; then
            return 0
		else
            return 1
		fi

	# Else, if the folder to create already exists in its parent directory AND this folder is empty.
	elif [ -d "$v_path" ] && [ ! "$(ls -A "$v_path")" ]; then
		BU::EchoSuccess "The $(BU::DechoHighlight "$p_name/") folder already exists in the $(BU::DechoHighlight "$p_parent/") folder and is empty."
		BU::Newline

		return 0
    fi
}

# The function "CheckSTAT_LOG()" creates the log file and its path when the __BU_MAIN_STAT_LOG variable's value is "true",
# but in case the value is "false", it's necessary to check if the project's temporary folder exists anyway.
function BU::Main::Directories::MkTmpDir()
{
    local lineno="$LINENO"; if [ ! -d "$__BU_MAIN_PROJECT_TMP_DIR_PATH" ]; then
        mkdir -p "$__BU_MAIN_PROJECT_TMP_DIR_PATH" ||
		{
			BU::Main:Status::ChangeSTAT_ECHO "true" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"
			
			BU::Main::Errors::HandleErrors "1" "THE $(BU::Main::Checkings::CheckDirPathExists "$(BU::DechoHighlight "$__BU_MAIN_PROJECT_TMP_DIR_PATH")") CANNOT BE CREATED !" \
            "Please check at the mentionned line in the mentionned file." "$__BU_MAIN_PROJECT_TMP_DIR_PATH" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$lineno"

			BU::Main:Status::ChangeSTAT_ECHO "false" "$(basename "${BASH_SOURCE[0]}")" "$LINENO"

			return 1
		}
    
		return 0
	fi

	return 0
}

# -----------------------------------------------

## PATH PROCESSING

# Getting the name of a target directory without its path.
function BU::Main::Directories::GetDirectoryName()
{
    #**** Parameters ****
    local p_path=$1
    
    #**** Code ****
    BU::Main::CheckArgs__Directories::GetDirectoryName "$p_path"
    
    if [ -d "$p_path" ]; then
        shopt -s extglob            # enable +(...) glob syntax

        result=${p_path%%+(/)}      # trim however many trailing slashes exist
        result=${result##*/}        # remove everything before the last / that still remains

        echo -e "$result"

		return 0
    else
        BU::Main::Errors::HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Check if the provided path is correct." \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-6 ))"
		
		return 1
    fi
}

# Checking if the directory's sub-folders paths passed as argument exists, then print its path.
function BU::Main::Directories::GetDirectoryPath()
{
    #**** Parameters ****
    local p_path=$1

    #**** Code ****
    BU::Main::CheckArgs__Directories::GetDirectoryPath "$p_path"

    if [ -d "$p_path" ]; then
        echo -e "$p_path"

		return 0
    else
        BU::Main::Errors::HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Please check if the provided path is correct." \
            "$p_path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO-3 ))"

		return 1
    fi
}

# Getting parent folder's name only (without its full path from the root directory), then printing it.
function BU::Main::Directories::GetParentDirectoryName()
{
    #**** Parameters ****
    local p_path=$1         # Path of the child file or folder.
    local p_iterations=$2   # Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Code ****
    BU::Main::CheckArgs__Directories::GetParentDirectoryName "$p_path" "$p_iterations"

    if ! BU::IsInt "$p_iterations"; then
        BU::EchoWarning "$(BU::DechoHighlight "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1'
    fi

    if [ -z "$p_iterations" ] || [ "$p_iterations" -lt 1 ]; then
        p_iterations='1'
    fi

    for ((i=0; i<p_iterations; i++)); do
        local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
            || {
                BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                    "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; return 1
            }; pwd -P )"

        p_path="$v_parent"
    done

    shopt -s extglob            # enable +(...) glob syntax.
    result=${p_path%%+(/)}      # trim however many trailing slashes exist.
    result=${result##*/}        # remove everything before the last / that still remains.

    echo -e "$result"
}

# Getting parent folder's path from the root directory, then printing it
function BU::Main::Directories::GetParentDirectoryPath()
{
    #**** Parameters ****
    local p_path=$1         # Path of the child file or folder.
    local p_iterations=$2   # Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Code ****
    BU::Main::CheckArgs__Directories::GetParentDirectoryPath "$p_path" "$p_iterations"

    if [ -z "$p_iterations" ] || [ "$p_iterations" -lt 1 ]; then
        p_iterations='1'
    fi

    if [ -d "$p_path" ]; then
        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
                || {
                    BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; return 1
                }; pwd -P )"

            p_path="$v_parent"
        done
        
        shopt -s extglob            # enable +(...) glob syntax.
        result=${p_path%%+(/)}      # trim however many trailing slashes exist.

        echo -e "$result"
    else
        local v_path_str=""
        local v_current_path="$p_path"

        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "$p_path")" > /dev/null 2>&1 \
                || {
                    BU::Main::Errors::HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "$p_path" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$LINENO"; return 1
                }; pwd -P )"
            
            local v_path_cut; v_path_cut="${v_parent##*/}"
            local v_path_str+="$v_path_cut/"

            # Removing the unnecessary folders.
            # WARNING !!!! USE THE "rmdir" COMMAND ONLY !!!!
            # DO NOT USE THE "rm -rf" COMMAND AT ALL, OR FILES AND FOLDERS COULD BE UNINTENTIONNALY ERASED !!!!
            rmdir "$v_current_path"; BU::Main::Errors::HandleErrors "$?" "UNABLE TO ERASE THE $(BU::DechoHighlight "$v_current_path") NEWLY CREATED FOLDER !"
            
            local v_current_path="$v_parent"
        done

        BU::Main::Text::ReverseStringWordsOrder "$v_path_str" '/'
    fi
}

# Check if the script is about to work at the root directory ('/').
function BU::Main::Directories::TriggerRootDirWarning()
{
	#**** Parameters ****
	p_path=$1

	#**** Code ****
	# Checking if the given path points towards the root directory or one of its subfolders
	# TODO : detecting if path points to a root sub-folder (like [ if "$p_path" = "/" ] || [ "$p_path" | cut blablabla ]).
	if [ "$(pwd "$p_path")" = "/" ] || [ "$(BU::Main::Directories::GetParentDirectoryPath "$p_path")" = '/' ]; then
		if [ "$__BU_MAIN_STAT_OPERATE_ROOT" = "forbidden" ]; then
            BU::EchoError "-------------------------------------------------"
			BU::EchoError "WARNING !!!!!! READ THIS MESSAGE CAREFULLY !!!!!!"
			BU::EchoError "-------------------------------------------------"

			BU::EchoError "The script was trying to operate at the root directory (or one of its sub directories) without authorization"
			BU::EchoError "Given path : $(BU::DechoHighlight "$p_path")"
			BU::EchoError "Authorization : $__BU_MAIN_STAT_OPERATE_ROOT"
			BU::Newline

			BU::Main::Errors::ExitError '1'; return 1

		elif [ "$__BU_MAIN_STAT_OPERATE_ROOT" = "restricted" ]; then
            BU::EchoWarning "---------------------------------------------------------------------------"
			BU::EchoWarning "WARNING !!!!!!! DO NOT SKIP THIS MESSAGE BEFORE READING IT CAREFULLY !!!!!!"
            BU::EchoWarning "---------------------------------------------------------------------------"

            BU::EchoWarning "You are about to operate at the root directory or one of its present sub-folders !"
			BU::EchoWarning "Given path : $(BU::DechoHighlight "$p_path")"
			BU::Newline

			# Calling the function that processes the given answer.
			if BU::Main::Case::Read_Directories::TriggerRootDirWarning; then
				return 0
			else
				return 1
			fi
		fi
	fi

	return 0
}

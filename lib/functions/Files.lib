#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT FILES PROCESSING FUNCTIONS

# Separate processing steps displays from the rest of the main script with a line.

# Featured functions and files from the "functions" folder :
#   - DrawLine      -> Headers.lib
#   - HandleErrors  -> Headers.lib
function ProcessingFile
{
    #***** Parameters *****
    function=$1
    
    #***** Variables *****
    char="'"
    
    #***** Code *****
	sleep "$PROJECT_STATUS_SLEEP_LINE"
    DrawLine "$COL_RESET" "$char"
    EchoNewstep "Processing the $(DechoN "$name") file."
    Newline
    
    if "$function"; then
        EchoSuccess "End of processing the $(DechoS "$name") file"
		DrawLine "$COL_RESET" "$char"
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		Newline
    else
        EchoError "End of processing the $(DechoE "$name") file"
		DrawLine "$COL_RESET" "$char"
		sleep "$PROJECT_STATUS_SLEEP_LINE"
		Newline
    fi
}

## OVERWRITING CONTENT

# Overwrite a file

# Featured functions and files from the "functions" folder :
#	- EchoError			-> Echo.lib
#	- EchoNewstep		-> Echo.lib
#	- EchoSuccess		-> Echo.lib
#	- Newline			-> Echo.lib
function OverwriteFile
{
    #***** Parameters *****
    path=$1
    
    #***** Code *****
    EchoNewstep "The $(DechoN "$path") file already exists and is not empty."
	EchoNewstep "Overwriting data from file $(DechoN "$path")"
	Newline

	true > "$path"
	HandleErrors "$?" "${FUNCNAME[0]} : THE CONTENT OF THE $(DechoE "$path") FILE HAD NOT BEEN OVERWRITTEN" "$LINENO" ""
	EchoSuccess "The content of the $(DechoS "$path") file has been successfully overwritten"
	Newline

	return 0
}

# -----------------------------------------------

## FILE CREATION

# File creation function.
# LORS DE SON APPEL, LA SORTIE DE CETTE FONCTION DOIT ÊTRE REDIRIGÉE SOIT VERS LE TERMINAL ET LE FICHIER DE LOGS, SOIT VERS LE FICHIER DE LOGS UNIQUEMENT.

# Featured functions and files from the "functions" folder :
#   - DrawLine          -> Headers.lib
#   - EchoError         -> Echo.lib
#   - EchoNewstep       -> Echo.lib
#   - EchoSuccess       -> Echo.lib
#   - HandleErrors      -> Handles.lib
function Makefile
{
	#***** Paramètres *****
	parent=$1      # Emplacement depuis la racine du dossier parent du fichier à traiter.
	name=$2        # Nom du fichier à traiter (dans son dossier parent).

	#***** Autres variables *****
	path="$parent/$name"	# Chemin du fichier à traiter.

	#***** Code *****
	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "$path" ]; then
        EchoNewstep "Creating the $(DechoN "$name") file in the parent folder $(DechoN "$parent/")."

		touch "$path"
        # Testing if the file has been created by checking the return code of the "touch" command via the "HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a
        # file in a folder where the user is not allowed to create a file without superuser privileges.
        HandleErrors "$?" "${FUNCNAME[0]} : THE $(DechoE "$name") FILE CANNOT BE CREATED IN THE PARENT FOLDER $(DechoE "$parent/")." "" "$lineno"
        EchoSuccess "The $(DechoS "$name") file was successfully created in the $(DechoS "$parent") folder."
        Newline
        
        return 0
	
	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "$path" ] && [ -s "$path" ]; then
        OverwriteFile "$path"
		return 0

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "$path" ] && [ ! -s "$path" ]; then
		EchoSuccess "The $(DechoS "$path/") file already exists in the $(DechoS "$parent/") folder and is empty."
		Newline

		return 0
	fi
}

# Creating the log file to [ répertorier chaque sortie de commande (sortie standard (STDOUT) ou sortie d'erreurs (STDERR)).
function CreateLogFile
{
    #***** Modifying status *****
#     STAT_ERROR="fatal"
#     STAT_LOG="true"
#     STAT_LOG_REDIRECT="log"
#     STAT_TIME_HEADER="0"; STAT_TIME_LINE="0"; STAT_TIME_TXT="0"
#     CheckProjectVarStatus
    
    #***** Code *****
    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Linux distribution.

	# On vérifie si le fichier de logs a bien été créé.
	if [ -f "$PROJECT_LOG_PATH" ]; then
		EchoSuccess "$MSG_CRLOGFILE_SUCCESS"
		Newline

		HeaderBase "$COL_BLUE" "$TXT_HEADER_LINE_CHAR" "$COL_BLUE" "RÉCUPÉRATION DES INFORMATIONS SUR LE SYSTÈME DE L'UTILISATEUR" "0" >> "$FILE_LOG_PATH"	# Au moment de la création du fichier de logs, la variable "$FILE_LOG_PATH" correspond au dossier actuel de l'utilisateur.

		# Récupération des informations sur le système d'exploitation de l'utilisateur contenues dans le fichier "/etc/os-release".
		EchoNewstep "$MSG_CRLOGFILE_GETOSINFOS :"
		Newline
		
		EchoNewstep "Operating system family :"
		CheckSupportedOS && EchoMsg "$OSTYPE"
		Newline
		
		EchoNewstep "Operating system general informations :"
		EchoMsg "$(cat "/etc/os-release")"
		Newline
		
		EchoNewstep "Bash version :"
		EchoMsg "$BASH_VERSION"
		Newline
		

		EchoSuccess "$MSG_CRLOGFILE_GOTOSINFOS."
    else
        # Étant donné que le fichier de logs n'existe pas dans ce cas, il est impossible d'appeler la fonction "HandleErrors" sans que le moindre bug ne se produise (cependant, il ne s'agit pas de bugs importants).
        EchoError "$MSG_CRLOGFILE_FAIL"
        EchoError "$MSG_CRLOGFILE_ADVICE"
        Newline

        EchoError "$MSG_LINENO $lineno."
        Newline

        exit 1
    fi
}

# -----------------------------------------------

## TEXT FILES PARSING

# Getting a specific line from a text file.
function GetLineFromTextFile
{
    #***** Parameters *****
    source=$1           # File to parse
    wanted_line=$2      # Line to get in the file
    
    #***** Variables *****
    i=0     # Line incrementer
    
    #***** Code *****
    cat "$source" | while read -r line; do
        # Incrementing the line incrementer variable's value...
        i=$(( i+1 ))
        
        # ... until it reaches the wanted line.
        if [ "$i" -eq "$wanted_line" ]; then
            # Creating a variable and storing the wanted line's text.
            FILE_GETTXTLINE="$line"
        fi
    done
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS

## (UN)COMPRESSION FUNCTIONS

# 

# Featured functions and files from the "functions" folder :
#   - 
function Compress
{
    #***** Parameters *****
    cmd=$1      # Compression command.
    opts=$2     # Options of the compression command.
    path=$3     # Path to the file/folder to archivate.
    name=$4     # Archive's name (only used into displayed messages).
    
    #***** Code *****
    
    
    return 0
}

# Uncompressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   - HandleErrors      -> Handles.lib
#   - EchoSuccess       -> Echo.lib
#   - Newline           -> Echo.lib
function Uncompress
{
    #***** Paramètres *****
    cmd=$1      # Compression command.
    # TODO : Vérifier si cette procédure est bonne
    opts=$2     # Options of the compression command. (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    path=$3     # Path to the l'archive to uncompress.
    name=$4     # Archive's name (only used into displayed messages).

    #***** Code *****
    # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
    "$cmd $opts $path"
    HandleErrors "$?" "${FUNCNAME[0]} : LA DÉCOMPRESSION DE L'ARCHIVE $(DechoE "$name") A ÉCHOUÉE"
    EchoSuccess "La décompression de l'archive $(DechoS "$name") s'est effectuée avec brio."
    Newline
    
    return 0
}

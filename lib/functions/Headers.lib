#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FUNCTIONS WITHOUT REDIRECTIONS TOWARDS A LOG FILE

## DÉFINITION DES FONCTIONS DE CRÉATION DE HEADERS

# Fonction de création et d'affichage de lignes selon le nombre de colonnes de la zone de texte du terminal.
function DrawLine
{
	#***** Parameters *****
	line_color=$1	# Deuxième paramètre servant à définir la couleur souhaitée du caractère lors de l'appel de la fonction.
	line_char=$2	# Premier paramètre servant à définir le caractère souhaité lors de l'appel de la fonction.

	#***** Code *****
    # Defining the color of the wished character for the whole line before displaying the first character.
    # If the value of the "$line_color" parameter (which stores the text's color encoding) is not empty,
    # then we write the color's encoding into the terminal, which displays the color, and not its encoding in text.
    
    # The color's encoding can be written via the "tput setaf $value" command. The line is empty before the first
    # ASCII characters if the first parameter "$line_color" is passed as an empty string, which means that no
    # "tput setaf $value" command was executed.

    # Since we want to write the characters composing the header line after the color encoding string, we use the options
	# '-n' (no line breaks) and '-e' (interpret backslashes) of the "echo" command to avoid making a line break after the
	# end of the string, to write the next string directly after the line.
    
	# Since all the columns in the row are used, the following characters will be written in the row, as if a line break has been made.
	if test "$line_color" != ""; then
		echo -ne "$line_color"
	fi

    # Displaying the desired character on the whole line. To do this, using a "for" loop, we start reading it from
	# the first column (1), then we read the entire line to the end of the terminal's text box. At each call
	# of the "echo" command, a character is displayed and colored according to the encoding defined and written above.
	
	# La variable 'i' de la boucle "for i in" a été remplacée par un underscore '_' pour que Shellcheck arrête d'envoyer un message d'avertissement
	# ("warning") en raison de la non-déclaration de la variable 'i', bien que cela ne change strictement rien lors de l'exécution du script.
	
	# The 'i' variable in the "for i in" loop has been replaced by an underscore '_' to stop Shellcheck from sending a warning
	# message due to the non-declaration of the variable 'i', although this does not change anything when the script is executed.
	for _ in $(eval echo "{1..$TXT_COLS}"); do
		echo -n "$line_char"
	done

	# Définition (ici, réintialisation) de la couleur des caractères suivant le dernier caractère de la ligne du header
	# en utilisant le même bout de code que la première condition, pour écrire l'encodage de la couleur de base du terminal
	# (il est recommandé d'appeller la commande "tput sgr0" pour réinitialiser la couleur selon les options du profil
	# du terminal). Comme tout encodage de couleur, le texte brut ne sera pas affiché sur le terminal.

    # Definition (here, reinitialization) of the color of the characters following the last character of the header line
	# using the same code snippet as the first condition, to write the terminal's base color encoding (it is recommended 
	# to call the "tput sgr0" command to reset the color according to the profile options of the terminal).
	# As with any color encoding, plain text will not be displayed on the terminal.

	# En pratique, La couleur des caractères suivants est déjà encodée quand ils sont appelés via une des fonctions d'affichage.
	# Cette réinitialisation de la couleur du texte n'est qu'une mini-sécurité permettant d'éviter d'avoir la couleur de l'invite de
	# commandes encodée avec la couleur des headers si l'exécution du script est interrompue de force avec la combinaison "CTRL + C"
	# ou mise en pause avec la combinaison "CTRL + Z", par exemple.
	if test "$line_color" != ""; then
        echo -ne "$COL_RESET"
	fi

	# Étant donné que l'on a utilisé l'option '-n' de la commande "echo", on effectue un saut de ligne pour éviter d'avoir à le répéter après chaque appel de la commande pour laisser un espace vide entre la ligne et le prochain caractère.
	echo

	return
}

# Fonction de création de base d'un header (Couleur et caractère de ligne, couleur et chaîne de caractères).
function HeaderBase
{
	#***** Parameters *****
	line_color=$1      # Deuxième paramètre servant à définir la couleur souhaitée du caractère lors de l'appel de la fonction.
	line_char=$2       # Premier paramètre servant à définir le caractère souhaité lors de l'appel de la fonction.
	string_color=$3	   # Définition de la couleur de la chaîne de caractères du header.
	string_txt=$4      # Chaîne de caractères affichée dans chaque header.
	
	# Le problème vient d'ici, c'est parce que la variable "string" d'ici porte le même nom que l'argument de la fonction cible.
	# TODO : vérifier comment outrepasser ceci sans modifier le nom de la variable quand je serai de nouveau connecté.
	
	#***** Variables *****
	HEADERBASE_COLOR_HEADER="$line_color"
	HEADERBASE_COLOR_TEXT="$string_color"
	
	#***** Code *****
	Newline
	
	EchoMsg "$(DrawLine "$line_color" "$line_char")"
	EchoMsg "$string_color##> $string_txt$COL_RESET"
	EchoMsg "$(DrawLine "$line_color" "$line_char")"
	Newline

	sleep "$STAT_TIME_HEADER"

	return
}

# Header display function when changing step.
function HeaderStep { HeaderBase "$(ColorChar "setaf" "$COL_CYAN" "l")" "-" "$(ColorChar "setaf" "$COL_CYAN" "t")" "$1"; }

# Header display function when switching to a new package category during package installation.
function HeaderInstall { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW" "l")" "-" "$(ColorChar "setaf" "$COL_GREEN" "t")" "$1"; }

# -----------------------------------------------

## UNICOLOR HEADERS

# Copy-paste this function to avoid losing time while creating unicolor headers :
# function Header<col> { HeaderBase "$(ColorChar "setaf" "$")" "-" "$(ColorChar "setaf" "$")" "$1"; }

function HeaderBlue { HeaderBase "$(ColorChar "setaf" "$COL_BLUE")" "-" "$(ColorChar "setaf" "$COL_BLUE")" "$1"; }
function HeaderCyan { HeaderBase "$(ColorChar "setaf" "$COL_CYAN")" "-" "$(ColorChar "setaf" "$COL_CYAN")" "$1"; }
function HeaderGreen { HeaderBase "$(ColorChar "setaf" "$COL_GREEN")" "-" "$(ColorChar "setaf" "$COL_GREEN")" "$1"; }
function HeaderRed { HeaderBase "$(ColorChar "setaf" "$COL_RED")" "-" "$(ColorChar "setaf" "$COL_RED")" "$1"; }
function HeaderYellow { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW")" "-" "$(ColorChar "setaf" "$COL_YELLOW")" "$1"; }

# -----------------------------------------------

## MULTICOLOR HEADERS

# Copy-paste this function to avoid losing time while creating multicolor headers :
# function Header<col1><col2> { HeaderBase "$(ColorChar "setaf" "$")" "-" "$(ColorChar "setaf" "$")" "$1"; }

# Blue lines, differently colored text.
function HeaderBlueCyan { HeaderBase "$(ColorChar  "$COL_BLUE")" "-" "$(ColorChar "setaf" "$COL_CYAN")" "$1"; }
function HeaderBlueGreen { HeaderBase "$(ColorChar "setaf" "$COL_BLUE")" "-" "$(ColorChar "setaf" "$COL_GREEN")" "$1"; }
function HeaderBlueRed { HeaderBase "$(ColorChar "setaf" "$COL_BLUE")" "-" "$(ColorChar "setaf" "$COL_RED")" "$1"; }
function HeaderBlueYellow { HeaderBase "$(ColorChar "setaf" "$COL_BLUE")" "-" "$(ColorChar "setaf" "$COL_YELLOW")" "$1"; }

# Cyan lines, differently colored text.
function HeaderCyanBlue { HeaderBase "$(ColorChar "setaf" "$COL_CYAN")" "-" "$(ColorChar "setaf" "$COL_BLUE")" "$1"; }
function HeaderCyanGreen { HeaderBase "$(ColorChar "setaf" "$COL_CYAN")" "-" "$(ColorChar "setaf" "$COL_GREEN")" "$1"; }
function HeaderCyanRed { HeaderBase "$(ColorChar "setaf" "$COL_CYAN")" "-" "$(ColorChar "setaf" "$COL_RED")" "$1"; }
function HeaderCyanYellow { HeaderBase "$(ColorChar "setaf" "$COL_CYAN")" "-" "$(ColorChar "setaf" "$COL_YELLOW")" "$1"; }

# Green lines, differently colored text.
function HeaderGreenBlue { HeaderBase "$(ColorChar "setaf" "$COL_GREEN")" "-" "$(ColorChar "setaf" "$COL_BLUE")" "$1"; }
function HeaderGreenCyan { HeaderBase "$(ColorChar "setaf" "$COL_GREEN")" "-" "$(ColorChar "setaf" "$COL_CYAN")" "$1"; }
function HeaderGreenRed { HeaderBase "$(ColorChar "setaf" "$COL_GREEN")" "-" "$(ColorChar "setaf" "$COL_RED")" "$1"; }
function HeaderGreenYellow { HeaderBase "$(ColorChar "setaf" "$COL_GREEN")" "-" "$(ColorChar "setaf" "$COL_YELLOW")" "$1"; }

# Purple lines, differently colored text
function HeaderPurpleBlue { HeaderBase "$(ColorChar "setaf" "$COL_PURPLE")" "-" "$(ColorChar "setaf" "")" "$1"; }

# Red lines, differently colored text.
function HeaderRedBlue { HeaderBase "$(ColorChar "setaf" "$COL_RED")" "-" "$(ColorChar "setaf" "$COL_BLUE")" "$1"; }
function HeaderRedCyan { HeaderBase "$(ColorChar "setaf" "$COL_RED")" "-" "$(ColorChar "setaf" "$COL_CYAN")" "$1"; }
function HeaderRedGreen { HeaderBase "$(ColorChar "setaf" "$COL_RED")" "-" "$(ColorChar "setaf" "$COL_GREEN")" "$1"; }
function HeaderRedYellow { HeaderBase "$(ColorChar "setaf" "$COL_RED")" "-" "$(ColorChar "setaf" "$COL_YELLOW")" "$1"; }

# Yellow lines, differently colored text.
function HeaderYellowBlue { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW")" "-" "$(ColorChar "setaf" "$COL_BLUE")" "$1"; }
function HeaderYellowCyan { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW")" "-" "$(ColorChar "setaf" "$COL_CYAN")" "$1"; }
function HeaderYellowGreen { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW")" "-" "$(ColorChar "setaf" "$COL_GREEN")" "$1"; }
function HeaderYellowRed { HeaderBase "$(ColorChar "setaf" "$COL_YELLOW")" "-" "$(ColorChar "setaf" "$COL_RED")" "$1"; }

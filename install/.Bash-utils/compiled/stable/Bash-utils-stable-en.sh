#!/usr/bin/env bash

# ------------------------
## SCRIPT'S INFORMATIONS :

# Name          : en.locale
# Author(s)     : Dimitri OBEID
# Version       : 1.0

# ------------------
# FILE DESCRIPTION :

# English translation messages of the module initialization script.

# ----------------------------



# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

############################### DEFINING THE TRANSLATIONS RESOURCES ###############################

#### DEFINING USEFUL VARIABLES

## REPEATED MESSAGES

# Writing the file name, function name and the line number where an error occured.
__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING="IN « %s », FUNCTION « %s », LINE « %s » --> BASH-UTILS WARNING";

# Writing the file name and the line number where an error occured.
__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING__NO_FNCT="IN « %s », LINE « %s » --> BASH-UTILS WARNING";

# Writing the file name, function name and the line number where a fatal error occured.
__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR="IN « %s », FUNCTION « %s », LINE « %s » --> BASH-UTILS ERROR";

# Writing the file name and the line number where a fatal error occured.
__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT="IN « %s », LINE « %s » --> BASH-UTILS ERROR";

# Writing the beginning of the text of any text that must be printed with the "BU.ModuleInit.PrintLogError()" function.
__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__PLE="%s";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

########################### PROCESSING THE MODULES INITIALIZATION SCRIPT ##########################

#### OUT OF FUNCTION MESSAGES

## MISSING BASH UTILS CONFIGURATIONS ROOT FOLDER

if [ ! -d "${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils" ]; then
    __BU_MODULE_INIT_MSG__OUT_OF_FNCT__MISSING_BASH_UTILS_HOME_FOLDER="The Bash Utils configurations root folder « .Bash-utils » doesn't exists in your home directory";
    __BU_MODULE_INIT_MSG__OUT_OF_FNCT__MISSING_BASH_UTILS_HOME_FOLDER__ADVICE="Please copy this folder in your home directory. You can install it by executing the « install_and_update.sh » file, or you can find it in the « Bash-utils/install » directory";
fi

# -----------------------------------------------*



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SECTION : BEGIN INITIALIZATION PROCESS

## SUB-SECTION : DEFINING GLOBAL VARIABLES

## FUNCTION : "BU.ModuleInit.DefineBashUtilsGlobalVariablesBeforeInitializingTheModules()"

# Note: This variable is also used in the main module configuration files.
__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : Unable to define the path to store in the « %s » global variable\n";

# --------

# -----------------------------------------------

## SUB-SECTION : CALLING THE OTHER FUNCTIONS FOR INITIALIZATION

__BU_MODULE_INIT_MSG__OUT_OF_FNCT__MSG_INITIALIZING_THE_MODULES="INITIALIZING THE MODULES";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SECTION : INITIALIZER RESOURCES - FUNCTIONS

## SUB-SECTION : FUNCTIONS AND RESOURCES NEEDED FOR TRAPPING SIGNALS

## FUNCTION : "BU.ModuleInit.DefineTraps()"
__BU_MODULE_INIT_MSG__DEFINE_TRAPS__EXITING_SCRIPT="Exiting script";

# --------

# -----------------------------------------------

## SUB-SECTION : FUNCTIONS NEEDED FOR THE DISPLAYING OF THE INITIALIZATION MESSAGES

## FUNCTION : "BU.ModuleInit.AskPrintLog()"

__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_LOG_TO_DISPLAY="No logs to display";
__BU_MODULE_INIT_MSG__ASKPRINTLOG__ASK_DISPLAY="Do you want to display the initialization logs (stored in the « __BU_MODULE_INIT_MSG_ARRAY_PERMISSION » array) ? (yes / no)";
__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_ENGLISH="To display the content of the « __BU_MODULE_INIT_MSG_ARRAY_PERMISSION » array, please type « yes » ou « Y » (no case sensibility)";
__BU_MODULE_INIT_MSG__ASKPRINTLOG__ENTER_ANS="Enter your answer : ";
__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_DISPLAY="The initializer script's log file's content will not be displayed on your screen";

# --------

## FUNCTION : "BU.ModuleInit.DisplayInitializedGlobalVarsInfos()"

# Initialization message.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_GLOBAL_VARS="INITIALIZING THE GLOBAL VARIABLES";

# Processus ID.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__SCRIPT_INFO="Initializing the script's informations";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__PID="This global variable stores the PID of the current program";

# Modules manager's paths.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_ROOT_DIR_VARS="Initializing the modules manager's root directory variables";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__ROOT_HOME="This global variable stores the path to the parent directory of each module configuration and initialization directories";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__ROOT="This global variable stores the path to the configuration and initialization directories of each module";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INITIALIZER_PATH="This global variable stores the path of the modules initializer script";

# Initializer script's temporary directory path.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__INIT_TMP_DIR="Initializing the framework's temporary directory";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__TMP_DIR_NAME="This global variable stores the name of the framework's temporary directory";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__TMP_DIR_PATH="This global variable stores the path to the framework's temporary directory";

# Configuration directories paths.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_CONF_DIRS="Initializing the configuration directories paths";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_DIR="This global variable stores the path to the configuration directory of each module";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR="This global variable stores the path of the configuration folder used by the modules initialization script";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_MODULES_DIR="This global variable stores the path of the configuration folder of the currently processed module";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_LANG_DIR="This global variable stores the path of the folder containing the translation files, used by the modules initialization script";

# Initializer script's configuration files.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR__CONFIGURATION_FILES="Initializing the Initializer script's configuration files path";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR__STATUS="This global variable stores the path of the global status variables configuration file";

# Module initializer script's paths.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_MODULE_INIT_DIR="Initializing the modules initializers files directory";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__MODULES_DIR="This global variable stores the path to the initialization files of the current module";

# Library's root directory path.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_VARS_LIB_ROOT_DIR_FILE_PATH="Initializing the variables of the file which contains the library's root folder's path";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_NAME="This global variable stores the name of the file containing the path to the root folder of the library";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR="This global variable stores the name of the parent folder of the file containing the path to the root folder of the library";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PATH="This global variable stores the path of the file containing the library's root folder's path";

# Library's root directory path (with root privileges).
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_VARS_LIB_ROOT_DIR_ROOT_FILE="Initializing the variables of the file which contains the library's root folder's path (installed with the super-user's privileges with the installer file)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_NAME="This global variable stores the name of the file containing the path to the root folder of the library (if this file is owned by the super-user)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR="This global variable stores the name of the parent folder of the file containing the path to the root folder of the library (if this file is owned by the super-user)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PATH="This global variable stores the path of the file containing the library's root folder's path (if this file is owned by the super-user)";

# Miscellaneous variables.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_MISC_VARS="Initializing the miscellaneous variables";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__BU_BASE_IS_TRANSLATED="This global variable stores the state which determines if the base of the Bash Utils framework (main module's library files) is translated or not";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__TRANSLATION_FILE_DELIM="This global variable stores the character that is used as the delimiter for the main module CSV translation file.";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__DATE_LOG="This global variable stores the current date, in order to display it before each log messages";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__USER_LANG="This global variable stores the user's language by keeping only it's ISO 639-1 code";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__BASHX_DEBUG_VALS_ARRAY="This global variable, which is an array, stores the list of all allowed values for the global status variable « \$__BU_MODULE_INIT_STAT_DEBUG_BASHX »";

# --------

## FUNCTION : "BU.ModuleInit.DisplayInitGlobalVarsInfos()"

# List of different messages, used to better measure the space between the text and the colon.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__1="Modl  : %s";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__2="File  : %s";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__3="Func  : %s";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__4="Line  : %s";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__5="Modl  : unknown";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__6="File  : unknown";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__7="Func  : none";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__8="Line  : unknown";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__9="Declared global array : %s";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__A="Declared global variable : %s";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__B="Description :";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__C="Type  : Array";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__D="Type  : %s %s";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__E="Value : The « %s » global variable's value is a command substition";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__F="Value : %s";

# Translation of each type of variables
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__ACHAR="(alphabetic character)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__ASTRING="(alphabetic string)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__BOOL="(boolean variable)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__CMD="(command substitution)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__CHAR="((alphanumeric) character)";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__DIR="(directory)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__DIRPATH="(path to a directory)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FILE="(file)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FILEPATH="(path to a file)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOAT="(floating number)";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOATNEG="(negative floating number)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOATPOS="(positive floating number)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INT="(integer)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INTNEG="(negative integer)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INTPOS="(positive integer)";

__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__PATH="(path to a directory or a file)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__STRING="(string)";

# Known files, functions and line numbers.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__MODL="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__1}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FILE="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__2}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FUNC="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__3}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__LINE="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__4}";

# Unknown files, functions and line numbers.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__MODL_NULL="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__5}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FILE_NULL="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__6}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FUNC_NULL="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__7}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__LINE_NULL="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__8}";

# Variables types checkings.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__NO_VAR_TYPE_GIVEN="No variable type given";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__UNKNOWN_VAR_TYPE_GIVEN="Unknown variable type";

# Array checkings.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__CHECK_IS_ARRAY="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__9}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__CHECK_IS_NOT_ARRAY="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__A}";

# Description.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DESCRIPTION="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__B}";

# Array processer.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_TYPE="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__C}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_VALUE="Value";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_EMPTY="The array is empty";

# Other value processer (not arrays).
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_TYPE="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__D}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_CMD="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__E}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_NOT_CMD="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__F}";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_EMPTY="No value is stored in this global variable";

# Deletion of the values stored in the variables constituting the list of the various messages, used to better measure the space between the text and the colon, in order to free up memory.
unset __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__1 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__2 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__3 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__4 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__5 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__6 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__7 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__8 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__9 \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__A \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__B \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__C \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__D \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__E \
    __BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__F


# These variables define a message to display instead of a module name, if the variable is defined in one of the provided initializer scripts.
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE="Main initializer script";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF="Main (configuration files)";
__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_INIT="Main (module's initializer script)";

# --------

## FUNCTION : "BU.ModuleInit.Msg()"

__BU_MODULE_INIT_MSG__MSG__BAD_PERMISSION_1="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « __BU_MODULE_INIT_MSG_ARRAY_PERMISSION » GLOBAL VARIABLE'S VALUE '%s' IS NOT SUPPORTED\n";
__BU_MODULE_INIT_MSG__MSG__BAD_PERMISSION_2="Please change its value by '--log-display', '--log-no-display', '--log-shut', '--log-shut-display' or an empty value where you (re)defined the value.";

# --------

## FUNCTION : "BU.ModuleInit.MsgAbort()"

__BU_MODULE_INIT_MSG__MSG_ABORT__ABORT="Aborting the module initialization script's execution";

# --------

## FUNCTION : "BU.ModuleInit.MsgAbort()"

__BU_MODULE_INIT_MSG__PRESS_ANY_KEY__PRESS="Press any key to";

# --------

## FUNCTION : "BU.ModuleInit.PrintLog"

# Title.
__BU_MODULE_INIT_MSG__PRINTLOG__INITLOGS="INITIALIZATION LOGS";

# Display initialization log informations.
__BU_MODULE_INIT_MSG__PRINTLOG__HERE="Here are the initialization logs";
__BU_MODULE_INIT_MSG__PRINTLOG__FULL_MODE="Logging mode : full (parameter « --mode-log-full » passed during the call of the module 0 « module »)";
__BU_MODULE_INIT_MSG__PRINTLOG__PARTIAL_MODE="Logging mode : partial (parameter « --mode-log-partial » passed during the call of the module 0 « module »)";

__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_TITLE="DISPLAYING THE INITIALIZATION LOGS WITH THE « less » COMMAND";
__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_ADVICE_IF_NO_LOGS_ARE_DISPLAYED="If nothing is displayed on the screen after a few seconds, please stop the script's execution by pressing CTRL + C";
__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_CALL_PRESS_ANY_KEY_FNCT="display the initialization logs with the « less » command";
__BU_MODULE_INIT_MSG__PRINTLOG__DONT_PRESS_Q="Don't press the « Q » button, or else you will close this file and you will have to execute again the script";

# Cannot create the temporary file.
__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_CANNOT_CREATE_TMP_FILE="Unable to create the temporary file to store the logs";

# Post-display instructions.
__BU_MODULE_INIT_MSG__PRINTLOG__POST_DISPLAY_TEXT="END OF THE INITIALIZATION LOG DISPLAY";

# --------

## FUNCTION : "BU.ModuleInit.PrintLogError"

__BU_MODULE_INIT_MSG__PRINTLOG_ERROR__PRINT_ERROR="[ ERROR ] FILE : %s | LINE : %s | CODE : %s";

# --------

# -----------------------------------------------

## SUB-SECTION : FUNCTIONS NEEDED FOR THE MODULES INITIALIZATION

## FUNCTION : "BU.ModuleInit.CheckPath()"

# Missing file path.
__BU_MODULE_INIT_MSG__CHECKPATH__NO_FILE_PATH="No file path";

# No target specified.
__BU_MODULE_INIT_MSG__CHECKPATH__NO_TARGET_SPECIFICATION="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : NO SPECIFICATION GIVEN ABOUT THE TARGET !!!";
__BU_MODULE_INIT_MSG__CHECKPATH__PLEASE_SPECIFY_TARGET_SPECIFICATION="Please specify if the target is a file or a folder by passing the 'f' (file) or the 'd' (directory) value as second argument when you call the « %s » function.";

# Target specified, but not found.
__BU_MODULE_INIT_MSG__CHECKPATH__DIR_NOT_FOUND="(bad directory path : not found)";
__BU_MODULE_INIT_MSG__CHECKPATH__FILE_NOT_FOUND="(bad file path : not found)";

# Target specified, but the type is unknown.
__BU_MODULE_INIT_MSG__CHECKPATH__UNKNOWN_TARGET="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « p_target » PARAMETER'S CURRENT VALUE IS « %s », NOT THE EXPECTED 'D', 'd', 'F' OR 'f'";

# --------

## FUNCTION : "BU.ModuleInit.FindPath()"

__BU_MODULE_INIT_MSG__FIND_PATH__PATH_NOT_FOUND="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : WARNING : UNABLE TO FIND THIS PATH";
__BU_MODULE_INIT_MSG__FIND_PATH__TOP_LEVEL_FUNCTION="Function where the « %s() » function was called : %s()";

# --------

## FUNCTION : "BU.ModuleInit.GetModuleName()"

__BU_MODULE_INIT_MSG__GET_MODULE_NAME__UNABLE_TO_GET="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : Unable to get the module's name from the parent directory name";

# --------

## FUNCTION : "BU.ModuleInit.ListInstalledModules()"

# Unable to create the temporary directory.
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNABLE_TO_CREATE_TMP_DIR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : Unable to create the initialization logs temporary directory « tmp » in the « %s/ » directory";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNABLE_TO_CREATE_TMP_DIR__ADVICE="If the problem persists, please create this folder manually";

# Listing the installed modules.
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__INSTALLED_MODULES_LIST="INSTALLED MODULES LIST";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__ONE_OR_MORE_MODULES_MISSING="WARNING ! A MODULE OR MORE ARE MISSING IN THE « %s » OR IN THE « %s » FOLDERS";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__MODULES_CONFIGURATION_FOLDER_LIST="INSTALLED MODULES CONFIGURATION FOLDERS LIST";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__MODULES_INITIALIZATION_FOLDER_LIST="INSTALLED MODULES INITIALIZATION FOLDERS LIST";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__LISTED_MODULES_DIFFERENCES_BELOW="THE DIFFERENCES BETWEEN THESE TWO FILES ARE LISTED BELOW";

# Missing modules or modules not found.
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNEXISTENT_PATH="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : The « ls -l » command pointed towards an unexistent path";

__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__BOTH_CONF_AND_INIT_FOLDER_ARE_MISSING="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE MODULES CONFIGURATION FOLDER AND THE MODULES INITIALIZATION FOLDER ARE MISSING !";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__CONF_FOLDER_IS_MISSING="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE MODULES CONFIGURATION FOLDER IS MISSING !";
__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__INIT_FOLDER_IS_MISSING="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE MODULES INITIALIZATION FOLDER IS MISSING !";

# --------

## FUNCTION : "BU.ModuleInit.SourcingFailure()"

__BU_MODULE_INIT_MSG__SOURCING_FAILURE__UNABLE_TO_SOURCE="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : UNABLE TO SOURCE THIS « %s » MODULE'S FILE --> %s";

# --------

# -----------------------------------------------

## SUB-SECTION : FUNCTIONS NEEDED FOR THE MODULES PROCESSING

## FUNCTION : "BU.ModuleInit.Usage()"

# List of different messages, used to better measure the space between the text and the colon.
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_1="--log-display            : display the initialization messages on the screen as they are logged in the « __BU_MODULE_INIT_MSG_ARRAY » array";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_2="--log-no-display         : don't display the initialization messages on the screen, but log them in the « __BU_MODULE_INIT_MSG_ARRAY » array";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_3="--log-shut               : don't display the initialization messages on the screen OR log them in the « __BU_MODULE_INIT_MSG_ARRAY » array";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_4="--log-shut-display       : display the initialization messages on the screen without logging them in the « __BU_MODULE_INIT_MSG_ARRAY » array";

__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_1="--mode-log-full          : display on the screen and / or log in the « __BU_MODULE_INIT_MSG_ARRAY » array EVERY informations about the initialization process";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_2="--mode-log-partial       : display on the screen and / or log in the « __BU_MODULE_INIT_MSG_ARRAY » array the essential informations only";

__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________DEBUG="--stat-debug=false            OR --stat-debug=true";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS____DEBUG_BASHX="--stat-debug-bashx=category   OR--stat-debug-bashx=file   OR --stat-debug-bashx=function  OR --stat-debug-bashx=sub-category";

# Display of the values supported by the "module" option.
__BU_MODULE_INIT_MSG__USAGE__SUPVALS="The supported values are :";

# Display of the supported values for the log redirection parameter.
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG="WARNING : the three following parameters are incompatible with each other, they will overwrite each other :";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_DISPLAY="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_1}";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_NO_DISPLAY="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_2}";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_SHUT="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_3}";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_SHUT_DISPLAY="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_4}";

# Display of the supported values for the logging parameter.
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG="WARNING : the two following parameters are incompatible with each other, they will overwrite each other :";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG_FULL="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_1}";
__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG_PARTIAL="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_2}";

# Global status variables.
__BU_MODULE_INIT_MSG__USAGE__DEBUG_VALUES_LIST="GLOBAL STATUS VARIABLES - DEBUG VALUES :";
__BU_MODULE_INIT_MSG__USAGE__DEBUG="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________DEBUG}";
__BU_MODULE_INIT_MSG__USAGE__DEBUG_BASHX="${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS____DEBUG_BASHX}";

# Deletion of the values stored in the variables constituting the list of the various messages, used to better measure the space between the text and the colon, in order to free up memory.
unset   __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_1 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_2 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_3 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________LOG_4 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_1 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_____LOG_2 \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS__________DEBUG \
        __BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS____DEBUG_BASHX;

# --------

## FUNCTION : "BU.ModuleInit.ProcessFirstModuleParameters.LogPermissionWarningOptimize()"

# Same value for the "--log-*" option was passed twice or more as argument when calling the "BashUtils_InitModules" function.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__SAME_MSG_ARRAY_PERM_PASSED_TWICE="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : you already passed the « %s » value as « module » value's argument for the « __BU_MODULE_INIT_MSG_ARRAY_PERMISSION » global variable when calling the « BashUtils_InitModules » function"

# Different values for the "--log-*" option were simultaneously passed as arguments when calling the "BashUtils_InitModules" function.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED__ADVICE_1="the « module » value's parameters '--log-display' 'log-no-display', '--log-shut' and '--log-shut-display' are incompatible with each other";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED__ADVICE_2="Please choose only one of these parameter values";

__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_EXTRA_INFO="The new value will be assignated to the « __BU_MODULE_INIT_MSG_ARRAY_PERMISSION » global variable";

__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_CURRENT_VAL="Current value stored in the permission variable : %s";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_NEW_VAL="New value : %s";

# --------

## FONCTION : "BU.ModuleInit.ProcessFirstModuleParameters.ProcessBadStatusOptionValues()"

__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__PBSOV__MSG="Warning : the supported values for the « %s » option are : %s";

# --------

## FUNCTION : "BU.ModuleInit.ProcessFirstModuleParameters()"

# No arguments were given to the "module" value if this value was called as argument 1 during the call of the "BashUtils_InitModules" function.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_NO_OPTS="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « module » VALUE WAS PASSED WITHOUT ARGUMENT(S)";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_NO_OPTS__ADVICE="Please pass at least a valid argument between the double quotes where you pass the « module » value";

# -------------------------------------------
# The arguments checking loop is running now.

# Processing each status global variable's value description : writing redundant sentences.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT_VAL_IS_BOOL="This Bash Utils framework status global variable stores a boolean value, which is used to";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT_VAL_IS_STRING="This Bash Utils framework status global variable stores a string, which is used to";

# Processing each main module's status global variable's value description.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG__ARG_HAS_AWAITED_VAL="${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT_VAL_IS_BOOL} enable debugging features";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__ARG_HAS_AWAITED_VAL="${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT_VAL_IS_STRING} enable advanced debugging features with the « set -x » command during a debugging procedure";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__ARG_HAS_AWAITED_VAL__VOID="${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__ARG_HAS_AWAITED_VAL}. As the value « void » has been passed, these features are disabled";

# If the value of the argument "--stat-debug" is not equal to "true".
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__STAT_DEBUG_ARG_NOT_TRUE="NOTE : The « __BU_MODULE_INIT_STAT_DEBUG » status global variable's value must be set to « true » in order to use this advanced debugging functionnality";

# If the "--stat-*" argument is not a supported value.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__STAT_IS_NOT_SUPPORTED="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : « %s » IS NOT A SUPPORTED STATUS ARGUMENT BY THE « module » PARAMETER";

# --------------------------------------------------------
# End of the execution of the arguments verification loop.

# One or more arguments were given to the "BashUtils_InitModules" function as "module" parameter's value(s) : unsupported "--log-*" option passed.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_LOG_OPT_UNSUPPORTED_VAL="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « module » VALUE'S LOG PERMISSION OPTION « %s » IS NOT SUPPORTED";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_LOG_OPT_UNSUPPORTED_VAL__ADVICE="Please modify or remove this value, called at the index « %s » of the « module » parameter";

# One or more arguments were given to the "BashUtils_InitModules" function as "module" parameter's value(s) : unsupported "--mode-log-*" option passed.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_MODE_LOG_OPT_UNSUPPORTED_VAL="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « module » PARAMETER'S LOG MODE MODE OPTION « %s » IS NOT SUPPORTED";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_MODE_LOG_OPT_UNSUPPORTED_VAL__ADVICE="Please modify or remove this value, called at the index « %s » of the « module » parameter";

# One or more arguments were given to the "BashUtils_InitModules" function as "module" parameter's value(s) : unsupported general option passed.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_GEN_OPT_UNSUPPORTED_VAL="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « module » PARAMETER'S GENERAL OPTION « %s » IS NOT SUPPORTED";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_GEN_OPT_UNSUPPORTED_VAL__ADVICE="Please modify or remove this value, called at the index « %s » of the « module » parameter";

# Sourcing the initializer script's "Status.conf" configuration file.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE__SOURCE_STATUS_CONF_FILE__ERROR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR} : UNABLE TO SOURCE THE « %s » FILE";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE__SOURCE_STATUS_CONF_FILE__SUCCESS="The « %s » file was successfully sourced";

# "module" parameter passed in argument, during the call of the « BashUtils_InitModules » function, but the main module is missing.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_MAIN_MODULE_MISSING="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE MAIN MODULE WAS NOT PASSED AFTER THE « MODULE » PARAMETER DURING THE CALL OF THE « BashUtils_InitModules » FUNCTION";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_MAIN_MODULE_MISSING__ADVICE="Please do so by setting the « %s » module's argument (with or without its parameters) in second position when you call the « %s » function in your script";

# "module" parameter passed in argument AFTER the call of the main module, during the call of the « BashUtils_InitModules » function.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_AFTER_MAIN_MODULE="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE MAIN MODULE WAS PASSED AS FIRST ARGUMENT, BUT BEFORE THE « module -- » PARAMETER DURING THE CALL OF THE « BashUtils_InitModules » FUNCTION";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_AFTER_MAIN_MODULE__ADVICE="Please reverse this order, call the « module » with its arguments BEFORE the main module";

# No "module" parameter passed in argument, nor main module, during the call of the « BashUtils_InitModules » function.
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_AND_MAIN_PARAMS_MISSING="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : NO « MODULE » PARAMETER AND NO « MAIN » MODULE PASSED AS FIRST, THEN SECOND ARGUMENTS DURING THE CALL OF THE « BashUtils_InitModules » FUNCTION";
__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_AND_MAIN_PARAMS_MISSING__ADVICE="Please do so by modifying the main module's argument position in your script, and optionally adding the « module » parameter with the needed mandatory arguments";

# --------

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SECTION : SOURCING THE MODULES

## SUB-SECTION : INCLUSION OF LIBRARY FILES ACCORDING TO THE INCLUDED MODULE

## FUNCTION : "BashUtils_InitModules()"

# First checkings.
__BU_MODULE_INIT_MSG__BU_IM__IS_ALREADY_CALLED="You have already called the %s function in your script";
__BU_MODULE_INIT_MSG__BU_IM__MUST_PASS_A_MODULE_NAME="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING__NO_FNCT} : YOU MUST PASS A MODULE NAME WHEN YOU CALL THE « %s » MODULES INITIALIZATION FUNCTION";

# Listing the included modules.
__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG="INTIALIZING THESE MODULES :";
__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG__LOOP_ADD_ARRAY_INDEX__IS_MODULE_PARAM="Module %s : %s       <-- Arguments passed to configure the initialization process";
__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG__LOOP_ADD_ARRAY_INDEX__IS_NOT_MODULE_PARAM="Module %s : %s";

# -----------------------------
# The main loop is running now.

# Definition of the information about the global variables that are defined in the "BashUtils_InitModules" function.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__CONF_PATH__DIGVI="This global variable stores the path of the currently processed module's configurations directory (current : %s | path : %s)";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INIT_PATH__DIGVI="This global variable stores the path of the currently processed module's initialization directory (current : %s | path : %s";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__NAME_WITH_ARGS="This global variable stores the current value passed as argument when calling the « %s » function (current index : %s | value : %s)";

# Inclusion of the configuration files of the module being processed : configuration directory not found.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__DIR_NOT_FOUND="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « %s » MODULE IS NOT INSTALLED, DOESN'T EXISTS, OR THE « ls » COMMAND HAD POINTED ELSEWHERE, TOWARDS AN UNEXISTENT « config » DIRECTORY !!!";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__DIR_NOT_FOUND__ADVICE="Install this module, or check if the module's configuration files exist in this folder --> ";

# Inclusion of the configuration files of the module being processed : configuration directory found.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__SOURCE_MSG="Sourcing the « %s » module's main configuration file";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__MODULE_CONF_FILE_NOT_FOUND="The « %s » module's configuration file was not found in its directory (%s)";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__MODULE_CONF_FILE_IS_EMPTY="The « %s » module's configuration file « %s/%s » is empty";

# Inclusion of the initialization files of the module being processed : initialization directory not found.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND__CALL_PLE="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__PLE} : The « %s » module's initialization files directory does not exists";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : THE « %s » MODULE IS NOT INSTALLED, DOESN'T EXISTS, OR THE « ls » COMMAND HAD POINTED ELSEWHERE, TOWARDS AN UNEXISTENT « modules » DIRECTORY !!!";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND__ADVICE="Install this module, or check if the module's initialization files exist in this folder --> ";

# Inclusion of the initialization files of the module being processed : initialization directory found.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__SOURCE="Sourcing the « %s » module's main initialization file";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__MODULE_INIT_FILE_NOT_FOUND="The « %s » module's initialization file was not found in its directory (%s)";
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__MODULE_INIT_FILE_IS_EMPTY="« %s » module's initializer file « %s/%s » is empty";

# End of the current module's initialization.
__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__END_OF_MODULE_INIT="END OF THE %s MODULE INITIALIZATION !";

# ---------------------------------
# End of the main loop's execution.

# End of the framework's initialization process.
__BU_MODULE_INIT_MSG__BU_IM__END_OF_FRAMEWORK_INIT="END OF THE FRAMEWORK INITIALIZATION PROCESS ! BEGINNING PROCESSING THE %s PROJECT'S MAIN SCRIPT %s !";

# --------

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

########################## SOURCING THE MAIN MODULE'S CONFIGURATION FILES #########################

#### INITIALIZING THE MAIN MODULE - INCLUDING THE CONFIGURATION FILES

## FILE : "Colors.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintRawColorCodeVarsName_FNCT_A="This global variable stores the raw ANSI color code for the color this action : %s";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintRawColorCodeVarsName_FNCT_C="This global variable stores the raw ANSI color code for this color : %s";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintVariableNameFailedToInitialize_FNCT_A="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : The « %s » action color global variable cannot be initialized because of a problem happening during the call of the associated command substitution";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintVariableNameFailedToInitialize_FNCT_C="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : The « %s » color global variable cannot be initialized because of a problem happening during the call of the associated command substitution";

# Definition of the global variables containing the names of the colors.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_AQUA='aqua blue';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLACK='black';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLUE='blue';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_CYAN='cyan blue';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_FUCHSIA='fuchsia';

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GRAY='gray';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GREEN='green';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_LIME='lime green';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_MAROON='maroon';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_NAVY='navy blue';

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_OLIVE='olive green';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_ORANGE='orange';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PINK='pink';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PURPLE='purple';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_RED='red';

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SALMON='salmon';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SILVER='silver gray';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TAN='brown tan';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TEAL='teal';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TURQUOISE='turquoise';

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_VIOLET='violet';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_WHITE='white';
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_YELLOW='yellow';


__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_CMD="command names";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_ERROR="error messages";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_FUNCTION="function names";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_HIGHLIGHT="text highlighting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_NEWSTEP="new step messages";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_PATH="paths highlighting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_SUCCESS="success messages";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_VAR="variables names highlighting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_WARNING="warning messages";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_RESET="This command substitution executes the « tput sgr0 » command to reset the text color";

# --------

## FILE : "ColorsBG.conf"
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_BG__PrintColorVarNameCmdSub_FNCT_A="This command substitution executes the « BU.Main.TextFormat.SetBGColor() » function in order to color the text's background with the defined « %s » action color code";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_BG__PrintColorVarNameCmdSub_FNCT_C="This command substitution executes the « BU.Main.TextFormat.SetBGColor() » function in order to color the text's background with the defined « %s » color code";

# --------

## FILE : "ColorsText.conf"
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_TEXT__PrintColorVarNameCmdSub_FNCT_A="This command substitution executes the « BU.Main.TextFormat.SetTextColor() » function in order to color the text with the defined « %s » action color code";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_TEXT__PrintColorVarNameCmdSub_FNCT_C="This command substitution executes the « BU.Main.TextFormat.SetTextColor() » function in order to color the text with the defined « %s » color code";

# --------

## FILE : "Exit.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__PrintReturnValue_FNCT="This global variable stores the return value of the last command in this situation : « %s »";

# Definition of the global variables.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NOT_PERMITTED__VAR_DESC="the operation was not permitted";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__DIR_FILE_NOT_FOUND__VAR_DESC="the target file or folder was not found";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__PERMISSION_DENIED__VAR_DESC="you don't have the permission to perform this action";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILE_EXISTS__VAR_DESC="the target file already exists";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NOT_DIR__VAR_DESC="the target is not a directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__IS_DIR__VAR_DESC="the target is a directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__INVALID_ARGUMENT__VAR_DESC="bad argument provided";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILE_TOO_LARGE__VAR_DESC="the file is too large";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NO_SPACE_LEFT__VAR_DESC="no space left on the target hard drive's partition";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__RO_FS__VAR_DESC="read-only file system";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILENAME_TOO_LONG_VAR_DESC="the name of the file to create is too long";

# --------

## FILE : "Filesystem.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__PrintFSLengthDescription_FNCT="This global variable stores the maximum length in bytes of a file name according to a file system. This length is associated with the « %s » file system";

# Definition of the global variables.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__UNSUPPORTED_FILESYSTEM="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING__NO_FNCT} : Unsupported file system (found « %s »)\n\nGeneration of basic informations, but several advanced functionalities of this framework may be prone to bugs";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__SET_GENERAL_SPECIFICATION__FILENAME_LENGTH="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING__NO_FNCT} : This global variable stores the maximum length in bytes of a file name. This length is not associated with any file system, but rather according to general specification";

# --------

# FILE : "Module.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__BIN="This global variable stores the path of the framework's binaries directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__CONFIG="This global variable stores the path of the « main » module's configurations directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__DOCS="This global variable stores the path of the whole framework's documentation directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__LIB="This global variable stores the path of the framework « lib » library directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__RES="This global variable stores the path of the framework « res » resources directory";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS="This global variable stores the path of the development tools root directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_BIN="This global variable stores the path of the development tools binaries folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_DSK="This global variable stores the path of the development tools desktop files folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_IMG="This global variable stores the path of the development tools icons folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_SRC="This global variable stores the path of the development tools source files folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_TRA="This global variable stores the path of the development tools translation files folder";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_FUNCTS_DIR_PATH="This global variable stores the path of the « functions » folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_MOD_DIR_PATH="This global variable stores the path of the « main » module's functions folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_LANG_DIR_PATH="This global variable stores the path of the modules « lib » translation files directory";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__MainModuleConfigFolderContentOptimize__FNCT="This global variable stores the path of the « %s » configuration file of the « main » module";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__MainModuleInitializerPath__FNCT__FILE_INITIALIZER_PATH="This global variable stores the path to the initializer script of the « main » module";

# Definition of the global variables.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH="This global variable stores the path to the file which contains the path to the Bash Utils framework's library root directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH__ROOT="This global variable stores the path to the file which contains the path to the Bash Utils framework's library root directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH="This global variable stores the path to Bash Utils framework's library root directory, which is written in the « %s » file";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__ERR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : THE PATH TO THE BASH UTILS FRAMEWORK'S LIBRARY ROOT FOLDER WRITTEN IN THE « %s » FILE WAS NOT FOUND IN YOUR HARD DRIVE";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__INFO="Path currently written in this file : %s";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__ADVICE="Please check the path recorded in this file for typos if you typed it by yourself, or verify where you've stored this root folder";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__EMPTY_ROOT_DIR_PATH__ERR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING__NO_FNCT} : THE BASH UTILS FRAMEWORK'S LIBRARY ROOT FOLDER'S PATH STORAGE FILE « %s » EXISTS, BUT IS EMPTY";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__EMPTY_ROOT_DIR_PATH__ADVICE="Please write the path to Bash Utils framework's library root directory inside this file, manually or with the installer file";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ERR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : YOU DON'T HAVE THE RIGHT TO READ THE BASH UTILS FRAMEWORK'S LIBRARY ROOT FOLDER'S PATH STORAGE FILE « %s »";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__INFO="It means that you have created this file with the super-user privileges, by hand or with the installation script (in this case, something may have be wrong)";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ADVICE_1="Please execute this script with root user privilieges, or change the ownership of the « %s » file, or create a new file, and rename the file to find in the « %s » file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ADVICE_2="If you opt for the last solution, please find the line containing the string « __BU_MODULES_UTILS_LIB_ROOT_DIR_FILE_NAME= » in the « DEFINING GLOBAL VARIABLES » subsection";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__ABSENT_ROOT_DIR_PATH__ERR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : THE BASH UTILS FRAMEWORK'S LIBRARY ROOT FOLDER'S PATH STORAGE FILE « %s » DOESN'T EXISTS";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__ABSENT_ROOT_DIR_PATH__ADVICE="Please create this file and write the path to Bash Utils framework's library root directory inside this file, manually or with the installer file";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY="This array stores the path of each « .lib » library file in the functions folder of the « Hardware » module TO SOURCE (NOT SOURCED YET)";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY="This array (MUST BE EMPTY BY DEFAULT) stores the global status variables values modified by the user during the inclusion of arguments for the « main » module's initialization";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY="This array (MUST BE EMPTY BY DEFAULT) stores the path of each SOURCED « main » module's library files";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY="This array (MUST BE EMPTY BY DEFAULT) stores the path of each SOURCED « main » module's configuration files";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY="This array stores the path of each « main » module's configuration files TO SOURCE (NOT SOURCED YET)";

# --------

## FILE : "Project.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__GetProjectFilePath__UNABLE_TO_GET_THE_PARENT_DIR="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR} : UNABLE TO GET THE PARENT DIRECTORY OF THE CURRENT PROJECT'S MAIN SCRIPT";

# Definition of the global variables.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_FILE_NAME__VAR="This global variable stores the name of the project's main script (the one executed right now), with its file extension";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_NAME__VAR="This global variable stores the name of the project's main script (the one executed right now), without its file extension";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME="This global variable stores the name of the project's temporary folder's parent directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH="This global variable stores the path to the project's temporary folder's parent directory";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PATH__VAR="This global variable stores the path to the project's temporary folder";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PATH__ROOT_VAR="This global variable stores the path to the project's temporary folder (with super-user's privileges)";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_FILE_PATH__VAR="This global variable stores the path to the main script of the current project";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_PARENT="This global variable stores the path to the aliases configurations file's parent directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_NAME="This global variable stores the name of the aliases configurations file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_PATH="This global variable stores the path to the aliases configurations file";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT="This global variable stores the path to the parent directory of the file saving the ANSI color code of the background color before a color change";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME="This global variable stores the name of the file saving the ANSI code of the background color before a color change";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH="This global variable stores the path to the file saving the ANSI code of the background color before a color change";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT="This global variable stores the path to the parent directory of the file containing the raw ANSI color code of the current background coloring retrieved by the « BU.Main.TextFormat.GetBGColorFromCMD() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME="This global variable stores the name of the file containing the raw ANSI color code of the current background coloring retrieved by the « BU.Main.TextFormat.GetBGColorFromCMD() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH="This global variable stores the path to the file containing the raw ANSI color code of the current background coloring retrieved by the « BU.Main.TextFormat.GetBGColorFromCMD() » function";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT="This global variable stores the path to the parent directory of the file saving the ANSI color code of the text color preceding a color change";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME="This global variable stores the name of the file saving the ANSI code of the text color preceding a color change";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH="This global variable stores the path to the file saving the ANSI code of the text color preceding a color change";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT="This global variable stores the path to the parent directory of the file containing the raw ANSI color code of the current text coloring retrieved by the « BU.Main.TextFormat.GetTextColorFromCMD() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME="This global variable stores the name of the file containing the raw ANSI color code of the current text coloring retrieved by the « BU.Main.TextFormat.GetTextColorFromCMD() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH="This global variable stores the path to the file containing the raw ANSI color code of the current text coloring retrieved by the « BU.Main.TextFormat.GetTextColorFromCMD() » function";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT="This global variable stores the path to the parent directory of the log file of the « BU.Main.Echo.__EchoVoid() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME="This global variable stores the name of the log file of the « BU.Main.Echo.__EchoVoid() » function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH="This global variable stores the path to the log file of the « BU.Main.Echo.__EchoVoid() » function";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_PARENT="This global variable stores the path to the parent directory of the folder containing the project's log file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_NAME="This global variable stores the name of the parent directory of the folder containing the project's log file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_PATH="This global variable stores the path to the parent directory of the folder containing the project's log file";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_PARENT="This global variable stores the path to the project's log file's parent directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_NAME="This global variable stores the name of the project's log file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_PATH="This global variable stores the path to the project's log path";

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT="This global variable stores the path to the CSV translations parser script's parent directory";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME="This global variable stores the name of the CSV translations parser script";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH="This global variable stores the path to the CSV translations parser script";

# --------

## FILE : "Text.conf"

# Definition of the functions necessary for the direct inclusion of the file (commands are executed directly at inclusion, and not later, with the code written in the function loaded in memory).
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintTextModeCmdSubs__FNCT="This command substitution executes the « tput %s » OR the « stty size » commands in order to get the total number of « %s » on the current text mode";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintFormatCmdSubs__FNCT="This command substitution executes the « BU.Main.TextFormat.SetTextFormat() » function in order to format the text with the defined « %s » text formatting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintResetCmdSubs__FNCT="This command substitution executes the « BU.Main.TextFormat.SetTextFormat() » function in order to reset the text from the « %s » text formatting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintAllResetCmdSubs__FNCT="This command substitution executes the « BU.Main.TextFormat.SetTextFormat() » function in order to reset the text from every text formatting";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintVariableNameFailedToInitialize__FNCT="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_ERROR__NO_FNCT} : The « %s » text global variable cannot be initialized because of a problem happening during the call of the associated command substitution";

# Definition of the global variables.
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_CHAR_HEADER_LINE__VAR="This global variable stores the default character that composes each lines drawn by the %s function";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_PRINT_TAB__VAR="This global variable stores the string which better showcases a string";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_STORE_LINE__VAR="This global variable stores a string extracted from a line in a file";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_STORE_ECHO_TRUE_MESSAGES_ARRAY__ARRAY="This array stores each error message displayed when the %s global status variable's value is set to %s";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_ERR_SUBSTR_DELIM__VAR="This global variable stores a string which serves as a delimiter for separating a string into substrings";

# --------

## FILE : "Time.conf"

__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TIME__BU_MAIN_TIME_DATE="This command substitution executes the « date » command, and passes arguments in order to print the date at the « YYYY-MM-DD hh-mm-ss » format";
__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TIME__BU_MAIN_TIME_DATE_DISPLAY="This command substitution prints the output of the « \$__BU_MAIN_TIME_DATE » command substitution with more decoration, in order to display the date in an easily and colored readable log format : [ YYYY-MM-DD hh-mm-ss ]";

# --------

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################## PROCESSING THE MAIN MODULE'S INITIALIZATION SCRIPT #######################

#### INITIALIZING THE MAIN MODULE - PROCESSING THE INITIALIZER FILE

## STEP ONE : DEFINING THE NEEDED RESOURCES

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_ONE__SOURCE_LIBRARY="Successfully sourced this library file : %s";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_ONE__SOURCE_CONFIG="Successfully sourced this configuration file : %s":

# -----------------------------------------------

## STEP TWO : MINIMAL INCLUSION OF FILES IN ORDER TO USE THEIR RESOURCES DURING THE TRANSLATION PART

# No text to display in this section for now.

# -----------------------------------------------

## STEP THREE : PROCESSING THE MAIN MODULE'S PARAMETERS

# List of accepted values.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE__SUPPORTED_ARGS="The supported arguments for the main module are :":

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______DECHO="--stat-decho=authorize         OR --stat-decho=forbid          OR --stat-decho=resctrict";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE________ECHO="--stat-echo=false              OR --stat-echo=true";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______ERROR="--stat-error=fatal             OR --stat-error=void			OR --stat-error=warning";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_________LOG="--stat-log=false               OR --stat-log=true";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______LOG_R="--stat-log-r=log               OR --stat-log-r=tee             OR --stat-log-r=void";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_____OP_ROOT="--stat-op-root=authorized      OR --stat-op-root=forbidden     OR --stat-op-root=restricted";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_H="--stat-time-header=float,      where « float » is a floating point number";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_N="--stat-time-newline=float,     where « float » is a floating point number";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_T="--stat-time-txt=float,         where « float » is a floating point number";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_____TXT_FMT="--stat-txt-fmt=false           OR --stat-txt-fmt=true";

# An incorrect value was given to the "--stat-*" option.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__BAD_VALUE_GIVEN="${__BU_MODULE_INIT_MSG__CURRENT_LOCALE_FILE__BU_WARNING} : the '--stat-*' option's « %s » value is incorrect.";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__BAD_VALUE_GIVEN__ADVICE="Try only one of these accepted values for this global status variable : ";

# Processing each main module's status global variable's value description : writing redundant sentences.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_BOOL="This main module's status global variable stores a boolean value, which is used to";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_FLOAT="This main module's status global variable stores a floatig number, which is used to";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING="This main module's status global variable stores a string, which is used to";

# Processing each main module's status global variable's value description.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_DECHO="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING} determine the level of text decoration";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_ECHO="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_BOOL} avoid causing an infinite loop while calling a text writing function in case these functions must be called to provide the same features than usual";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_ERROR="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING} determine if the script's execution must be stopped in case of an error";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_LOG="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_BOOL} determine if any text must be redirected towards a log file or not";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_LOG_R="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING} determine if the text must be redirected to the log file only, to the screen only, or both at the same time";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_OP_ROOT="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING} determine if the script can edit files or folders located directly in the system's root folder, or in one of it's direct sub-folders";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_H="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_FLOAT} determine the script's pause time after displaying a header";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_N="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_FLOAT} determine the script's pause time after displaying a line break";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_T="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_FLOAT} determine the script's pause time after displaying any text";

__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TXT_FMT="${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_BOOL} determine if the script has the permission to display any text decoration";

# Unsetting the redundant sentences.
unset __BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_BOOL \
    __BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_FLOAT \
    __BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR__IS_STAT_VAL_STRING

# -----------------------------------------------

## STEP FOUR : INCLUSION OF THE REST OF THE LIBRARY AND CONFIGURATION FILES

# No text to display in this section for now.

# -----------------------------------------------

## STEP FIVE : PROCESSING PROJECT'S RESOURCES

# Creation of the text color code file.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__ERROR="UNABLE TO CREATE THE %s TEXT COLOR CODE FILE IN THE %s DIRECTORY";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__SUCCESS="The %s text color code file was successfully created in the %s directory";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__EXISTS="The file containing the current foreground color code already exists : %s";

# Creation of the background color code file.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__ERROR="Unable to create the %s background color file in the %s directory";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__SUCCESS="The %s background color code file was successfully created in the %s directory";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__EXISTS="The file containing the current background color code already exists : %s";

# Creation of the project's log file.
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__ERROR="UNABLE TO CREATE THE %s LOG FILE FOR THE %s PROJECT";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__SUCCESS="The %s log file was successfully created in the %s directory";
__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__EXISTS="The %s log file already exists in the %s directory";
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034


# Modules debug variable

# This variable only accepts "true", "false" or an empty string as values.
# DO NOT uncomment this variable here, its value will be (re)assigned to false, and will mess with the "BU.Main.Echo.Debug()" function from the main module.
# Default value : "false" (if not processed in the "Bash-utils-init.sh" file)

# shellcheck disable=SC2034
# __BU_MODULE_INIT_STAT_DEBUG="false";


# Advanced project's debug variable

# This variable accepts "category", "file", "function", "module", "sub-category" "subcategory" (both last values do the same thing) or nothing as values,
# if the value of the "${__BU_MODULE_INIT_STAT_DEBUG}" status global variable is equal to 'true'.
# Default value : "file"

if [ "${__BU_MODULE_INIT_STAT_DEBUG}" == 'false' ]; then
    # shellcheck disable=SC2034
    __BU_MODULE_INIT_STAT_DEBUG_BASHX="";

elif [ "${__BU_MODULE_INIT_STAT_DEBUG}" == 'true' ]; then

    # Declare a variable to easily change the location of the parent directory of the status configuration files.
    ____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir="status";

    # ------------------------------------------------------
    # Add or remove any supported values inside these arrays
    # ------------------------------------------------------

    # -------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT
    # -------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == c?(at?(eg?(ory))) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == c?(at?(eg?(orie)))?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'C' ]; then

        # Each accepted value is written under each category name, in each library file.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every categores.

        # Every values are case-insensitive.

        BashXCatConf="${____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir}/BashXCat.conf";

        # If the "" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "${BashXCatConf}" ] && [ -s "${BashXCatConf}" ]; then
            mapfile -t __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT < "${BashXCatConf}";

        # Else, you can manually fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT=();
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXCatConf;
    fi

    # ---------------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY
    # ---------------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == fi?(l?(e))?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'F' ]; then

        # The accepted values are the name of every ".lib" files from the Bash-utils/lib/functions/main/ directory.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every files.

        # Every values are case-insensitive.

        BashXFilesConf="${____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir}/BashXFiles.conf";

        # If the "BashXFiles.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "${BashXFilesConf}" ] && [ -s "${BashXFilesConf}" ]; then
            mapfile -t __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY < "${BashXFilesConf}";

        # Else, you can manually fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY=('Echo.lib');
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXFilesConf;
    fi

    # -------------------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY
    # -------------------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == fun?(c?(t?(ion))?(s)) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == FN?(C?(T))?(S) ]]; then

        # The accepted values are the name of each function you want to debug.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every files.

        # Every values are case-insensitive.

        BashXFNCTConf="${____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir}/BashXFNCT.conf";

        # If the "BashXFNCT.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "${BashXFNCTConf}" ] && [ -s "${BashXFNCTConf}" ]; then
            mapfile -t __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY < "${BashXFNCTConf}";

        # Else, you can manually fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY=("BU.Main.Echo.Newstep");
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXFNCTConf;
    fi

    # -----------------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY
    # -----------------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == m?(od?(ule))?(s) ]]; then

        # The accepted values are the neame of every modules.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every modules.

        # Every values are case-insensitive.

        BashXModulesConf="${____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir}/BashXModules.conf";

        # If the "BashXModules.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "${BashXModulesConf}" ] && [ -s "${BashXModulesConf}" ]; then
            mapfile -t __BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY < "${BashXModulesConf}";

        # Else, you can manually fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY=();
        fi
    fi

    # -----------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT
    # -----------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)c?(at?(eg?(ory))) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)?(c?(at?(eg?(orie)))?(s)) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'S' ]; then
        # Each accepted value is written under each sub-category name, in each library file, and named according to their parent category.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every sub-categories.

        # Every values are case-insensitive.

        BashXSubCatConf="${____v_bu_module_init_stat_debug_bashx_status_conf_files_parent_dir}/BashXSubCat.conf";

        # If the "BashXSubCat.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "${BashXSubCatConf}" ] && [ -s "${BashXSubCatConf}" ]; then
            mapfile -t __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT < "${BashXSubCatConf}";

        # Else, you can manually fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT=();
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXSubCatConf;
    fi
fi
#!/usr/bin/env bash

# ------------------------
## SCRIPT'S INFORMATIONS :

# Name          : Bash-utils-init.sh
# Author(s)     : Dimitri OBEID
# Version       : 3.0

# ------------------
# FILE DESCRIPTION :

# This file contains the main part of the framework initializer script.

# This script declares every global variables, defines some useful functions you may use in the main module,
# and initializes all the modules you need for your scripts, from their configuration files to their initializer file.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC1090

# ------------------------
# NOTES ABOUT SHELLCHECK :

# To display the content of a variable in a translated string, the use of the "$(printf)" command is mandatory in order to interpret each "%s" pattern as the value of a variable.

# This means that the Shellcheck warning code SC2059 will be triggered anyway, since we have no choice but to store the entire translated string in a variable.

# If you add new messages to translate, you must call the "shellcheck disable=SC2059" directive before the line where you call the
# "$(printf)" command to display the translated message, otherwise Shellcheck will display many warnings during the debugging procedure.

# If the message is displayed inside a function, you can write the "shellcheck disable=SC2059" directive on the line above the declaration of the said function.

# You can also write this directive at the beginning of a Bash script, but I would not recommand you to do so, since you may use the "$(printf)" command in another context, without the same purpose.

# --------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it in your main script file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### INITIALIZER RESOURCES - FUNCTIONS

## USEFUL FUNCTIONS

# Use this function to have a better view about a bug location during a "bash -x" debug.
function DbgMsg()
{
    #**** Parameters ****
    local p_code=${1:-1};   # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : 1    - DESC : Exit code.
    local p_sleep=${2:-2};  # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : 2    - DESC : Pause time in seconds.

    #**** Code ****
printf "

-------------------------------------------------
                      DEBUG
-------------------------------------------------

"
    sleep "${p_sleep}";

    if [ "${p_code}" -eq 0 ]; then return 0;
    else
        # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
        exit "${p_code}";
    fi
}

# TODO in both "BU.ModuleInit.IsFrameworkUnlocalizedWrapped()" and "BU.ModuleInit.IsFrameworkLocalizedWrapped()" functions :
#   - Faire en sorte que le code détecte le nom du fichier "Bash-utils.sh" ou "Bash-utils-[a-z][az-]" sourcé, directement depuis le fichier en question quand il est sourcé.

# Stopping the execution of the framework in case an error occurs, after printing an error message.
function BU.ModuleInit.Exit()                           { local p_code=${1:-1}; BU.ModuleInit.IsInScript && exit "${p_code}"; return "${p_code}"; }

# Checking if the framework is being installed thanks to the installation script (TODO).
function BU.ModuleInit.IsFrameworkBeingInstalled()      { if [ "${__BU_MODULE_PRE_INIT__IS_FRAMEWORK_INSTALLED,,}" == 'true' ] || [ "${0,,}" == "./install-framework.sh" ] || [ "${0,,}" == "install-framework.sh" ]; then return 0; else return 1; fi }

# Checking if the whole framework's main code (config, initializer and main module's code) is wrapped in a single unlocalized file (generated by the "res/dev-tools/dev-bin/lib-unite.sh" (or "bin/lib-unite.sh") script).
function BU.ModuleInit.IsFrameworkUnlocalizedWrapped()  { local v_currFile; v_currFile="$(basename "${BASH_SOURCE[2]}")"; if [ "${v_currFile}" == "Bash-utils.sh" ] && [ "$(wc -l "${v_currFile}" | cut -f1 -d" ")" -ge 19078 ]; then echo "FILE = ${v_currFile}"; return 0; else return 1; fi }

# Checking if the whole framework's main code (config, initializer and main module's code) is wrapped in a single localized file (generated by a script to develop, but inspired by the "res/dev-tools/dev-bin/lib-unite.sh" (or "bin/lib-unite.sh") script).
function BU.ModuleInit.IsFrameworkLocalizedWrapped()    { local v_currFile; v_currFile="$(basename "${BASH_SOURCE[0]}")"; if [[ "${v_currFile}" == Bash-utils-[a-z][a-z].sh ]] && [ "$(wc -l "${v_currFile}" | cut -f1 -d" ")" -ge 15000 ]; then return 0; else return 1; fi }

# Checking if the whole framework's main code (config, initializer and main module's code) is wrapped in a single (un)localized file.
function BU.ModuleInit.IsFrameworkWrapped()             { if BU.ModuleInit.IsFrameworkLocalizedWrapped || BU.ModuleInit.IsFrameworkUnlocalizedWrapped; then return 0; else return 1; fi }

# Checking if the function and / or sourced code currently executed is a part of a script file or running in an interactive shell.
function BU.ModuleInit.IsInScript()                     { local v_3="${0: -3}"; local v_5="${0: -5}"; if [ "${0:0:2}" == './' ] || [[ "${v_3,,}" == .sh ]] || [[ "${v_5,,}" == .bash ]]; then return 0; elif [ "${0}" == 'bash' ]; then return 1; fi }

# Checking if the framework is translated.
function BU.ModuleInit.IsTranslated()                   { if [ "${__BU_MODULE_INIT__BU_BASE_IS_TRANSLATED,,}" == 'true' ]; then return 0; else return 1; fi }

# Checking if the framework is still initializing, and if the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable's value is '--log-shut', in order to display every error messages from the main module's functions.
function BU.ModuleInit.SetInitErrorMsg()                { if BU.Main.Status.CheckStatIsInitializing && [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" == '--log-shut' ]; then v_msg_arr_permission_global_backup="${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}"; __BU_MODULE_INIT_MSG_ARRAY_PERMISSION='--log-shut-display'; return 0; else return 1; fi }

# Unsetting the former function's result.
function BU.ModuleInit.UnsetInitErrorMsg()              { if BU.Main.Status.CheckStatIsInitializing && [ -n "${v_msg_arr_permission_global_backup}" ]; then __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${v_msg_arr_permission_global_backup}"; unset v_msg_arr_permission_global_backup; fi }

# -----------------------------------------------

## FUNCTIONS AND RESOURCES NEEDED FOR TRAPPING SIGNALS

# NOTE : In the functions with embedded translations, only the languages spoken by more than 100 million people in
# the world (according to this website : https://lingua.edu/the-20-most-spoken-languages-in-the-world-in-2022/)
# will be embedded, in order to avoid bloating the initializer script with thousands of lines of messages.

# Printing that the script's execution was interrupted by the user.
function BU.ModuleInit.SIGINT()
{
    #**** Variables ****
    local v_isPrinted; # VAR TYPE : Bool   - DESC :

    #**** Code ****
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'de' ] && { echo >&2; echo "Die Ausführung des Skripts wurde vom Benutzer unterbrochen" >&2 && v_isPrinted='true'; };
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'en' ] && { echo >&2; echo "The script's execution was interrupted by the user" >&2 && v_isPrinted='true'; };
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'es' ] && { echo >&2; echo "La ejecución del script fue interrumpida por el usuario" >&2 && v_isPrinted='true'; };

    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'fr' ] && { echo >&2; echo "L'exécution du script a été interrompue par l'utilisateur" >&2 && v_isPrinted='true'; };
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'pt' ] && { echo >&2; echo "A execução do guião foi interrompida pelo utilizador" >&2 && v_isPrinted='true'; };
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'ru' ] && { echo >&2; echo "Выполнение сценария было прервано пользователем" >&2 && v_isPrinted='true'; };

    [ "${v_isPrinted}" != 'true' ] && { echo >&2; echo "The script's execution was interrupted by the user" >&2; };

    echo >&2;
}

# Defining the framework's traps.
function BU.ModuleInit.DefineTraps()
{
    # Defining strings variables.
    __BU_MODULE_INIT_MSG__DEFINING_TRAPS__="";

    # Defining traps.
    trap 'echo "${__BU_MODULE_INIT_MSG__DEFINE_TRAPS__EXITING_SCRIPT}"' 0;

    trap "BU.ModuleInit.SIGINT; BU.ModuleInit.Exit 2" SIGINT;
}

# -----------------------------------------------

## FUNCTIONS NEEDED FOR THE TRANSLATIONS OF MESSAGES BEFORE THE INCLUSION OF THE TRANSLATION FILES.

# NOTE : In the functions with embedded translations, only the languages spoken by more than 100 million people in
# the world (according to this website : https://lingua.edu/the-20-most-spoken-languages-in-the-world-in-2022/)
# will be embedded, in order to avoid bloating the initializer script with thousands of lines of messages.

function BU.ModuleInit.PrintLogErrorNoTranslationFilesSourced()
{
    # No need to redefine the three arguments inside this function, the scope of the "BU.ModuleInit.PrintLogError()"
    # function's local variables reach the sub-functions called inside the "BU.ModuleInit.PrintLogError()" function.

    #**** Variables ****
    local v_isPrinted;  # VAR TYPE : Bool               - DESC :
    local v_userLang;   # VAR TYPE : ISO 639-1 code     - DESC :

    #**** Code ****
    v_userLang="$(echo "${LANG}" | cut -d _ -f1)";

    [ "${v_userLang,,}" == 'de' ] && BU.ModuleInit.MsgLine "$(printf "[FEHLER] DATEI : %s | LINIEN : %s | FEHLERCODE : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';
    [ "${v_userLang,,}" == 'en' ] && BU.ModuleInit.MsgLine "$(printf "[ERROR] FILE : %s | LINE : %s | CODE : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';
    [ "${v_userLang,,}" == 'es' ] && BU.ModuleInit.MsgLine "$(printf "[ERROR] FICHERO : %s | LÍNEA : %s | CÓDIGO : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';

    [ "${v_userLang,,}" == 'fr' ] && BU.ModuleInit.MsgLine "$(printf "[ ERREUR ] FICHER : %s | LIGNE : %s | CODE : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';
    [ "${v_userLang,,}" == 'pt' ] && BU.ModuleInit.MsgLine "$(printf "[ERRO] FICHEIRO : %s | LINHA : %s | CÓDIGO : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';
    [ "${v_userLang,,}" == 'ru' ] && BU.ModuleInit.MsgLine "$(printf "[ОШИБКА] ФАЙЛ : %s | ЛИНИЯ : %s | КОД : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2 && v_isPrinted='true';

    # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
    [ "${v_isPrinted}" != 'true' ] && BU.ModuleInit.MsgLine "$(printf "[ERROR] FILE : %s | LINE : %s | CODE : %s" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2;

    echo >&2;
}

function BU.ModuleInit.FindPathNoTranslationFilesSourced()
{
    #**** Parameters ****
    local p_func0=${1:-${FUNCNAME[1]}};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : "${FUNCNAME[1]}"     - DESC :
    local p_func1=${2:-${FUNCNAME[2]}};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : "${FUNCNAME[2]}"     - DESC :
    local p_file=${3:-${BASH_SOURCE[0]}};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : "${BASH_SOURCE[0]}"  - DESC :
    local p_lineno=${4:-NULL};              # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL                 - DESC :
    local p_type=${5:-NULL};                # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL                 - DESC :

    #**** Variables ****
    local v_isPrinted;  # VAR TYPE : Bool               - DESC :
    local v_type;       # VAR TYPE : CMD                - DESC : Checking the value of the "" parameter in order to display the correct string.
    local v_userLang;   # VAR TYPE : ISO 639-1 code     - DESC :

    #**** Code ****
    v_type="$([ "${p_type,,}" == 'echo' ] && printf 'echo' || printf 'MSG')";

    v_userLang="$(echo "${LANG}" | cut -d _ -f1)";

    # Deutch | German
    [ "${v_userLang,,}" == 'de' ] && {
        printf "IN DER DATEI « %s », AN DIE FUNKTION « %s », ZUR LINIE « %s », BASH-UTILS WARNUNG : DIESER PFAD KANN NICHT GEFUNDEN WERDEN --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Funktion, bei der die Funktion « %s() » aufgerufen wurde: %s" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    }

    # English
    [ "${v_userLang,,}" == 'en' ] && {
        printf "IN « %s », FUNCTION « %s », LINE « %s » --> BASH-UTILS WARNING : UNABLE TO FIND THIS PATH --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Function where the « %s() » function was called : %s()\n" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    };

    # Español | Spanish
    [ "${v_userLang,,}" == 'es' ] && {
        printf "EN EL FICHERO « %s », A LA FUNCIÓN « %s », A LA LÍNEA « %s » --> ADVERTENCIA DE BASH-UTILS : NO SE ENCUENTRA ESTA RUTA DE ARCHIVO --> %s%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Función en la que se ha llamado a la función « %s() » : %s()" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    };

    # Français | French
    [ "${v_userLang,,}" == 'fr' ] && {
        printf "DANS LE FICHIER « %s », À LA FONCTION « %s », À LA LIGNE « %s » --> AVERTISSEMENT DE BASH-UTILS : IMPOSSIBLE DE TROUVER CE CHEMIN --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Fonction où la fonction « %s() » a été appelée : %s()" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    };

    # Português | Portuguese
    [ "${v_userLang,,}" == 'pt' ] && {
        printf "EM « %s » FICHEIRO, NA FUNÇÃO « %s() », EM LINHA « %s » --> AVISO DE BASH-UTILS : IMPOSSÍVEL DE ENCONTRAR ESTE CAMINHO --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Função onde a função « %s() » foi chamada : %s()" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    };

    # Русский | Russian
    [ "${v_userLang,,}" == 'ru' ] && {
        printf "В ФАЙЛЕ « %s », К ФУНКЦИИ « %s », К СТРОКЕ « %s » --> ПРЕДУПРЕЖДЕНИЕ « BASH-UTILS » : НЕВОЗМОЖНО НАЙТИ ЭТУ ПУТЬ --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Функция, в которой была вызвана функция « %s() » : %s()" "${v_type}" "${p_func0}" "${p_func1}" >&2; v_isPrinted='true';
    }

    # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
    [ "${v_isPrinted}" != 'true' ] && {
        printf "IN « %s », FUNCTION « %s », LINE « %s » --> BASH-UTILS WARNING : UNABLE TO FIND THIS PATH --> %s/%s\n\n" "${p_file}" "${p_func0}" "${p_lineno}" "${v_parentdir}" "${v_target}" >&2;

        printf "(%s) Function where the « %s() » function was called : %s()\n" "${v_type}" "${p_func0}" "${p_func1}" >&2;
    };
}

# -----------------------------------------------

## FUNCTIONS NEEDED FOR THE INITIALIZATION PROCESS TRANSLATIONS

# NOTE : In the functions with embedded translations, only the languages spoken by more than 100 million people in
# the world (according to this website : https://lingua.edu/the-20-most-spoken-languages-in-the-world-in-2022/)
# will be embedded, in order to avoid bloating the initializer script with thousands of lines of messages.

# Printing the message that warns the user that the rest of the framework will use english as default language (this function is not called if the framework is wrapped in a single file).
function BU.ModuleInit.GetModuleInitLanguage_RestOfLibrary()
{
    #**** Variables ****
    local v_isPrinted; # VAR TYPE : Bool   - DESC :

    #**** Code ****
    echo '------------------------------------------------------------------------' >&2;
    echo >&2;

    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'de' ] && echo "Der Rest der Bibliothek wird Englisch als Standardsprache verwenden" >&2 && v_isPrinted='true';
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'en' ] && echo "The rest of the library will use English as default language" >&2 && v_isPrinted='true';
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'es' ] && echo "El resto de la biblioteca utilizará el inglés como idioma por defecto" >&2 && v_isPrinted='true';

    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'fr' ] && echo "Le reste de la librairie utilisera l'anglais en tant que langue par défaut" >&2 && v_isPrinted='true';
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'pt' ] && echo "O resto da biblioteca utilizará o inglês como língua padrão" >&2 && v_isPrinted='true';
    [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'ru' ] && echo "Остальная часть библиотеки будет использовать английский язык в качестве языка по умолчанию" >&2 && v_isPrinted='true';

    # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
    [ "${v_isPrinted}" != 'true' ] && echo "The rest of the library will use English as default language" >&2;

    echo >&2;

    sleep 0.5;

    BU.ModuleInit.GetModuleInitLanguage_SetEnglishAsDefaultLanguage || return 1;
}

# Set english as default language if an unsupported language is stored in the "${__BU_MODULE_INIT__USER_LANG}" global variable (this function is not called if the framework is wrapped in a single file).
# shellcheck disable=SC1090,SC1091
function BU.ModuleInit.GetModuleInitLanguage_SetEnglishAsDefaultLanguage()
{
    #**** Variables ****
    local v_lang_backup="${__BU_MODULE_INIT__USER_LANG}"; # VAR TYPE : ISO 639-1 code   - DESC : Backupping the former language used / chosen by the user.

    #**** Code ****

    # Changing the current language to English.
    LANG="en_US.UTF-8"; __BU_MODULE_INIT__USER_LANG="$(echo "${LANG}" | cut -d _ -f1)";

    BU.ModuleInit.SourceEnglishTranslationFiles "${v_lang_backup}";
}

# Sourcing the English translation files.

# shellcheck disable=SC1090,SC1091
function BU.ModuleInit.SourceEnglishTranslationFiles()
{
    #**** Parameters ****
    local p_lang_backup=${1:-'en'}; # ARG TYPE : ISO 639-1 code    - REQUIRED | DEFAULT VAL : en    - DESC : language in which the  language's backup from the "BU.ModuleInit.GetModuleInitLanguage_SetEnglishAsDefaultLanguage()" function.

    #**** Code ****
    BU.ModuleInit.IsFrameworkWrapped || source "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}/en.locale" || {
        echo >&2;

        # Deutch | German
        [ "${p_lang_backup,,}" == 'de' ] && {
            echo '------------------------------------------------------------------------------------------------' >&2 && echo >&2;
            echo "FATALER FEHLER : DIE ENGLISCHE ÜBERSETZUNGSDATEI KONNTE NICHT VON DER QUELLE REFERENZIERT WERDEN" >&2 && echo >&2;

            echo "Da die Nachrichten in der Modulinitialisierungsdatei in Variablen gespeichert werden, stützt sich diese Datei auf diese Übersetzungsdateien, die diese Variablen definieren" >&2;
            echo "Anhalten der Skriptausführung" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # English
        [ "${p_lang_backup,,}" == 'en' ] && {
            echo '-----------------------------------------------------------' >&2 && echo >&2;
            echo "FATAL ERROR : UNABLE TO SOURCE THE ENGLISH TRANSLATION FILE" >&2 && echo >&2;

            echo "Since the messages in the module initialization file are stored into variables, this file relies on these translation files, which define these variables" >&2;
            echo "Aborting the script's execution" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # Español | Spanish
        [ "${p_lang_backup,,}" == 'es' ] && {
            echo '-----------------------------------------------------------------' >&2 && echo >&2;
            echo "ERROR FATAL: IMPOSIBLE OBTENER EL ARCHIVO DE TRADUCCIÓN AL INGLÉS" >&2 && echo >&2;

            echo "Como los mensajes del fichero de inicialización del módulo se almacenan en variables, este fichero es asumido por estos ficheros de traducción, que definen estas variables" >&2;
            echo "Detener la ejecución del script" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # Français | French
        [ "${p_lang_backup,,}" == 'fr' ] && {
            echo '------------------------------------------------------------------------' >&2 && echo >&2;
            echo "ERREUR FATALE : IMPOSSIBLE D'INCLURE LE FICHIER DE TRADUCTION EN ANGLAIS" >&2 && echo >&2;

            echo "Comme les messages du fichier d'initialisation du module sont stockés dans des variables, ce fichier s'appuie sur ces fichiers de traduction, qui définissent ces variables" >&2;
            echo "Arrêt de l'exécution du script" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # Português | Portuguese
        [ "${p_lang_backup,,}" == 'pt' ] && {
            echo '-----------------------------------------------------------------------' >&2 && echo >&2;
            echo "ERRO FATAL: IMPOSSIBILIDADE DE INCLUIR O FICHEIRO DE TRADUÇÃO EM INGLÊS" >&2 && echo >&2;

            echo "Como as mensagens no ficheiro de inicialização do módulo são armazenadas em variáveis, este ficheiro baseia-se nestes ficheiros de tradução, que definem estas variáveis" >&2;
            echo "Interrupção da execução do guião" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # Русский | Russian
        [ "${p_lang_backup,,}" == 'ru' ] && {
            echo '----------------------------------------------------------------------' >&2 && echo >&2;
            echo "ФАТАЛЬНАЯ ОШИБКА: НЕВОЗМОЖНО ВКЛЮЧИТЬ ФАЙЛ ПЕРЕВОДА НА АНГЛИЙСКИЙ ЯЗЫК" >&2 && echo >&2;

            echo "Comme les messages du fichier d'initialisation du module sont stockés dans des variables, ce fichier s'appuie sur ces fichiers de traduction, qui définissent ces variables" >&2;
            echo "Arrêt de l'exécution du script" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }

        # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
        [[ "${p_lang_backup}" == * ]] && {
            echo '-----------------------------------------------------------' >&2 && echo >&2;
            echo "FATAL ERROR : UNABLE TO SOURCE THE ENGLISH TRANSLATION FILE" >&2 && echo >&2;

            echo "Since the messages in the module initialization file are stored into variables, this file relies on these translation files, which define these variables" >&2;
            echo "Aborting the script's execution" >&2;
            echo >&2;

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
            return 1;
        }
    }
}

# Writing the error messages that , before the definition of the necessary variables for the inclusion of the translation files.
function BU.ModuleInit.PrintErrorMissingBashUtilsHomeFolder()
{
    #**** Parameters ****
    local v_file=${1:-${BASH_SOURCE[0]}};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : "${BASH_SOURCE[0]}"  - DESC :
    local v_func=${2:-${FUNCNAME[1]}};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : "${FUNCNAME[1]}"     - DESC :
    local v_line=${3:-${LINENO}};           # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : "${LINENO}"          - DESC :

    #**** Variables ****
    local __bu_module_init__user_lang;      # VAR TYPE : ISO 639-1 Code     - DESC : Getting the language used / chosen by the user.
    local v_installFile;                    # VAR TYPE : File               - DESC : Name of the framework installation program.
    local v_isPrinted;                      # VAR TYPE : Bool               - DESC :

    #**** Code ****
    __bu_module_init__user_lang="$(echo "${LANG}" | cut -d _ -f1)";

    v_installFile='install_and_update.sh';

    echo >&2;

    # Deutch | German
    [ "${__bu_module_init__user_lang,,}" == 'de' ] && {
        printf "IN DER DATEI « %s », AN DIE FUNKTION « %s », ZUR LINIE « %s », BASH-UTILS WARNUNG :\n" "${v_file}" "${v_func}" "${v_line}" >&2; echo >&2;

        echo "Der Stammordner des Bash-Utils-Konfigurationsverzeichnisses « .Bash-utils » existiert nicht in Ihrem Heimatverzeichnis" >&2; echo >&2;
        echo "Bitte kopieren Sie diesen Ordner in Ihr Home-Verzeichnis. Sie können es installieren, indem Sie die Datei « ${v_installFile} » ausführen, oder Sie können es im Verzeichnis « Bash-utils/install » finden" >&2;

        v_isPrinted='true';
    };

    # English
    [ "${__bu_module_init__user_lang,,}" == 'en' ] && {
        printf "IN « %s », FUNCTION « %s() », LINE « %s » --> BASH-UTILS ERROR\n" "${v_file}" "${v_func}" "${v_line}">&2; echo >&2;

        echo "The Bash Utils framework's configurations root folder « .Bash-utils » doesn't exists in your home directory" >&2; echo >&2;
        echo "Please copy this folder in your home directory. You can install it by executing the « ${v_installFile} » file, or you can find it in the « Bash-utils/install » directory" >&2;
    };

    # Español | Spanish
    [ "${__bu_module_init__user_lang,,}" == 'es' ] && {
        printf "EN EL FICHERO « %s », A LA FUNCIÓN « %s », A LA LÍNEA « %s » --> ADVERTENCIA DE BASH-UTILS :\n" "${v_file}" "${v_func}" "${v_line}" >&2; echo >&2;

        echo "La carpeta raíz para las configuraciones de Bash Utils « .Bash-utils » no existe en su directorio personal." >&2; echo >&2;
        echo "Por favor, copie este archivo en su directorio personal. Puede instalarlo ejecutando el archivo « ${v_installFile} », o puede encontrarlo en la carpeta « Bash-utils/install »" >&2;

        v_isPrinted='true';
    };

    # Français | French
    [ "${__bu_module_init__user_lang,,}" == 'fr' ] && {
        printf "DANS LE FICHIER « %s », À LA FONCTION « %s() », À LA LIGNE « %s » --> ERREUR FATALE DE BASH-UTILS\n" "${v_file}" "${v_func}" "${v_line}" >&2; echo >&2;

        echo "Le dossier racine des configurations du framework Bash Utils « .Bash-utils » n'existe pas dans votre répertoire personnel" >&2; echo >&2;
        echo "Veuillez copier ce dossier dans votre répertoire personnel. Vous pouvez l'installer en exécutant le fichier « ${v_installFile} », ou vous pouvez le trouver dans le dossier « Bash-utils/install »" >&2;

        v_isPrinted='true';
    };

    # Português | Portuguese
    [ "${__bu_module_init__user_lang,,}" == 'pt' ] && {
        printf "EM « %s » FICHEIRO, NA FUNÇÃO « %s() », EM LINHA « %s » --> BASH-UTILS ERRO FATAL\n" "${v_file}" "${v_func}" "${v_line}" >&2; echo >&2;

        echo "A pasta de configuração da raiz da estrutura Bash Utils « .Bash-utils » não existe no seu directório home" >&2; echo >&2;
        echo "Por favor copie esta pasta para o seu directório pessoal. Pode instalá-lo executando o ficheiro « ${v_installFile} », ou pode encontrá-lo na pasta « Bash-utils/install »" >&2;

        v_isPrinted='true';
    };

    # Русский | Russian
    [ "${__bu_module_init__user_lang,,}" == 'ru' ] && {
        printf "В ФАЙЛЕ « %s », К ФУНКЦИИ « %s », К СТРОКЕ « %s » --> ФАТАЛЬНАЯ ОШИБКА « BASH-UTILS »\n" "${v_file}" "${v_func}" "${v_line}" >&2; echo >&2;

        echo "Корневая папка конфигураций фреймворка 'Bash Utils' « .Bash-utils » не существует в вашем домашнем каталоге" >&2; echo >&2;
        echo "Пожалуйста, скопируйте эту папку в свой домашний каталог. Вы можете установить его, запустив файл « ${v_installFile} », или вы можете найти его в папке « Bash-utils/install »" >&2;

        v_isPrinted='true';
    };

    # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
    [ "${v_isPrinted}" != 'true' ] && [[ "${__bu_module_init__user_lang,,}" == * ]] && {
        printf "IN « %s », FUNCTION « %s() », LINE « %s » --> BASH-UTILS ERROR\n" "${v_file}" "${v_func}" "${v_line}">&2; echo >&2;

        echo "The Bash Utils configurations root folder « .Bash-utils » doesn't exists in your home directory" >&2; echo >&2;
        echo "Please copy this folder in your home directory. You can install it by executing the « ${v_installFile} » file, or you can find it in the « Bash-utils/install » directory" >&2;
    };
}

# Rewriting the library's languages messages (this function is not called if the framework is wrapped in a single file).
# shellcheck disable=SC1091,SC1090
function BU.ModuleInit.GetModuleInitLanguage()
{
    #**** Parameters ****
    local p_lang_ISO_639_1=${1:-NULL};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Wanted language.

    #**** Variables ****
    local v_supportedLang;  # VAR TYPE : Array  - DESC :
    local v_langMatch;      # VAR TYPE :

    local v_isPrinted;      # VAR TYPE : Bool   - DESC :

    #**** Code ****
    v_supportedLang=('de' 'en' 'es' 'fr' 'pt');

    [[ ${v_supportedLang[*]} =~ ${p_lang_ISO_639_1,,} ]] && v_langMatch="match";

    # If the selected language was not found among the supported languages.
    if [ -z "${v_langMatch}" ]; then

        if [ -n "${p_lang_ISO_639_1}" ]; then
            echo "WARNING : Your selected language (${p_lang_ISO_639_1}) is not (yet) supported by the initialisation script" >&2
            echo >&2;
        else
            echo "WARNING : Your current language (${__BU_MODULE_INIT__USER_LANG}) is not (yet) supported by the initialisation script" >&2
            echo >&2;
        fi

        echo "The initialisation script will use english as default language" >&2;
        echo >&2;

        # Changing the current language to English.
        __BU_MODULE_INIT__USER_LANG="en_US.UTF-8";
    fi

	if [ "${p_lang_ISO_639_1^^}" == 'NULL' ]; then
        [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'de' ] && echo "ACHTUNG : Keine Sprache wird als Argument angegeben, wenn die Funktion « ${FUNCNAME[0]} » aufgerufen wird" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'en' ] && echo "WARNING : No language specified as argument when calling the « ${FUNCNAME[0]} » function" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'es' ] && echo "ADVERTENCIA : No se especifica ningún idioma como argumento al llamar a la función « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';

		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'fr' ] && echo "ATTENTION : Aucune langue spécifiée en argument lors de l'appel de la fonction « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';
        [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'pt' ] && echo "ATENÇÃO : Nenhuma língua especificada como argumento ao chamar a função « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'ru' ] && echo "ВНИМАНИЕ : При вызове функции « ${FUNCNAME[0]} » в качестве аргумента не указан язык" >&2 && v_isPrinted='true';

        [ "${v_isPrinted}" != 'true' ] && echo "WARNING : No language specified as argument when calling the « ${FUNCNAME[0]} » function" >&2;

        echo >&2;

		BU.ModuleInit.GetModuleInitLanguage_RestOfLibrary || return 1;

    elif [ "${p_lang_ISO_639_1^^}" != 'NULL' ] && [ ! -f "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}/${p_lang_ISO_639_1}.locale" ]; then
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'de' ] && echo "ACHTUNG : Die Übersetzungsdatei für die Sprache, die beim Aufruf der Funktion « ${FUNCNAME[0]} » als Argument angegeben wurde, konnte im Ordner « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} » nicht gefunden werden" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'en' ] && echo "WARNING : The translation file for the language specified as an argument when calling the « ${FUNCNAME[0]} » function was not found in the « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} » directory" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'es' ] && echo "ADVERTENCIA : El archivo de traducción para el idioma especificado como argumento al llamar a la función « ${FUNCNAME[0]} » no se encontró en el directorio « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} »" >&2 && v_isPrinted='true';

		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'fr' ] && echo "ATTENTION : Le fichier de traduction destiné à la langue spécifiée en argument lors de l'appel de la fonction « ${FUNCNAME[0]} » n'a pas été trouvé dans le dossier « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} »" >&2 && v_isPrinted='true';
        [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'pt' ] && echo "ATENÇÃO : O ficheiro de tradução para a língua especificada como argumento ao chamar a função « ${FUNCNAME[0]} » não foi encontrado na pasta « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} »" >&2 && v_isPrinted='true';
		[ "${__BU_MODULE_INIT__USER_LANG,,}" == 'ru' ] && echo "ВНИМАНИЕ : Файл перевода для языка, указанного в качестве аргумента при вызове функции « ${FUNCNAME[0]} » не найден в каталоге « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} »." >&2 && v_isPrinted='true';

        [ "${v_isPrinted}" != 'true' ] && echo "WARNING : The translation file for the language specified as an argument when calling the « ${FUNCNAME[0]} » function was not found in the « ${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH} » directory" >&2;

        echo >&2;

        BU.ModuleInit.GetModuleInitLanguage_RestOfLibrary || return 1;

    else
        # Sourcing the English translation files first, since these files are the most supported, so that if new variables are added, no empty strings will be displayed if the next language files are not updated yet.
        BU.ModuleInit.SourceEnglishTranslationFiles "${__BU_MODULE_INIT__USER_LANG,,}";

        # Sourcing the language
        BU.ModuleInit.IsFrameworkWrapped || source "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}/${p_lang_ISO_639_1}.locale" || {
            [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'de' ] && echo "ACHTUNG : Die Übersetzungsdatei für die als Argument angegebene Sprache konnte beim Aufruf der Funktion « ${FUNCNAME[0]} » nicht gefunden werden." >&2 && v_isPrinted='true';
            [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'en' ] && echo "WARNING : Unable to source the translation file for the language specified as argument when calling the « ${FUNCNAME[0]} » function" >&2 && v_isPrinted='true';
            [ "${__BU_MODULE_INIT__USER_LANG,,}" == "es" ] && echo "ADVERTENCIA : No se ha podido obtener el archivo de traducción para el idioma especificado en el argumento al llamar a la función « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';

            [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'fr' ] && echo "ATTENTION : Impossible de sourcer le fichier de traduction destiné à la langue spécifiée en argument lors de l'appel de la fonction « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';
            [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'pt' ] && echo "ATENÇÃO : Não foi possível obter o ficheiro de tradução para a língua especificada como argumento ao chamar a função « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';
            [ "${__BU_MODULE_INIT__USER_LANG,,}" == 'ru' ] && echo "ВНИМАНИЕ : Невозможно включить файл перевода для языка, указанного в качестве аргумента, при вызове функции « ${FUNCNAME[0]} »" >&2 && v_isPrinted='true';

            # If the language chosen by the user is not (yet) supported directly in this function, the message is displayed in English.
            [ "${v_isPrinted}" != 'true' ] && echo "WARNING : Unable to source the translation file for the language specified as argument when calling the « ${FUNCNAME[0]} » function" >&2;

            echo >&2;

            BU.ModuleInit.GetModuleInitLanguage_RestOfLibrary || return 1;
        }
    fi
}

# -----------------------------------------------

## FUNCTIONS NEEDED FOR THE DISPLAYING OF THE INITIALIZATION MESSAGES

# Asking to the user if (s)he wants to display the initialization logs on the screen (preferably before stopping the script's execution after a fatal error).
function BU.ModuleInit.AskPrintLog()
{
    #**** Code ****
    # If no value is stored in the log messages array, then the log messages display procedure is cancelled.
    if [ -z "${__BU_MODULE_INIT_MSG_ARRAY}" ]; then
        echo "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_LOG_TO_DISPLAY}";
        echo; return 0;
    fi

	if [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" == '--log-display' ]; then
        echo;

		BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__ASK_DISPLAY}" '#' 'echo';

		# If the user's defined language is not English, then a message will be displayed to ask the user in his/her language to write 'yes' or 'Y' if he/she wants to display the initialization logs.
		if [ "${__BU_MODULE_INIT__USER_LANG,}" != 'en' ]; then
            echo; echo "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_ENGLISH}";
		fi

		echo; read -rp "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__ENTER_ANS}" read_ask_print_log;

		if [ "${read_ask_print_log,,}" == 'yes' ] || [ "${read_ask_print_log^^}" == 'Y' ]; then
			BU.ModuleInit.PrintLog || return 1;

			return 0;
		else
			echo; echo "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_DISPLAY}"; echo; return 0;
		fi
	else
		return 0;
	fi
}

# Printing and / or logging the global variables already defined.
function BU.ModuleInit.DisplayInitGlobalVarsInfos__DisplayInitializedGlobalVarsInfos()
{
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_GLOBAL_VARS}" '#' 'msg';
    BU.ModuleInit.Msg;

    # PID
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__SCRIPT_INFO}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__PROJECT_PID'                 "${__BU_MODULE_INIT__PROJECT_PID}"             'Int'       "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__PID}"                     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__project_pid__lineno}";
    BU.ModuleInit.Msg;

    # FINDING THE ".Bash-utils" FOLDER'S PARENT DIRECTORY
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__ROOT_HOME"                  "${__BU_MODULE_INIT__ROOT_HOME}"                'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__ROOT_HOME}"               "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__root_home__lineno}";
    # FINDING THE ".Bash-utils" FOLDER
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_ROOT_DIR_VARS}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__ROOT"                       "${__BU_MODULE_INIT__ROOT}"                     'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__ROOT}"                    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__root__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__INITIALIZER_PATH'           "${__BU_MODULE_INIT__INITIALIZER_PATH}"         'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INITIALIZER_PATH}"        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__initializer_path__lineno}";
    BU.ModuleInit.Msg;

    # TEMPORARY DIRECTORY
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__INIT_TMP_DIR}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__TMP_DIR_NAME'               "${__BU_MODULE_INIT__TMP_DIR_NAME}"             'String'    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__TMP_DIR_NAME}"            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__tmp_dir_name__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__TMP_DIR_PATH"               "${__BU_MODULE_INIT__TMP_DIR_PATH}"             'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIVGI__TMP_DIR_PATH}"            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__tmp_dir_path__lineno}";

    # CONFIGURATION DIRECTORIES
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_CONF_DIRS}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__CONFIG_DIR_PATH"                 "${__BU_MODULE_INIT__CONFIG_DIR_PATH}"               'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_DIR}"              "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__config_dir_path__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__CONFIG_INIT_DIR_PATH"            "${__BU_MODULE_INIT__CONFIG_INIT_DIR_PATH}"          'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__config_init_dir_path__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH"         "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}"       'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_MODULES_DIR}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__config_modules_dir_path__lineno}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH"       "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}"     'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_LANG_DIR}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__config_init_lang_dir_path__lineno}";
    BU.ModuleInit.Msg;

    # INITIALIZER SCRIPT'S CONFIGURATION FILES.
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR__CONFIGURATION_FILES}" '+' 'msg';
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS'    "${__BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS}"  'Filepath' "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__CONFIG_INIT_DIR__STATUS}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__config_init_dir__status__lineno}";

    # MODULE DIRECTORIES
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_MODULE_INIT_DIR}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__MODULES_DIR"                "${__BU_MODULE_INIT__MODULES_DIR}"              'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__MODULES_DIR}"             "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__modules_dir__lineno}";
    BU.ModuleInit.Msg;

    # FILES
    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_VARS_LIB_ROOT_DIR_FILE_PATH}" '+' 'msg'; BU.ModuleInit.Msg
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_NAME"                "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_NAME}"              'File'      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_NAME}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir__file_name__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR_FILE__PARENT_DIR"          "${__BU_MODULE_INIT__LIB_ROOT_DIR_FILE__PARENT_DIR}"        'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR}"   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir_file__parent_dir__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH"                "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}"              'Filepath'  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PATH}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir__file_path__lineno}";
    BU.ModuleInit.Msg;

    if [ -z "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}" ]; then
        BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_VARS_LIB_ROOT_DIR_ROOT_FILE}" '+' 'msg'; BU.ModuleInit.Msg;
        BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_NAME"           "${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_NAME}"         'File'      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_NAME}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir_root__file_name__lineno}";
        BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR"     "${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR}"   'Dirpath'   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR}"   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir_root_file__parent_dir__lineno}";
        BU.ModuleInit.DisplayInitGlobalVarsInfos "__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_PATH"           "${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_PATH}"         'Filepath'  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__LIB_ROOT_DIR_ROOT_FILE_PATH}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__lib_root_dir_root__file_path__lineno}";
        BU.ModuleInit.Msg;
    fi

    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__INIT_MISC_VARS}" '+' 'msg'; BU.ModuleInit.Msg;
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__BU_BASE_IS_TRANSLATED'                  "${__BU_MODULE_INIT__BU_BASE_IS_TRANSLATED}"                'Bool'      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__BU_BASE_IS_TRANSLATED}"               "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__bu_base_is_translated__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__CSV_TRANSLATION_FILE__DELIM'            "${__BU_MODULE_INIT__CSV_TRANSLATION_FILE__DELIM}"          'Char'      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__TRANSLATION_FILE_DELIM}"              "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__csv_translation_file__delim__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__DATE_LOG'                               "${__BU_MODULE_INIT__DATE_LOG}"                             'CMD'       "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__DATE_LOG}"                            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__date_log__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__USER_LANG'                              "${__BU_MODULE_INIT__USER_LANG}"                            'CMD'       "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__USER_LANG}"                           "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__user_lang__lineno}";
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT__BASHX_DEBUG_VALS_ARRAY'                 "${__BU_MODULE_INIT__BASHX_DEBUG_VALS_ARRAY}"               'Array'     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__BASHX_DEBUG_VALS_ARRAY}"              "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_module_init__bashx_debug_vals_array__lineno}";

    # Unsetting every string variables in order to free up some memory.

	# DO NOT single or double quote the following command substitution.

	# shellcheck disable=SC2046
	unset $(compgen -v "__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__");

    # Unsetting the line number values.

    # shellcheck disable=SC2046
	unset $(compgen -v __bu_module_init__*__lineno);
    unset __bu_module_init__project_pid__lineno \
        __bu_module_init__root_home__lineno \
        __bu_module_init__root__lineno \
        __bu_module_init__initializer_path__lineno \
        __bu_module_init__config_dir_path__lineno \
        __bu_module_init__config_init_dir_path__lineno \
        __bu_module_init__config_modules_dir_path__lineno \
        __bu_module_init__config_init_lang_dir_path__lineno \
        __bu_module_init__config_init_dir__status__lineno \
        __bu_module_init__modules_dir__lineno \
        __bu_module_init__tmp_dir_name__lineno \
        __bu_module_init__tmp_dir_path__lineno \
        __bu_module_init__lib_root_dir__file_name__lineno \
        __bu_module_init__lib_root_dir_file__parent_dir__lineno \
        __bu_module_init__lib_root_dir__file_path__lineno \
        __bu_module_init__lib_root_dir_root__file_name__lineno \
        __bu_module_init__lib_root_dir_root_file__parent_dir__lineno \
        __bu_module_init__lib_root_dir_root__file_path__lineno \
        __bu_module_init__csv_translation_file__delim__lineno \
        __bu_module_init__date_log__lineno \
        __bu_module_init__user_lang__lineno \
        __bu_module_init__bashx_debug_vals_array__lineno
}

# Displaying the information on the initialized global variables.

# shellcheck disable=SC2059
function BU.ModuleInit.DisplayInitGlobalVarsInfos()
{
    if [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ]; then

        #**** Parameters ****
        local p_var_name=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the variable.
        local p_var_val=${2:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Value stored in the variable (DO NOT FILL THIS FIELD IF THE VARIABLE TYPE IS AN ARRAY, INSTEAD, LEAVE IT AS AN EMPTY STRING).
        local p_var_type=${3:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of variable (array, int (integer), float, path, string).
        local p_var_desc=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Description of the variable.
        local p_modl=${5:-NULL};            # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the variable was declared.
        local p_file=${6:-NULL};            # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the variable was declared.
        local p_func=${7:-NULL};            # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function where the variable was declared.
        local p_line=${8:-NULL};            # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the variable was declared.

        # If the variable type is an array, then the values must be passed as an array,
        # or else only the first index's value will be displayed.
        shift 8;
        local pa_var_val_array=("${@}");    # ARG TYPE : Array      - OPTIONAL  | DEFAULT VAL : NULL    - DESC :

        #**** Variables ****
        local v_modl; # VAR TYPE : String   - DESC :
        local v_file; # VAR TYPE : String   - DESC :
        local v_func; # VAR TYPE : String   - DESC :
        local v_line; # VAR TYPE : String   - DESC :

        local v_type; # VAR TYPE : String   - DESC : Translating and giving more informations about the variable types.

        #**** Code ****
        v_modl="$(if [[ "${p_modl^^}" != 'NULL' ]]; then printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__MODL}" "${p_modl}"; else echo "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__MODL_NULL}"; fi)";
        v_file="$(if [[ "${p_file^^}" != 'NULL' ]]; then printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FILE}" "${p_file}"; else echo "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FILE_NULL}"; fi)";
        v_func="$(if [[ "${p_func^^}" != 'NULL' ]]; then printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FUNC}" "${p_func}"; else echo "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__FUNC_NULL}"; fi)";
        v_line="$(if [[ "${p_line^^}" != 'NULL' ]]; then printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__LINE}" "${p_line}"; else echo "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__LINE_NULL}"; fi)";

		if [ "${p_var_type^^}" == 'NULL' ]; then
            p_var_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__NO_VAR_TYPE_GIVEN}";
        else
            # Checking if the "${p_var_type}" argument value matches an awaited pattern.
            # - array	: this variable is an array.
            # - achar   : this variable stores an alphabetic character.
            # - astring : this variable stores an alphabetic string.
            # - bool    : this variable stores a boolean value ("true" or "false" only).
            # - cmd	    : this variable stores code in order to perform an action (either a function, a command or a condition)
            # - char    : this variable stores a single alphanumeric character (can be alphabetic or numeric).
            # - dir		: this variable stores the name of a directory.
            # - dirpath : this variable stores the path to a directory.
            # - file	: this variable stores the name of a file.
            # - filepath: this variable stores the path to a file.
            # - float	: this variable stores a floating number.
            # - floatneg: this variable stores a negative floating number only.
            # - floatpos: this variable stores a positive floating number only.
            # - int		: this variable stores an integer.
            # - intneg  : this variable stores a negative integer only.
            # - intpos  : this variable stores a positive integer only.
            # - path 	: this variable stores the path to a directory or a file.
            # - string	: this variable stores a string (other than the name of a directory or a file, or a path).
            if      [[ "${p_var_type,,}" != arr?(ay) ]];    then true;
            elif    [ "${p_var_type,,}" != 'cmd' ];         then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__CMD}";
            elif    [ "${p_var_type,,}" != 'dir' ];         then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__DIR}";
            elif    [ "${p_var_type,,}" != 'int' ];         then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INT}";
            elif    [ "${p_var_type,,}" != 'bool' ];        then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__BOOL}";
            elif    [ "${p_var_type,,}" != 'char' ];        then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__CHAR}";
            elif    [ "${p_var_type,,}" != 'file' ];        then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FILE}";
            elif    [ "${p_var_type,,}" != 'path' ];        then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__PATH}";
            elif    [ "${p_var_type,,}" != "achar" ];       then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__ACHAR}";
            elif    [ "${p_var_type,,}" != 'float' ];       then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOAT}";
            elif    [ "${p_var_type,,}" != "intneg" ];      then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INTNEG}";
            elif    [ "${p_var_type,,}" != "intpos" ];      then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__INTPOS}";
            elif    [ "${p_var_type,,}" != 'string' ];      then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__STRING}";
            elif    [ "${p_var_type,,}" != "astring" ];     then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__ASTRING}";
            elif    [ "${p_var_type,,}" != 'dirpath' ];     then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__DIRPATH}";
            elif    [ "${p_var_type,,}" != "filepath" ];    then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FILEPATH}";
            elif    [ "${p_var_type,,}" != "floatneg" ];    then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOATNEG}";
            elif    [ "${p_var_type,,}" != "floatpos" ];    then v_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__TYPE__FLOATPOS}";
			else
				p_var_type="${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__UNKNOWN_VAR_TYPE_GIVEN}";
            fi
		fi

        BU.ModuleInit.Msg;

		# Checking if the variable is an array.
		if [ "${p_var_type}" == 'array' ]; then
            BU.ModuleInit.MsgLine "$(printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__CHECK_IS_ARRAY}" "${p_var_name}")" '-' 'msg';

		# Checking if the variable is not an array.
		else
            # shellcheck disable=SC2059
            BU.ModuleInit.MsgLine "$(printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__CHECK_IS_NOT_ARRAY}" "${p_var_name}")" '-' 'msg';
		fi

		BU.ModuleInit.Msg;

		BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DESCRIPTION} ${p_var_desc}";
		BU.ModuleInit.Msg;

		BU.ModuleInit.Msg "${v_modl}";
		BU.ModuleInit.Msg "${v_file}";
		BU.ModuleInit.Msg "${v_func}";
		BU.ModuleInit.Msg "${v_line}";

		# If the variable type is an array, then each value is displayed in several blocks of five rows high, with it's index.
		if [ "${p_var_type,,}" == 'array' ]; then
            BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_TYPE}";
            BU.ModuleInit.Msg;

    		# If a value or more are stored in the processed array.
			if [ -n "${pa_var_val_array[*]}" ]; then

                local v_index=0;

                # Listing every values stored in the array.
                for _ in "${pa_var_val_array[@]}"; do
                    BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_VALUE} [${v_index}] : ${_}";

                    # Storing the following value's index, in order to check if the fifth line is reached (processed in the following condition).
                    local v_value_line=$(( v_index + 1 ));

                    # Writing a blank line every five lines, in order to keep the list easily readable for a human.
                    if [ $(( v_value_line % 5 )) -eq 0 ]; then

                        local TEST_var_val_arr;

                        # shellcheck disable=SC2116
                        TEST_var_val_arr="$(echo "${pa_var_val_array[${#pa_var_val_array[@]} -1]}")";

                        echo "VALUE : ${TEST_var_val_arr}";

                        # Avoid line breaks when the end of the array is reached, if it's last index's modulo of five is equal to 0.
                        if [ "${i}" -eq "${pa_var_val_array[${#pa_var_val_array[@]} -1]}" ]; then BU.ModuleInit.Msg '' '-n';

                        else BU.ModuleInit.Msg;

                        fi
                    fi

                    v_index=$(( v_index + 1 ));
                done;

                BU.ModuleInit.Msg;

                local v_index=0;

			else
				BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__ARR_PROC_ARR_EMPTY}" '-' 'msg';
                BU.ModuleInit.Msg;
			fi
		else
            # shellcheck disable=SC2059
            BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_TYPE}" "${p_var_type}" "${v_type}")";
            BU.ModuleInit.Msg;

			# If a variable is stored in the processed variable.
			if [ -n "${p_var_val}" ]; then

				if [ "${p_var_type,,}" == 'cmd' ]; then
                    # shellcheck disable=SC2059
					BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_CMD}" "${p_var_name}")";
				else
                    # shellcheck disable=SC2059
					BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_NOT_CMD}" "${p_var_val}")";
				fi

			else
				BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__VAL_IS_EMPTY}" '-' 'msg';
            fi

			BU.ModuleInit.Msg;

			return 0;
		fi
	else
		return 0;
    fi
}

# Handling the initializer's messages. In case of an error, there's no need to call this function, as the error messages MUST be displayed.
function BU.ModuleInit.Msg()
{
    #**** Parameters ****
    local p_str=${1:-$'\0'};    # ARG TYPE : String     - OPTIONAL  | DEFAULT VAL : NULL    - DESC : The string to write.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL  | DEFAULT VAL : NULL    - DESC : The "echo" command's options.

    #**** Code ****
    # If the '--log-display' argument is passed as a 'module' parameter, then every messages must
    # be printed on the screen and redirected towards the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
    if [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" == '--log-display' ]; then

        # If no messages are stored in the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" array yet;
        if [ -z "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION[*]}" ]; then
            declare __BU_MODULE_INIT_MSG_ARRAY=();
        fi;

        case "${p_option,,}" in
            '-n' | 'n')
                # If no value is stored in the string parameter, it must not be interpreted as a newline, since the '-n' echo command's parameter forbids carriage returns.
                if [ -z "${p_str}" ]; then
                    __BU_MODULE_INIT_MSG_ARRAY+=(''); echo -ne '';

                # Else, if a value is stored in the string parameter, it must be printed on the screen, without carriage returns.
                else
                    # Printing the date before the text to log.
                    __BU_MODULE_INIT_MSG_ARRAY+=("${__BU_MODULE_INIT__DATE_LOG} ${p_str}");

                    echo -ne "${p_str}";
                fi;

                return 0;
            ;;
            '' | *)
                # If no value is stored in the string parameter, it must be interpreted as a newline.
                if [ -z "${p_str}" ]; then
                    __BU_MODULE_INIT_MSG_ARRAY+=('\n'); echo -e '';

                # Else, if a value is stored in the string parameter, it must be printed on the screen with carriage returns.
                else
                    # Printing the date before the text to log.
                    __BU_MODULE_INIT_MSG_ARRAY+=("${__BU_MODULE_INIT__DATE_LOG} ${p_str}\n");

                    echo -e "${p_str}";
                fi;

                return 0;
            ;;
        esac

    # Else, if the '--log-shut' argument is passed as a 'module' parameter, then every initialization
    # messages must be redirected towards the "/dev/null" virtual device file, and the array must be emptied.
    elif [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" == '--log-shut' ]; then
        return 0;

    # Else, if the '--log-shut-display' argument is passed as a 'module' parameter, then
    # every initialization messages must be redirected to the screen only, not to the array.
    elif [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" == '--log-shut-display' ]; then
        case "${p_option,,}" in
            '-n' | 'n')
                # If no value is stored in the string parameter, it must not be interpreted as a newline, since the '-n' echo command's parameter forbids carriage returns.
                if [ -z "${p_str}" ]; then
                    echo -ne '';

                # Else, if a value is stored in the string parameter, it must be printed on the screen, without carriage returns.
                else
                    echo -ne "${p_str}";
                fi

                return 0;;
            '' | *)
                # If no value is stored in the string parameter, it must be interpreted as a newline.
                if [ -z "${p_str}" ]; then
                    echo -e '\n';

                # Else, if a value is stored in the string parameter, it must be printed on the screen with carriage returns.
                else
                    # Printing the date before the text to log.
                    echo -e "${p_str}";
                fi

                return 0;
            ;;
        esac

    # Else, if the '--log-no-display' argument is passed as a 'module' parameter OR if the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable
    # stores no value (empty by default), then every initialization messages must be stored in the "${__BU_MODULE_INIT_MSG_ARRAY}" array without being printed on the screen.
    elif [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" == '--log-no-display' ] || [ -z "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" ]; then
        case "${p_option,,}" in
            '-n' | 'n')
                # If no value is stored in the string parameter, it must not be interpreted as a newline, since the '-n' echo command's parameter forbids carriage returns.
                if [ -z "${p_str}" ]; then
                    __BU_MODULE_INIT_MSG_ARRAY+=('');

                # Else, if a value is stored in the string parameter, it must be printed on the screen, without carriage returns.
                else
                    # Printing the date before the text to log.
                    __BU_MODULE_INIT_MSG_ARRAY+=("${__BU_MODULE_INIT__DATE_LOG} ${p_str}");
                fi

                    return 0;
                ;;
            '' | *)
                # If no value is stored in the string parameter, it must be interpreted as a newline.
                if [ -z "${p_str}" ]; then
                    __BU_MODULE_INIT_MSG_ARRAY+=('\n');

                # Else, if a value is stored in the string parameter, it must be printed on the screen with carriage returns.
                else
                    # Printing the date before the text to log.
                    __BU_MODULE_INIT_MSG_ARRAY+=("${__BU_MODULE_INIT__DATE_LOG} ${p_str}\n");
                fi

                return 0;
            ;;
        esac

    # Else, if an incorrect value is passed as "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable's value.
    else
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 1))" 'E_BUINIT__MSG__BAD_ARRAY_PERMISSION_VAL';

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__MSG__BAD_PERMISSION_1}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" >&2; echo >&2;

        echo "${__BU_MODULE_INIT_MSG__MSG__BAD_PERMISSION_2}" >&2;

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    fi

    return 0;
}

# Writing a text under a line with the same size.
function BU.ModuleInit.MsgLine()
{
    #**** Parameters ****
    local p_str=${1:-$'\0'};        # ARG TYPE : String     - OPTIONAL  | DEFAULT VAL : NULL    - DESC : String to write.
    local p_line=${2:-$'\0'};       # ARG TYPE : Char       - OPTIONAL  | DEFAULT VAL : NULL    - DESC : Line character.
    local p_context=${3:-'echo'};   # ARG TYPE : String     - OPTIONAL  | DEFAULT VAL : NULL    - DESC : Context of the function's call (should the text be processed by the "BU.ModuleInit.Msg" function or with a simple "echo" command ?).

    #**** Code ****
    if      [ "${p_context,,}" == 'echo' ]; then
        BU.ModuleInit.MsgLineCount "${#p_str}" "${p_line}" 'echo';
        echo "${p_str}";

    elif    [ "${p_context,,}" == 'msg' ]; then
        BU.ModuleInit.MsgLineCount "${#p_str}" "${p_line}" 'msg' || return 1;
        BU.ModuleInit.Msg "${p_str}" || return 1;
    fi

    return 0;
}

# Drawing a line with a character, that is the same lenght as a string, in order to separate the messagges from different steps.
function BU.ModuleInit.MsgLineCount()
{
    #**** Parameters ****
    local p_number=${1:-$'\0'};     # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of times the character has to be display.
    local p_line=${2:-$'\0'};       # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : NULL     - DESC : Line character.
    local p_context=${3:-'echo'};   # ARG TYPE : NULL   - REQUIRED | DEFAULT VAL : NULl     - DESC : Context of the function's call (should the text be processed by the "BU.ModuleInit.Msg" function or with a simple "echo" command ?).

    #**** Code ****
    if      [ "${p_context,,}" == 'echo' ]; then
        for ((i=0; i<p_number; i++)); do echo -n "${p_line}"; done; echo;

    elif    [ "${p_context,,}" == 'msg' ]; then
        for ((i=0; i<p_number; i++)); do BU.ModuleInit.Msg "${p_line}" '-n' || return 1; done; BU.ModuleInit.Msg || return 1;
    fi

    return 0;
}

# Writing a non-empty (and translated) string.
function BU.ModuleInit.MsgTranslate()
{
    if [ -n "${1}" ]; then
        echo "${1}";
    else
        if [ "${2,,}" == 'nofail' ]; then
            return 0;
        else
            echo "No message to translate";

            if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi;
        fi
    fi
}

# BU.ModuleInit.MsgTranslate "$(printf "TEST %s" "AS")";

# BU.ModuleInit.Msg "$(BU.ModuleInit.MsgTranslate "TEST 2")";
# BU.ModuleInit.Msg;

# Displaying a text when the script's execution must be stopped.
function BU.ModuleInit.MsgAbort() { echo >&2; echo "${__BU_MODULE_INIT_MSG__MSG_ABORT__ABORT}" >&2; echo >&2; return 0; }

# Pressing any key on the keyboard to do an action.

# shellcheck disable=SC2059
function BU.ModuleInit.PressAnyKey() { echo; read -n 1 -s -r -p "$(printf "${__BU_MODULE_INIT_MSG__PRESS_ANY_KEY__PRESS} %s" "${1}")"; echo; return 0; }

# Printing the initialization on the screen. Although this function is called if the '--log-display' value is passed with the
# "module" argument, this function could be used as a help, in case this value's parameters doesn't work in case of a rework.

# shellcheck disable=SC2129
function BU.ModuleInit.PrintLog()
{
    #**** Variables ****
    declare -i v_int_randomizer;    # VAR TYPE : Int        - DESC : This variable stores a random number between 3 and 6 included.

    local v_str_randomizer;         # VAR TYPE : String     - DESC : This string stores the randomized string which is written in the log file's name.
    local v_tmp_file;               # VAR TYPE : Filepath   - DESC : Path to the file which stores the content of the "${__BU_MODULE_INIT_MSG_ARRAY[@]}" array.

    #**** Code ****
    v_str_randomizer="$(echo "${RANDOM}" | md5sum)";
    v_str_randomizer="${v_str_randomizer%%+( -)}";

    # Adding some extra randomized numbers, a random number of times between 3 and 6 included.
    v_int_randomizer="$(shuf -i 3-6 -n 1)";

    for ((i=0; i<v_int_randomizer; i++)); do
        v_str_randomizer+="${v_str_randomizer%%+( -)}";
    done

    shopt -s extglob;

    # Removing the extra whitespace with the dash.
    v_tmp_file="$(printf "%s" "${__BU_MODULE_INIT__ROOT}/$(date +"%Y-%m-%d %H:%M:%S")")___${v_str_randomizer}.tmp"; shopt -u extglob;

    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__PRINTLOG__HERE}" '#' 'echo'; echo

    # If no value is stored in the log messages array, then the log messages display procedure is cancelled.
    if [ -z "${__BU_MODULE_INIT_MSG_ARRAY[*]}" ] || [ ${#__BU_MODULE_INIT_MSG_ARRAY[@]} -eq 0 ]; then
        echo "${__BU_MODULE_INIT_MSG__ASKPRINTLOG__NO_LOG_TO_DISPLAY}";
        echo; return 0;
    fi

    if [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ]; then
        echo "${__BU_MODULE_INIT_MSG__PRINTLOG__FULL_MODE}"; echo;

    elif [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-partial' ]; then
        echo "${__BU_MODULE_INIT_MSG__PRINTLOG__PARTIAL_MODE}"; echo;
    fi

    BU.ModuleInit.MsgLine "${__BU_MODULE_INIT_MSG__PRINTLOG__INITLOGS}" '-' 'echo';
    BU.ModuleInit.MsgLineCount "${#__BU_MODULE_INIT_MSG__PRINTLOG__INITLOGS}" '-' 'echo';
    echo '';

    echo "${__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_TITLE}";
    echo '';

	echo "${__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_ADVICE_IF_NO_LOGS_ARE_DISPLAYED}";
	echo '';

    BU.ModuleInit.PressAnyKey "${__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_CALL_PRESS_ANY_KEY_FNCT}";
    echo '';

    touch "${v_tmp_file}" || { echo >&2; echo "${__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_CANNOT_CREATE_TMP_FILE}" >&2; echo >&2; return 1; };

    echo "${__BU_MODULE_INIT_MSG__PRINTLOG__DISPLAY_LOGS_TITLE}" >> "${v_tmp_file}";
    echo >> "${v_tmp_file}";

    echo "${__BU_MODULE_INIT_MSG__PRINTLOG__DONT_PRESS_Q}" >> "${v_tmp_file}";
    echo >> "${v_tmp_file}";
    echo >> "${v_tmp_file}";

    for value in "${__BU_MODULE_INIT_MSG_ARRAY[@]}"; do
        # shellcheck disable=SC2059
        printf "${value##* ] }" >> "${v_tmp_file}";
    done

    less "${v_tmp_file}"; rm "${v_tmp_file}";

    echo; echo ">>>>> ${__BU_MODULE_INIT_MSG__PRINTLOG__POST_DISPLAY_TEXT}"; echo;

	# WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array, and it calls this function.

	return 0;
}

# Print an error message in the log storage variable.
function BU.ModuleInit.PrintLogError()
{
    #**** Parameters ****
    local p_file=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the error happened.
    local p_lineno=${2:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the error happened.
    local p_errcode=${3:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Error code, in order to find what kind of error happened.

    #**** Code ****
    if [ -z "${__BU_MODULE_INIT_MSG_ARRAY_EXISTS}" ]; then
        echo >&2;

        # No need to redefine the three arguments inside this sub-function, the scope of the current function's local variables reach the sub-functions called inside the current function.
        BU.ModuleInit.PrintLogErrorNoTranslationFilesSourced;
    else
        if [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION,,}" != '--log-shut-display' ]; then
            local v_msg_arr_mode_backup="${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}";

            __BU_MODULE_INIT_MSG_ARRAY_PERMISSION='--log-shut-display';
        fi

        BU.ModuleInit.Msg >&2;

        # shellcheck disable=SC2059
        BU.ModuleInit.MsgLine "$(printf "${__BU_MODULE_INIT_MSG__PRINTLOG_ERROR__PRINT_ERROR}" "${p_file}" "${p_lineno}" "${p_errcode}")" '-' 'echo' >&2;

        BU.ModuleInit.Msg >&2;

        if [ -n "${v_msg_arr_mode_backup}" ]; then __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${v_msg_arr_mode_backup}"; fi
    fi

    return 0;
}

# -----------------------------------------------

## FUNCTIONS NEEDED FOR THE MODULES INITIALIZATION

# Checking the currently used Bash language's version.
function BU.ModuleInit.CheckBashMinimalVersion()
{
	if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
		printf "BASH-UTILS MODULES INITIALIZATION ERROR : In \n\t%s,\n\tline $(( LINENO - 1 ))\n\n", "$(basename "${BASH_SOURCE[0]}")" >&2;
		echo -e "This Bash library requires at least the Bash language's version 4.0.0" >&2;
		echo >&2;

		echo -e "Your Bash version is : ${BASH_VERSION}" >&2;
		echo >&2

		echo -e "Please install at least the Bash version 4.0.0 to use this library" >&2;
		echo >&2;

		# WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY}" array.
		return 1;
	fi
}

# Check if the given path exists (This function is called by the "BU.ModuleInit.SourcingFailure()" function).
function BU.ModuleInit.CheckPath()
{
    #**** Parameters ****
    local p_path=${1:-NULL};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the target file or directory.
    local p_target=${2:-NULL};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Specify if the target is a directory or a file.
#    local p_findPath=${3:-NULL}     # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    if [ "${p_path^^}" == 'NULL' ]; then
        # shellcheck disable=SC2059
        printf "« ${__BU_MODULE_INIT_MSG__CHECKPATH__NO_FILE_PATH} »" >&2; return 0;

    else
        if [ "${p_target,,}" == 'NULL' ]; then
            echo  >&2;

            # shellcheck disable=SC2059
            printf "${__BU_MODULE_INIT_MSG__CHECKPATH__NO_TARGET_SPECIFICATION}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" >&2; echo >&2;

            # shellcheck disable=SC2059
            printf "${__BU_MODULE_INIT_MSG__CHECKPATH__PLEASE_SPECIFY_TARGET_SPECIFICATION}" "${FUNCNAME[0]}" >&2; echo >&2; return 1;
        else
            if [[ "${p_target}" == [D-d] ]]; then

                if [ -d "${p_path}" ]; then
                    printf "%s" "${p_path}"; return 0;

                else
                    printf "%s ${__BU_MODULE_INIT_MSG__CHECKPATH__DIR_NOT_FOUND}" "${p_path}" >&2; return 0;
                fi

            elif [[ "${p_target}" == [F-f] ]]; then

                if [ -f "${p_path}" ]; then
                    printf "%s" "${p_path}"; return 0;

                else
                    printf "%s ${__BU_MODULE_INIT_MSG__CHECKPATH__FILE_NOT_FOUND}" "${p_path}" >&2; return 0;
                fi
            else
                echo >&2;

                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__CHECKPATH__UNKNOWN_TARGET}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" "${p_target}" >&2; echo >&2; return 1;
            fi
        fi
    fi
}

# Getting the path returned by the "find" command, to make the directories and files searching case insensitive.
# shellcheck disable=SC2059
function BU.ModuleInit.FindPath()
{
    #**** Parameters ****
    local v_parentdir=${1:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Parent directory.
    local v_target=${2:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted directory or file.
    local v_targetType=${3:-$'\0'};     # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Getting the type of data to create (d : Directory ; f : File), for the "BU.ModuleInit.CheckPath()" function.
    local v_shut=${4:-$'\0'};           # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Shut the function's text output, when the function is used to find a file according to a certain pattern.
    local v_specific_var=${5:-$'\0'}    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Create a temporary file to store a specific path, for example if you check the existence of a file in a condition.

    #**** Variables ****
    local v_hasFailed;                  # VAR TYPE : String     - DESC : Ending the execution of the current function if an error occured during the execution of the "$(find)" command when a value is passed to the "${v_specific_var}" parameter.

    #**** Code ****
    [ "${v_targetType,,}" != 'd' ] && [ "${v_targetType,,}" != 'f' ] && v_targetType='NULL';

    find "${v_parentdir}" -maxdepth 1 -iname "${v_target}" -print 2>&1 | grep -v "Permission denied" || \
	{
        # If the "Bash-utils-root-val.path" was not found, its error management is skipped, since there may be a super-user privileged version called "Bash-utils-root-val-ROOT.path";
        if [ -z "${__BU_MODULE_INIT__TMP_VAR__FIND_PATH_FUNC_NO_ERR}" ]; then
            #**** Error management variables ****
            declare -i v_e_lineno="$(( LINENO - 2 ))";  # VAR TYPE : Int   - DESC : Storing the line where the last command has failed to execute correctly.

            #**** Error management code ****
            if [ -z "${__BU_MODULE_INIT_MSG_ARRAY_EXISTS}" ]; then
                if [ "${v_shut,,}" != 'shut' ]; then
                    echo >&2;

                    # If the "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}" directory is not defined yet, or if the current file is not a compiled version of the Bash Utils Framework,
                    # it means that the translation files are not sourced yet, so the messages to display are hard-coded in this file.
                    if [ -z "${__BU_MODULE_INIT_IS_TRANSLATION_FILES_SOURCED}" ] && ! BU.ModuleInit.IsFrameworkWrapped && ! BU.ModuleInit.IsFrameworkBeingInstalled; then
                        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_e_lineno}" 'E_BUINIT__FIND_PATH__ECHO_1__PATH_NOT_FOUND';

                        BU.ModuleInit.FindPathNoTranslationFilesSourced "${FUNCNAME[0]}" "${FUNCNAME[1]}" "${BASH_SOURCE[0]}" "${v_e_lineno}" 'echo';

                        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
                    else
                        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_e_lineno}" 'E_BUINIT__FIND_PATH__ECHO_2__PATH_NOT_FOUND';

                        printf "${__BU_MODULE_INIT_MSG__FIND_PATH__PATH_NOT_FOUND} --> %s/%s\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" "${v_parentdir}" "${v_target}" >&2; echo >&2;

                        printf "${__BU_MODULE_INIT_MSG__FIND_PATH__TOP_LEVEL_FUNCTION}\n" "${FUNCNAME[0]}" "${FUNCNAME[1]}" >&2;

                        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
                    fi
                fi

            else
                if [ "${v_shut,,}" != 'shut' ]; then declare -i lineno="${LINENO}";
                    BU.ModuleInit.Msg >&2;

                    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__FINDPATH__PATH_NOT_FOUND";

                    # If the "${__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH}" directory is not defined yet, or if the current file is not a compiled version of the Bash Utils Framework,
                    # it means that the translation files are not sourced yet, so the messages to display are hard-coded in this file.
                    if [ -z "${__BU_MODULE_INIT_IS_TRANSLATION_FILES_SOURCED}" ] && ! BU.ModuleInit.IsFrameworkWrapped && ! BU.ModuleInit.IsFrameworkBeingInstalled; then
                        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_e_lineno}" 'E_BUINIT__FIND_PATH__MSG_1__PATH_NOT_FOUND';

                        BU.ModuleInit.FindPathNoTranslationFilesSourced "${FUNCNAME[0]}" "${FUNCNAME[1]}" "${BASH_SOURCE[0]}" "${v_e_lineno}" 'echo';

                        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
                    else
                        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_e_lineno}" 'E_BUINIT__FIND_PATH__MSG_2__PATH_NOT_FOUND';

                        BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__FIND_PATH__PATH_NOT_FOUND} --> %s/%s\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" "${v_parentdir}" "${v_target}")" >&2; BU.ModuleInit.Msg >&2;

                        BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__FIND_PATH__TOP_LEVEL_FUNCTION}\n" "${FUNCNAME[0]}" "${FUNCNAME[1]}")" >&2;

                        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

                        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
                    fi
                fi
            fi

            v_hasFailed='failed';
        fi
	};

	if [ "${v_hasFailed}" == 'failed' ]; then echo "FAILED"; if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi; fi

	if [ -n "${v_specific_var}" ]; then
        if [ -n "${__BU_MODULE_INIT__TMP_DIR_PATH}" ]; then
            local v_tmpfile;

            v_tmpfile="${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.${v_specific_var}.tmp";

            if [ ! -f "${v_tmpfile}" ]; then touch "${v_tmpfile}"; fi

            echo "${v_parentdir}/${v_target}" > "${v_tmpfile}";

            return 0;
        else
            # This function is called when the "${__BU_MODULE_INIT__TMP_DIR_PATH}" is created, but at this point, the temporary directory doesn't exists yet, so this feature MUST be disabled UNTIL this directory is created.
            if [ -z "${__BU_MODULE_INIT__TMP_DIR_NAME}" ]; then
                # Creating a variable to store the path of the file, if this value needs to be processed externally.
                __BU_MODULE_INIT__FIND_PATH_RETVAL="${v_parentdir}/${v_target}"; echo "${__BU_MODULE_INIT__FIND_PATH_RETVAL}" > "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.tmp";

                return 0;
            fi
        fi
    fi

	return 0;
}

# Getting the module's name from a subdirectory (this function is called in the main module's "module.conf" configuration file).
function BU.ModuleInit.GetModuleName()
{
    v_module="$(cd "$(dirname "${1}")" || { local lineno="${LINENO}";
        echo >&2;

        # shellcheck disable=SC2059
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__GETMODULE_NAME__MODULE_NOT_FOUND";

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__GET_MODULE_NAME__UNABLE_TO_GET}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" >&2; echo >&2;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    }; pwd -P)";

    echo "${v_module##*/}"; return 0;
}

# Listing all the installed modules if the developer mistyped the module's name at the beginning of the main project's script.

# shellcheck disable=SC2059
function BU.ModuleInit.ListInstalledModules()
{
    #**** Variables ****
    local v_module_tmp_d;   # VAR TYPE : Dirpath    - DESC : Path to the temporary folder which stores the files created in this function.

    local v_module_conf_f;  # VAR TYPE : Filepath   - DESC :
    local v_module_diff_f;  # VAR TYPE : Filepath   - DESC :
    local v_module_init_f;  # VAR TYPE : Filepath   - DESC :

    #**** Code ****
    v_module_tmp_d="${__BU_MODULE_INIT__ROOT}/${__BU_MODULE_INIT__TMP_DIR_NAME}";

    v_module_conf_f="${v_module_tmp_d}/BU_modules_config_dir.out";
    v_module_diff_f="${v_module_tmp_d}/BU_modules_init_diff.out";
    v_module_init_f="${v_module_tmp_d}/BU_modules_init_dir.out";

    if [ ! -d "${v_module_tmp_d}" ]; then
        mkdir -p "${v_module_tmp_d}" ||
		{
            BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__LIST_INSTALLED_MODULES__UNABLE_TO_CREATE_TMPDIR";

			printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNABLE_TO_CREATE_TMP_DIR}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 4 ))" "${__BU_MODULE_INIT__ROOT}" >&2; echo >&2;

			echo "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNABLE_TO_CREATE_TMP_DIR__ADVICE}" >&2; echo >&2;

            BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

            if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
		}
    fi

    if [ -d "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}" ] && [ -d "${__BU_MODULE_INIT__MODULES_DIR}" ]; then

																				# In case the "ls" command points towards a bad path because of a bad variable's value.
        ls -1 "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}"    > "${v_module_conf_f}"  || { echo >&2; printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNEXISTENT_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" >&2; echo >&2; BU.ModuleInit.AskPrintLog >&2 || return 1; return 1; };
        ls -1 "${__BU_MODULE_INIT__MODULES_DIR}"            > "${v_module_init_f}"  || { echo >&2; printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__UNEXISTENT_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}" >&2; echo >&2; BU.ModuleInit.AskPrintLog >&2 || return 1; return 1; };

        if diff "${v_module_conf_f}" "${v_module_init_f}" > "${v_module_diff_f}"; then
            echo; echo "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__INSTALLED_MODULES_LIST} :"; echo; sleep ".5";

            # Displaying the content of the file which stores both the found modules configuration folders and the the modules initialization folders.
            cat "${v_module_conf_f}"; echo; sleep 1;
        else
            echo >&2;

            printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__ONE_OR_MORE_MODULES_MISSING}\n" "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}" "${__BU_MODULE_INIT__MODULES_DIR}" >&2; echo >&2;

            echo "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__MODULES_CONFIGURATION_FOLDER_LIST} :" >&2; echo >&2;

            # Displaying the content of the file which stores the found modules configuration folders.
            cat "${v_module_conf_f}" >&2; echo >&2;

            echo "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__MODULES_INITIALIZATION_FOLDER_LIST} :" >&2; echo >&2;

            # Displaying the content of the file which stores the found modules initialization folders.
            cat "${v_module_init_f}"; echo >&2; echo >&2;

			# Getting the differences between the two files.
			echo "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__LISTED_MODULES_DIFFERENCES_BELOW}" >&2; echo >&2;

			# Printing the differences between the two generated files.
			sdiff "${v_module_conf_f}" "${v_module_conf_f}"; echo >&2;
        fi
    else
        if [ ! -d "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}" ] && [ ! -d "${__BU_MODULE_INIT__MODULES_DIR}" ]; then
            printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__BOTH_CONF_AND_INIT_FOLDER_ARE_MISSING}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" >&2;

        elif [ -d "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}" ]; then
            printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__CONF_FOLDER_IS_MISSING}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" >&2;

        elif [ -d "${__BU_MODULE_INIT__MODULES_DIR}" ]; then
            printf "${__BU_MODULE_INIT_MSG__LIST_INSTALLED_MODULES__INIT_FOLDER_IS_MISSING}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" >&2;
        fi

		echo >&2;
    fi

    BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
}

# Printing an error message if a file cannot be sourced.

# shellcheck disable=SC2059
function BU.ModuleInit.SourcingFailure()
{
    #**** Parameters ****
    local p_path=${1:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file that cannot be sourced.
    local p_module=${2:-NULL};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the module.
    local p_file=${3:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the inclusion failed.
    local p_func=${4:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function where the inclusion failed.
    local p_line=${5:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the inclusion failed.

    #**** Code ****
    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${LINENO}" 'E_BUINIT__SOUCING_FAILURE';

    if [ "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" != '--log-shut-display' ]; then local v_msg_arr_mode_backup="${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}"; __BU_MODULE_INIT_MSG_ARRAY_PERMISSION='--log-shut-display'; fi

    BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__SOURCING_FAILURE__UNABLE_TO_SOURCE}" "${p_file}" "${p_func}" "${p_line}" "${p_module}" "$(BU.ModuleInit.CheckPath "${p_path}" 'f')")" >&2; BU.ModuleInit.Msg >&2;

    if [ -n "${v_msg_arr_mode_backup}" ]; then __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${v_msg_arr_mode_backup}"; fi

    BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
}

# -----------------------------------------------

## FUNCTIONS NEEDED FOR THE MODULES PROCESSING

# Usage function
function BU.ModuleInit.Usage()
{
    echo >&2; echo "${__BU_MODULE_INIT_MSG__USAGE__SUPVALS}" >&2;
    echo >&2;

	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG}";
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_DISPLAY}" >&2;
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_NO_DISPLAY}" >&2;
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_SHUT}" >&2;
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_LOG_SHUT_DISPLAY}" >&2;
	echo >&2;

	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG}";
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG_FULL}" >&2;
	echo "${__BU_MODULE_INIT_MSG__USAGE__INCOMPATIBLE_VALS_MODE_LOG_PARTIAL}" >&2;
	echo >&2

	echo "${__BU_MODULE_INIT_MSG__USAGE__DEBUG_VALUES_LIST}" >&2;
    echo "${__BU_MODULE_INIT_MSG__USAGE__DEBUG}" >&2;
    echo "${__BU_MODULE_INIT_MSG__USAGE__DEBUG_BASHX}" >&2;
}

# Easy writing status error.
function BU.ModuleInit.DisplayStatError()
{
    #**** Parameters ****
    local p_file=${1:-NULL};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called (mainly from the "BU.Main.StatusCheckSTAT<...>()" functions).
    local p_lineno=${2:-NULL};      # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called (mainly from the "BU.Main.StatusCheckSTAT<...>()" functions).
    local p_bad_value=${3:-NULL};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Bad value passed as "BU.Main.StatusCheckSTAT<...>()" function's argument.
    local p_var_name=${4:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the variable that stores the bad value.

    # Shifting the same number of time as the former arguments number
    # to avoid including these arguments values in the allowed values array.
    shift 4;
    local pa_correctValues=("${@}");

    #**** Variables ****
    local i=0;

    #**** Code ****
    echo "AN ERROR OCCURED DURING THIS STATUS VARIABLE CHECKING --> ${p_var_name}" >&2;
    printf "In « %s », line « %s »" "${p_file}" "${p_lineno}" >&2;
    echo "Error : the « %s » variable's value is incorrect." "${p_var_name}" >&2;

    if [ "${p_bad_value^^}" == 'NULL' ]; then
        echo >&2; echo "Bad value : 'An empty string'" >&2;
    else
        echo >&2; EchoError "Bad value : « %s »" "${p_bad_value}" >&2;
    fi

    echo "The allowed values are :" >&2;

    # Displaying the list of every allowed arguments.
    for val in "${pa_correctValues[@]}"; do
        i=$(( i + 1 ));

        # If an empty argument is allowed.
        if [ -z "${val}" ]; then
            echo "%s/%s --> 'An empty argument'" "${i}" "${#pa_correctValues[@]}" >&2;
        else
            echo "%s/%s  --> %s" "${i}" "${#pa_correctValues[@]}" "${val}" >&2;
        fi
    done

    echo >&2;

    return 1;
}

# Checking the "${__BU_MODULE_INIT_STAT_DEBUG}" status variable's value.
function BU.ModuleInit.CheckSTAT_DEBUG()
{
    #**** Parameters ****
    local p_file=${1:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${2:-NULL};  # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("true" "false");    # VAR TYPE : Bool   - DESC :

    #**** Code ****
    if [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" != "true" ] && [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" != "false" ]; then
        BU.ModuleInit.DisplayStatError "${p_file}" "${p_lineno}" "${__BU_MODULE_INIT_STAT_DEBUG}" "__BU_MODULE_INIT_STAT_DEBUG" "${va_correctValues[@]}"; return "${?}";
    fi

    return 0;
}

# Checking the "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" status variable's value.
function BU.ModuleInit.CheckSTAT_DEBUG_BASHX()
{
    #**** Parameters ****
    local p_file=${1:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${2:-NULL};  # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("${__BU_MODULE_INIT__BASHX_DEBUG_VALS_ARRAY[@]}");
    local v_ArrayValueFound;

    #**** Code ****
    [[ ${va_correctValues[*]} =~ ${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,} ]] && { v_ArrayValueFound='true'; return 0; };

    if [ "${v_ArrayValueFound,,}" != 'true' ]; then BU.ModuleInit.DisplayStatError "${p_file}" "${p_lineno}" \
            "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" "__BU_MODULE_INIT_STAT_DEBUG_BASHX" "${va_correctValues[@]}"; return "${?}"; fi

    return 0;
}

# Changing the "${__BU_MODULE_INIT_STAT_DEBUG}" status variable's value.
function BU.ModuleInit.ChangeSTAT_DEBUG()         { __BU_MODULE_INIT_STAT_DEBUG="${1}";         BU.ModuleInit.CheckSTAT_DEBUG         "${2}" "${3}" || return "${?}"; return 0; }

# Changing the "${__BU_MODULE_INIT_STAT_DEBUG}" status variable's value.
function BU.ModuleInit.ChangeSTAT_DEBUG_BASHX()   { __BU_MODULE_INIT_STAT_DEBUG_BASHX="${1}";   BU.ModuleInit.CheckSTAT_DEBUG_BASHX   "${2}" "${3}" || return "${?}"; return 0; }

# Checking if the debug mode is active.
function BU.ModuleInit.CheckIsDebugging()         { [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" == 'true' ] && return 0; return 1; }

# Processing the "module" value's parameters.

# shellcheck disable=SC1090
function BU.ModuleInit.ProcessFirstModuleParameters()
{
    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module to include passed as argument, with its own parameters.
    local p_count=${2:-$'\0'};  # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Counting the times the function was called in the "BashUtils_InitModules" function's main loop.

    #**** Variables ****
    local v_module_name;        # VAR TYPE : String     - DESC : Name of the module without its parameters.
    local v_loop_error;         # VAR TYPE : String     - DESC : This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #**** Code ****
    v_module_name="$(echo "${p_module}" | cut -d' ' -f1)";

    # -----------------------------------------------

    ## PROCESSING THE 'module' VALUE'S ARGUMENTS VALUES

    # Checking if the "module --" value is passed as first argument, in order to configure immediately the initialization language and the authorization to display the initialization logs on the screen.

    # These numbers stored in the "${p_count}" variable refer to the modules indexes.
    if [ "${p_count}" -eq 0 ]; then

        # If the "module" value is passed without parameters.
        if [[ "${p_module}" == "${v_module_name}" ]]; then
            # shellcheck disable=SC2059
            BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__NO_OPTS";

            # shellcheck disable=SC2059
            printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_NO_OPTS}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( BASH_LINENO - 5 ))" >&2; echo >&2;

            echo "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_NO_OPTS__ADVICE}" >&2;

            BU.ModuleInit.MsgAbort;

            BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

            if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

        elif [[ "${p_module}" == 'module --'* ]]; then

            # Creating a new global variable to store the word array made with the "module" value and the values that come with it.
            read -ra module_array <<< "${p_module}";

			# Unsetting the "module" value from the newly created array, in order to avoid an "unsupported argument" error.
			unset "module_array[0]";

            # -----------------------------------------------

            ## MODULE : DEFINING RESOURCES FOR THE « module » ARGUMENTS PROCESSING

            # Defining a function to optimize the displaying of errors for the 3 "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable's accepted values.
            function BU.ModuleInit.ProcessFirstModuleParameters.LogPermissionWarningOptimize()
            {
                #**** Parameters ****
                local p_value=${1:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New value to assign to the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable.

                #**** Code ****
                # If the current value AND the new value are the same.
                if [ "${p_value}" == "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" ]; then
                    # shellcheck disable=SC2059
                    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__LPWO__SAME_MSG_ARRAY_PERM_PASSED_TWICE";

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__SAME_MSG_ARRAY_PERM_PASSED_TWICE}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))" "${p_value}" >&2;

                    echo >&2; return 1;
                else
                    # shellcheck disable=SC2059
                    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED";

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED__ADVICE_1}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))" >&2; echo >&2;
                    echo "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED__ADVICE_2}" >&2; echo >&2

                    echo "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_EXTRA_INFO}" >&2; echo >&2;

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_CURRENT_VAL}\n" "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" >&2;

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__LPWO__DIFF_MSG_ARRAY_PERM_PASSED_NEW_VAL}\n" "${p_value}" >&2;

                    echo >&2; return 1;
                fi
            }

            # Processing the list of arguments for the "module" module.
            for module_args in "${module_array[@]}"; do

                # -----------------------------------------------

                ## "DEBUG" AND "DEBUG_BASHX" STATUS VARIABLES

                # Creating a function to print the correct values for the current option in different languages structures.
                function BU.ModuleInit.ProcessFirstModuleParameters.ProcessBadStatusOptionValues()
                {
                    # shellcheck disable=SC2059
                    BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__PBSOV__MSG}" "${1}" "${2}")" >&2;
                    BU.ModuleInit.Msg >&2;
                }

                # Else, if the "module" parameter's value is a debug value : '--stat-debug=false', '--stat-debug=true'
                if [[ "${module_args,,}" == *'--stat-'* ]]; then
                    #**** Condition variables ****
					local value;    # VAR TYPE : String     - DESC :

                    #**** Condition code ****
                    case "${module_args,,}" in

                        # "${__BU_MODULE_INIT_STAT_DEBUG" global status variable.
                        '--stat-debug='*)
							value="${module_args#*=}";
							value="${value% *}";

                            if      [ "${value,,}" == 'false' ]                                  || [ "${value,,}" == 'true' ]; then
                                    __BU_MODULE_INIT_STAT_DEBUG="${value}";                     BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT_STAT_DEBUG' "${__BU_MODULE_INIT_STAT_DEBUG}" 'bool' "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG__ARG_HAS_AWAITED_VAL}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";
                            else
                                BU.ModuleInit.ProcessFirstModuleParameters.ProcessBadStatusOptionValues "--stat-debug" "\n    --stat-debug=false\n    --stat-debug=true" || { v_loop_error='error'; break; };
                            fi
                        ;;

                        # "${__BU_MODULE_INIT_STAT_DEBUG_BASHX" global status variable.
                        '--stat-debug-bashx='*)
							value="${module_args#*=}";
							value="${value% *}";

                            if BU.ModuleInit.CheckIsDebugging; then
                                if      [[ "${value,,}" == c?(at?(eg?(ory))) ]] \
									||  [[ "${value,,}" == c?(at?(eg?(orie)))?(s) ]] \
									||  [[ "${value,,}" == fi?(l?(e))?(s) ]] \
									||  [[ "${value^^}" == FN?(C?(T))?(S) ]] \
									||  [[ "${value,,}" == fun?(c?(t?(ion))?(s)) ]] \
									||  [[ "${value,,}" == m?(od?(ule))?(s) ]] \
									||  [[ "${value,,}" == s?(ub)?(-)c?(at?(eg?(ory))) ]] \
									||  [[ "${value,,}" == s?(ub)?(-)?(c?(at?(eg?(orie)))?(s)) ]]; then

                                    __BU_MODULE_INIT_STAT_DEBUG_BASHX="${value}";               BU.ModuleInit.DisplayInitGlobalVarsInfos  '__BU_MODULE_INIT_STAT_DEBUG_BASHX' "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" 'String' "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__ARG_HAS_AWAITED_VAL}"            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                                elif    [ "${value,,}" == 'void' ]; then
                                    __BU_MODULE_INIT_STAT_DEBUG_BASHX='';                       BU.ModuleInit.DisplayInitGlobalVarsInfos  '__BU_MODULE_INIT_STAT_DEBUG_BASHX' "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" 'String' "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__ARG_HAS_AWAITED_VAL__VOID}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                                else
                                    BU.ModuleInit.ProcessFirstModuleParameters.ProcessBadStatusOptionValues "--stat-debug-bashx" "\n    --stat-debug-bashx=category\n    --stat-debug-bashx=file\n    --stat-debug-bashx=function\n    --stat-debug-bashx=module\n    --stat-debug-bashx=sub-category" || { v_loop_error='error'; break; };
                                fi
                            else
                                BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__DEBUG_BASHX__STAT_DEBUG_ARG_NOT_TRUE}";
                                BU.ModuleInit.Msg;
                            fi
                        ;;

                        *)
                            #**** Error management variables ****
                            declare -i lineno="$(( LINENO - 1 ))";  # VAR TYPE : Int    - DESC :

                            #**** Error management code ****
                            value="${module_args#* }";
                            value="${value% *}";

                            # shellcheck disable=SC2059
                            printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VALS_CHECK_LOOP__STAT__STAT_IS_NOT_SUPPORTED}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${lineno}" "${value}" >&2;
                            echo >&2;

                            return 1;
                        ;;
                    esac

                # -----------------------------------------------

                ## MODULE : LOG MESSAGES PROCESSING

                # Else, if the "module" parameter's value is a log redirection parameter : '--log-display', '--log-shut' or '--log-shut-display'.

				# WARNING : these arguments are incompatible with each other, adding a new value will overwrite the former one.
                elif [[ "${module_args,,}" == *'--log-'* ]]; then

					case "${module_args,,}" in

						# Log value : --log-display (printing the initialization messages on the screen while they are appened to the "${__BU_MODULE_INIT_MSG_ARRAY" array).
						'--log-display' | '--log-no-display')
							# Handling the incompatibility with each other '--log-display', '--log-no-display', '--log-shut' and '--log-shut-display' arguments
							# by checking if the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable already contains a value.
							if [ -n "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" ]; then
								BU.ModuleInit.ProcessFirstModuleParameters.LogPermissionWarningOptimize "${module_args}";
							fi

                            # By default, the initialization process doesn't prints the log messages, unless there's an error (this printing cannot be avoided).
                            # To print the initialization logs on the screen, you have to pass the '--log-display' argument when you pass the "module" value as first argument
                            __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${module_args}";
                            echo "INDEX LIST : ${#__BU_MODULE_INIT_MSG_ARRAY[*]}";
                        ;;

						# Log value : --log-shut (don't print the initialization messages on the screen, nor append them into the "${__BU_MODULE_INIT_MSG_ARRAY" array).
						'--log-shut')
                            # Handling the incompatibility with each other '--log-display', '--log-no-display', '--log-shut' and '--log-shut-display' arguments
							# by checking if the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable already contains a value.
							if [ -n "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" ]; then
                                BU.ModuleInit.ProcessFirstModuleParameters.LogPermissionWarningOptimize "${module_args}";
                            fi

                            # If this argument is passed, no initialization messages will be logged in the "${__BU_MODULE_INIT_MSG_ARRAY}" variable,
                            # the existing logged messages will be erased, and no initialization messages will be displayed, unless it's an error message.
                            __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${module_args}";

                            # Erasing the content of the "${__BU_MODULE_INIT_MSG_ARRAY" variable, since it's no more useful.
                            unset __BU_MODULE_INIT_MSG_ARRAY;
                        ;;

						# Log value : --log-shut-display (print the initialization messages on the screen without appening them into the "${__BU_MODULE_INIT_MSG_ARRAY" array).
						'--log-shut-display')
							# Handling the incompatibility with each other '--log-display', '--log-no-display', '--log-shut' and '--log-shut-display' arguments
							# by checking if the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION" global variable already contains a value.
							if [ -n "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" ]; then
                                BU.ModuleInit.ProcessFirstModuleParameters.LogPermissionWarningOptimize "${module_args}";
							fi

                            # If this argument is passed, no initialization messages will be logged in the "${__BU_MODULE_INIT_MSG_ARRAY}" variable,
                            # but all the log messages will be displayed on the screen.
                            __BU_MODULE_INIT_MSG_ARRAY_PERMISSION="${module_args}";
                        ;;

						# An unsupported log argument is passed.
						*)
                            #**** Error management variables ****
                            declare -i lineno="$(( LINENO - 1 ))"   # VAR TYPE : Int    - DESC :

                            local v_unsupported_log_param;          # VAR TYPE : String | DESC :

                            #**** Error management code ****
                            v_unsupported_log_param="$(printf "%s" "${module_args}" | sed "s/^[^ ]* //")";

                            # shellcheck disable=SC2059
							BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_VAL_LOG_OPT_UNSUPPORTED_VAL";

							# shellcheck disable=SC2059
							printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_LOG_OPT_UNSUPPORTED_VAL}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 5 ))" "${v_unsupported_log_param}" >&2; echo >&2;

							# shellcheck disable=SC2059
							printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_LOG_OPT_UNSUPPORTED_VAL__ADVICE}\n" "${p_count}" >&2;

							BU.ModuleInit.Usage;

							BU.ModuleInit.MsgAbort;

							BU.ModuleInit.AskPrintLog >&2 || { v_loop_error='error'; break; }

							v_loop_error='error'; break;
                        ;;
					esac

                # -----------------------------------------------

                ## MODULE : MODES PROCESSING

				# Else, if the "module" parameter's value is a logging option : "--mode-log-full" or "--mode-log-partial".

				# WARNING : these arguments are incompatible with each other, adding a new value will overwrite the former one.
                elif [[ "${module_args,,}" == '--mode-'* ]]; then

					case "${module_args,,}" in

						# Setting the "${__BU_MODULE_INIT_MSG_ARRAY_MODE" global variable to '--mode-log-full', in order to print every initialization messages, and not only the essential initialization messages.
						'--mode-log-full')
							__BU_MODULE_INIT_MSG_ARRAY_MODE="${module_args}";

							# Displaying the initialization messages already appened in the "${__BU_MODULE_INIT_MSG_ARRAY" global variable.
							BU.ModuleInit.DisplayInitGlobalVarsInfos__DisplayInitializedGlobalVarsInfos;;

						# Setting the "${__BU_MODULE_INIT_MSG_ARRAY_MODE" global variable to '--mode-log-partial', in order to print the essential initialization messages only (already set by default).
						'--mode-log-partial')
							__BU_MODULE_INIT_MSG_ARRAY_MODE="${module_args}";

                            # Unsetting every unsused string variables in order to free up some memory.

                            # shellcheck disable=SC2046
                            unset $(compgen -v "__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__DIGVI__")
                        ;;

						# An unsupported mode argument is passed.
						*)
                            #**** Error management variables ****
                            declare -i lineno="$(( LINENO - 1 ))";  # VAR TYPE : Int    - DESC :

                            local v_unsupported_log_param;          # VAR TYPE : String | DESC :

                            #**** Error management code ****
                            v_unsupported_log_param="$(printf "%s" "${module_args}" | sed "s/^[^ ]* //")";

                            # shellcheck disable=SC2059
							BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_VAL_MODE_LOG_OPT_UNSUPPORTED_VAL";

							# shellcheck disable=SC2059
							printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_MODE_LOG_OPT_UNSUPPORTED_VAL}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" "${v_unsupported_log_param}" >&2; echo >&2;

							# shellcheck disable=SC2059
							printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_VAL_MODE_LOG_OPT_UNSUPPORTED_VAL__ADVICE}\n" "${p_count}" >&2;

							BU.ModuleInit.Usage;

							BU.ModuleInit.MsgAbort;

							BU.ModuleInit.AskPrintLog >&2 || { v_loop_error='error'; break; }

							v_loop_error='error'; break;
                        ;;
					esac

                # -----------------------------------------------

                ## MODULE : HANDLING UNSUPPORTED ARGUMENTS

                # Else, if the "module" value's argument is not a supported one.
                else
                    #**** Error management variables ****
                    declare -i lineno="$(( LINENO - 1 ))";  # VAR TYPE : Int    - DESC

                    local v_unsupported_log_param;          # VAR TYPE : String | DESC

                    #**** Error management code ****
                    v_unsupported_log_param="$(printf "%s" "${module_args}" | sed "s/^[^ ]* //")";

                    # shellcheck disable=SC2059
                    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_GEN_OPT_UNSUPPORTED_VAL";

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_GEN_OPT_UNSUPPORTED_VAL}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" "${v_unsupported_log_param}" >&2; echo >&2;

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_GEN_OPT_UNSUPPORTED_VAL__ADVICE}\n" "${p_count}" >&2;

                    BU.ModuleInit.Usage;

                    BU.ModuleInit.MsgAbort;

                    BU.ModuleInit.AskPrintLog >&2 || { v_loop_error='error'; break; };

                    v_loop_error='error'; break;
                fi
            done; if [ "${v_loop_error,,}" == 'error' ]; then if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi; fi

            # Sourcing the "Status.conf" file, and then modifying the sourced global status variables values.
            if ! BU.ModuleInit.IsFrameworkWrapped && ! source "${__BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS}"; then echo >&2;
                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE__SOURCE_STATUS_CONF_FILE__ERROR}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))"; echo >&2; return 1;
            else
                # shellcheck disable=SC2059
                BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE__SOURCE_STATUS_CONF_FILE__SUCCESS}" "${__BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS}")";
                BU.ModuleInit.Msg;
            fi

            # Creating a global variable to store a value which proves that the 'module --*' value was passed as first argument, for the condition which checks if the 'main' module is passed as second argument.
            __BU_MODULE_INIT_MODULE_FIRST_ARG='true';

        fi

    # -----------------------------------------------

    ## HANDLING OTHER MODULES, AFTER THE 'module' VALUE AND THE 'main' MODULE PASSING

    # Else, if the "main" module is passed as second argument, after the "module" value.

    # Note : the « main » value is made case insensitive, in order to support uppercase and lowercase arguments.
    elif [ "${p_count}" -eq 1 ] && [ -n "${__BU_MODULE_INIT_MODULE_FIRST_ARG}" ] && [[ "${p_module,,}" == 'main' ]] || [[ "${p_module}" == [Mm][Aa][Ii][Nn][[:space:]]--* ]]; then

        __BU_MODULE_INIT_IS_MAIN_MODULE_INITIALIZED='true';

        # Since the arguments processings are made in the "main" module's initializer, the function can be exited.
        return 0;

    # -----------------------------------------------

    ## 'module' VALUE NOT PASSED, BUT 'main' MODULE PASSED AS FIRST ARGUMENT

    # Else, if the "module --*" value is not passed as first argument.

    # Checking if the "main" module is passed as first argument, in order to avoid unexpected bugs during the other modules' initialization process.

    # Note : the « main » value is made case insensitive, in order to support uppercase and lowercase arguments.
    elif [ "${p_count}" -eq 0 ] && [[ "${p_module,,}" == 'main' ]] || [[ "${p_module}" == [Mm][Aa][Ii][Nn][[:space:]]--* ]]; then

        __BU_MODULE_INIT_IS_MAIN_MODULE_INITIALIZED='true';

        # Since the arguments processings are made in the "main" module's initializer, the function can be exited.
        return 0;

    # -----------------------------------------------

    ## MISSING 'main' MODULE AFTER THE 'module' VALUE

    # Else, if the the "module --" value is passed as first argument, but the "main" module is missing.

    # Note : the « main » value is made case insensitive, in order to support uppercase and lowercase arguments.
    elif [ "${p_count}" -ge 1 ] && [[ ( -n "${__BU_MODULE_INIT_MODULE_FIRST_ARG}" ) && ( -z "${__BU_MODULE_INIT_IS_MAIN_MODULE_INITIALIZED}" ) ]] && [[ ("${p_module,,}" != 'main') || ( "${p_module}" != [Mm][Aa][Ii][Nn][[:space:]]--* ) ]]; then
        # shellcheck disable=SC2059
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_PARAM_PASSED_MAIN_MODULE_MISSING";

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_MAIN_MODULE_MISSING}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))" >&2; echo >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_MAIN_MODULE_MISSING__ADVICE}\n" "${v_module_name}" "${FUNCNAME[0]}" >&2;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

        return 1;

	# -----------------------------------------------

    ## 'Main' MODULE PASSED AS FIRST ARGUMENT, BUT BEFORE THE 'module' VALUE

	# Else, if the "main" module is passed as first argument, BUT before the "module --*" value.

	elif [ "${p_count}" -ge 1 ] && [ -n "${__BU_MODULE_INIT_IS_MAIN_MODULE_INITIALIZED}" ] && [[ "${p_module,,}" == "module --"* ]]; then
        # shellcheck disable=SC2059
		BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_PARAM_PASSED_AFTER_MAIN_MODULE";

		# shellcheck disable=SC2059
		printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_AFTER_MAIN_MODULE}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))" >&2;
		echo >&2; echo "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_PARAM_PASSED_AFTER_MAIN_MODULE__ADVICE}" >&2;

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

    # -----------------------------------------------

    ## HANDLING OTHER MODULES, AFTER THE 'module' VALUE OR THE 'main' MODULE PASSING

    # Else, if the count is superior to 0 or 1, then the function'e execution is stopped.
    elif [ "${p_count}" -ge 1 ]; then

        return 0;

    # -----------------------------------------------

    ## NO 'module' AND 'main' PASSED AS FIRST, THEN AS SECOND ARGUMENTS

    else
        # shellcheck disable=SC2059
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__PROCESS_FIRST_MODULE_PARAMETERS__MODULE_AND_MAIN_PARAMS_MISSING";

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_AND_MAIN_PARAMS_MISSING}\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))" >&2;
        echo >&2; echo "${__BU_MODULE_INIT_MSG__PROCESS_FIRST_MODULE_PARAMS__MODULE_AND_MAIN_PARAMS_MISSING__ADVICE}" >&2;

        BU.ModuleInit.MsgAbort;

        echo >&2; BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    fi

    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BEGIN INITIALIZATION PROCESS

## CHECKING IF THE CURRENT SHELL IS BASH

# shellcheck disable=SC2009
if ! ps -a | grep -E "${$}" | grep "bash" > /dev/null; then
    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'de' ] && echo "BASH-UTILS ERROR : Ihr aktueller Shell-Interpreter ist nicht der « Bash » Interpreter, sondern der « ${SHELL##*/} » Interpreter" >&2 && echo >&2;
    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'en' ] && echo "BASH-UTILS ERROR : Your current shell interpreter is not the « Bash » interpretor, but the « ${SHELL##*/} » interpretor" >&2 && echo >&2;
    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'es' ] && echo "ERROR BASH-UTILS : Su intérprete de shell actual no es el intérprete « Bash », sino el intérprete « ${SHELL##*/} »" && echo >&2;

    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'fr' ] && echo "ERREUR DE BASH-UTILS : Votre interpréteur shell actuel n'est pas l'interpréteur « Bash », mais l'interpréteur « ${SHELL##*/} »" >&2 && echo >&2;
    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'pt' ] && echo "BASH-UTILS ERRO : O seu intérprete shell actual não é o intérprete « Bash », mas o intérprete « ${SHELL##*/} »" >&2 && echo >&2;
    [ "$(echo "${LANG}" | cut -d _ -f1)" == 'ru' ] && echo "ОШИБКА « BASH-UTILS » : Ваш текущий интерпретатор оболочки - это не интерпретатор « Bash », а интерпретатор « ${SHELL##*/} »" >&2 && echo >&2;

	# WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY" array.
    BU.ModuleInit.IsInScript && exit 1; return 1;
fi

# -----------------------------------------------

## CHECKING THE CURRENT VERSION OF THE LANGUAGE

# Checking the version of the Bash language currently used on the user's system.
BU.ModuleInit.CheckBashMinimalVersion || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

# -----------------------------------------------

## CALLING THE TRAPS RESOURCES

BU.ModuleInit.DefineTraps;

# -----------------------------------------------

## DEFINING GLOBAL VARIABLES

# Defining a function in order to suppress every shellcheck advices about the "printf" command, in order to do so at once AND to keep the code's decoration.

# shellcheck disable=SC2059,SC2016
function BU.ModuleInit.DefineBashUtilsGlobalVariablesBeforeInitializingTheModules()
{
    #**** Code ****

    # PID
    __BU_MODULE_INIT__PROJECT_PID="${$}";
    __bu_module_init__project_pid__lineno="$(( LINENO - 1 ))";

    # -------------------------------------------

    ## FINDING THE ".Bash-utils" FOLDER'S PARENT DIRECTORY

    __BU_MODULE_INIT__ROOT_HOME="${HOME}";
    __bu_module_init__root_home__lineno="$(( LINENO - 1 ))";

    # -------------------------------------------

    ## STORING THE NAME OF THE FRAMEWORK'S TEMPORARY DIRECTORY

    __BU_MODULE_INIT__TMP_DIR_NAME="tmp";
    __bu_module_init__tmp_dir_name__lineno="$(( LINENO - 1 ))";

    # -------------------------------------------

    ## FINDING THE ".Bash-utils" FOLDER

    # If the framework base is not being installed on the user's hard drive.
    if ! BU.ModuleInit.IsFrameworkBeingInstalled; then
        # If the ".Bash-utils" folder exists in its defined parent directory,
        # then the ".Bash-utils" default parent folder is defined as the user's home directory.
        if [ -d "${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils" ]; then
            __bu_module_init__root__lineno="$(( LINENO + 2 ))";

            __BU_MODULE_INIT__ROOT="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT_HOME}" ".Bash-utils" 'd' || {
                printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
                    "$(basename "${BASH_SOURCE[0]}")" "${__bu_module_init__root__lineno}" '$__BU_MODULE_INIT__ROOT';

                BU.ModuleInit.IsInScript && exit 1; return 1;
            })";

            # If the base code of the framework is not wrapped in a single file.
            if ! BU.ModuleInit.IsFrameworkWrapped; then
                # shellcheck disable=SC2034
                __bu_module_init__initializer_path__lineno="$(( LINENO + 2 ))";

                __BU_MODULE_INIT__INITIALIZER_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT_HOME}" "$(basename "${BASH_SOURCE[0]}")" 'f' || {
                    printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" "$(basename "${BASH_SOURCE[0]}")" \
                        "${__bu_module_init__initializer_path__lineno}" '$__BU_MODULE_INIT__INITIALIZER_PATH';

                    BU.ModuleInit.IsInScript && exit 1; return 1;
                })";
            fi
        # Else, if the ".Bash-utils" folder does not exists in its defined parent directory.
        else
            BU.ModuleInit.PrintErrorMissingBashUtilsHomeFolder "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

            # WARNING : Do not call the "BU.ModuleInit.AskPrintLog()" function here, the current function is defined before the "${__BU_MODULE_INIT_MSG_ARRAY" array.
            BU.ModuleInit.IsInScript && exit 1; return 1;
        fi

    # Else, if the ".Bash-utils" folder doesn't exists in its defined parent directory AND the framework base is being installed on the user's hard drive,
    # then the ".Bash-utils" default parent folder is defined as the "/tmp" folder in the system root directory. This redefinition is important for the next path variables' values.
    else
        # Checking if the ".Bash-utils" folder exists in the user's home directory.
        if [ ! -d "${__BU_MODULE_INIT__ROOT_HOME}" ]; then
            # Redefining the "${__BU_MODULE_INIT__ROOT_HOME}" global variable.
            __BU_MODULE_INIT__ROOT_HOME='/tmp';
            __bu_module_init__root_home__lineno="$(( LINENO - 1 ))";

            # Creating the framework's temporary folder to store the temporary files generated by the initializer script.
            mkdir -p "/${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils/${__BU_MODULE_INIT__TMP_DIR_NAME}" > /dev/null || \
                mkdir -p "${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils/${__BU_MODULE_INIT__TMP_DIR_NAME}" || {
                    echo "ERROR : PLEASE LAUNCH THIS SCRIPT WITH SUPER-USER PRIVILEGES, OR CHECK YOUR PERMISSIONS ON THE « ${__BU_MODULE_INIT__ROOT_HOME} » DIRECTORY";
                }

            BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT_HOME}" ".Bash-utils" && {
                __bu_module_init__root__lineno="$(( LINENO + 2 ))";

                __BU_MODULE_INIT__ROOT="$(BU.ModuleInit.FindPath "/${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils" "${__BU_MODULE_INIT__TMP_DIR_NAME}" 'd' || {
                    printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
                        "$(basename "${BASH_SOURCE[0]}")" "${__bu_module_init__root__lineno}" '$__BU_MODULE_INIT__ROOT';

                    BU.ModuleInit.IsInScript && exit 1; return 1;
                })";
            };

        else
            BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT_HOME}" ".Bash-utils" && {
                __bu_module_init__root__lineno="$(( LINENO + 2 ))";

                __BU_MODULE_INIT__ROOT="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT_HOME}/.Bash-utils" "${__BU_MODULE_INIT__TMP_DIR_NAME}" 'd' || {
                    printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
                        "$(basename "${BASH_SOURCE[0]}")" "${__bu_module_init__root__lineno}" '$__BU_MODULE_INIT__ROOT';

                    BU.ModuleInit.IsInScript && exit 1; return 1;
                })";
            };
        fi
    fi

    # -------------------------------------------

    ## TEMPORARY DIRECTORY

    if [ ! -d "${__BU_MODULE_INIT__ROOT}/${__BU_MODULE_INIT__TMP_DIR_NAME}" ]; then mkdir -p "${__BU_MODULE_INIT__ROOT}/${__BU_MODULE_INIT__TMP_DIR_NAME}"; fi

    __bu_module_init__tmp_dir_path__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__TMP_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT}" "${__BU_MODULE_INIT__TMP_DIR_NAME}" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__TMP_DIR_PATH';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # -------------------------------------------

    # CONFIGURATIONS DIRECTORIES

    # -----------------------------
    # Configurations directory path
    # -----------------------------

    __bu_module_init__config_dir_path__lineno="$(( LINENO - + 2 ))";

    __BU_MODULE_INIT__CONFIG_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT}" "config" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
        "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__CONFIG_DIR_PATH';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # ------------------------------------------
    # Module's initializer script directory path
    # ------------------------------------------

    __bu_module_init__config_init_dir_path__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__CONFIG_INIT_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__CONFIG_DIR_PATH}" "initializer" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__CONFIG_INIT_DIR_PATH';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # --------------------------------
    # Modules configurations directory
    # --------------------------------

    __bu_module_init__config_modules_dir_path__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__CONFIG_DIR_PATH}" "modules" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # ------------------------------------------------------------------------------------
    # Translation files for the initializer script + the main module config and init files
    # ------------------------------------------------------------------------------------

    __bu_module_init__config_init_lang_dir_path__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__CONFIG_INIT_DIR_PATH}" "locale" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__CONFIG_INIT_LANG_DIR_PATH';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # -------------------------------------------

    ## INITIALIZER SCRIPT'S CONFIGURATION FILES

    __bu_module_init__config_init_dir__status__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__CONFIG_INIT_DIR_PATH}" "Status.conf" 'f')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__CONFIG_INIT_DIR__STATUS';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # -------------------------------------------

    ## MODULES DIRECTORIES
    __bu_module_init__modules_dir__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__MODULES_DIR="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__ROOT}" "modules" 'd')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__MODULES_DIR';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    # -------------------------------------------

    # FILES

    # Creating a global variable for storing the instruction not to stop the script if the "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}" is not found, since a super-user privileged version exists.
    __BU_MODULE_INIT__TMP_VAR__FIND_PATH_FUNC_NO_ERR='no-err';

    __BU_MODULE_INIT__LIB_ROOT_DIR__FILE_NAME="Bash-utils-root-val.path";
    __bu_module_init__lib_root_dir__file_name__lineno="$(( LINENO - 1 ))";

    __BU_MODULE_INIT__LIB_ROOT_DIR_FILE__PARENT_DIR="${__BU_MODULE_INIT__ROOT}";
    __bu_module_init__lib_root_dir_file__parent_dir__lineno="$(( LINENO - 1 ))";

    # ----------------------------------------------
    # Path to the framework's library root directory
    # ----------------------------------------------

    __bu_module_init__lib_root_dir__file_path__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__LIB_ROOT_DIR_FILE__PARENT_DIR}" "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_NAME}" 'f')" || {
        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__MODULES_DIR';

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    unset __BU_MODULE_INIT__TMP_VAR__FIND_PATH_FUNC_NO_ERR;

    if [ -z "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}" ]; then
        __BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_NAME="Bash-utils-root-val-ROOT.path";
        __bu_module_init__lib_root_dir_root__file_name__lineno="$(( LINENO - 1 ))";

        __BU_MODULE_INIT__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR="${__BU_MODULE_INIT__ROOT}";
        __bu_module_init__lib_root_dir_root_file__parent_dir__lineno="$(( LINENO - 1 ))";

        __BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT_FILE_PARENT_DIR}" "${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_NAME}" 'f' || { printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MODULE_INIT__MODULES_DIR'; BU.ModuleInit.IsInScript && exit 1; return 1; })";
        __bu_module_init__lib_root_dir_root__file_path__lineno="$(( LINENO - 1 ))";
    fi

    # -------------------------------------------

    ## MISC

    # Storing the "false" value in the variable whose purpose is to check via the "BU.ModuleInit.IsTranslated()"
    # function if the framework's main module is translated thanks to the CSV file parser.
    __BU_MODULE_INIT__BU_BASE_IS_TRANSLATED="false";
    __bu_module_init__bu_base_is_translated__lineno="$(( LINENO - 1 ))";

    __BU_MODULE_INIT__CSV_TRANSLATION_FILE__DELIM=',';
    __bu_module_init__csv_translation_file__delim__lineno="$(( LINENO - 1 ))";

    __BU_MODULE_INIT__DATE_LOG="[ $(date +"%Y-%m-%d %H:%M:%S") ]";
    __bu_module_init__date_log__lineno="$(( LINENO - 1 ))";

    # If you want to use another language than your system's, please redefine the "${LANG}" environment variable before sourcing this initialization file.
    __BU_MODULE_INIT__USER_LANG="$(echo "${LANG}" | cut -d _ -f1)";
    __bu_module_init__user_lang__lineno="$(( LINENO - 1 ))";

    # --------------------------------------------------------------------------------------
    # Array of allowed values for the "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" global variable
    # --------------------------------------------------------------------------------------

    __bu_module_init__bashx_debug_vals_array__lineno="$(( LINENO + 2 ))";

    __BU_MODULE_INIT__BASHX_DEBUG_VALS_ARRAY=('C' 'cs' 'cat' 'cats' 'categ' 'categs' 'category' 'categorie' 'categories' \
                                              'fi' 'fil' 'fils' 'fis'  'file' 'files' \
                                              'FN' 'FNC' 'FNCS' 'FNS' 'FNCT' 'FNCTS' \
                                              'fun' 'funs' 'func' 'funcs' 'funct' 'functs' 'function' 'functions' \
                                              'M' 'ms' 'mod' 'mods' 'module' 'modules' \
                                              'S' 'ss' 'sub' 'subs' 'subc' 'subcs' 'subcat'  'subcats' 'subcateg'  'subcategs'  'subcategory'  'subcategorie'  'subcategories' \
                                              'sc' 'scs' 'scat' 'scats' 'scateg' 'scategs' 'scategory'  'scategorie' 'scategories' \
                                              's-'  's-s' 's-c' 's-cs' 's-cat' 's-cats' 's-categ' 's-categs' 's-category' 's-categorie' 's-categories' \
                                              'sub-' 'sub-s' 'sub-c' 'sub-cs' 'sub-cat' 'sub-cats' 'sub-categ' 'sub-categs' 'sub-category' 'sub-categorie' 'sub-categories');
    return 0;
}

# Calling the function previously defined, or else the global variables will not be declared.
BU.ModuleInit.DefineBashUtilsGlobalVariablesBeforeInitializingTheModules;

# -----------------------------------------------

## CALLING THE NEEDED FUNCTIONS (DEFINED IN THIS FILE) THAT MUST BE CALLED BEFORE INITIALIZING THE FIRST GLOBAL VARIABLES

# THIS FUNCTION (BU.ModuleInit.GetModuleInitLanguage()) MUST BE THE FIRST FUNCTION TO BE CALLED !!!!

# Since this function gets the language currently used by the system, if you want to change the language, you just have to define
# a new value to the "${LANG}" environment variable before calling the "BashUtils_InitModules()" function in your main script file.

# Setting the whole project's language by getting and sourcing the "gettext.sh" file.

# If the framework is wrapped, then you should call the "Bash-utils-${language}.sh" file which corresponds to the language that you want to use.
BU.ModuleInit.IsFrameworkLocalizedWrapped || BU.ModuleInit.GetModuleInitLanguage "${__BU_MODULE_INIT__USER_LANG}" || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

declare __BU_MODULE_INIT_IS_TRANSLATION_FILES_SOURCED='true';

# -----------------------------------------------

## DEFINING NEW GLOBAL VARIABLES TO STORE THE INITIALIZATION LOGS AND DISPLAY THEM OR NO

# NOTE : The redirections are processed by the "BU.ModuleInit.Msg" function.

# This global variable stores the log messages.
declare __BU_MODULE_INIT_MSG_ARRAY=();

# This global variables stores a random text. It's enough to determine if the messages can be printed and / or stored in the "${__BU_MODULE_INIT_MSG_ARRAY" array with the "BU.ModuleInit.Msg" function.
declare __BU_MODULE_INIT_MSG_ARRAY_EXISTS="$((RANDOM % 255))";

# This global variable stores the processing mode (partial or full).

# By default, it stores the '--mode-log-partial' value, in order to avoid the initialization process being too much verbose.
declare __BU_MODULE_INIT_MSG_ARRAY_MODE='--mode-log-partial';

# This global variable stores the value (given in the "BashUtils_InitModules()" function's main loop)
# which authorizes the displaying of the logs messages on the screen.

# By default, it stores no value, so that the messages are redirected to the "${__BU_MODULE_INIT_MSG_ARRAY" only,
# without being redirected to the screen too (these instructions are processed in the "BU.ModuleInit.Msg" function).
declare __BU_MODULE_INIT_MSG_ARRAY_PERMISSION='';

# -----------------------------------------------

## CALLING THE OTHER FUNCTIONS FOR INITIALIZATION

# Writing the initialization content into the messages array. It will be displayed later on the screen if the « --log-init-display » argument is passed with the « module » argument.
__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__OUT_OF_FNCT__MSG_INITIALIZING_THE_MODULES}")");
__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg)");

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SOURCING THE MODULES

## INCLUSION OF LIBRARY FILES ACCORDING TO THE INCLUDED MODULE

# Please call immediately this function once this file is sourced, and pass it each module you need as arguments, and their supported options.

# shellcheck disable=SC1090
function BashUtils_InitModules()
{
    #**** Pre-initialization processing ****
    if [ -n "${__BU_MODULE_INIT_IS_SOURCED}" ] && [ "sourced" == "${__BU_MODULE_INIT_IS_SOURCED}" ]; then
        # shellcheck disable=SC2059
        BU.Main.Headers.Header.Warning "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__IS_ALREADY_CALLED}\n" "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")")"; return 1;
    fi

    #**** Parameters ****
    local p_modules_list=("${@}");    # List of all the modules to include passed as arguments

	#**** Variables (global) ****

	#**** Variables (local) ****
    local v_index=0;    # Index of the currently processed module (incremented at each loop's iteration). ALWAYS BEGIN WITH THE '0' VALUE !!!
    local v_loop_error; # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

	#**** Code ****
	# Checking if the arguments array length is equal to zero (no arguments passed).
	if [ -z "${p_modules_list[*]}" ]; then local lineno="${LINENO}";
        # shellcheck disable=SC2059
		printf "${__BU_MODULE_INIT_MSG__BU_IM__MUST_PASS_A_MODULE_NAME}\n\n" "$(basename "${BASH_SOURCE[0]}")" "${lineno}" "${FUNCNAME[0]}" >&2;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
	fi

    # Writing the list of the installed modules.
	__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg "${__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG}")");
	__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg)");

    # Listing the included modules.
	for module_args in "${p_modules_list[@]}"; do
        i=0; # Module's array index incrementer.

        if [[ "${module_args,,}" == 'module --'* ]]; then
            # shellcheck disable=SC2059
            __BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG__LOOP_ADD_ARRAY_INDEX__IS_MODULE_PARAM}" "${i}" "${module_args}")")");
        else
            i="$(( i + 1 ))" # Incrementing the module's array index

            # Name and arguments of the module stored as the nth index of the module list array.

            # shellcheck disable=SC2059
            __BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__MODULES_INIT_MSG__LOOP_ADD_ARRAY_INDEX__IS_NOT_MODULE_PARAM}" "${i}" "${module_args}")")");
        fi
	done

	__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg)");
	__BU_MODULE_INIT_MSG_ARRAY+=("$(BU.ModuleInit.Msg)");

	# Checking if any wanted module exists with its configuration and its library, then source every related shell files.
	for module in "${p_modules_list[@]}"; do

		# -----------------------------------------------

		## INITIALIZER'S FIRST ARGUMENTS PROCESSING ("module --*" AND "main --*" VALUES)

		# Calling the function which processes the « module » argument and its parameters, along with the « main » module.
        BU.ModuleInit.ProcessFirstModuleParameters "${module}" "${v_index}" || { v_loop_error='error'; break; }

		# -----------------------------------------------

		## DEFINING LOCAL VARIABLES FOR EACH MODULE TO BE INITIALIZED

		# Defining variables for each iteration.
		local v_module_name;

        v_module_name="$(echo "${module}" | cut -d' ' -f1)";

		# -----------------------------------------------

		## DEFINING GLOBAL VARIABLES FOR EACH MODULE TO BE INITIALIZED

		__BU_MODULE_INIT_MODULE_NAME="${v_module_name}";

		# Getting the current module's configurations directory AND its initialization directory (the "module --"* value is NOT a module).
		if [[ "${module}" != 'module --'* ]]; then

            # Getting the current module's configurations directory, in order to process each directory's files and sub-folders.
            __BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__CONFIG_MODULES_DIR_PATH}" "${v_module_name}" 'd' || {
                BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

                if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
            })";

            # shellcheck disable=SC2059
            BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH' "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" 'Dirpath' \
                "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__CONF_PATH__DIGVI}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}")" \
                "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";


            # Getting the current module's initialization directory, in order to process each directory's files and sub-folders.
            __BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT__MODULES_DIR}" "${v_module_name}" 'd' || {
                BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

                if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
            })";

            # shellcheck disable=SC2059
            BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH' "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" 'Dirpath' \
                "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INIT_PATH__DIGVI}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}")" \
                "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
        fi

		# Storing the module's name with it's arguments, in order to transform it in an array of strings to be processed in this loop (for each module, in their "initializer.sh" file).
		if [[ "${p_modules_list[i]}" == "${v_module_name} --"* ]]; then

            # shellcheck disable=SC2034
			__BU_MODULE_INIT_MODULE_AND_ARGS_STRING="${module}";

			# shellcheck disable=SC2059
			BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MODULE_INIT_MODULE_AND_ARGS_STRING' "${__BU_MODULE_INIT_MODULE_AND_ARGS_STRING}" 'String' \
				"$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__NAME_WITH_ARGS}" "${FUNCNAME[0]}" "${#p_modules_list}" "${module}")" \
				"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_FILE}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
		fi

        # Checking for each module's files if the currently processed "BashUtils_InitModules" argument is not "module" (already processed in the "BU.ModuleInit.ProcessFirstModuleParameters()" function).
        if [[ "${module}" != 'module --'* ]]; then

            # -----------------------------------------------

            # MODULES' CONFIGURATION FILES SOURCING

            # Checking if the module's configuration directory exists (by removing its optionnaly passed configurations arguments).
            if ! ls --directory "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}"; then local lineno="${LINENO}";
                # shellcheck disable=SC2059
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__INITMODULE__MODULE_CONFIG_DIR_NOT_FOUND";

                printf '\n' >&2;

                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__DIR_NOT_FOUND}\n\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" "${v_module_name}" >&2;

                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__DIR_NOT_FOUND__ADVICE}" >&2; BU.ModuleInit.CheckPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" 'f' >&2;
                printf '\n\n';

                # Listing all the installed modules in the user's hard drive.
                # No need to call the function "BU.ModuleInit.AskPrintLog" function, it's already called in the function "BU.ModuleInit.ListInstalledModules".
                BU.ModuleInit.ListInstalledModules || { v_loop_error="error"; break; }

                v_loop_error="error"; break;
            else
                BU.ModuleInit.Msg;

                # ---------------------------------------------------------------------------------------------------------------
                # OPTIONAL : SOURCING THE ALIASES CONFIGURATION FILE IN ORDER TO LET THE DEVELOPER WRITING SHORTER FUNCTION NAMES

                # Thanks to the "BU.ModuleInit.FindPath()" function, the file names are case-insensitive.
                if  [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Aliases.${v_module_name}.conf" 'shut' 'f' 'modaliasfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_name}.Aliases.conf" 'shut' 'f' 'modaliasfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Aliases.${v_module_name}.Aliases.conf" 'f' 'shut' 'modaliasfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_name}.Aliases.${v_module_name}.conf" 'f' 'shut' 'modaliasfile')" ]] \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Aliases.conf" 'f' 'shut' 'modaliasfile')" ]]; then

                        local v_module_aliases_file_name;

                        v_module_aliases_file_name="$(basename "$(cat "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.modaliasfile.tmp")")";
                fi

                if [ -n "${v_module_aliases_file_name}" ]; then
                    BU.ModuleInit.IsFrameworkWrapped || {
                        # If the aliases file is empty.
                        if [ ! -s "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_aliases_file_name}" 'f')" ]; then false > /dev/null; fi

                        source "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_aliases_file_name}" 'f')" || {
                            BU.ModuleInit.SourcingFailure "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}/${v_module_aliases_file_name}" "${v_module_name}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                            v_loop_error="error";

                            break;
                        }
                    }
                fi

                unset v_module_aliases_file_name;

                # ----------------------------------------------------
                # MANDATORY : SOURCING THE MODULE'S CONFIGURATION FILE

                # shellcheck disable=SC2059
                BU.ModuleInit.MsgLine "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__SOURCE_MSG}" "${v_module_name}")" '#' 'msg'; BU.ModuleInit.Msg;

                # Thanks to the "BU.ModuleInit.FindPath()" function, the file names are case-insensitive.
                if  [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Module.${v_module_name}.conf" 'f' 'shut' 'modconffile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_name}.Module.conf" 'f' 'shut' 'modconffile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Module.${v_module_name}.Module.conf" 'f' 'shut' 'modconffile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_name}.Module.${v_module_name}.conf" 'f' 'shut' 'modconffile')" ]] \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "module.conf" 'f' 'shut' 'modconffile')" ]]; then

                        local v_module_config_file_name;

                        v_module_config_file_name="$(basename "$(cat "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.modconffile.tmp")")";
                else
                    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "E_BUINIT__INITMODULE__MODULE_CONFIG_FILE_NOT_FOUND";

                    # shellcheck disable=SC2059
                    printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__MODULE_CONF_FILE_NOT_FOUND}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}";

                    BU.ModuleInit.MsgAbort;

                    BU.ModuleInit.AskPrintLog >&2 || { v_loop_error="error"; break; }

                    v_loop_error="error"; break;
                fi

                BU.ModuleInit.IsFrameworkWrapped || {
                    # If the module's configuration file is empty, then the initialization stops.
                    if [ ! -s "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_config_file_name}" 'f')" ]; then

                        # shellcheck disable=SC2059
                        BU.ModuleInit.PrintLogError "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_CONF_DIRS__MODULE_CONF_FILE_IS_EMPTY}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_config_file_name}")" "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO - 1 ))" "E_BUINIT__INITMODULE__MODULE_CONFIG_FILE_IS_EMPTY";

                        BU.ModuleInit.SourcingFailure "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}/${v_module_config_file_name}" "${v_module_name}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                        BU.ModuleInit.MsgAbort;

                        BU.ModuleInit.AskPrintLog >&2 || { v_loop_error="error"; break; }

                        v_loop_error='error';

                        break;
                    fi

                    source "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "${v_module_config_file_name}" 'f')" || {
                        BU.ModuleInit.SourcingFailure "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}/${v_module_config_file_name}" "${v_module_name}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}"; v_loop_error="error"; break;
                    }
                }

                unset v_module_config_file_name;
            fi

            # -----------------------------------------------

            # MODULES' INITIALIZATION FILES SOURCING

            # Checking if the module's initialization directory exists (by removing its optionnaly passed configurations arguments).
            if ! ls --directory "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}"; then local lineno="${LINENO}";
                # shellcheck disable=SC2059
                BU.ModuleInit.PrintLogError "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND__CALL_PLE}" "${v_module_name}")" "$(basename "${BASH_SOURCE[0]}")" "${lineno}" "E_BUINIT__INITMODULE__MODULE_INIT_DIR_NOT_FOUND";

                printf '\n' >&2;

                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND}\n\n" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" "${v_module_name}" >&2;

                # shellcheck disable=SC2059
                printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__DIR_NOT_FOUND__ADVICE}"; BU.ModuleInit.CheckPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" 'f' >&2;
                printf '\n\n' >&2;

                BU.ModuleInit.MsgAbort;

                v_loop_error="error"; break;
            else
                # shellcheck disable=SC2059
                BU.ModuleInit.MsgLine "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__SOURCE}" "${v_module_name}")" '-' 'msg';

                # -----------------------------------------------------
                # MANDATORY : SOURCING THE MODULE'S INITIALIZATION FILE

                # Thanks to the "BU.ModuleInit.FindPath()" function, the file names are case-insensitive.
                if  [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Initializer.${v_module_name}.sh" 'f' 'shut' 'modinitfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_name}.Initializer.sh" 'f' 'shut' 'modinitfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Initializer.${v_module_name}.Initializer.sh" 'f' 'shut' 'modinitfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_name}.Initializer.${v_module_name}.sh" 'f' 'shut' 'modinitfile')" ]] || \

                    [[ -f "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Initializer.sh" 'f' 'shut' 'modinitfile')" ]]; then
                        local v_module_init_file_name;

                        v_module_init_file_name="$(basename "$(cat "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.modinitfile.tmp")")";
                else
                    # shellcheck disable=SC2059
                    BU.ModuleInit.PrintLogError "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__MODULE_INIT_FILE_NOT_FOUND}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}")" "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO - 1 ))" "E_BUINIT__INITMODULE__MODULE_INIT_FILE_NOT_FOUND";

                    BU.ModuleInit.MsgAbort;

                    BU.ModuleInit.AskPrintLog >&2 || { v_loop_error="error"; break; }

                    v_loop_error="error"; break;
                fi

                BU.ModuleInit.IsFrameworkWrapped || {
                    # If the module's initializer file is empty, then the initialization stops.
                    if [ ! -s "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_init_file_name}" 'f')" ]; then

                        # shellcheck disable=SC2059
                        BU.ModuleInit.PrintLogError "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__INCLUDE_INIT_DIRS__MODULE_INIT_FILE_IS_EMPTY}" "${v_module_name}" "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_init_file_name}")" "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO - 1 ))" "E_BUINIT__INITMODULE__MODULE_INIT_FILE_IS_EMPTY";

                        BU.ModuleInit.SourcingFailure "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}/${v_module_init_file_name}" "${v_module_name}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                        BU.ModuleInit.MsgAbort;

                        BU.ModuleInit.AskPrintLog >&2 || { v_loop_error="error"; break; }

                        v_loop_error='error';

                        break;
                    fi

                    source "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_init_file_name}" 'f')" || {
                        BU.ModuleInit.SourcingFailure "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}/${v_module_init_file_name}" "${v_module_name}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}"; v_loop_error="error"; break;
                    }
                }

                unset v_module_init_file_name;

                # shellcheck disable=SC2059
                BU.Main.Headers.Header.Green "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__SOURCE_MODULES_CONF_DIRS__CURRENT_MODULE__END_OF_MODULE_INIT}" "$(BU.Main.Decho.Decho.Highlight "${v_module_name}")")";
            fi
        fi

        # Incrementing the modules array index variable.
        v_index="$(( v_index + 1 ))";

	done; if [ "${v_loop_error,,}" == 'error' ]; then BU.ModuleInit.IsInScript && BU.ModuleInit.Exit 1; return 1; fi

	# Sourcing the user defined aliases file if the library is directly used from a script file.
	if ! BU.ModuleInit.IsInScript && [ -f "${__BU_MAIN_PROJECT_ALIAS_FILE_PATH}" ] && [ -n "${__BU_MAIN_PROJECT_ALIAS_FILE_PATH}" ]; then BU.Main.Files.SourceFile "${__BU_MAIN_PROJECT_ALIAS_FILE_PATH}" || return 1; fi

	# /////////////////////////////////////////////////////////////////////////////////////////////// #

	#### ENDING THE WHOLE INITIALIZATION PROCESS

	# shellcheck disable=SC2059
	BU.Main.Headers.Header.Green "$(printf "${__BU_MODULE_INIT_MSG__BU_IM__END_OF_FRAMEWORK_INIT}" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_FILE_PATH}" "${__BU_MAIN_COLOR_TXT_PATH}")")";

	# This is the ONLY line where the "${__BU_MAIN_STAT_INITIALIZING}" global status variable's value can be modified.
	# DO NOT set it anymore to "true", or else your script can be prone to bugs.
    if  BU.Main.Status.CheckStatIsInitializing; then
        BU.Main.Status.ChangeSTAT_INITIALIZING "false" "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || return 1;
	fi

	# Note : the "${__BU_MODULE_INIT_MSG_ARRAY" variable is purged from the logged messages after writing its content in the project's log file.

	# Setting a global variable that prevent a new call of this function.
	__BU_MODULE_INIT_IS_SOURCED='sourced';

	# Backupping a message variable in case the current function is called again, in order to display again the same error message after unsetting every initialization message variables.
	local var_backup="${__BU_MODULE_INIT_MSG__BU_IM__IS_ALREADY_CALLED}";

	# Unsetting every initialization message variables in order to free up some memory.

	# Don't double quote the command substitution.

	# shellcheck disable=SC2046
	unset $(compgen -v "__BU_MODULE_INIT_MSG__");

	# Resetting the "${__BU_MODULE_INIT_MSG__BU_IM__IS_ALREADY_CALLED" variable.
	__BU_MODULE_INIT_MSG__BU_IM__IS_ALREADY_CALLED="${var_backup}";

    # Defining a function which is to be used to check if the framework is already sourced, in order to avoid too many checkings in the very beginning of any script that uses this framework, and a new inclusion of the framework's files.

    # Just write this line at the beginning of your script : "x="$(IsInBUFramework)"; if [ "${x^^}" != 'BU' ]; then".

    # After the 'then', call the "BashUtils_InitModules()" with it's mandatory arguments, and then your wanted arguments.
    if ! BU.ModuleInit.IsInScript; then function IsInBUFramework() { echo "BU"; }; fi

	return 0;
}



## NOTE : At this point, the "${__BU_MODULE_INIT_MSG__}" variables values are deleted. Do not add message variables related to the following functions in the initializer file's languages files.

# Initializing a single new module after the successful initialization of the main module, in case another module must be added later in the project's script, after the execution of the "BashUtils_InitModules()" function.
function BU.ModuleInit.InitNewModule()
{
    #**** Parameters ****
    local p_newmodule=${:-$'\0'};   # String    - Default : NULL    - Name of the module to include.

    #**** Code ****
    # If no module name is passed as argument.
    if [ -z "${p_newmodule}" ]; then local lineno="${LINENO}";
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULE NAME PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass a module name when you call the « %s » module initialization function" "${FUNCNAME[0]}")" \
			"No new module name passed as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return 1;
    else
        return 0;
    fi
}


# Initializing more than one new modules after the successful initialization of the main module, in case other modules must be added later in the project's script, after the execution of the "BashUtils_InitModules()" function.
function BU.ModuleInit.InitNewModules()
{
	#**** Parameters ****
	local p_module_list=("${@}"); # Array    - Default : NULL    - List of the new modules to init.

	#**** Variables (global) ****

	#**** Variables (local) ****
    local v_index=0;    # Index of the currently processed module (incremented at each loop's iteration). ALWAYS BEGIN WITH THE '0' VALUE !!!
    local v_loop_error; # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

	#**** Code ****
	# Checking if the arguments array length is equal to zero (no arguments passed).
	if [ -z "${p_modules_list[*]}" ]; then local lineno="${LINENO}";
        # shellcheck disable=SC2059
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULES NAMES PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass one or more modules names when you call the « %s » modules initialization function" "${FUNCNAME[0]}")" \
			"No new module(s) name(s) passed as argument(s)" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

		return 1;
    else
        # At this point, the main module is initialized, so its functions can be safely called.
        BU.Main.Headers.Header.Aqua.Turquoise "";

        for i in "${p_module_list[@]}"; do
            BU.ModuleInit.InitNewModule "${i}" || { v_loop_error='error'; break; };
        done

        if [ "${v_loop_error}" == 'error' ]; then BU.ModuleInit.IsInScript && BU.ModuleInit.Exit 1; return 1; fi

        return 0;
	fi
}

# Unsource a single module.
function BU.ModuleInit.UnsourceModule()
{
    #**** Parameters ****
    local p_module=${:-$'\0'};  # String    - Default : NULL    - Name of the module to unsource.

    #**** Code ****
    # If no module name is passed as argument.
    if [ -z "${p_module}" ]; then local lineno="${LINENO}";
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULE NAME PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass a module name when you call the « %s » module unsourcing function" "${FUNCNAME[0]}")" \
			"No module name passed as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return 1;
    else
        # Checking if the main module is passed as argument, to prevent its unsourcing.
        if [[ "${p_module}" == [Mm][Aa][Ii][Nn] ]]; then
            BU.Main.Errors.HandleErrors '1' "$(printf "%s YOU TRIED TO UNSOURCE THE MAIN MODULE" "$(BU.Main.Decho.__Decho.Yellow "WARNING :")")" \
                "Calling the main module as argument would unsource every files related to the main module, thus making the main functions of the framework unusable" \
                "$(printf "Main module passed as argument to the %s function" "${FUNCNAME[0]}")" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";
        else
            BU.Main.Headers.Newstep "UNSOURCING THE ${p_module^^} MODULE";
            BU.Main.Echo.Newline;

            # Unsourcing functions whose names does not follow the advised Bash Utils coding style.
            if  [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.sh"                                           'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.sh"                                 'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.sh"                               'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.Unsource.sh"                      'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Unsource.${p_module}.UnsourceExceptions.sh"            'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "UnsourceExceptions.${p_module}.UnsourceExceptions.sh"  'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.Unsource.sh"                               'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.UnsourceExceptions.sh"                     'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.Unsource.${p_module}.sh"                   'f' 'shut' 'unsourceexcept')" ]] || \
                [[ "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${p_module}.UnsourceExceptions.${p_module}.sh"         'f' 'shut' 'unsourceexcept')" ]]; then

                    v_module_unsourceexcept_file_name="$(basename "$(cat "${__BU_MODULE_INIT__TMP_DIR_PATH}/BU_module_init__find_path.unsourceexcept.tmp")")";

                    # Sourcing the file to get every functions and variables names, in order to unset each of them.

                    # shellcheck disable=SC1090
                    source "$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "${v_module_unsourceexcept_file_name}" 'f')" || {
                        BU.Main.Errors.HandleErrors "1" "UNABLE TO SOURCE THE ${p_module} MODULE'S UNSOURCER FILE" \
                            "" "" "$(basename "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 1 ))")";
                    };

                    # Calling the "BU.UnsourceExceptionFunctions()" function (defined in the "${v_module_unsourceexcept_file_name}" file),
                    # which calls the "$(unset ${function})" command before each function name in order to unsource it.
                    BU.UnsourceExceptionFunctions;

                    # Calling the "BU.UnsourceExceptionVariables()" function (defined in the "${v_module_unsourceexcept_file_name}" file),
                    # which calls the "$(unset ${variable})" command before each variable name in order to unsource it.
                    BU.UnsourceExceptionVariables;

                    return 0;
            fi

            # Unsetting every functions from the target module (DO NOT QUOTE THE $(compgen -v ...) COMMAND SUBSTITUTION !!!).
            # unset -f $(compgen -c "BU.${p_module}.");

            # Unsetting every variables from the target module (DO NOT QUOTE THE $(compgen -v ...) COMMAND SUBSTITUTION !!!).
            # unset $(compgen -v "__BU_${p_module^^}_");

            return 0;
        fi
    fi
}

# Unsource multiple modules at once from the.
function BU.ModuleInit.UnsourceModules()
{
    #**** Parameters ****
    local p_modules_list=("${@}");  # Array     - Default : NULL    - List of the modules to unsource.

    #**** Code ****
	# Checking if the arguments array length is equal to zero (no arguments passed).
	if [ -z "${p_modules_list[*]}" ]; then local lineno="${LINENO}";
        # shellcheck disable=SC2059
		BU.Main.Errors.HandleErrors '1' "$(printf "NO MODULES NAMES PASSED AS « %s() » FUNCTION ARGUMENT" "${FUNCNAME[0]}")" \
			"$(printf "You must pass one or more module name when you call the « %s » modules unsourcing function" "${FUNCNAME[0]}")" \
			"No module(s) name(s) passed as argument(s)" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

		return 1;
    else
        # At this point, the main module is initialized, so its functions can be safely called.
        BU.Main.Headers.Header.Aqua.Turquoise "";

        for i in "${p_module_list[@]}"; do
            BU.ModuleInit.UnsourceModule "${i}" || { v_loop_error='error'; break; };
        done

        if [ "${v_loop_error}" == 'error' ]; then BU.ModuleInit.IsInScript && BU.ModuleInit.Exit 1; return 1; fi

        return 0;
	fi

    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MODULES TRANSLATIONS

## MISC FUNCTIONS DEFINITION

# Remaking the "BU.Main.Errors.HandleErrors()" function in order to make it working for the initialization process.
function BU.ModuleInit.HandleErrors()
{
    #**** Parameters ****
    local p_returnCode=${1:-0}          # Int       - Default : NULL    - Return code of the last command or function called before the current function.
    local p_errorString=${2:-NULL};     # String    - Default : NULL    - String of the type of error to display.
    local p_adviceString=${3:-NLL};     # String    - Default : NULL    - String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=${4:-NULL};        # String    - Default : NULL    - Incorrect value which caused the error.
    local p_file=${5:-NULL};            # String    - Default : NULL    - The name of the file where the error occured.
    local p_function=${6:-NULL};        # String    - Default : NULL    - The name of the function where the error occured.
    local p_lineno=${7:-NULL};          # String    - Default : NULL    - Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "${LINENO}").

    #**** Code ****
    if [ "${p_returnCode}" -eq 0 ]; then return 0; else
        if [ -n "${__BU_MODULE_INIT_IS_SOURCED}" ] && [ "${__BU_MODULE_INIT_IS_SOURCED}" == 'sourced' ]; then
            BU.Main.Errors.HandleErrors "${p_returnCode}" "${p_errorString}" "${p_adviceString}" "${p_badValue}" "${p_file}" "${p_function}" "${p_lineno}"; return "${?}";

        else
            echo "IN ${p_file}, FUNCTION ${p_function}, LINE ${p_lineno} --> ERROR : ${p_errorString}" >&2;
            echo "Advice : ${p_adviceString}" >&2;
            echo >&2;

            echo "Value that caused this error : ${p_badValue}" >&2;

            BU.ModuleInit.MsgAbort;

            BU.ModuleInit.AskPrintLog >&2 || return 1;

            return "${p_returnCode}";
        fi
    fi

    return 0;
}

# -----------------------------------------------

## PARSING THE TRANSLATION FILE OF THE CURRENTLY PROCESSED MODULE

# Parsing the translation CSV file of each module.

# The "BU.ModuleInit.ParseCSVLang" function MUST be called in the current module's initialization script.

# IMPORTANT : It MUST be called AFTER the "BU.Main.Initializer.SourceLibrary" and BEFORE the "BU.Main.Initializer.SourceConfig()"
# functions in the main module's initialization file, in the "STEP FOUR" sub-section, in order to get the main module's functions and
# to translate the global variables descriptions written with the "BU.ModuleInit.DisplayInitGlobalVarsInfos" function.

# shellcheck disable=SC1090
function BU.ModuleInit.ParseCSVLang()
{
    #**** Parameters ****
    local p_lang_ISO_639_1=${1:-${__BU_MODULE_INIT__USER_LANG}};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : ${__BU_MODULE_INIT__USER_LANG}   - DESC : Language to fetch.
    local p_delim=${2:-$'\0'};                                   	# ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL                             - DESC : CSV file delimiter.

    #**** Variables ****
    local v_outputFileName="${__BU_MODULE_INIT_MODULE_NAME}.${p_lang_ISO_639_1}.translate";
    local v_outputFileParent="${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}";
    local v_outputFilePath="${v_outputFileParent}/${v_outputFileName}";

    local v_filename="${__BU_MODULE_INIT_MODULE_NAME}-${p_lang_ISO_639_1}.csv";
    local v_CSVFirstColRow;

    # Getting the total number of columns.
    local x;

	# Gets the return code of the Perl script used to parse the translation file in CSV format.
	local v_perlScriptReturnCode;

	local v_perlScriptExecLineno;

    # Getting the wanted column (set to 0, and the value will be taken from a new assignation of the variable with the call of the "BU.Main.Text.GetSubStringAfterDelim" function as sub-shell).
#    local v_wantedColID=0;

    # Getting the string of values (gathered from the first row of the CSV file) after the nth delimiter.
#    local v_CSVFirstColRowAfterNthDelim;

    # Perl script return codes.
    local v_perlScriptNoCSVFileGivenAsArgErrorCode="10022";             # Do not change this return code.
    local v_perlScriptPathIsDirErrorCode="1";
    local v_perlScriptFileIsNotCSVFormatErrorCode="2";

    local v_perlScriptIndexColNotPassedAsSecondArgErrorCode="3";
    local v_perlScriptIndexColIsNotIntErrorCode="4";
    local v_perlScriptLangFileOutputNotPassedAsThirdArgErrorCode="5";

    local v_perlScriptCSVFileCannotBeReadErrorCode="6";
    local v_perlScriptOutputFileCannotBeCreatedErrorCode="7";
    local v_perlScriptNotEnoughDiskSpaceAvailableErrorCode="14";        # Do not change this return code.

    #**** Code ****
    # Note : if the file cannot be obtained, or if there is another error during the parsing of the current module's translations CSV file,
    # then the execution of the script MUST be stopped, or else no messages will be printed on the screen while the script is executed.

    # If the output file already exists, then it's not necessary to retranslate the module.
    if [ -f "${v_outputFilePath}" ] && [ -n "${v_outputFilePath}" ]; then
		BU.ModuleInit.Msg "The ${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH} translations CSV file already exists for this language : ${p_lang_ISO_639_1}";
		BU.ModuleInit.Msg;

		BU.ModuleInit.IsFrameworkUnlocalizedWrapped && {
            source "${v_outputFilePath}" || {
                local C="${?}";

                local lineno="$(( LINENO - 3 ))";

                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNABLE_TO_SOURCE_TRANSL_OUT_FILE";

                BU.ModuleInit.HandleErrors "${C}" "$(printf "UNABLE TO SOURCE THE EXISTING « %s » TRANSLATIONS FILE" "${v_outputFilePath}")" \
                    "Please check what causes the script to not source the output file, which contains the target language's translations" \
                    "${v_outputFilePath}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

                return "${?}";
            }

            return 0;
		};
	fi

    # If no path to the module's translation CSV file is given.
    if [ -z "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__NO_PATH_TO_MOD_TRANSL_FILE";

        BU.ModuleInit.HandleErrors '1' "$(printf "NO PATH TO THE « %s » MODULE'S TRANSLATION FILE EXISTS" "${__BU_MODULE_INIT_MODULE_NAME}")" \
            "Please give a valid path to the current module's translations CSV file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    if [ -z "${v_filename}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" 'E_BUINIT__PARSECSVLANG__';

        return "${?}";
    fi

    # if a path to the module's translation CSV was given, but doesn't matches to a valid file path (the given path doesn't exists).
    if [ -n "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] && [ ! -f "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__INVALID_TRANSL_FILE_PATH";

        BU.ModuleInit.HandleErrors '1' "$(printf "THE PATH TO THE « %s » TRANSLATION FILE IS NOT VALID" "${__BU_MODULE_INIT_MODULE_NAME}")" \
            "Please give a valid path to the current module's translations CSV file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # If a path to the module's translation CSV was given AND the path exists AND the output file doesn't exists, but the exact file name doesn't matches with the defined name pattern.
    if [ -n "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] \
        && [ -f "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ] \
        && [ ! -f "${v_outputFilePath}" ] \
        && [ "$(basename "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" != "${v_filename}" ]; then local lineno="${LINENO}";
            BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__TARGET_TRANSL_FILE_DOES_NOT_MATCHES_DEFINED_PATTERN";

            BU.ModuleInit.HandleErrors '1' "$(printf "THE NAME OF THE « %s » PROJECT'S TRANSLATION FILE DOESN'T MATCHES WITH THE DEFINED NAME PATTERN" "${__BU_MODULE_INIT_MODULE_NAME}")" \
                "Please give a valid name to the current module's translations CSV file. The pattern is (without single quotes) : '\$module_name'-'\$ISO_639-1_language_code'" \
				"${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

            return "${?}";
    fi

    # If no delimiter is given.
    if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNDEFINED_DELIM";

        BU.ModuleInit.HandleErrors '1' "NO DELIMITER WAS GIVEN FOR THE CSV FILE" \
            "Please give a « single unicode character » as CSV delimiter in order to get each wanted cell" \
            "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    if [ -n "${p_delim}" ] && [ "${#p_delim}" -gt 1 ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__DELIM_MUST_BE_UNICODE_CHAR";

        BU.ModuleInit.HandleErrors '1' "THE GIVEN DELIMITER MUST BE A SINGLE UNICODE CHARACTER" \
            "Please give a « single unicode character » as valid CSV delimiter in order to get each wanted cell" \
            "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # Begin parsing the CSV file.
    BU.Main.Headers.Header.Blue "$(printf "PARSING THE « %s » PROJECT'S  « %s » TRANSLATIONS CSV FILE" "${__BU_MAIN_PROJECT_NAME}" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";

    BU.ModuleInit.Msg "Finding the variables list column";
    BU.ModuleInit.Msg;

    # If the targeted CSV file cannot be read by the current user.
    if [ ! -r "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" ]; then local lineno="${lineno}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__UNABLE_TO_READ_FILE";

        BU.ModuleInit.HandleErrors '1' "$(printf "Unable to read the « %s » file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "Please check the permissions of this file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" \
            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    fi

    # Getting the first row and first column's cell.
    v_CSVFirstColRow="$(BU.Main.Text.GetSubStringBeforeDelim "$(awk 'NR == 1 {print $1}' "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" || {
        local C="${?}";

        local lineno="$(( LINENO - 3 ))";

        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__VARIABLE_VAL_UNABLE_TO_FIND";

        BU.ModuleInit.HandleErrors '1' "$(printf "UNABLE TO FIND THE VALUE « VARIABLE » IN THE FIRST ROW AND FIRST COLUMN OF THE « %s » FILE" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "$(printf "Please check if the value mentioned above is present on this EXACT cell of the « %s » file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "${v_CSVFirstColRow}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    })" "${p_delim}" '--init')";

    if [ "${v_CSVFirstColRow}" != "VARIABLE" ]; then local lineno="${LINENO}";
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${lineno}" "E_BUINIT__PARSECSVLANG__VARIABLE_VAL_NOT_FOUND";

        BU.ModuleInit.HandleErrors '1' "$(printf "NO « VARIABLE » VALUE FOUND AT THE FIRST COLUMNN AND FIRST ROW OF THE « %s »" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")" \
            "Make sure the current module's CSV translations file is correctly formatted. You can check the main module's CSV file to check how the formatting should be done" \
            "${v_CSVFirstColRow}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

        return "${?}";
    else
        BU.ModuleInit.Msg "$(printf "Parsing the « %s » translations file" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";
        BU.ModuleInit.Msg;

        BU.ModuleInit.Msg "$(printf "Getting the chosen language's row (targeted language : %s)" "${p_lang_ISO_639_1}")";
        BU.ModuleInit.Msg;

        # Getting the total number of columns.
        x="$(awk -F, '{ print NF; exit }' "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}")";

        # Getting the langage ISO 639-1 code from the first row.
#        v_CSVFirstColRowAfterNthDelim="$(BU.Main.Text.GetSubStringAfterDelim "${v_CSVFirstColRow}" "${p_delim}" "$(( x - 1 ))") '' '--init'";

        # Getting the wanted language's column.
        v_wantedColID="$(BU.Main.Text.GetSubStringAfterDelim "${v_CSVFirstColRow}" "${p_delim}" "$(( x - 1 ))" "count" '--init')";

        # The targeted column is acquired, the Perl script's parsing program SetMouduleLang.pl can finally be called.
		v_perlScriptExecLineno="${LINENO}"; perl "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "${v_filename}" "${v_wantedColID}" "${v_outputFilePath}";

        # Getting the return value of the last command.
		v_perlScriptReturnCode="${?}";

		# Checking the eventual errors returned by the parsing program.
		if [ "${v_perlScriptReturnCode}" -eq 0 ]; then
			BU.ModuleInit.Msg "$(printf "The « %s » translations CSV file was successfully parsed, and the « %s » language's translations output file « %s » was successfully created" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "${p_lang_ISO_639_1}" "${v_outputFilePath}")";
			BU.ModuleInit.Msg;

			__BU_MODULE_INIT__BU_BASE_IS_TRANSLATED='true';

			BU.ModuleInit.IsFrameworkUnlocalizedWrapped && {
                source "${v_outputFilePath}" || {
                    local C="${?}"; BU.ModuleInit.SourcingFailure "${v_outputFilePath}" "${__BU_MODULE_INIT_MODULE_NAME}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}";

                    return "${C}";
                };  return    0;
            };

		else
			# The CSV file was not passed as first argument.
			if		[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptNoCSVFileGivenAsArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_NOT_CSV_FILE";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "NO CSV FILE GIVEN AS FIRST ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations CSV file you want to process" \
                    "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# A path was passed as first argument, but it's a directory path.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptPathIsDirErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_IS_DIR";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "THE PATH PASSED AS FIRST ARGUMENT FOR THE « %s » PERL SCRIPT IS A DIRECTORY PATH, AND NOT A CSV FILE PATH" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations CSV ${__BU_MAIN_TXT_FMT_ITALIC}>>> file <<<${__BU_MAIN_TXT_FMT_ITALIC_RESET} you want to process" \
                    "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# A path was passed as first argument. It's a file, but not in CSV format.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptFileIsNotCSVFormatErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_FIRST_ARG_FILE_IS_NOT_CSV";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "THE FILE PATH PASSED AS FIRST ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT IS NOT A CSV FILE PATH" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as first argument the path of the translations ${__BU_MAIN_TXT_FMT_ITALIC}>>> CSV file <<<${__BU_MAIN_TXT_FMT_ITALIC_RESET} you want to process" \
                    "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The column's index was not passed as second argument.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptIndexColNotPassedAsSecondArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_SEC_ARG_NO_COL_INDEX";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "NO COLUMN INDEX PASSED AS SECOND ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass as second argument as the index of the column you want to process" "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The column's index passed as second argument was not an integer.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptIndexColIsNotIntErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_SEC_ARG_NOT_INT";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "THE PERL TRANSLATION SCRIPT'S SECOND ARGUMENT IS NOT AN INTEGER" \
                    "Please pass an integer as second argument, as the target column ID" "${v_perlScriptReturnCode}" \
                    "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

            # The language file's output path was not passed as third argument.
            elif    [ "${v_perlScriptReturnCode}" -eq "${v_perlScriptLangFileOutputNotPassedAsThirdArgErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_THIRD_ARG_NO_OUT_FILEPATH";

                BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "NO LANGUAGE FILE'S OUTPUT PATH PASSED AS THIRD ARGUMENT FOR THE « %s » PERL TRANSLATION SCRIPT" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please pass a third argument as the output file path to create" "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The CSV file cannot be read by the Perl script.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptCSVFileCannotBeReadErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_UNABLE_TO_READ_CSV_FILE";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "THE « %s » PERL TRANSLATION SCRIPT CANNOT READ THE TARGET « %s » CSV TRANSLATIONS FILE" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}" "${v_filename}")" \
                    "Please check the permissions of the targeted CSV file, then relaunch the script" "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

			# The output file cannot be created by the Perl script.
			elif	[ "${v_perlScriptReturnCode}" -eq "${v_perlScriptOutputFileCannotBeCreatedErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_UNABLE_TO_CREATE_OUT_FILE";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "THE « %s » LANGUAGE'S OUTPUT FILE CANNOT BE CREATED BY THE « %s » PERL TRANSLATION SCRIPT" "${v_outputFilePath}" "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}")" \
                    "Please check the cause of this error, then relaunch the script" "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

				return "${v_perlScriptReturnCode}";

            # Not enough storage is available to complete this operation.
            elif    [ "${v_perlScriptReturnCode}" -eq "${v_perlScriptNotEnoughDiskSpaceAvailableErrorCode}" ]; then
                BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_perlScriptExecLineno}" "E_BUINIT__PARSECSVLANG__PERL_SCRIPT_NO_SPACE_LEFT_ON_DEVICE";

				BU.ModuleInit.HandleErrors "${v_perlScriptReturnCode}" "$(printf "NO SPACE LEFT ON THE DEVICE FOR THE CREATION OF THE « %s » LANGUAGE'S OUTPUT FILE" "${v_outputFilePath}")" \
                    "Please free up some disk memory before using this script to translate the current module" "${v_perlScriptReturnCode}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${v_perlScriptExecLineno}";

                printf "Deleting the created language's output file « %s »\n" "${v_outputFilePath}" >&2;
                echo >&2;

                if rm -v "${v_outputFilePath}"; then
                    printf "The « %s » file was successfully erased\n" "${v_outputFilePath}" >&2;
                    echo >&2;

                else
                    printf "UNABLE TO DELETE THE LANGUAGE'S OUTPUT FILE « %s »\n" "${v_outputFilePath}" >&2;
                    echo "Please do so before relaunching this script after freeing some space on your hard drive, in order to avoid this script to consider the translations already done" >&2;
                    echo >&2;
                fi

                BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

                if BU.ModuleInit.IsInScript; then exit "${v_perlScriptReturnCode}"; else return "${v_perlScriptReturnCode}"; fi
            fi
		fi
	fi
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Args.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# These functions act as argument checkers for several functions in the library, whose checking would make the code more difficult to read.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2116

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### ARGUMENT VALUES CHECKING : UTILITES FUNCTIONS
#### DEBUG ID : args::argument-values-checking--utilities-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS="args::argument-values-checking--utilities-functions";

## PATH CHECKING FUNCTIONS
## DEBUG ID : path-checking-functions

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__PATH_CHECKING_FUNCTIONS="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::path-checking-functions";

# -----------------------------------------------

## QUICK MESSAGE PRINTING
## DEBUG ID : quick-message-printing

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::quick-message-printing";

# Print a message without the need to write the whole "BU.Main.Errors.HandleErrors()" function's second argument, and according to the test option which failed :
function BU.Main.Args.PrintBadOption()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__QUICK_MESSAGE_PRINTING}";

    #**** Parameters ****
    local p_option=${1};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Test option.
    local p_advice=${2};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : "BU.Main.Errors.HandleErrors()"'s advice argument.
    local p_argname=${3};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the parameter that stores the argument.

    local p_value=${4};     # ARG TYPE : Any        - REQUIRED | DEFAULT VAL : NULL     - DESC : "BU.Main.Errors.HandleErrors()"'s value argument.
    local p_filename=${5};  # ARG TYPE : File       - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file where the error occured.
    local p_funcname=${6};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function where the test failed.

    local p_lineno=${7};    # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the test failed.

    #**** Variables ****
	# Changing the "${__BU_MAIN_STAT_ECHO}" status variable's value to "true" in case this function is called during a .
	if [ "${__BU_MAIN_STAT_ECHO,,}" == "false" ]; then
		local v_STAT_ECHO_was_false="true";     # VAR TYPE : Bool | DESC :

		BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
            local C="${?}";

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return "${C}";
		}
	fi

	# Since this function can be called from the "Lang.lib" file, and eventually in other library files, it's better to include a support for an appropriated file name.
	if [ -n "${p_filename}" ]; then
        local v_filename; # VAR TYPE : File | DESC :

        v_filename="${p_filename}";
	else
        local v_filename; # VAR TYPE : File | DESC :

        v_filename="$(BU.Main.Args.GetFileName)";
	fi

	if [ -n "${p_funcname}" ]; then
        local v_funcname; # VAR TYPE : String | DESC :

        v_funcname="${p_funcname}";
	else
        local v_funcname; # VAR TYPE : String | DESC :

        v_funcname="$(BU.Main.Args.GetFunctionName)";
	fi

	if [ -n "${p_lineno}" ]; then
        declare -i v_lineno; # VAR TYPE : Int | DESC :

        v_lineno="${p_lineno}";
	else
        declare -i v_lineno; # VAR TYPE : Int | DESC :

        v_lineno="$(BU.Main.Args.GetLineNumber)";
	fi

    #**** Code ****
	# Verifying that all the mandatory arguments are given.
	BU.Main.Args.Argc "${#}" '6' "${v_filename}" "${v_funcname}" "${v_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

	# If no value is passed as argument.
    if [[ "${p_option}" == [Z-z] ]]; then
		BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER HAS NO VALUE" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not an alphabetic character.
    elif [ "${p_option,,}" == '!alphachar' ]; then
        BU.Main.Errors.HandleErrors '1' \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphabetic string.
    elif [ "${p_option,,}" == '!alphastr' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphabetic string OR character.
    elif [ "${p_option,,}" == '!alphastrchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHABETIC STRING OR CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric character.
    elif [ "${p_option,,}" == '!alphanumchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric string.
    elif [ "${p_option,,}" == '!alphanumstr' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an alphanumeric string OR character.
    elif [ "${p_option,,}" == '!alphanumstrchar' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN ALPHANUMERIC STRING OR CHARACTER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not a string, which is precisely the name of a command or any other executable file.
    elif [ "${p_option^^}" == '!CMDSTR' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A COMMAND OR EXECUTABLE FILE NAME" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a valid directory path (only directories accepted).
    elif [ "${p_option,,}" == '!d' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID DIRECTORY PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_DIR}";

	# Else, if the value passed as argument is not a valid directory or file path (both are accepted).
    elif [ "${p_option,,}" == '!df' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID DIRECTORY OR FILE PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}";

	# Else, if the value passed as argument is not a valid file path (only files accepted).
    elif [ "${p_option,,}" == '!f' ]; then
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A VALID FILE PATH" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a floating number.
    elif [ "${p_option,,}" == '!float' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    # Else, if the value passed as argument is not a negative floating number.
    elif [ "${p_option,,}" == '!floatneg' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A NEGATIVE FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return 1;

	# Else, if the value passed as argument is not a positive floating number.
    elif [ "${p_option,,}" == '!floatpos' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A POSITIVE FLOAT" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not an integer.
    elif [ "${p_option,,}" == '!int' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT AN INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a negative integer.
    elif [ "${p_option,,}" == '!intneg' ]; then

        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A NEGATIVE INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

	# Else, if the value passed as argument is not a positive integer.
    elif [ "${p_option,,}" == '!intpos' ]; then
        BU.Main.Errors.HandleErrors "1" \
            "THE $(BU.Main.Decho.Decho.Function "${v_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')${p_argname}") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
            "${p_advice}" "${p_value}" "${v_filename}" "${v_funcname}" "${v_lineno}";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

		return "${__BU_MAIN_EXIT_NOT_PERMITTED}";
    fi

	if [ "${v_STAT_ECHO_was_false}" == "true" ]; then
		BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# -----------------------------------------------

## ARGUMENT PRESENCE CHECKING
## DEBUG ID = argument-presence-checking

# shellcheck disable=SC2034
__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING="${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}::argument-presence-checking";

# Checking the values stored in the argument array of a function.
function BU.Main.Args.GetFuncArgsArrayValues()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_funcname=${1};          # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function where the array was set.
    local p_decorate=${2:-NULL};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Special text processing for the "Decho()" function's "BU.Main.Args__Decho.Decho()" sub-fonction.
    shift 2;

    local pa_argsArray=("${@}");      # ARG TYPE : Array      - | DEFAULT VAL : NULL    - Array of values to check and display.

    #**** Variables ****
    local v_index=0;                # VAR TYPE : Int        - DESC : Initial value of the "for" loop's iterations counter.

    # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.
    local v_loop_error;             # VAR TYPE : String     - DESC :

    #**** Code ****
    BU.Main.Status.CheckStatIsBackupEchoing || {
        local v_echo="${__BU_MAIN_STAT_ECHO}";

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    }

    BU.ModuleInit.CheckIsDebugging && {
        BU.Main.Echo.Newstep "Values stored in the $(if [[ "${p_decorate,,}" == ?(-)?(-)d?(ec?(h)o) ]]; then BU.Main.Decho.Decho.Function "${p_funcname}"; else echo "« ${p_funcname} »"; fi) function's array of arguments :";

        for i in "${pa_argsArray[@]}"; do
            BU.Main.Echo.Msg "Value [${v_index}] : ${i}" || { local C="${?}"; v_loop_error='error'; break; }

            # Line break every five lines, in order to keep the values list readable for a human.
            local v_value_line=$(( v_index + 1 ));

            if [ $(( v_value_line % 5 )) -eq 0 ]; then
                BU.Main.Echo.Newline || { local C="${?}"; v_loop_error='error'; break; };
            fi

            v_index=$(( v_index + 1 ));
        done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    }

    if [ -n "${v_echo}" ] && [ "${v_echo,,}" == 'false' ]; then
        BU.Main.Status.ChangeSTAT_ECHO "${v_echo}" 'main' "$(basename "${BASH_SOURCE[0]}")" "$(( LINENO - 1 ))" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Checking a file's name passed as argument.
function BU.Main.Args.GetFileName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        # Checking if the file's name was specified, in order to print it.
        if [ -z "${p_filename}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Path 'no file identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Path "${p_filename}")"; fi;
    else
        if [ -z "${p_filename}" ]; then printf "« no file identified »"; else printf "« %s »" "${p_filename}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a function's name passed argument.
function BU.Main.Args.GetFunctionName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_funcname=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate,,}" == ?(-?(-))d?(ec?(h)o) ]]; then
        # Checking if the function's name was specified, in order to print it.
        if [ -z "${p_funcname}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Function 'no function identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Function "${p_funcname}()")"; fi;
    else
        if [ -z "${p_funcname}" ]; then printf "« no line identified »"; else printf "« %s »" "${p_funcname}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking a file's name passed as argument.
function BU.Main.Args.GetLineNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_lineno=${1:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line number to process.
    local p_decorate=${2:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        if [ -z "${p_lineno}" ]; then printf "%s" "$(BU.Main.Decho.Decho.Highlight 'no line identified')"; else printf "%s" "$(BU.Main.Decho.Decho.Highlight "${p_lineno}")"; fi;
    else
        # Checking if the file's name was specified, in order to print it.
        if [ -z "${p_lineno}" ]; then printf "« no line identified »"; else printf "« %s »" "${p_lineno}"; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the three informations simultaneously.
function BU.Main.Args.GetFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    if [ -n "${p_filename}" ] && [ -n "${p_funcname}" ] && [ -n "${p_lineno}" ] && BU.Main.Checkings.IsPositiveInt "${p_lineno}"; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    else
        #**** Variables ****
        local v_missing_filename="« NULL (as GetFFL arg 1) »";
        local v_missing_funcname="« NULL (as GetFFL arg 2) »";
        local v_missing_lineno="« NULL (as GetFFL arg 3) | »";

        if [ -z "${p_filename}" ]; then

            if [ -n "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_missing_funcname}" "${p_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${p_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${p_funcname}" "${v_missing_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${p_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_funcname}" "${p_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${v_missing_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "$(BU.Main.Args.PrintFFL "${v_missing_filename}" "${v_missing_funcname}" "${v_missing_lineno}") : " \
                    "Please give a ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_filename' "${v_missing_filename}" "${v_missing_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

        else
            if [ -n "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_funcname' "${p_filename}" "${p_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -n "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    " " \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_funcname' "${p_filename}" "${v_missing_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -z "${p_funcname}" ] && [ -z "${p_lineno}" ]; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_lineno' "${p_filename}" "${v_missing_funcname}" "${v_missing_lineno} $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

            elif [ -n "${p_lineno}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_lineno}"; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "" \
                    " ${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    'p_lineno' "${p_filename}" "${p_funcname}" "${p_lineno} (as GetFFL arg3) | $(( LINENO - 1 )) (actual file line)";

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi
    fi
}

# Printing the file, function and line.

# This function is called in the "BU.Main.Args.Argc()" and "BU.Main.Echo.__EchoOutput()" functions, for example.
function BU.Main.Args.PrintFFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Variables ****
    local v_filename; v_filename="$(BU.Main.Args.GetFileName "${p_filename}")";
    local v_funcname; v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}")";
    local v_lineno; v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}")";

    #**** Code ****
    echo -n "${v_filename} file, function ${v_funcname}, line ${v_lineno}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Printing the file, function and line.

# Please call this function after the advice given as second argument for the "BU.Main.Args.PrintBadOption()" function.
function BU.Main.Args.PrintFFLErrorOccured()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_target_f=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function where the checking happened.
    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.

    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.
    local p_decorate=${5:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow the call of any "BU.Main.Decho.Decho<...>()" function.

    #**** Variables ****
    local v_target_f;               # VAR TYPE : CMD        - DESC :
    local v_filename;               # VAR TYPE : CMD        - DESC :
    local v_funcname;               # VAR TYPE : CMD        - DESC :
    local v_lineno;                 # VAR TYPE : CMD        - DESC :

    #**** Code ****
    if [[ "${p_decorate}" == ?(-?(-))d?(ec?(h)o) ]]; then
        v_target_f="$(BU.Main.Decho.Decho.Function "${p_target_f}")";

        v_filename="$(BU.Main.Args.GetFileName "${p_filename}" '--decho')";
        v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}" '--decho')";
        v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}" '--decho')";
    else
        v_target_f="${p_target_f}";

        v_filename="$(BU.Main.Args.GetFileName "${p_filename}")";
        v_funcname="$(BU.Main.Args.GetFunctionName "${p_funcname}")";
        v_lineno="$(BU.Main.Args.GetLineNumber "${p_lineno}")";
    fi

    echo -n "The error occured in the ${v_filename} file, at function ${v_funcname}, on line ${v_lineno}, during the checking of the ${v_target_f}() function";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking if any mandatory arguments are provided for any function.

# This function is called in the "BU.Main.Args.PrintBadOption()" function, DO NOT call the "BU.Main.Args.PrintBadOption()" function here.
function BU.Main.Args.Argc()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    local p_argcount=${1:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of arguments passed.
    local p_argawait=${2:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of arguments awaited.

    local p_filename=${3:-$'\0'};   # ARG TYPE : File       - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Variables ****
    local v_funcname;       # VAR TYPE : CMD        - DESC :

    #**** Code ****
    v_funcname="$(BU.Main.Decho.Decho.Highlight "$(BU.Main.Args.GetFunctionName "${p_funcname}")")";

    # If both "${p_argcount}" and "${p_argawait}" arguments contain a value.
    if [ -n "${p_argcount}" ] && [ -n "${p_argawait}" ]; then

        # If both "${p_argcount}" and "${p_argawait}" argument values are integer.
        if BU.Main.Checkings.IsPositiveInt "${p_argcount}" && BU.Main.Checkings.IsPositiveInt "${p_argawait}"; then

            # If the correct number of arguments is given to the processed function.
            if [ "${p_argcount}" -eq "${p_argawait}" ] || [ "${p_argawait}" -eq 0 ]; then
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            # Else, if an incorrect number of arguments is given to the processed function.
            else
                # If the function awaits only one argument AND no argument is given to the function.
                if [ "${p_argawait}" -eq 1 ] && [ "${p_argcount}" -lt "${p_argawait}" ]; then
                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") NEEDS AN ARGUMENT" \
                        "Please pass only one argument to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND no arguments are passed to the function.
                elif [ "${p_argawait}" -ge 1 ] && [ "${p_argcount}" -eq 0 ]; then
                    local total="";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") NEEDS $(BU.Main.Decho.Decho.Highlight "${p_argawait}") ARGUMENTS" \
                        "Please pass $(BU.Main.Decho.Decho.Highlight "${p_argawait}") argument$(if [ "${p_argawait}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if the function awaits more than one argument AND not enough arguments are passed to the function.
                elif [ "${p_argcount}" -gt 0 ] && [ "${p_argcount}" -lt "${p_argawait}" ]; then
                    local total="$(( p_argawait-p_argcount ))";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") HAS NOT ENOUGH ARGUMENTS" \
                        "Please pass $(BU.Main.Decho.Decho.Highlight "${total}") more argument$(if [ "${total}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

                # Else, if more arguments than expected are given to the function.
                elif [ "${p_argcount}" -gt "${p_argawait}" ]; then
                    local total="$(( p_argcount - p_argawait ))";

                    BU.Main.Errors.HandleErrors "1" "THE FUNCTION $(BU.Main.Decho.Decho.Function "${v_funcname}") HAS TOO MUCH ARGUMENTS" \
                        "Please remove $(BU.Main.Decho.Decho.Highlight "${total}") argument$(if [ "${total}" -gt 1 ]; then printf 's'; fi) to the $(BU.Main.Decho.Decho.Function "${v_funcname}") function${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                        "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                fi
            fi

        # Else, if "${p_argcount}" AND / OR "${p_argawait}" argument values are not integer.
        else
            if ! BU.Main.Checkings.IsPositiveInt "${p_argcount}"; then local lineno="${LINENO}";
                BU.Main.Errors.HandleErrors '1' \
                    "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S ARGUMENT COUNTER $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argcount") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") first argument $(BU.Main.Decho.Decho.Var 'p_argcount')'s value needs to be an integer, since it is an argument counter${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi

            if ! BU.Main.Checkings.IsPositiveInt "${p_argawait}"; then local lineno="${LINENO}";
                BU.Main.Args.PrintBadOption '1' \
                    "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S AWAITED ARGUMENTS COUNTER $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argawait") PARAMETER'S VALUE IS NOT A POSITIVE INTEGER" \
                    "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") second argument $(BU.Main.Decho.Decho.Var 'p_argawait')'s value needs to be an integer, since it is an argument limit${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                    "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

    # Else, if "${p_argcount}" AND / OR "${p_argawait}" argument values are empty.
    else
        if [ -z "${p_argcount}" ]; then local lineno="${LINENO}";
            BU.Main.Errors.HandleErrors '1' \
                "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Highlight "$(echo -n '$')p_argcount") PARAMETER HAS NO VALUE" \
                "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") first argument $(BU.Main.Decho.Decho.Var 'p_argcount')'s value needs to be an integer, since it is an argument counter${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

        if [ -z "${p_argawait}" ]; then local lineno="${LINENO}";
            BU.Main.Errors.HandleErrors '1' \
                "THE $(BU.Main.Decho.Decho.Function "${p_funcname}") FUNCTION'S $(BU.Main.Decho.Decho.Var "$(echo -n '$')p_argawait") PARAMETER HAS NO VALUE" \
                "The function $(BU.Main.Decho.Decho.Function "${p_funcname}") second argument $(BU.Main.Decho.Decho.Var 'p_argawait')'s value needs to be an integer, since it is an argument limit${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                "${p_argcount}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi
    fi
}

# Checking if any mandatory arguments are provided for any function AND the file, function and line number
# informations simultaneously, by calling both the "BU.Main.Args.Argc" and "BU.Main.Args.GetFFL()" functions.
function BU.Main.Args.GetArgc-FFL()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ARGS_LIB__CAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS}" \
        "${__BU_MAIN_ARGS_LIB__SUBCAT_DEBUG_ID__ARGUMENT_VALUES_CHECKINGS__ARGUMENT_PRESENCE_CHECKING}";

    #**** Parameters ****
    #   ${1}    -> BU.Main.Args.Argc "${p_argcount}" parameter.
    #   ${2}    -> BU.Main.Args.Argc "${p_argawait}" parameter.

    #   ${3}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_filename}" parameter.
    #   ${4}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_funcname}" parameter.
    #   ${5}    -> BU.Main.Args.Argc && BU.Main.Args.GetFFL "${p_lineno}" parameter.

#    BU.Main.Args.Argc      "${1}" "${2}" "${3}" "${4}" "${5}"  || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
#    BU.Main.Args.GetFFL    "${3}" "${4}" "${5}"                || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Checkings.lib" FILE'S FUNCTIONS

## CATEGORY : "FILES PATHS CHECKING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Checkings.CheckProjectRelatedFile()" function.
function BU.Main.Args__Checkings.CheckProjectRelatedFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to process (into its parent directory).
    local p_child=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file or folder to process (into its parent directory).
    local p_type=${3:-$'\0'};       # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of data to create (d = directory, f = file).

    local p_filename=${4:-$'\0'};   # ARG TYPE : Path       - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

	#**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a folder path passed as first argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_child}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a file OR folder name passed as second argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_child' "${p_child}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ -z "${p_type}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "The function $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${p_funcname}")") needs a type of data ('d' or 'f') passed as third argument to work properly (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_type' "${p_type}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ "${p_type}" != 'd' ] && [ "${p_type}" != 'f' ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption '!df' \
            "You need to precise if what you want to create is a directory or a file (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_type' "${p_type}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "CMDS.lib" FILE'S FUNCTIONS

## CATEGORY : "GET COMMAND OUTPUTS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.CMDSGetCommandPath()" function.
function BU.Main.Args__CMDS.GetCommandPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Command's name.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "You must specify the name of the command whose path you want to know (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Decho.lib" FILE'S FUNCTIONS

## CATEGORY : "TEXT WRITING AND DECORATION (FORMATTING)"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Decho.Decho()" function.
function BU.Main.Args__Decho.Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

	#**** Parameters ****
    local p_string=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL	    - DESC : String to display.
    local p_newTextColor=${2:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL	    - DESC : Color to apply on each string's characters.
    local p_newBGColor=${3:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL	    - DESC : Color to apply in the text's background.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

	#**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	# If the text's color code is not an integer.
	if ! BU.Main.Checkings.IsPositiveInt "${p_newTextColor}"; then local lineno="${LINENO}";
        printf "IN « %s », FUNCTION « %s », LINE « %s » : WARNING : THE « p_newTextColor » PARAMETER VALUE IS NOT AN INTEGER\n\nPlease pass a positive integer as text color code, as second argument for the « %s » function (optional argument)\n${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}%s" "${p_filename}" "${p_funcname}" "${p_lineno}" "${__BU_MAIN_COLOR_FUNCTION}${p_funcname}${__BU_MAIN_COLOR_ERROR}" "$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    # If the background's color code is not an integer.
    if ! BU.Main.Checkings.IsPositiveInt "${p_newBGColor}"; then local lineno="${LINENO}";
        printf "IN « %s », FUNCTION « %s », LINE « %s » : WARNING : THE « p_newBGColor » PARAMETER VALUE IS NOT AN INTEGER\n\nPlease pass a positive integer as background color code, as third argument for the « %s » function (optional argument)\n${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}%s" "${p_filename}" "${p_funcname}" "${p_lineno}" "${__BU_MAIN_COLOR_FUNCTION}${p_funcname}${__BU_MAIN_COLOR_ERROR}" "$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')";
            "${p_newTextColor}" "" "${p_funcname}" "${lineno}";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### "Directories.lib" FILE'S FUNCTION

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PROCESSING FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.ProcessingDir()" function.
function BU.Main.Args__Directories.ProcessingDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the function to process.
    local p_parent=${2:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the target directory's parent.
    local p_name=${3:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the target directory.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_function}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a function's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_function' "${p_function}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a valid parent directory path as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the folder to process as third argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - FOLDER CREATION FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Directories.OverwriteDir()" function.
function BU.Main.Args__Directories.OverwriteDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to overwrite.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the given folder path is incorrect.
    if [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.Make()" function.
function BU.Main.Args__Directories.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Parent folder's path.
    local p_name=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to create.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the parent folder's path is missing (no path is given).
    if [ -z  "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the new directory's parent folder as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the folder's name is missing (no name is given).
    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the directory to create as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.MakePath()" function.
function BU.Main.Args__Directories.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the directory to create.
    local p_overwrite=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the directory.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the new folder's full path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	if [ -n "${p_overwrite}" ] && [ "${p_overwrite}" != "--rmdir" ]; then local lineno="${LINENO}";
		BU.Main.Args.PrintBadOption '' \
			"Please pass the valid string $(BU.Main.Decho.Decho.Var "--rmdir") that allows overwriting the $(BU.Main.Decho.Decho.Function "${p_path}") directory (optional argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
			'p_overwrite' "${p_overwrite}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "MAIN MODULE'S "Directories.lib" FILE'S FUNCTIONS - PATH PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Directories.GetDirectoryName()" function.
function BU.Main.Args__Directories.GetDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "The $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetDirectoryPath()" function.
function BU.Main.Args__Directories.GetDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "The $(BU.Main.Text.CutSubStringBeforeNthDelim "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")") function takes a path as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetParentDirectoryName()" function.
function BU.Main.Args__Directories.GetParentDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.
    local p_iterations=${2:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of iterations.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Directories.GetParentDirectoryPath()" function.
function BU.Main.Args__Directories.GetParentDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.
    local p_iterations=${2:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Number of iterations.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target folder path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] || ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as number of iterations (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Errors.lib" FILE'S FUNCTIONS

## CATEGORY : ""
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

#

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Files.lib" FILE'S FUNCTIONS

## CATEGORY : "TEXT FILE PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Files.ProcessingFile()" function.
function BU.Main.Args__Files.ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Function to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_function}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please pass a valid file processing function as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_function' "${p_function}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.OverwriteFile()" function.
function BU.Main.Args__Files.OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #***** Parameters ****
    local p_path=${1:-$'\0'}            # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to overwrite.
    local p_authorization=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the file.

    local p_filename=${3:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the target file's path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the directory to overwrite as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the given file path is incorrect.
    if [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass the correct path of the directory to overwrite as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if no authorization to overwrite the current file is given.
	if [ -z "${p_authorization}" ]; then local lineno="${LINENO}";
		 BU.Main.Args.PrintBadOption 'z' \
            "Please enter a valid value for the overwrite authorization as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_authorization' "${p_authorization}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.Make()" function's arguments.
function BU.Main.Args__Files.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_parent=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Parent folder path of the file to create.
    local p_name=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to create.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the parent folder's path is missing (no path is given).
    if [ -z "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the path of the new file's parent folder as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the parent folder's path is incorrect.
    if [ ! -d "${p_parent}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption '!d' \
            "Please pass a valid parent directory path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_parent' "${p_parent}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # Else, if the file's name is missing (no name is given).
    if [ -z "${p_name}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass the name of the file to create as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

#     # Else, if the file's name is too long (usually with a string size greater than 255 bytes).
    if [ "$(echo "${p_name}" | wc --bytes)" -gt "${__BU_MAIN_FS_MAX_FILE_SIZE}" ]; then local lineno="${LINENO}";
        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_FILENAME_TOO_LONG}" \
            "THE FILE NAME IS TOO LONG FOR THIS FILESYSTEM" \
            "Please give a name length smaller than $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}") bytes${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_name' "${p_name}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.MakePath()" function.
function BU.Main.Args__Files.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the file to create.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If the new file's full path is missing (no path is given).
    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass the full path of the directory to create as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "SETTING FILE INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.FilesSetLastAccess()" function.
function BU.Main.Args__Files.SetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to check its last access.
    local p_fakedate=${2:-$'\0'};   # ARG TYPE : Date       - REQUIRED | DEFAULT VAL : NULL     - DESC : Access date to replace.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_filepath}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as first argument the path of the file whose last access date you wish to change (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_filepath' "${p_filepath}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ ! -f "${p_filepath}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!f' \
            "Please pass a valid file path as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_filepath' "${p_filepath}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_fakedate}" ]; then local lineno="${LINENO}";
         BU.Main.Args.PrintBadOption 'z' \
            "Please pass a date in $(BU.Main.Decho.Decho.Highlight "[[CC]YY]MMDDhhmm[.ss]") format as second argument (like 20220221212020.22 | 2022 02 21 21h 20m 20s and 22 ms) (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fakedate' "${p_fakedate}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "ARCHIVES PROCESSING FUNCTIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Files.CompressCMD()" function.
function BU.Main.Args__Files.CompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${2:-$'\0'}        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	# If the command line compression tool is not found.
    if ! command -v "${p_cmd}"; then
            BU.Main.Args.PrintBadOption '!CMDSTR' \
                "Please pass an existing / installed compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If no name of the archive to create is given (remember that the second parameter "${p_opts}" is optional here, so the "${p_arch}" parameter is the third parameter of the original function).
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as third argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.CompressFormat()" function.
function BU.Main.Args__Files.CompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${2:-$'\0'}        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a compression command name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    # If no name of the archive to create is given.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as second argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.SearchInArchive()" function.
function BU.Main.Args__Files.SearchInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_arch=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the target archive.

    local p_filename=${2}:-$'\0';   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    # If no archive path is provided as first argument.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as first argument the path to the archive to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If a bad archive path is provided as first argument.
    if [ ! -f "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!f' \
            "Please pass as first argument an existing path to find the archive to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Files.UncompressCMD()" function.
function BU.Main.Args__Files.UncompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
    local p_arch=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_cmd}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a(n) (un)compression command's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	# If the command line compression tool is not found.
    if ! command -v "${p_cmd}"; then local lineno="${LINENO}";
            BU.Main.Args.PrintBadOption '!CMDSTR' \
                "Please pass an existing / installed (un)compression command's name as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
                'p_cmd' "${p_cmd}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # If no path to the archive to uncompress is given (remember that the second parameter "${p_opts}" is optional here, so the "${p_arch}" parameter is the third parameter of the original function).
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as third argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# "BU.Main.Files.UncompressFormat()" function.
function BU.Main.Args__Files.UncompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_form=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
    local p_arch=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_form}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass an archive format name (like 7z, Gzip, Cab, etc...) as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_form' "${p_form}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    # If no name / path to the archive to uncompress is given.
    if [ -z "${p_arch}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as second argument the path of the archive to uncompress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_arch' "${p_arch}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Filesystem.lib" FILE'S FUNCTIONS

## CATEGORY : "GETTING FILE SYSTEM'S INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.IsPartitionFull()" function.
function BU.Main.Args__Filesystem.IsPartitionFull()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_fileFS=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file or folder's file system host.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_fileFS}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fileFS' "${p_fileFS}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_fileFS}" ] && [ ! -d "${p_fileFS}" ] || [ ! -f "${p_fileFS}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_fileFS' "${p_fileFS}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "GETTING FILE SYSTEM'S INFORMATIONS"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.GetFS<...>()" functions.
function BU.Main.Args__Filesystem.GetFSInfos()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file or folder's file system host.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass a path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ] || [ ! -f "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please pass a valid path to get the file or folder's host file system (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.Chown()" function.
function BU.Main.Args__Filesystem.Chown()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Former owner of the directory or the file (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New owner of the directory or the file.
    local p_path=${3:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory or the file to process.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_currentOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the former directory's or file's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_currentOwner' "${p_currentOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_newOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the new directory's or file's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_newOwner' "${p_newOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the path to the directory or the file to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ] || [ ! -f "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!df' \
            "Please give a valid path for the directory or the file to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Filesystem.ChownRec()" function.
function BU.Main.Args__Filesystem.ChownRec()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_currentOwner=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Former owner of the directory (this parameter is used in the translated / log messages, stored into their own variables).
    local p_newOwner=${2:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New owner of the directory.
    local p_path=${3:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory to process.

    local p_filename=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_currentOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the former directory's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_currentOwner' "${p_currentOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_newOwner}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the name of the new directory's owner (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_newOwner' "${p_newOwner}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give the path to the directory to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_path}" ] && [ ! -d "${p_path}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!d' \
            "Please give a valid path for the directory to process (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_path' "${p_path}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### MAIN MODULE'S "Text.lib" FILE'S FUNCTIONS

## MULTI-CATEGORY FUNCTIONS :
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# Functions :
#	- BU.Main.Text.CutFirstFieldBeforeDelim()
#	- BU.Main.Text.CutLastFieldAfterDelim()
#	- BU.Main.Text.GetFirstFieldBeforeDelim()
#	- BU.Main.Text.GetLastFieldAfterDelim()
#   - BU.Main.Text.ReverseStringWordsOrder()
function BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "CUTTING TEXT"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Text.CutSubStringAfterNthDelim()" function.
function BU.Main.Args__Text.CutSubStringAfterNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.CutSubStringBeforeNthDelim()" function.
function BU.Main.Args__Text.CutSubStringBeforeNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations.

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_delimiter}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a character as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delimiter' "${p_delimiter}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.DeleteLettersInString()" function
function BU.Main.Args__Text.DeleteLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.
    shift;

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "GETTING TEXT"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.

# "BU.Main.Text.GetCharacterOccurences()" function.
function BU.Main.Args__Text.GetCharacterOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};     # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_target}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -n "${p_target}" ] && [ "${#p_target}" -gt 1 ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!alphanumchar' \
            "Please give only a single character to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetFirstCharacter()" and "BU.Main.Text.GetLastCharacter()" functions.
function BU.Main.Args__Text.GetFirstLastCharacter()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Args__Text.GetSubStringAfterDelim()" function.
function BU.Main.Args__Text.GetSubStringAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_iterations=${3:-1};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Iterations

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delim' "${p_delim}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetSubStringBeforeDelim()" function.
function BU.Main.Args__Text.GetSubStringBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL	    - DESC : Delimiter
	local p_iterations=${3:-$'\0'};	# ARG TYPE : Int		- REQUIRED | DEFAULT VAL : 1		- DESC : Iterations

    local p_filename=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${6:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
	BU.Main.Args.GetArgc-FFL "${#}" '6' "${p_filename}" "${p_funcname}" "${p_lineno}";

	if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

	if [ -z "${p_delim}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any single character as delimiter to process as second argument${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_delim' "${p_delim}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsPositiveInt "${p_iterations}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption '!intpos' \
            "Please pass a positive integer as third argument (optional)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_iterations' "${p_iterations}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# "BU.Main.Text.GetSubStringOccurences()" function.
function BU.Main.Args__Text.GetSubStringOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted sub-string

    local p_filename=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${5:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give a string to process as first argument (mandatory argument). $(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    if [ -z "${p_target}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please give any sub-string to process as second argument (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_target' "${p_target}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CATEGORY : "SPLITTING TEXT AND SPLITTED TEXT PROCESSING"
## DEBUG ID : Dependant on the debug ID from the original function's file sub-category.	BU.Main.Args.GetArgc-FFL "${#}" '5' "${p_filename}" "${p_funcname}" "${p_lineno}";

# "BU.Main.Text.StrToWordArray()" function.
function BU.Main.Args__Text.StrToWordArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "" "";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to convert in an array of words.

    local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file in which the currently processed function is located.
    local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the currently processed function.
    local p_lineno=${4:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where this argument processing function is called.

    #**** Code ****
    BU.Main.Args.GetArgc-FFL "${#}" '4' "${p_filename}" "${p_funcname}" "${p_lineno}";

    if [ -z "${p_string}" ]; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'Z' \
            "Please give as first argument a string to convert in a word array (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}" '--decho')" \
            'p_string' "${p_string}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : BasicMaths.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# -----------------
# FILE DSCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### CONVERSIONS
#### DEBUG ID : basicmathsconversions

__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS="basicmaths::conversions";

## NUMERIC CONVERSIONS
## DEBUG ID : numeric-conversions

__BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMERIC_CONVERSIONS="${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}::numeric-conversions";

# Converts a byte count to a human readable format in IEC binary notation (base-1024 (eg : GiB)), rounded to two decimal places for anything larger than a byte. Switchable to padded format and base-1000 (eg : MB) if desired.

# Initial source of this AWK script (since it's not mine, plus I added more informations as comments and the localization) :
# https://unix.stackexchange.com/questions/44040/a-standard-tool-to-convert-a-byte-count-into-human-kib-mib-etc-like-du-ls1/98790#98790
function BU.Main.BasicMaths.BytesToHuman()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_BASICMATHS_LIB__CAT_DEBUG_ID__CONVERSIONS}" \
        "${__BU_MAIN_BASICMATHS_LIB__SUBCAT_DEBUG_ID__CONVERSIONS__NUMERIC_CONVERSIONS}";

    #**** Parameters ****
    local L_BYTES="${1:-0}"     # ARG TYPE : Int                - REQUIRED | DEFAULT VAL : 0        - DESC : Raw size in bytes.
    local L_PAD="${2:-no}"      # ARG TYPE : String             - REQUIRED | DEFAULT VAL : no       - DESC : Allow result display padding.
    local L_BASE="${3:-1024}"   # ARG TYPE : Int                - REQUIRED | DEFAULT VAL : 1024     - DESC : Base (1000 (metric) or 1024 (binary notation))
    local V_LANG="${4:-en}";    # ARG TYPE : ISO 639-1 code     - REQUIRED | DEFAULT VAL : en       - DESC : Language, for localizing the byte count (default language : English).

    #**** Code ****
    if [[ "${L_PAD^^}" == N?(I|U)L?(L) ]]; then L_PAD='no'; fi

    # Creating a command substitution to calculate the byte count according to the values passed as arguments, with an AWK script.
    local BYTESTOHUMAN_RESULT; BYTESTOHUMAN_RESULT=$(awk -v bytes="${L_BYTES}" -v pad="${L_PAD}" -v base="${L_BASE}" -v lang="${V_LANG}" 'function human(x, pad, base, lang) {

        # If the desired base format is not the binary prefix, then the base format used will be the metric one.
        if(base!=1024)base=1000

        # Setting the prefixes list (K = kilo, M = mega, G = giga, T = tera, P = peta, E = exa, Z = zeta, Y = yotta), and corrected the inversion of the Exa with Peta, and Zeta with Yotta.
        if (lang == "fr") {
            # Condition ternaire : si le format de base utilise le préfixe binaire, cette unité "io" ([préfixe]bioctet) est affichée après la valeur. Sinon, cette unité "o" ([préfixe]octet) est affichée après la valeur.
            basesuf=(base==1024)?"io":"o"

            s="oKMGTPEZY"
        } else {
            # Ternary condition : if the base format uses the binary prefix, then the "iB" ([prefix]bibyte) unit is displayed after the value. Else the "[prefix]byte" unit is displayed after the value.
            basesuf=(base==1024)?"iB":"B"

            s="BKMGTPEZY"
        }

        # While the "x" ("human" function first parameter value) is superior or equal to the "base" (human function third parameter value) AND
        while (x>=base && length(s)>1)
               {x/=base; s=substr(s,2)}
        s=substr(s,1,1)

        if (lang == "fr") {
            xf=(pad=="yes") ? ((s=="o")?"%5d   ":"%8.2f") : ((s=="o")?"%d":"%.2f")
            s=(s!="o") ? (s basesuf) : ((pad=="no") ? s : ((basesuf=="io")?(s "  "):(s " ")))
        } else {
            xf=(pad=="yes") ? ((s=="B")?"%5d   ":"%8.2f") : ((s=="B")?"%d":"%.2f")
            s=(s!="B") ? (s basesuf) : ((pad=="no") ? s : ((basesuf=="iB")?(s "  "):(s " ")))
        }

        return sprintf( (xf " %s\n"), x, s)
    }

    BEGIN{print human(bytes, pad, base, lang)}')

    BU.Main.Echo.Msg "${BYTESTOHUMAN_RESULT}" '-n' 'nodate';

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Negative number (float or int) to positive number (float or int).
function BU.Main.BasicMaths.NegativeToPositive()
{
    #**** Parameters ****
    local x=${1:-$'\0'}; # ARG TYPE : Number    - REQUIRED | DEFAULT VAL : NULL     - Value to convert.

    #**** Code ****
    echo "$(( x = x < 0 ? x * -1 : x ))";

    return 0;
}

# Positive number (float or int) to negative number (float or int).
function BU.Main.BasicMaths.PositiveToNegative()
{
    #**** Parameters ****
    local x=${1:-$'\0'}; # ARG TYPE  : Number   - REQUIRED | DEFAULT VAL : NULL     - Value to convert.

    #**** Code ****
    echo "$(( x = x > 0 ? x * -1 : x ))";

    return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Case.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### LIBRARY RESOURCES

## VARIABLES

# __BU_MAIN_CASE_INVALID_ANSWER="Please enter a valid answer ($(BU.Main.Decho.Decho.Highlight 'yes') or ($(BU.Main.Decho.Decho.Highlight 'no')) !";
#
# __BU_MAIN_CASE_ASK_CONTINUE_EXEC="Do you want to continue the script's execution ? (yes / no)";
#
# __BU_MAIN_CASE_ANSWER_PROMPT="Enter your answer : ";
#
# __BU_MAIN_CASE_RESUME_EXEC="Resuming the execution of the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") script.";
#
# __BU_MAIN_CASE_CANCEL_EXEC="Aborting the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'s execution.";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### READING CASE STATEMENTS BY FUNCTIONS
#### DEBUG ID : case::reading-case-statements-by-functions

__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS="case::reading-case-statements-by-functions";

## "Directories.lib" FILE
## DEBUG ID : directories.lib-file

__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE="${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}::directories.lib-file";

# "BU.Main.Directories.TriggerRootDirWarning" function.
function BU.Main.Case.Read_DirectoriesTriggerRootDirWarning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__DIRECTORIES_LIB_FILE}";

    #**** Variables ****
    local __read_TriggerRootDirWarning; # VAR TYPE : String     - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VTriggerRootDirWarning='1';

    BU.Main.Echo.Newstep "${__BU_MAIN_CASE_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_CASE_ANSWER_PROMPT}" __read_TriggerRootDirWarning;
	BU.Main.Echo.Read "${__read_TriggerRootDirWarning}";
	BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_TriggerRootDirWarning,,}" in
		"yes")
            BU.Main.Echo.Newstep "${__BU_MAIN_CASE_RESUME_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
            BU.Main.Echo.Error "${__BU_MAIN_CASE_CANCEL_EXEC}";

			[ -n "${VTriggerRootDirWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_CASE_INVALID_ANSWER}";
			BU.Main.Case.Read_DirectoriesTriggerRootDirWarning;
			;;
	esac
}

# -----------------------------------------------

## "Errors.lib" FILE
## DEBUG ID : errors.lib-file

__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE="${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}::errors.lib-file";

# "BU.Main.Errors.HandleErrors" function, with the "${__BU_MAIN_STAT_ECHO}" variable set to "false".
function BU.Main.Case.Read_Errors.HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CASE_LIB__CAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS}" \
        "${__BU_MAIN_CASE_LIB__SUBCAT_DEBUG_ID__READING_CASE_STATEMENTS_BY_FUNCTIONS__ERRORS_LIB_FILE}";

    #**** Variables ****
    local __read_HandleErrors; # VAR TYPE : String      - DESC :

    #**** Code ****
    BU.ModuleInit.SetInitErrorMsg && declare -i VReadHandleErrors='1';

	BU.Main.Echo.Newstep "${__BU_MAIN_CASE_ASK_CONTINUE_EXEC}";

	read -rp "${__BU_MAIN_CASE_ANSWER_PROMPT}" __read_HandleErrors;
	BU.Main.Echo.Read "${__read_HandleErrors}";
    BU.Main.Echo.Newline;

	# shellcheck disable=SC2154
	case "${__read_HandleErrors,,}" in
		"yes")
			BU.Main.Echo.Newstep "${__BU_MAIN_CASE_RESUME_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return 0;
			;;
		"no")
			BU.Main.Echo.Error "${__BU_MAIN_CASE_CANCEL_EXEC}";

			[ -n "${VReadHandleErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			BU.Main.Errors.Exit "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			;;
		*)
			BU.Main.Echo.Error "${__BU_MAIN_CASE_INVALID_ANSWER}";
			BU.Main.Case.Read_Errors.HandleErrors;
			;;
	esac
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Checkings.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### VARIABLES VALUES CHECKINGS
#### DEBUG ID : checkings::variable-values-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS="checkings::variable-values-checkings";

## ARRAYS CHECKINGS
## DEBUG ID : array-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::array-checkings";

# Checking if the variable is an array.
function BU.Main.Checkings.IsArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    if [[ -n ${1} ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if an array in empty.
function BU.Main.Checkings.IsArrayEmpty()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    #**** Parameters ****
    local arr=("${@}")  # ARG TYPE : Array  - REQUIRED : DEFAULT VAL : NULL     - DESC : Array to process.

    #**** Code ****
    if [ ${#arr[@]} -eq 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if an array is not empty.
function BU.Main.Checkings.IsArrayNotEmpty()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__ARRAY_CHECKINGS}";

    #**** Parameters ****
    local arr=("${@}")  # ARG TYPE : Array  - REQUIRED : DEFAULT VAL : NULL     - DESC : Array to process.

    #**** Code ****
    if [ ${#arr[@]} -gt 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## COMMAND SUBSTITUTIONS
## DEBUG ID : command-substitutions

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::command-substitutions";

# Checking if the value is a command substitution.
function BU.Main.Checkings.IsCMD()
{
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS}";

    if  [ -n "${1}" ] && \
        ! BU.Main.Checkings.IsAlphaNumChar "${1}" && \
        ! BU.Main.Checkings.IsAlphaNumString "${1}" && \
        ! BU.Main.Checkings.IsInt "${1}" && \
        ! BU.Main.Checkings.IsFloat "${1}"; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# Checking if the value is not a command substitution.
function BU.Main.Checkings.IsNotCMD()
{
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__COMMAND_SUBSTITUTIONS}";

    if BU.Main.Checkings.IsCMD "${1}"; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## DATE FORMAT
## DEBUG ID : date-format

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::date-format";

# Checking if a given hour is formatted in timestamp format, with separators, and in these formats :
#   - hh:mm:ss
function BU.Main.Checkings.IsDateHMS() { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}"; [[ "$(date "+%H:%M:%S" > /dev/null)" ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats :
#   - YYYY-MM-DD
#   - DD-MM-YYYY
#   - YYYY/MM/DD
#   - DD/MM/YYYY
#   - YYYYMMDD
#   - DDMMYYYY
function BU.Main.Checkings.IsDateYMD() { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}"; [[ $(date "+%d-%m-%Y" -d "${1}" > /dev/null) ]] || return 1; return 0; }

# Checking if a given date is formatted in timestamp format, with separators, and in these formats.
#   - YYYY-MM-DD hh:mm:ss
#   - DD-MM-YYYY hh:mm:ss
#   - YYYY/MM/DD hh:mm:ss
#   - DD/MM/YYYY hh:mm:ss
#   - YYYYMMDD hh:mm:ss
#   - DDMMYYYY hh:mm:ss
function BU.Main.Checkings.IsDateYMD_HMS()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__DATE_FORMAT}";

    #**** Variables ****
    local v_date;   # VAR TYPE : Date   - DESC : Getting the year, the month and the day.
    local v_hour;   # VAR TYPE : Date   - DESC : Getting the hour.

    #**** Code ****
    v_date="$(echo "${1}" | rev | cut -d ' ' -f2- | rev)";
    v_hour="$(echo "${1}" | rev | cut -d ' ' -f 1 | rev)";

    [[ $(BU.Main.Checkings.IsDateYMD "${v_date}" > /dev/null) ]] || \
    {
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")() --> Warning : the date is not formatted in a correct timestamp";
        BU.Main.Echo.Warning "Please use one of these formats :";
        BU.Main.Echo.Warning "YYYY-MM-DD";
        BU.Main.Echo.Warning "DD-MM-YYYY";
        BU.Main.Echo.Warning "YYYY/MM/DD";
        BU.Main.Echo.Warning "DD/MM/YYYY";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    date "+%H:%M:%S" -d "${v_hour}" || \
    {
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")() --> Warning : the hour is not formatted in a correct timestamp";
        BU.Main.Echo.Warning "Please use only this format : hh:mm:ss";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## NUMBER VALUES
## DEBUG ID : number-values

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::number-values";

# Checking floating value.
function BU.Main.Checkings.IsFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [[ "${1}" =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking negative only floating value.
function BU.Main.Checkings.IsNegativeFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if BU.Main.Checkings.IsFloat "${1}" && (( 1 < 0 )); then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking positive only floating value.
function BU.Main.Checkings.IsPositiveFloat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if BU.Main.Checkings.IsFloat "${1}" && (( 1 >= 0 )); then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking integer value.
function BU.Main.Checkings.IsInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

    if [[ "${1}" =~ ^[\-0-9]+$ ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking negative only integer value.
function BU.Main.Checkings.IsNegativeInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

	if BU.Main.Checkings.IsInt "${1}" && (( 1 < 0 )); then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking positive only integer value.
function BU.Main.Checkings.IsPositiveInt()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__NUMBER_VALUES}";

	if BU.Main.Checkings.IsInt "${1}" && (( 1 >= 0 )); then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# -----------------------------------------------

## CHARACTERS AND STRING VALUES
## DEBUG ID : characters-and-string-values

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::characters-and-string-values";

# Checking if the value is an alphabetic character (not any number allowed).
function BU.Main.Checkings.IsAlphaChar()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [[ "${1}" == [a-zA-Z] ]]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking if the value is an alphabetic string (not any number allowed)
function BU.Main.Checkings.IsAlphaString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

    if [[ "${1}" == [^a-zA-Z\ ] ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters AND not any number allowed).
function BU.Main.Checkings.IsAlphaStringOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "${1}" == [^a-zA-Z\ ] ]]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

# Checking if the value is a character.
function BU.Main.Checkings.IsAlphaNumChar()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [[ "${1}" == [a-zA-Z0-9] ]]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking if the value is an alphanumeric string.
function BU.Main.Checkings.IsAlphaNumString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

    if [[ "${1}" =~ [^a-zA-Z0-9\ ] ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if the value is an alphabetic string only (not less than two characters).
function BU.Main.Checkings.IsAlphaNumStringOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}" "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__CHARACTERS_AND_STRING_VALUES}";

	if [ "${#1}" -lt 2 ]; then
    	echo "Not a string"; return 1;

	else
		if [[ "${1}" == [^a-zA-Z0-9\ ] ]]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
    		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		fi
	fi
}

# -----------------------------------------------

## OTHER VARIABLES CHECKINGS
## DEBUG ID : other-variables-checkings

# shellcheck disable=SC2034
__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS__OTHER_VARIABLES_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_CHECKINGS}::other-variables-checkings";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### DIFFERENT CHECKINGS
#### DEBUG ID : checkings::different-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS="checkings::different-checkings";

## CHECKING FOR IDENTIFIANTS
## DEBUG ID : checking-for-identifiants

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}::checking-for-identifiants";

# Checking if the current effective UID (EUID) is not equal to 0 (root user's EUID).

# Required functions and files :
#   - BU.Main.Errors.HandleErrors      --> From this file.
function BU.Main.Checkings.CheckRootEUID()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__CHECKING_FOR_IDENTIFIANTS}";

    if [ "${EUID}" -eq 0 ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else return 1; fi
}

alias BU.Main.Checkings.IsRoot='BU.Main.Checkings.CheckRootEUID';

# -----------------------------------------------

## BASIC HARDWARE CHECKINGS
## DEBUG ID : basic-hardware-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}::basic-hardware-checkings";

# Check if hard drive is full.
function BU.Main.Checkings.CheckDiskUsedSpace()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__DIFFERENT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__DIFFERENT_CHECKINGS__BASIC_HARDWARE_CHECKINGS}";

	#**** Parameters ****
    local p_fileFS=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Target file's file system.
    local p_dirfile=${2:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Create the file with the directory if not exists, then erase it, in order to get the target file system.
    local p_authorization=${3:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to call the "BU.Main.Errors.HandleErrors()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and that "BU.__/Decho()" functions are called in the "BU.Main.Errors.HandleErrors()" function). Set this value to "false" to forbid this call.

    #**** Code ****

    # The function "BU.Main.Checkings.CheckProjectLogStatus()" function is called in each "Echo<...>()" functions if the "${__BU_MAIN_STAT_ECHO}" status global
    # variable's value is set to 'false', and the current function is called at the beginning of the "BU.Main.Checkings.CheckProjectLogStatus()" function.

    # Changing the "${__BU_MAIN_STAT_ECHO}" global status variable's value to 'true', in order to avoid an infinite
    # loop during the call of any function from the "Filesystem.lib" file, which call an "Echo<...>()" function.

    if [ "${__BU_MAIN_STAT_ECHO,,}" == 'false' ]; then
        local v_echoBackup="${__BU_MAIN_STAT_ECHO}";

        # There is no need to call the associated function "BU.Main.Status.ChangeSTAT_ECHO", since no text have to be redirected to the log file afterwards, because the script has to definitely exit if the disk is full.
        __BU_MAIN_STAT_ECHO="true";
    fi

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

    if [ "${p_dirfile,,}" == 'create' ]; then
            BU.Main.Filesystem.IsPartitionFull "${p_fileFS}" "${p_dirfile}"; local IsPartitionFullReturnCode="${?}";
    else    BU.Main.Filesystem.IsPartitionFull "${p_fileFS}"; fi

    # If the execution of the "BU.Main.Filesystem.IsPartitionFull()" function was successful.
    if [ "${IsPartitionFullReturnCode}" -eq 0 ]; then

        # Resetting the former "${__BU_MAIN_STAT_ECHO}" global status variable's value.
        if [ "${v_echoBackup,,}" == 'false' ]; then
            __BU_MAIN_STAT_ECHO="${v_echoBackup}";
        fi

        [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if no directory or file is passed as first argument for the "BU.Main.Filesystem.IsPartitionFull()" function.
    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" "NO DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" \
                "Please give a filepath in order to check if the target file system is full or not${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" \
                "Unknown file system size because of a missing path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        else
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : NO DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" >&2;
            echo "Please give a path in order to check if the target file system is full or not" >&2;
            echo >&2;

            echo "Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi

    # Else, if an invalid directory or file was passed as first argument for the "BU.Main.Filesystem.IsPartitionFull()" function.
    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" "INVALID DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" \
                "Please give a valid path in order to check if the target file system is full or not${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" \
                "Unknown file system size because of a missing file path" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        else
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : INVALID DIRECTORY OR FILE PASSED AS FIRST ARGUMENT !!!" >&2;
            echo "Please give a valid path in order to check if the target file system is full or not" >&2;
            echo >&2;

            echo "Since the file system's disk space is unknown, the script has to be exited, in order to avoid potential bugs" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi

    elif [ "${IsPartitionFullReturnCode}" == "${__BU_MAIN_EXIT_NO_SPACE_LEFT}" ]; then local lineno="${LINENO}";

        # If the framework is still initializing when an error occurs.
        BU.ModuleInit.SetInitErrorMsg && local VCheckDiskUsedSpace='1';

        # As mentioned in the previous comment, it is mandatory that the script's execution ends.
        BU.Main.Status.ChangeSTAT_ERROR 'fatal' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        if [ "${p_authorization,,}" == 'true' ]; then
            BU.Main.Errors.HandleErrors "${IsPartitionFullReturnCode}" \
                "NO SPACE LEFT ON THE TARGET FILE {SYSTEM} !!!" \
				"Please empty this file system (mounted on the « $(BU.Main.Filesystem.GetFSMountPoint "${p_fileFS}") » partition) before using it, or use another partition to write data in a file${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}Since the file system's disk space is full, the script has to be exited in order to avoid potential bugs" \
                "No space left on the target device's partition" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        elif [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
            echo "IN $(basename "${BASH_SOURCE[0]}"), FUNCTION ${FUNCNAME[0]}, LINE $(( LINENO - 1 )) --> ERROR : NO SPACE LEFT ON THE TARGET FILE SYSTEM !!!" >&2;
            echo "Please empty this file system (mounted on the « $(BU.Main.Filesystem.GetFSMountPoint "${p_fileFS}") » partition) before using it, or use another partition to write data in a file" >&2;
            echo >&2;

            echo "Since the file system's disk space is full, the script has to be exited" >&2;
            echo >&2;

            [ -n "${VCheckDiskUsedSpace}" ] && BU.ModuleInit.UnsetInitErrorMsg;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.ModuleInit.IsInScript && exit "${IsPartitionFullReturnCode}"; return "${IsPartitionFullReturnCode}";
        fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PATHS CHECKINGS
#### DEBUG ID : Checkings.paths-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS="checkings::paths-checkings";

## DIRECTORIES PATHS CHECKINGS
## DEBUG ID : directories-paths-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}::directories-paths-checkings";

# Checking for an existent directory path (for the "BU.Main.Errors.HandleErrors()" function mainly).
function BU.Main.Checkings.CheckDirPathExists()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the (in)existent directory.
    local p_authorization=${2:-true};   # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : true     - DESC : Authorization to call the "BU.Main.Decho.Decho.Path()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and they are called in the "BU.Main.Decho.Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -d "${p_path}" ] && [ "${p_authorization,,}" == 'true' ]; then
        BU.Main.Decho.Decho.Path "<missing directory path>";  # Since this function should be called into a string, it's better to use a formatting function.

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -d "${p_path}" ] && [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
        printf "<missing directory path>"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking if a directory was successfully created.
function BU.Main.Checkings.CheckDirPathWasCreated()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__DIRECTORIES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the newly created directory.

	#**** Code ****
	if [ -d "${p_path}" ]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# -----------------------------------------------

## FILES PATHS CHECKINGS
## DEBUG ID : files-path-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}::files-paths-checkings";

# Checking for an existent file path (for the "BU.Main.Errors.HandleErrors()" function mainly).
function BU.Main.Checkings.CheckFilePathExists()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the (in)existent file.
    local p_authorization=${2:-true};   # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : true     - DESC : Authorization to call the "BU.Main.Decho.Decho.Path()" function (since this function is called in the "BU.Main.Decho.SetBG/TextColor()" functions, and they are called in the "BU.Main.Decho.Decho<...>()" functions). Set this value to "false" to forbid this call.

    #**** Code ****
    if [ ! -f "${p_path}" ] && [ "${p_authorization,,}" == 'true' ]; then
        BU.Main.Decho.Decho.Path "<missing file path>";       # Since this function should be called into a string, it's better to use a formatting function.

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;

    elif [ ! -f "${p_path}" ] && [ "${p_authorization,,}" == 'false' ] || [ -z "${p_authorization}" ]; then
        printf "<missing file path>"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Checking if a file was successfully created.
function BU.Main.Checkings.CheckFilePathWasCreated()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the newliy created file.

	#**** Code ****
	if [ -f "${p_path}" ]; then
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	fi
}

# Checking for "${__BU_MAIN_PROJECT_LOG_FILE_PATH}".

# Required functions and files :
function BU.Main.Checkings.CheckProjectLogPath()
{
    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && declare -i VCheckProjectLogPath='1';

    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

    # Since the "${__BU_MAIN_STAT_DECHO}" and the "${__BU_MAIN_STAT_ECHO}" status variables values are set to their safe mode in the "BU.Main.Status.CheckProjectLogStatus()" function
    # (the only one where the "BU.Main.Checkings.CheckProjectLogPath()" function can be called), it's safe to call an "BU.Echo<...>()" function, the "BU.Main.Errors.HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
    if [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
		BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : no existing log file";
		BU.Main.Echo.Newstep "Creating a log file for the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project";

		if ! BU.Main.Files.CreateProjectLogFile; then
			[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		else
			[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi

    # Remember : since the "$[__BU_MAIN_STAT_DECHO]" and the "$[__BU_MAIN_STAT_ECHO]" status variables values are set to their safe mode in the "BU.Main.Status.CheckProjectLogStatus()" function
    # (the only one where the "BU.Main.Checkings.CheckProjectLogPath()" function can be called), it's safe to call an "BU.Echo<...>()" function, the "BU.Main.Errors.HandleErrors()" or the "DechoHighlight" functions without risking an infinite loop.
     elif [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
         echo "${__BU_MAIN_PROJECT_LOG_FILE_PATH}";

         BU.Main.Errors.HandleErrors "1" "BAD PATH PROVIDED INTO THE $(BU.Main.Decho.Decho.Path "__BU_MAIN_PROJECT_LOG_FILE_PATH") VARIABLE" \
             "Please correct the path passed as argument, or redefine the variable if its value was modified somewhere" \
             "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

 		[ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    else
        [ -n "${VCheckProjectLogPath}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# Checking for project's log file's status, then write the wanted text with 'echo' command's parameters.

# Accepted arguments : 'nodate', '<an empty string>'
function BU.Main.Status.CheckProjectLogStatus()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

	# Checking first if the partition where the log file exists is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; exit "${C}"; };

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : Any        - REQUIRED | DEFAULT VAL : NULL     - DESC : Text to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}");   # Array - More processing arguments (like the processing of a whole line-long string).

    #**** Variables ****

	# WARNING : DO NOT call any "BU.Echo<...>()" function from the "main/Echo.lib" file, as they all call the "BU.Main.Status.CheckProjectLogStatus()" function.

	# Also, DO NOT call any "Decho<...>()" function, as they call the "BU.Main.Errors.HandleErrors()" function in case of a bad value passed as array of argument,
	# which also calls this same "BU.Main.Status.CheckProjectLogStatus()" function.

    # If you need to call a function here, please verify if it doesn't calls the "BU.Main.Status.CheckProjectLogStatus()" function,
    # nor any function called by the function you want to add, or else set the "${__BU_MAIN_STAT_ECHO}" status variable value to "true" BEFORE calling the wanted function.

    # -------------------------------------------

    # Setting the "${__BU_MAIN_STAT_DECHO}" global status variable's value to 'restrict', in case an error occurs during a function call.

    # Also disabling a shellcheck warning, which is a false positive (saying that "${__BU_MAIN_STAT_DECHO}" may not be assigned, but "${__BU_MAIN_STAT_ECHO}" is (both of them are valid and working differently)).

    # shellcheck disable=SC2153
    local v_bu_stat_decho_old="${__BU_MAIN_STAT_DECHO}"; BU.Main.Status.ChangeSTAT_DECHO "restrict" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    }

    # Setting the "${__BU_MAIN_STAT_ECHO}" global status variable's value to 'true', in case an error occurs during a function call, where the "BU.Main.Status.CheckProjectLogStatus()" function or any other function that calls it might be called.
    local v_bu_stat_echo_old="${__BU_MAIN_STAT_ECHO}"; BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    }

    local v_redirectionError;
        v_redirectionError="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to write into the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") file.\nRedirection option --> ";

    local v_warning_array_value;
        v_warning_array_value="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : incorrect argument given as extra argument array in $(BU.Main.Decho.Decho.Path "${BASH_SOURCE[0]}"), function $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()").\nValue --> $(BU.Main.Decho.Decho.Highlight "${val}")\nLine -->";

    #**** Code ****
    # This checking must be done before the long condition below, since it needs to know if the project's log file is present.
    if [ "${__BU_MAIN_STAT_LOG,,}" == "true" ]; then
        BU.Main.Checkings.CheckProjectLogPath || \
        {
            local returnCode="${?}";

            # Resetting the "${__BU_MAIN_STAT_DECHO}" status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is stopped.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

            # Resetting the "${__BU_MAIN_STAT_ECHO}" status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is stopped.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

            return "${returnCode}";
        };
    fi

    BU.Main.Status.CheckSTAT_LOG             'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }
    BU.Main.Status.CheckSTAT_LOG_REDIRECT    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }
    BU.Main.Status.CheckSTAT_TIME_TXT        'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }

    # If a log file exists AND if "${__BU_MAIN_STAT_LOG}" value is "false" AND if "${__BU_MAIN_STAT_LOG_REDIRECT}" has a redirection value.
    if [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ] && [ "${__BU_MAIN_STAT_LOG,,}" == "true" ]; then

        # If messages must be redirected in the log file only ("${__BU_MAIN_STAT_LOG_REDIRECT}" value is equal to "log").
        if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "log" ]; then

            # Setting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_header="${__BU_MAIN_STAT_TIME_HEADER}"; BU.Main.Status.ChangeSTAT_TIME_HEADER "0" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Setting the "${__BU_MAIN_STAT_TIME_NEWLINE}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_newline="${__BU_MAIN_STAT_NEWLINE}"; BU.Main.Status.ChangeSTAT_TIME_NEWLINE "0"   || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Setting the "${__BU_MAIN_STAT_TIME_TXT}" global status variable's value to 0 seconds, since no text is being displayed on the screen.
            local v_stat_time_txt="${__BU_MAIN_STAT_TIME_TXT}"; BU.Main.Status.ChangeSTAT_TIME_TXT "0"          || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            for val in "${pa_extraArgs[@]}"; do

                # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.
                local v_loop_error;

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" == 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}" 'n';
                            else
                                echo -ne "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}";  BU.Main.Echo.Newline >&2; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                        '' | *)
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}";
                            else
                                echo -e "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                    esac

                # Else, if no argument is passed in "${pa_extraArgs}" parameter array.
                elif [ -z "${val}" ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}" 'n';
                            else
                                echo -ne "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                        '' | *)
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}";
                            else
                                echo -e "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                    esac
                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "log" option)).
                else
                    # If the framework is still initializing when an error occurs.
                    BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1';

                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}" 'n';

                                # Since the "${__BU_MAIN_STAT_ECHO}" status variable's value is set to 'true', this "BU.Main.Status.CheckProjectLogStatus()" function won't be called, only a minimalist substitute function.
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline;
							else
                                echo -ne "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
							fi; BU.Main.Echo.Newline;
                        ;;
                        '' | *)
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}";
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
							else
                                echo -e "${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "log")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
							fi
                        ;;
                    esac

                    [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg;
                fi
            done; if [ "${v_loop_error}" == 'error' ]; then [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

            # Resetting the "${__BU_MAIN_STAT_DECHO}" status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"            'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_ECHO}" status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"              'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_HEADER    "${v_stat_time_header}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_HEADER}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_NEWLINE   "${v_stat_time_newline}"   'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_TIME_TXT}" global status variable's value to the former timer.
            BU.Main.Status.ChangeSTAT_TIME_TXT       "${v_stat_time_txt}"       'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            return 0;

        # Else, if messages must be redirected in the log file AND to the terminal ("${__BU_MAIN_STAT_LOG_REDIRECT}" value is equal to "tee").
        elif [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "tee" ]; then

            for val in "${pa_extraArgs[@]}"; do

                # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.
                local v_loop_error;

                # If the 'nodate' value is passed as argument.
                if [ "${val,,}" == 'nodate' ]; then
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string#* ] }" 'n';
                            else
                                echo -ne "${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                        '' | *)
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string#* ] }";
                            else
                                echo -e "${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                            fi
                        ;;
                    esac

                # Else, if no argument is passed in "${pa_extraArgs}" parameter array.
                elif [ -z "${val}" ]; then
                    case "${p_option,,}" in
                    '-n' | 'n')
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}" 'n';
                        else
                            echo -ne "${p_string}";
                            echo -ne "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                        fi
                    ;;
                    '' | *)
                        if BU.Main.Status.CheckStatIsInitializing; then
                            BU.ModuleInit.Msg "${p_string}";
                        else
                            echo -e "${p_string}";
                            echo -e "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.ModuleInit.SetInitErrorMsg && local VCheckProjectLogStatus='1'; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                        fi
                    ;;
                    esac

                # Else, if an unsupported option is passed (note for myself : the extra args checking
                # "for" loop (for val in "${pa_extraArgs[@]}"; do) is still running (for the "tee" option)).
                else
                    case "${p_option,,}" in
                        '-n' | 'n')
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "${p_string}" 'n';
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; v_loop_error='error'; break; };
							else
                                echo -ne "${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; v_loop_error='error'; break; };
							fi; BU.Main.Echo.Newline;
                        ;;
                        '' | *)
                            if BU.Main.Status.CheckStatIsInitializing; then
                                BU.ModuleInit.Msg "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}";
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
							else
                                echo -e "${p_string}" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
                                BU.Main.Echo.Warning "${v_warning_array_value} $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate' 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { local C="${?}"; BU.Main.Echo.Newline >&2; BU.Main.Echo.Error "${v_redirectionError} $(BU.Main.Decho.Decho.Var "tee")\nLine --> $(BU.Main.Decho.Decho.Highlight "${LINENO}")" "${p_option}" 'nodate'; BU.Main.Echo.Newline >&2; v_loop_error='error'; break; };
							fi
                        ;;
                    esac

                    [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg;
                fi
            done; if [ "${v_loop_error}" == 'error' ]; then [ -n "${VCheckProjectLogStatus}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

            sleep "${__BU_MAIN_STAT_TIME_TXT}";

			# Resetting the "${__BU_MAIN_STAT_DECHO}" status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
			BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"  'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

			# Resetting the "${__BU_MAIN_STAT_ECHO}" status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
			BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

			return 0;

        # Else, if messages must not be redirected in the log file.
        else
            case "${p_option,,}" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}";
                    else
                        echo -ne "${p_string}";
                    fi
                ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}";
                    else
                        echo -e "${p_string}";
                    fi
                ;;
            esac

            sleep "${__BU_MAIN_STAT_TIME_TXT}";

            # Resetting the "${__BU_MAIN_STAT_DECHO}" status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            # Resetting the "${__BU_MAIN_STAT_ECHO}" status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
            BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            return 0;

        fi

    # Else, if no log file exists OR if "${__BU_MAIN_STAT_LOG}" value is "false" OR if "${__BU_MAIN_STAT_LOG_REDIRECT}" has no redirection value.
    else
        case "${p_option,,}" in
            '-n' | 'n')
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}" 'n';
                else
                    echo -ne "${p_string}";
                fi
                ;;
            '' | *)
                if BU.Main.Status.CheckStatIsInitializing; then
                    BU.ModuleInit.Msg "$(if [ -n "${__BU_MAIN_TIME_DATE_DISPLAY}" ]; then echo "${__BU_MAIN_TIME_DATE_DISPLAY}"; fi) ${p_string}";
                else
                    echo -e "${p_string}";
                fi
                ;;
        esac

        sleep "${__BU_MAIN_STAT_TIME_TXT}";

        # Resetting the "${__BU_MAIN_STAT_DECHO}" status variable's value to its former value, since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
        BU.Main.Status.ChangeSTAT_DECHO "${v_bu_stat_decho_old}"    'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

		# Resetting the "${__BU_MAIN_STAT_ECHO}" status variable's value to its former value if it was "false", since the "BU.Main.Status.CheckProjectLogStatus()" function's execution is over.
		BU.Main.Status.ChangeSTAT_ECHO "${v_bu_stat_echo_old}"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

		return 0;
	fi
}

# Check project related file presence, or create this file.
function BU.Main.Checkings.CheckProjectRelatedFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__PATHS_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__PATHS_CHECKINGS__FILES_PATHS_CHECKINGS}";

	#**** Parameters ****
    local p_parent=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the folder to process (into its parent directory).
    local p_child=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file or folder to process (into its parent directory).
    local p_type=${3:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of data to create (d = directory, f = file).
    local p_decho=${4:-$'\0'};  # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC :

	#**** Variables ****
    local v_path="${p_parent}/${p_child}";  # VAR TYPE : Path   - DESC : Path to the file to check for its existence, or to create if it does not exists on the computer's hard drive.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${v_path}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; exit "${C}"; };

	if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
        if ! BU.Main.Args__Checkings.CheckProjectRelatedFile "${p_parent}" "${p_child}" "${p_type}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi
    fi

	if [ "${p_type}" == 'f' ]; then
		if [ -f "${v_path}" ]; then
			if [ -s "${v_path}" ]; then
				true > "${v_path}" || {
                    if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                        BU.Main.Errors.HandleSmallErrors 'E' \
                            "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to overwrite this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file --> $(BU.Main.Checkings.CheckFilePathExists "${v_path}" 'true')" 'E';
                    else
                        BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to overwrite this « ${__BU_MAIN_PROJECT_NAME} » project's file --> ${v_path}";
                        BU.Main.Echo.Newline;
                    fi

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                }
			fi

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
			if [ ! -d "${p_parent}" ]; then
                if [ "${p_parent}" == "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" ]; then BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_BG_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

                elif [ "${p_parent}" == "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" ]; then echo TEST; BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_TXT_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

                else
                    mkdir -p "${p_parent}" || {
                        local returnCode="${?}";

                        if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                            BU.Main.Errors.HandleSmallErrors 'E' \
                                "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file's parent folder --> $(BU.Main.Checkings.CheckDirPathExists "${p_parent}" 'true')" 'E';
                        else
                            BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to create this « ${__BU_MAIN_PROJECT_NAME} » project's file parent folder --> ${p_parent}";
                            BU.Main.Echo.Newline;
                        fi

                        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
                    }
                fi

				BU.Main.Checkings.CheckDirPathWasCreated "${p_parent}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
			fi

            if [ "${p_child}" == "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}" ]; then BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_BG_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            elif [ "${p_child}" == "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}" ]; then echo TEST2; BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_TXT_RESET}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            else
                touch "${v_path}" || {
                    local returnCode="${?}";

                    if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                        BU.Main.Errors.HandleSmallErrors 'E' \
                            "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's file --> $(BU.Main.Checkings.CheckFilePathExists "${v_path}" 'true')" 'E';
                    else
                        BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to overwrite this « ${__BU_MAIN_PROJECT_NAME} » project's file --> ${v_path}";
                        BU.Main.Echo.Newline;
                    fi

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
                }
            fi

			BU.Main.Checkings.CheckFilePathWasCreated "${v_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; return 0;
		fi

    elif [ "${p_type}" == 'd' ]; then
		if [ -d "${v_path}" ]; then
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		else
            mkdir -p "${v_path}" || {
                local returnCode="${?}";

                if [ -z "${p_decho}" ] || [ -n "${p_decho}" ] && [ "${p_decho,,}" == '--decho' ]; then
                    BU.Main.Errors.HandleSmallErrors 'E' \
                        "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : unable to create this $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}") project's folder --> $(BU.Main.Checkings.CheckDirPathExists "${v_path}" 'true')" 'E';
                else
                    BU.Main.Echo.Error "${FUNCNAME[0]}() --> Error : unable to create this « ${__BU_MAIN_PROJECT_NAME} » project's folder --> ${v_path}";
                    BU.Main.Echo.Newline;
                fi

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${returnCode}";
            }
			BU.Main.Checkings.CheckDirPathWasCreated "${v_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT CHECKINGS
#### DEBUG ID : Checkings.text-checkings

__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS="Checkings::text-checkings";

## FORMATTING CHECKINGS
## DEBUG ID : formatting-checkings

__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS="${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS}::formatting-checkings";

# Checking if the project's color code file exists or not.

# WARNING ! DO NOT CALL ANY "Decho<...>()" FUNCTION HERE, OR THE SCRIPT WILL LOOP FOREVER !!!
function BU.Main.Checkings.CheckDecho()
{
    #**** Code ****
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CHECKINGS_LIB__CAT_DEBUG_ID__TEXT_CHECKINGS}" \
        "${__BU_MAIN_CHECKINGS_LIB__SUBCAT_DEBUG_ID__TEXT_CHECKINGS__FORMATTING_CHECKINGS}";

    # If the text formatting is forbidden, then the "Decho()" function will not decorate the targeted text :
    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" == "false" ] || [ "${__BU_MAIN_STAT_DECHO,,}" == 'forbid' ]; then
        return 1;
    else
        # Creating the "fgcolor.tmp" (text color) file in case it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then
            if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}" 'f'; then
                BU.Main.Errors.HandleSmallErrors 'E' "Unable to create the $(BU.Main.Decho.Decho "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}") file" 'E' 'CPLS'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        # Creating the "bgcolor.tmp" (background color) file in case it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then
            if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}" 'f'; then
                BU.Main.Errors.HandleSmallErrors 'E' "Unable to create the $(BU.Main.Decho.Decho "${__BU_MAIN_PROJECT_COLOR_TEXT_BG_FILE_PATH}") file" 'E' 'CPLS'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        fi

        if [ -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ] && [ "$(cat "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")" == '' ]; then
            echo "${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" || \
            {
                # It's better to call the "BU.Main.Echo.Msg()" function, so that its redirection and debug process wil not have to be reprogrammed.
                # It's also better to not call the "BU.Main.Errors.HandleSmallErrors()" function here, so that there won't be any problem when this function calls the "Decho<...>()" functions.
                BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}()${__BU_MAIN_COLOR_TXT_WARNING}--> Warning : Unable to write any color code into the ${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}${__BU_MAIN_COLOR_TXT_WARNING} file." 'R' '';

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            }

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
	fi
}

# -----------------------------------------------
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : CMDS.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# Functions used to process information about executable commands.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### PROCCESSING COMMANDS
#### DEBUG ID : cmds.processing-commands

__BU_MAIN_CMDS_LIB__CAT_DEBUG_ID__PROCESSING_COMMANDS="cmds::processing-commands";

## GETTING COMMAND OUTPUTS
## DEBUG ID : getting-command-output

__BU_MAIN_CMDS_LIB__SUBCAT_DEBUG_ID__PROCESSING_COMMANDS__GET_COMMAND_OUTPUTS="${__BU_MAIN_CMDS_LIB__CAT_DEBUG_ID__PROCESSING_COMMANDS}::getting-command-output";

# Get command's executable file's path.
function BU.Main.CMDS.GetCommandPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CMDS_LIB__CAT_DEBUG_ID__PROCESSING_COMMANDS}" \
        "${__BU_MAIN_CMDS_LIB__SUBCAT_DEBUG_ID__PROCESSING_COMMANDS__GET_COMMAND_OUTPUTS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}; #ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the command to process, with it's options.

    #**** Code ****
    if ! BU.Main.Args__CMDS.GetCommandPath "${p_cmd}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    command -v "${p_cmd}" || { local C="${?}"; BU.Main.Errors.HandleSmallErrors 'E' "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : The $(BU.Main.Decho.Decho.Highlight "${p_cmd}") command was not found on your system" 'E'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Get the command's return output.
function BU.Main.CMDS.GetCommandReturnOutputValue()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_CMDS_LIB__CAT_DEBUG_ID__PROCESSING_COMMANDS}" \
        "${__BU_MAIN_CMDS_LIB__SUBCAT_DEBUG_ID__PROCESSING_COMMANDS__GET_COMMAND_OUTPUTS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the command to process, with it's options.

    #**** Code ****
    if eval "${p_cmd}" > /dev/null; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : BU.Main.Decho.Decho.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2181

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT WRITING AND DECORATION (FORMATTING)
#### DEBUG ID : decho::text-writing-and-decoration-(formatting)

__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING="decho::text-writing-and-decoration-(formatting)";

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS
## DEBUG ID : writing-differently-cf-text-between-Text.basis

__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS="${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}::writing-differently-cf-text-between-Text.basis";

# Text's inside decoration/formatting procssing (light version, safe to use when the complete version cannot be called without provoking an infinite loop).
function BU.Main.Decho.__Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}" \
        "${__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS}";

	#**** Parameters ****
	local p_string=${1:-$'\0'};         # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
	local p_newTextColor=${2:-$'\0'};   # ARG TYPE : CMD		- OPTIONAL | DEFAULT VAL : NULL	    - DESC : Color to apply on each string's characters.
	local p_newBGColor=${3:-$'\0'};	    # ARG TYPE : CMD		- OPTIONAL | DEFAULT VAL : NULL	    - DESC : Color to apply in the text's background.

	#**** Code ****
    printf "%s\n" "${p_newTextColor}${p_string}${p_newBGColor}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Text's inside decoration/formatting procssing (complete version).

# Featured functions and files from the "functions" folder :
#   - BU.Main.Checkings.CheckDecho
#   -
function BU.Main.Decho.Decho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DECHO_LIB__CAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING}" \
        "${__BU_MAIN_DECHO_LIB__SUBCAT_DEBUG_ID__TEXT_WRITING_AND_DECORATION_FORMATTING__WRITING_DIFFERENTLY_COLORED_FORMATTED_TEXT_BETWEEN_TEXT_BASIS}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};         # String	- Default : NULL	- String to display.
    local p_newTextColor=${2:-NULL};    # Int       - Default : NULL	- Color to apply on each string's characters.
    local p_newBGColor=${3:-NULL};      # Int       - Default : NULL	- Color to apply in the text's background.

    if [ "${p_newTextColor^^}"  == 'NULL' ]; then p_newTextColor=$'\0'; fi
    if [ "${p_newBGColor^^}"    == 'NULL' ]; then p_newBGColor=$'\0';   fi

    # Processing the arguments array.
    if [ -n "${p_string}" ]; then
        if [ -z "${p_newTextColor}" ] && [ -z "${p_newBGColor}" ]; then
            shift 1;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :

            BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}";

        elif [ -n "${p_newBGColor}" ] && [ -z "${p_newTextColor}" ] || [ -n "${p_newTextColor}" ] && [ -z "${p_newBGColor}" ]; then
            shift 2;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :

            BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}";
        else
            shift 3;

            local pa_fmtArgs=("${@}");  # ARG TYPE : ARRAY  - OPTIONAL : DEFAULT VAl : NULL     - DESC :
        fi
    fi

	#**** Variables ****
    local v_loop_error; # VAR TYPE : String     - DESC : This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #**** Code ****
    # If a string is provided as a color name, the corresponding color code is assigned to the variable.
    if BU.Main.Checkings.IsAlphaString "${p_newTextColor}";     then BU.Main.TextFormat.Atoi "${p_newTextColor}";   p_newTextColor="${__BU_MAIN_COLORS_ATOI_COLOR}";    fi
    if BU.Main.Checkings.IsAlphaString "${p_newBGColor}";       then BU.Main.TextFormat.Atoi "${p_newBGColor}";     p_newBGColor="${__BU_MAIN_COLORS_ATOI_COLOR}";      fi

    if ! BU.Main.Args__Decho.Decho "${p_string}" "${p_newTextColor}" "${p_newTextColor}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then return 1; fi

    BU.Main.Checkings.CheckDecho;

    if test "${?}" -ne 0; then
        if [ "${__BU_MAIN_STAT_DECHO,,}" == 'forbid' ]; then

            # If the text formatting is forbidden, but the "${__BU_MAIN_STAT_TXT_FMT}" global status variable's value is set to "true", the text to decorate will be put between French guillemets.
            if BU.Main.Status.CheckStatAllowFormatting; then
                echo -ne "« ${p_string} »"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

            # Else, if the text formatting is forbidden, AND the "${__BU_MAIN_STAT_TXT_FMT}" global status variable's value is set to "false", no decoration nor highlighting will be made.
            else
                echo -ne "${p_string}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
            fi
        else
            echo -ne "« ${p_string} »"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
    else
        if [ -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then
            local v_oldBGColor;
                v_oldBGColor="$(cat "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}")"; fi

        if [ -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then
            local v_oldTextColor;
                v_oldTextColor="$(cat "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")"; fi
    fi

    # If both of the new colors are equal.
    if [ "${p_newBGColor}" == "${p_newTextColor}" ]; then
        p_newBGColor="$(( p_newBGColor + 34 ))";
    fi

    # If the text color code's value is equal to it's former value.
    if [ "${p_newTextColor}" == "${v_oldTextColor}" ]; then

        # TODO : Développer un meilleur système de changement de couleur (P-Ê en appelant une fonction à créer, ou en utilisant une formule mathématique). Se renseigner sur la commande "tput setaf".
		p_newTextColor="$(( p_newTextColor + 38 ))";
    fi

    # If the background color code's value is equal to it's former value.
    if [ "${p_newBGColor}" == "${v_oldBGColor}" ]; then
		p_newBGColor="$(( p_newBGColor + 38 ))";
	fi

    # Setting the new values in their color code temporary file.
    if [ -n "${p_newTextColor}" ]; then BU.Main.TextFormat.SetTextColor "${p_newTextColor}"; fi

    if [ -n "${p_newBGColor}" ]; then BU.Main.TextFormat.SetBGColor "${p_newBGColor}"; fi

    # Test code, to check the values from the command substitutes.
    echo "STRING : ${p_string}";
    echo "TEXT COLOR : ${p_newTextColor}";
    echo "BG COLOR : ${p_newBGColor}";

    # -----------------------------------------------

    ## APPLYING THE FORMATTINGS ON THE TEXT

    # If the "${__BU_MAIN_STAT_DECHO}" status global variable is set to "restrict", then only basic formatting is applied.
	if [ "${__BU_MAIN_STAT_DECHO,,}" == 'restrict' ]; then
        printf "%s" "${p_newTextColor}";
        printf "%s" "${p_newBGColor}";
        printf "%s" "${p_string}";
        printf "%s" "${v_oldBGColor}";
        printf "%s" "${v_oldTextColor}";
        printf "\n";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        # Setting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU.Main.Checkings.IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE}";;

                *)
                    printf "IN %s, FUNCTION %s, LINE %s --> ERROR : AT LEAST ONE OF THE ${FUNCNAME[0]}()'S ARRAY ARGUMENT VALUE IS INCORRECT\n\nCheck if the value is supported in the first value checking case" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                    BU.Main.Status.ChangeSTAT_TXT_FMT "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; v_loop_error='error'; break; };

                    local C="${__BU_MAIN_EXIT_NOT_PERMITTED}"; v_loop_error='error'; break;
                ;;
            esac
        done; if [ "${v_loop_error}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

        echo -e "${p_string}${p_newTextColor}${__BU_MAIN_COLOR_CODE_RESET}";

        # -----------------------------------------------

        ## APPLYING THE FORMATTINGS ON THE TEXT

        # Resetting the text's color.
        if [ -n "${p_newTextColor}" ]; then BU.Main.TextFormat.SetTextColor "${v_oldTextColor}"; fi

        if [ -n "${p_newBGColor}" ]; then BU.Main.TextFormat.SetBGColor "${v_oldBGColor}"; fi

        # Resetting every formattings.
        for val in "${pa_fmtArgs[@]}"; do
            case "${val^^}" in
                "$(BU.Main.Checkings.IsInt "${#val}")") return;;

                'BLINK') echo -ne "${__BU_MAIN_TXT_FMT_BLINK_RESET}";;

                'BOLD')  echo -ne "${__BU_MAIN_TXT_FMT_BOLD_RESET}";;

                'D') echo -ne "${__BU_MAIN_TXT_FMT_DIM_RESET}";;

                'I') echo -ne "${__BU_MAIN_TXT_FMT_ITALIC_RESET}";;

                'S') echo -ne "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}";;

                'U') echo -ne "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}";;

                *)
                    printf "IN %s, FUNCTION %s, LINE %s --> ERROR : AT LEAST ONE OF THE ${FUNCNAME[0]}()'S ARRAY ARGUMENT VALUE IS INCORRECT\n\nCheck if the value is supported in the first value checking case" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                    BU.Main.Status.ChangeSTAT_TXT_FMT "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; v_loop_error='error'; break; };

                    local C="${__BU_MAIN_EXIT_NOT_PERMITTED}"; v_loop_error='error'; break;
                ;;
            esac
        done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST

# Tip : to avoid defining a function for each color and formatting (which would take a monstruous amount of time, especially if new colors or formattings are added),
# it's easier to call the wanted text formatting function, then the wanted coloring text function, or vice-versa.

# Examples :
# echo -e "Lorem ipsum $(BU.Main.Decho.Decho.FMT_BlinkBoldDISU "$(BU.Main.Decho.Orange "dolor")") sit amet...";
# echo -e "Lorem ipsum $(BU.Main.Decho.Orange "$(BU.Main.Decho.Decho.FMT_BlinkBoldDISU "dolor")") sit amet...";

# Easy "BU.Main.Decho.Decho()" function calls with colors.
function BU.Main.Decho.Decho.Aqua                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_AQUA}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Black                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_BLACK}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Blue                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_BLUE}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Cyan                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_CYAN}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Fuchsia                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Gray                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_GRAY}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Green                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_GREEN}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Lime                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_LIME}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Maroon                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_MAROON}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Navy                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_NAVY}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Olive                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_OLIVE}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Orange                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_ORANGE}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Pink                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_PINK}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Purple                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_PURPLE}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Red                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_RED}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Salmon                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_SALMON}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Silver                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_SILVER}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Tan                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TAN}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Teal                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TEAL}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Turquoise              { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"  "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Violet                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_VIOLET}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.White                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_WHITE}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Yellow                 { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_YELLOW}"     "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.Decho()" function calls with specific text display colors.
function BU.Main.Decho.Decho.Highlight              { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}" "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}"  "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.CMD                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_CMD}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Error                  { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_BoldIU  "${v_str}" "${__BU_MAIN_COLOR_CODE_ERROR}"      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Function               { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_FUNCTION}"   "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Newstep                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_I       "${v_str}" "${__BU_MAIN_COLOR_CODE_NEWSTEP}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Path                   { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_PATH}"       "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

function BU.Main.Decho.Decho.Success                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_I       "${v_str}" "${__BU_MAIN_COLOR_CODE_SUCCESS}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Var                    { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_Bold    "${v_str}" "${__BU_MAIN_COLOR_CODE_VAR}"        "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }
function BU.Main.Decho.Decho.Warning                { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho.FMT_BoldIU  "${v_str}" "${__BU_MAIN_COLOR_CODE_WARNING}"    "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.Decho()" function calls with background color display.
function BU.Main.Decho.BGColor                      { local v_str=${1:-$'\0'}; local v_bg=${2:-$'\0'}; shift 2; local pa_arr=("${@}"); BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_fmtArgs[@]}"; BU.Main.Decho.Decho             "${v_str}"                                      "${v_bg}" "${pa_arr[@]}" || return 1; return 0; }

# Easy "BU.Main.Decho.__Decho()" function calls with colors.
function BU.Main.Decho.__Decho.Aqua                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_AQUA}"        "${2}"; }
function BU.Main.Decho.__Decho.Black                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_BLACK}"       "${2}"; }
function BU.Main.Decho.__Decho.Blue                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_BLUE}"        "${2}"; }

function BU.Main.Decho.__Decho.Cyan                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_CYAN}"        "${2}"; }
function BU.Main.Decho.__Decho.Fuchsia              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_FUCHSIA}"     "${2}"; }
function BU.Main.Decho.__Decho.Gray                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_GRAY}"        "${2}"; }

function BU.Main.Decho.__Decho.Green                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_GREEN}"       "${2}"; }
function BU.Main.Decho.__Decho.Lime                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_LIME}"        "${2}"; }
function BU.Main.Decho.__Decho.Maroon               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_MARRON}"      "${2}"; }

function BU.Main.Decho.__Decho.Navy                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_NAVY}"        "${2}"; }
function BU.Main.Decho.__Decho.Olive                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_OLIVE}"       "${2}"; }
function BU.Main.Decho.__Decho.Orange               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_ORANGE}"      "${2}"; }

function BU.Main.Decho.__Decho.Pink                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PINK}"        "${2}"; }
function BU.Main.Decho.__Decho.Purple               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PURPLE}"      "${2}"; }
function BU.Main.Decho.__Decho.Red                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_RED}"         "${2}"; }

function BU.Main.Decho.__Decho.Salmon               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SALMON}"      "${2}"; }
function BU.Main.Decho.__Decho.Silver               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SILVER}"      "${2}"; }
function BU.Main.Decho.__Decho.Tan                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TAN}"         "${2}"; }

function BU.Main.Decho.__Decho.Teal                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TEAL}"        "${2}"; }
function BU.Main.Decho.__Decho.Turquoise            { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_TURQUOISE}"   "${2}"; }
function BU.Main.Decho.__Decho.Violet               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_VIOLET}"      "${2}"; }

function BU.Main.Decho.__Decho.White                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_WHITE}"       "${2}"; }
function BU.Main.Decho.__Decho.Yellow               { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_YELLOW}"      "${2}"; }

# Easy "BU.Main.Decho.__Decho()" function calls with specific text display colors.
function BU.Main.Decho.__Decho.Highlight            { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_HIGLIGHT}"    "${2}"; }
function BU.Main.Decho.__Decho.CMD                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_CMD}"         "${2}"; }
function BU.Main.Decho.__Decho.Error                { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_ERROR}"       "${2}"; }

function BU.Main.Decho.__Decho.Function             { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_FUNCTION}"    "${2}"; }
function BU.Main.Decho.__Decho.Newstep              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_NEWSTEP}"     "${2}"; }
function BU.Main.Decho.__Decho.Path                 { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_PATH}"        "${2}"; }

function BU.Main.Decho.__Decho.Success              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_SUCCESS}"     "${2}"; }
function BU.Main.Decho.__Decho.Var                  { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_VAR}"         "${2}"; }
function BU.Main.Decho.__Decho.Warning              { BU.Main.Decho.__Decho "${1}" "${__BU_MAIN_COLOR_WARNING}"     "${2}"; }

# Tip : you can also pass a second argument when you call the following functions, which is the same than the "Decho" function's second argument
# (one of the color global variables defined in the main module's Colors.conf file, in the "ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetTextColor" FUNCTIONS" sub-section).

# Positionnal parameters :
#   ${1}    --> String to display.
#   ${2}    --> Text color to display.
#	${3}	--> Background color display.

# Blink formatting.
function BU.Main.Decho.Decho.FMT_Blink              { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink'                         	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBold          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold'                  	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldD         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDI        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDIS       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'S'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDISU      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'S' 'U'   || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDIU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'I' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDSU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'S' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldDU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'D' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'S' 'U'       || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'I' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'S'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'S' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkBoldU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'Bold' 'U'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkD             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D'                     	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDI            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDIS           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'S'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDISU          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'S' 'U'         	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDIU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'I' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDS            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'S'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDSU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'S' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkDU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'D' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkI             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I'                      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkIS            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'S'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkISU           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'S' 'U'             	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkIU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'I' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkS             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'S'                     	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkSU            { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'S' 'U'                 	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BlinkU             { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Blink' 'U'                      || return 1; return 0; }

# Bold formatting.
function BU.Main.Decho.Decho.FMT_Bold           { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold'                  	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldD          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'S'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'S' 'U'   || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'I' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'S' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldDU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'D' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldI          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldIS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'S'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldISU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'S' 'U'      	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldIU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'I' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldS          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'S'              	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldSU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'S' 'U'          	|| return 1; return 0; }
function BU.Main.Decho.Decho.FMT_BoldU          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'Bold' 'U'               || return 1; return 0; }

# Dim formatting
function BU.Main.Decho.Decho.FMT_D          { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D'              || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DI         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DIS        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DISU       { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'S' 'U'  || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DIU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'I' 'U'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DS         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'S'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DSU        { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'S' 'U'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_DU         { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'D' 'U'          || return 1; return 0; }

# Italic formatting.
function BU.Main.Decho.Decho.FMT_I      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I'          || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_IS     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_ISU    { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'S' 'U'  || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_IU     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'I' 'U'      || return 1; return 0; }

# Strikethrough formatting.
function BU.Main.Decho.Decho.FMT_S      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'S'      || return 1; return 0; }
function BU.Main.Decho.Decho.FMT_SU     { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'S' 'U'  || return 1; return 0; }

# Underline formatting.
function BU.Main.Decho.Decho.FMT_U      { BU.Main.Decho.Decho "${1}" "${2}" "${3}" 'U'  || return 1; return 0; }
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : DevTools.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# Tools used for debugging or specific tasks for the dev-tools executable scripts.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DEBUG FUNCTIONS
#### DEBUG ID : "devtools:debug-functions"

__BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS='devtools:debug-functions';

## SHELLCHECK
## DEBUG ID : "shellcheck"

__BU_MAIN_DEVTOOLS_LIB__SUBCAT_DEBUG_ID__DEBUG_FUNCTIONS__SHELLCHECK="${__BU_MAIN_DEVTOOLS_LIB__CAT_DEBUG_ID__DEBUG_FUNCTIONS}:shellcheck";

# Writing the error message if a Shellcheck verification failed.
function BU.Main.DevTools.ShellcheckVerif()
{
    #**** Parameters ****
    local p_path=${1:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL  - DESC : Path of the file whose Shellcheck verification failed.

    #**** Code ****
    echo >&2;

    # shellcheck disable=SC2059
    printf "${__BU_COMPILE__SHELLCHECK__FAIL}" "${p_path}"; echo >&2; return 0;
}

# Verifying for any programming errors in a Bash script file with the "shellcheck" command.
function BU.Main.DevTools.ShellcheckVerif()
{
    #**** Parameters ****
    local p_path=${1:-\$'0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to verify.
    local p_stable=${2:-NULL};  # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : If the file to be compiled is a stable version, the target file will be shellchecked, overriding the code's behavior about the "${__BU_SHELLCHECKED}" variable's value.

    #**** Code ****
    # shellcheck disable=SC2059
    if [ "${__BU_SHELLCHECKED}" == 'false' ] || [ "${p_stable}" == 'compile-stable' ]; then
        printf "${__BU_COMPILE__SHELLCHECK__VERIFICATION}" "${p_path}"; echo;

        if ! shellcheck "${p_path}"; then BU.Main.DevTools.ShellcheckVerif "${p_path}"; return 1; fi

        # shellcheck disable=SC2059
        printf "${__BU_COMPILE__SHELLCHECK__SUCCESS}" "${p_path}"; echo;

        echo;
    fi

    return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Directories.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### DIRECTORIES FUNCTIONS
#### DEBUG ID : directoriesdirectories-functions

__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS="directories::directories-functions";

## PROCESSING FUNCTIONS
## DEBUG ID : processing-functions

__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PROCESSING_FUNCTIONS="${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}::processing-functions";

# Separate processing steps displays from the rest of the main script with a line.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Headers.DrawLine      -> Headers.lib
#   - BU.Main.Errors.HandleErrors  -> Headers.lib
function BU.Main.Directories.ProcessingDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PROCESSING_FUNCTIONS}";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_parent=${2:-$'\0'};     # ARG TYPE : Dir        - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_name=${3:-$'\0'};       # ARG TYPE : Dir        - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Variables ****
    local v_char='"';                       # VAR TYPE : Char       - DESC :
    local v_path="${p_parent}/${p_name}";   # VAR TYPE : Dirpath    - DESC :

    #**** Code ****
    # Arguments checking.
	if ! BU.Main.Args__Directories.ProcessingDir "${p_function}" "${p_parent}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

	sleep "${PROJECT_STATUS_SLEEP_LINE}";

    BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
    BU.Main.Echo.Newstep "Processing the $(BU.Main.Decho.Decho.Path "${p_name}") folder in the parent folder $(BU.Main.Decho.Decho.Path "${p_parent}").";
    BU.Main.Echo.Newline;

    if "${p_function}"; then
        BU.Main.Echo.Success "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}/") folder.";
		BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
		sleep "${PROJECT_STATUS_SLEEP_LINE}";
		BU.Main.Echo.Newline;
    else
        BU.Main.Echo.Error "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}/") folder.";
		BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
		sleep "${PROJECT_STATUS_SLEEP_LINE}";
		BU.Main.Echo.Newline;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FOLDER CREATION FUNCTIONS
## DEBUG ID : folder-creation-functions

__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__FOLDER_CREATION_FUNCTIONS="${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}::folder-creation-functions";

# Overwriting an existing directory's content

# Featured functions and files from the "functions" folder :
#	- BU.Main.Echo.Error()			-> Echo.lib
#	- BU.Main.Echo.Newstep()		-> Echo.lib
#	- BU.Main.Echo.Success()		-> Echo.lib
#	- BU.Main.Echo.Newline()        -> Echo.lib
function BU.Main.Directories.OverwriteDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__FOLDER_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : Path       - REQUIRED | DEFAULT VAL : NULL     - DESC :
	local p_authorization=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU.Main.Args__Directories.OverwriteDir "${p_path}" "${p_authorization}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    # Checking second if the script is operating at the root directory.
    BU.Main.Directories.TriggerRootDirWarning "${p_path}";

    BU.Main.Echo.Newstep "A non-empty folder with exactly the same name ($(BU.Main.Decho.Decho.Path "${p_name}")) is already in the target folder $(BU.Main.Decho.Decho.Path "${p_parent}/")";
	BU.Main.Echo.Newstep "Deleting the contents of the $(BU.Main.Decho.Decho.Path "${v_path}/") folder";
	BU.Main.Echo.Newline;

	if [ "${p_authorization}" == "--rmdir" ]; then
        # TODO : Si la variable n'est pas initialisée.
        if [ -n "${p_path+x}" ]; then
            # WARNING ! DO NOT MODIFY THE FOLLOWING COMMAND, UNLESS YOU KNOW >>> EXACTLY <<< WHAT YOU DO !!!
            # WARNING ! IF YOU MODIFY THE NAME OF THE VARIABLES, PLEASE CHECK THE NAME OF EVERY
            # VARIABLES INTO THIS FUNCTION, OR ELSE THIS PROGRAM COULD OPERATE FROM THE ROOT DIRECTORY !!!!!!!!!

            # Check this link for more informations about this command --> https://github.com/koalaman/shellcheck/wiki/SC2115
            rm -rfv "${v_path/:?}/"*;

            BU.Main.Errors.HandleErrors "${?}" "UNABLE TO DELETE THE CONTENT OF THE $(BU.Main.Text.KeepFormatting "$(BU.Main.Decho.Decho.Path "${v_path}/")") FOLDER." \
                "Please check the permissions of the targeted directory" "${v_path}" "${v_path}" \
                "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

            BU.Main.Echo.Success "Deletion of the contents of the folder $(BU.Main.Decho.Decho.Path "${v_path}/") performed successfully";
            BU.Main.Echo.Newline;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Errors.HandleErrors "1" "" "" "" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# folder creation function, with the parent folder's path and the new folder's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Args__Directories.Make()              -> Main -> Args.lib
#   - BU.Main.Checkings.CheckFilePathWasCreated()   -> Main -> Checkings.lib
#   - BU.Main.Directories.OverwriteDir()            -> Main -> Directories.lib (this file)
#   - BU.Main.Directories.TriggerRootDirWarning()   -> Main -> Directories.lib (this file)
#   - BU.Main.Errors.HandleErrors()                 -> Main -> Errors.lib
#   - BU.Main.Headers.DrawLine()                    -> Main -> Headers.lib

#   - BU.Main.Decho.Decho.Path()                    -> Main -> Decho.lib
#   - BU.Main.Echo.Error()                          -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()                        -> Main -> Echo.lib
function BU.Main.Directories.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__FOLDER_CREATION_FUNCTIONS}";

	#**** Parameters ****
	local p_parent=${1:-$'\0'}; # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Emplacement of the currently processed directory's parent folder from the root directory.
	local p_name=${2:-$'\0'};   # ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULl     - DESC : Name of the folder to process (into its parent directory).
	local p_rm=${3:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the targeted directory.

	#**** Variables ****
	local v_path="${p_parent}/${p_name}";   # VAR TYPE : String     - DESC : Path of the file to process.

	#**** Code ****
	# Checking first if the awaited arguments are given
    if ! BU.Main.Args__Directories.Make "${p_parent}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then return "${?}"; fi

    # Checking second if the script is operating at the root directory.
    if ! BU.Main.Directories.TriggerRootDirWarning "${v_path}"; then return 1; fi

	# If the folder to create doesn't exists, ths script creates it with the help of the "mkdir" command.
	if [ ! -d "${v_path}" ]; then
		BU.Main.Echo.Newstep "Creating the $(BU.Main.Decho.Decho.Path "${p_name}") folder in the parent folder $(BU.Main.Decho.Decho.Path "${p_parent}/").";
		BU.Main.Echo.Newline;

        mkdir -pv "${v_path}";

        BU.Main.Errors.HandleErrors "${?}" \
            "THE $(BU.Main.Text.KeepFormatting "$(BU.Main.Decho.Decho.Path "${p_name}/")") FOLDER CANNOT BE CREATED IN THE PARENT FOLDER $(BU.Main.Text.KeepFormatting "$(BU.Main.Decho.Decho.Path "${p_parent}/")") !" \
            "Please check the permissions of the targeted directory" "${v_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";
        BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_name}") folder was successfully created in the $(BU.Main.Decho.Decho.Path "${p_parent}/") folder.";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the folder to create already exists in its parent directory AND this folder already contains AT LEAST one file or folder.
	elif [ -d "${v_path}" ] && [ "$(ls -A "${v_path}")" ]; then

        if [ "${p_rm}" == '--rmdir' ]; then
            BU.Main.Directories.OverwriteDir "${v_path}" "${p_rm}";

			if test "${?}" -eq 0; then
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
            else
                return 1;
            fi
        fi

	# Else, if the folder to create already exists in its parent directory AND this folder is empty.
	elif [ -d "${v_path}" ] && [ ! "$(ls -A "${v_path}")" ]; then
		BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_name}/") folder already exists in the $(BU.Main.Decho.Decho.Path "${p_parent}/") folder and is empty.";
		BU.Main.Echo.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# Folder creation function, with the parent folder's path and the directory's name as unique argument.
function BU.Main.Directories.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__FOLDER_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the directory to create.
    local p_overwrite=${2:-$'\0'};	# ARG TYPE : String	    - REQUIRED | DEFAULT VAL : NULL     - DESC : Authorization to overwrite the directory.

    #**** Variables ****
    local v_parent; v_parent="$(echo "${p_path}" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the folder to create.
    local v_target; v_target="$(echo "${p_path}" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the folder to create.

    #**** Code ****
    if ! BU.Main.Args__Directories.MakePath "${p_path}" "${p_overwrite}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    if [ "${p_overwrite}" != 'rmdir' ]; then
        BU.Main.Directories.Make "${v_parent}" "${v_target}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    else
        BU.Main.Directories.Make "${v_parent}" "${v_target}" '--rmdir' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    return 0;
}

# The function "CheckSTAT_LOG()" creates the log file and its path when the __BU_MAIN_STAT_LOG variable's value is "true",
# but in case the value is "false", it's necessary to check if the project's temporary folder exists anyway.
function BU.Main.Directories.MkTmpDir()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__FOLDER_CREATION_FUNCTIONS}";

    if [ ! -d "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" ]; then declare -i lineno="${LINENO}";
        mkdir -p "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" ||
		{
			BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

			BU.Main.Errors.HandleErrors "1" "THE $(BU.Main.Checkings.CheckDirPathExists "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" 'true') CANNOT BE CREATED !" \
				"Please check at the mentionned line in the mentionned file." "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" \
				"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}";

			BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
		}

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## PATH PROCESSING
## DEBUG ID : path-processing

__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING="${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}::path-processing";

# Getting the name of a target directory without its path.
function BU.Main.Directories.GetDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL  - DESC : Full path of the directory.

    #**** Variables ****
    local result;   # VAR TYPE : String     - DESC :

    #**** Code ****
    if ! BU.Main.Args__Directories.GetDirectoryName "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    if [ -d "${p_path}" ]; then
        shopt -s extglob;           # Enable +(...) glob syntax.

        result=${p_path%%+(/)};     # Trim however many trailing slashes exist
        result=${result##*/}:       # Remove everything before the last / that still remains

        shopt -u extglob;           # Disable +(...) glob syntax.

        echo -e "${result}";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Errors.HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Check if the provided path is correct." \
            "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 6 ))";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if the directory's sub-folders paths passed as argument exists, then print its path.
function BU.Main.Directories.GetDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the folder to get.

    #**** Code ****
    if ! BU.Main.Args__Directories.GetDirectoryPath "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    if [ -d "${p_path}" ]; then
        echo -e "${p_path}";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Errors.HandleErrors "1" "THE PROVIDED PATH IS INCORRECT !" "Please check if the provided path is correct." \
            "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Getting parent folder's name only (without its full path from the root directory), then printing it.
function BU.Main.Directories.GetParentDirectoryName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the child file or folder.
    local p_iterations=${2:-1}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Variables ****
    local result;   # VAR TYPE : String     - DESC :

    #**** Code ****
    if ! BU.Main.Args__Directories.GetParentDirectoryName "${p_path}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    for ((i=0; i<p_iterations; i++)); do
        local v_parent; v_parent="$( cd "$(dirname "${p_path}")" > /dev/null 2>&1 \
            || {
                BU.Main.Errors.HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "${p_path}" \
                    "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            }; pwd -P )";

        p_path="${v_parent}";
    done

    shopt -s extglob;       # Enable +(...) glob syntax.

    result=${p_path%%+(/)};	# Trim however many trailing slashes exist.
    result=${result##*/};   # Remove everything before the last / that still remains.

    shopt -u extglob;       # Disable +(...) glob syntax.

    echo -e "${result}";
}

# Getting parent folder's path from the root directory, then printing it
function BU.Main.Directories.GetParentDirectoryPath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the child file or folder.
    local p_iterations=${2:-1}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1        - DESC : Number of iterations, corresponding to the number of folders to go up in the directory tree.

    #**** Variables ****
    local result;   # VAR TYPE : String     - DESC :

    #**** Code ****
    if ! BU.Main.Args__Directories.GetParentDirectoryPath "${p_path}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    if [ "${p_iterations}" -lt 1 ]; then
        p_iterations="$(BU.Main.BasicMaths.NegativeToPositive "${p_iterations}")";
    fi

    if [ -d "${p_path}" ]; then
        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "${p_path}")" > /dev/null 2>&1 \
                || {
                    BU.Main.Errors.HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "${p_path}" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}";
                }; pwd -P )";

            p_path="${v_parent}";
        done

        # Enable +(...) glob syntax.
        shopt -s extglob;

        # Trim however many trailing slashes exist.
        result=${p_path%%+(/)};

        # Disable +(...) glob syntax.
        shopt -u extglob;

        echo -e "${result}";
    else
        local v_path_str="";
        local v_current_path="${p_path}";

        for ((i=0; i<p_iterations; i++)); do
            local v_parent; v_parent="$( cd "$(dirname "${p_path}")" > /dev/null 2>&1 \
                || {
                    BU.Main.Errors.HandleErrors "1" "UNABLE TO GET THE PARENT DIRECTORY'S NAME" "Please check if the provided path is correct." "${p_path}" \
                        "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}";
                }; pwd -P )";

            local v_path_cut; v_path_cut="${v_parent##*/}";
            local v_path_str+="${v_path_cut}/";

            # Removing the unnecessary folders.
            # WARNING !!!! USE THE "rmdir" COMMAND ONLY !!!!
            # DO NOT USE THE "rm -rf" COMMAND AT ALL, OR FILES AND FOLDERS COULD BE UNINTENTIONNALY ERASED !!!!
            rmdir "${v_current_path}"; BU.Main.Errors.HandleErrors "${?}" "UNABLE TO ERASE THE $(BU.Main.Decho.Decho.Path "${v_current_path}") NEWLY CREATED FOLDER !";

            local v_current_path="${v_parent}";
        done

        BU.Main.Text.ReverseStringWordsOrder "${v_path_str}" '/';
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Check if the script is about to work at the root directory ('/').
function BU.Main.Directories.TriggerRootDirWarning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_DIRECTORIES_LIB__CAT_DEBUG_ID__DIRECTORIES_FUNCTIONS}" \
        "${__BU_MAIN_DIRECTORIES_LIB__SUBCAT_DEBUG_ID__DIRECTORIES_FUNCTIONS__PATH_PROCESSING}";

	#**** Parameters ****
	local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the folder to check.

	#**** Code ****
	# Checking if the given path points towards the root directory or one of its subfolders
	# TODO : detecting if path points to a root sub-folder (like [ if "${p_path}" == "/" ] || [ "${p_path}" | cut blablabla ]).
	if [ "$(pwd "${p_path}")" == "/" ] || [ "$(BU.Main.Directories.GetParentDirectoryPath "${p_path}")" == '/' ]; then
		if [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" == "forbidden" ]; then
			BU.Main.Headers.Header.Error "WARNING !!!!!! READ THIS MESSAGE CAREFULLY !!!!!!" 'strlen';

			BU.Main.Echo.Error "The script was trying to operate at the root directory (or one of its sub directories) without authorization";
			BU.Main.Echo.Error "Given path : $(BU.Main.Decho.Decho.Path "${p_path}")";
			BU.Main.Echo.Error "Authorization : ${__BU_MAIN_STAT_OPERATE_ROOT}";
			BU.Main.Echo.Newline;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

			return "${__BU_MAIN_EXIT_PERMISSION_DENIED}";

		elif [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" == "restricted" ]; then
            BU.Main.Headers.Header.Warning "WARNING !!!!!!! DO NOT SKIP THIS MESSAGE BEFORE READING IT CAREFULLY !!!!!!" 'strlen';

            BU.Main.Echo.Warning "You are about to operate at the root directory or one of its present sub-folders !";
			BU.Main.Echo.Warning "Given path : $(BU.Main.Decho.Decho.Path "${p_path}")";
			BU.Main.Echo.Warning "Authorization : ${__BU_MAIN_STAT_OPERATE_ROOT}";
			BU.Main.Echo.Newline;

			# Calling the function that processes the given answer.
			if BU.Main.Case.Read_DirectoriesTriggerRootDirWarning; then
				BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
			else
				BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_PERMISSION_DENIED}";
			fi
		fi
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

	return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Echo.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# (Colored) text display functions.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### PRINTING FORMATTED STRINGS
#### DEBUG ID : echo::printing-formatted-strings

__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS="echo::printing-formatted-strings";

## DEBUGGING
## DEBUG ID : debugging

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING="${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS}::debugging";

# This function only serves as text printer for the " BU.Main.Echo.Debug()" function.
function BU.Main.Echo.__Debug()
{
    BU.ModuleInit.CheckIsDebugging && {
        BU.Main.Echo.__EchoVoid;

        echo "----------------------------------------";
        echo "DEBUGGING THE FUNCTION ${1}";

        echo; echo "Waiting for the two seconds timer for the ${1}() function to elapse"; echo;

        sleep 2;

     #   set -x;

        BU.Main.Echo.__EchoVoid;
    }
}

# This function only serves as text printer for the " BU.Main.Echo.Debug()" function.
function BU.Main.Echo.DebugEnd()
{
 #   set +x;

    BU.ModuleInit.CheckIsDebugging && {
        if [ "${__BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION,,}" == 'true' ]; then
            BU.Main.Echo.__EchoVoid;

            echo "---------------------------------------";
            echo "END OF THE DEBUGGING OF THE FUNCTION ${1}";

            BU.Main.Echo.__EchoVoid;

            __BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION='false';
        fi
    }
}

# Printing the name of the processed function if the main script is launched with the "bash -x" command.

## TODO : RÉFLÉCHIR À LA MISE EN PLACE DE L'AFFICHAGE DU NOM DE LA FONCTION CIBLE LORS DE LA PROCÉDURE DE DÉBOGUAGE AVEC LA COMMANDE "bash -x".
function BU.Main.Echo.Debug()
{
    # The six following conditional lines are used as test / debug procedures. Please leave them commented if you are not debugging the behavior of the modules debugger.
    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" ];                         then echo "BASHX : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX}"; else echo 'BASHX FALSE'; fi

    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[*]}" ];       then echo "CATS ARRAY VALUES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[*]}";     else echo 'CATS ARRAY FALSE'; fi
    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[*]}" ];          then echo "FILE ARRAY VALUES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[*]}";        else echo 'FILE ARRAY FALSE'; fi
    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[*]}" ];      then echo "FUNC ARRAY VALUES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[*]}";    else echo 'FUNC ARRAY FALSE'; fi
    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[*]}" ];        then echo "MODL ARRAY VALUES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[*]}";      else echo 'MODL ARRAY FALSE'; fi
    # if [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[*]}" ];   then echo "SUBC ARRAY VALUES : ${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[*]}"; else echo 'SUBC ARRAY FALSE'; fi

    BU.ModuleInit.CheckIsDebugging && {
        #**** Parameters ****
        local p_modname=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the function currently processed is defined.
        local p_filename=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the function currently processed is defined.
        local p_funcname=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Print the name of the function currently processed, during the debug procedure.
        local p_category=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Get the category of the targeted function.
        local p_subcateg=${5:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Get the sub-category of the targeted function.

        #**** Code ****
        [ -n "${__BU_MODULE_INIT_STAT_DEBUG_BASHX}" ] &&
        {
            if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == c?(at?(eg?(ory))) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == c?(at?(eg?(orie)))?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'C' ]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "${p_funcname}"; return 0;
                else
                    for targetCategory in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_CATEGORY_ARRAY[@]}"; do
                        # If the "${targetCategory}" value is found in the array, and the function which comes from the "${p_category}" file matches with the "${targetCategory}" variable's value.
                        [[ ${targetCategory,,} =~ ${p_category,,} ]] && { BU.Main.Echo__Debug "${p_funcname}"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == fi?(l?(e))?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'F' ]; then
                local v_file="${p_filename%%.[Ll][Ii][Bb]*}";

                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "${p_funcname}"; return 0;
                else
                    for targetFile in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY[@]}"; do
                        # If the "${targetFile}" value is found in the array, and the function which comes from the "${v_file}" file matches with the "${targetFile}" variable's value.
                        [[ ${targetFile,,} =~ ${v_file,,} ]] && { BU.Main.Echo.__Debug "${p_funcname}"; break; };
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == fun?(c?(t?(ion))?(s)) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == FN?(C?(T))?(S) ]]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "${p_funcname}"; return 0;
                else
                    for targetFunction in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY[@]}"; do
                        # If the "${targetFunction}" value is found in the array, and the function which comes from the "${p_funcname}" file matches with the "${targetFunction}" variable's value.
                        [[ ${targetFunction,,} =~ ${p_funcname,,} ]] && { BU.Main.Echo.__Debug "${p_funcname}"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == m?(od?(ule))?(s) ]]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "${p_modname}"; return 0;
                else
                    for targetModule in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_MODULES_ARRAY[@]}"; do
                        # If the "${targetModule}" value is found in the array, and the function which comes from the "${p_modname}" file matches with the "${targetModule}" variable's value.
                        [[ ${targetModule,,} =~ ${p_modname,,} ]] && { BU.Main.Echo.__Debug "${p_funcname}"; break; }
                    done
                fi

            elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)c?(at?(eg?(ory))) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == s?(ub)?(-)?(c?(at?(eg?(orie)))?(s)) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" == 'S' ]; then
                if [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[0],,}" == 'all' ]; then
                    BU.Main.Echo.__Debug "${p_funcname}"; return 0;
                else
                    for targetSubCategory in "${__BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CATEGORY_ARRAY[@]}"; do
                        # If the "${targetSubCategory}" value is found in the array, and the function which comes from the "${p_subcateg}" file matches with the "${targetSubCategory}" variable's value.
                        [[ ${targetSubCategory,,} =~ ${p_subcateg,,} ]] && { BU.Main.Echo__Debug "${p_funcname}"; break; }
                    done
                fi
            fi
        }

        __BU_MAIN_ECHO__IS_DEBUGGING_THIS_FUNCTION='true';

    } # > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}";

    return 0;
}

# Print void lines before and after calling a header.
function BU.Main.Echo.__EchoVoid()
{
printf "









" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" ||
    {
        echo >&2; echo "IN « ${BASH_SOURCE[0]} », LINE « ${LINENO} » --> WARNING --> UNABLE TO WRITE THE « ${FUNCNAME[0]} » IN THE « ${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH} FILE »" >&2; echo >&2; exit 1;
    }
}

# "BU.Echo<...>()" functions debug output for a better view during a debug process.
# It's better to also execute the project's script with the "bash - x ${project_name}" command, instead of the "./${project_name}" way.
function BU.Main.Echo.__EchoOutput()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING}";

	#**** Parameters ****
	local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to display.
	local p_context=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Begin or end of the debug process.
	local p_type=${3:-$'\0'};       # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of message (error 'E', Msg 'm', newstep 'N', success 'S' or warning 'W').

	#**** Variables ****
	local v_strlen="${#p_string}";  # VAR TYPE : Int        - DESC :

	#**** Code ****
	# If the "${p_type}" argument is a string, then the first character is extracted.
	if ! BU.Main.Checkings.IsAlphaChar "${p_type}"; then
        local v_type=${p_type:0:1};

        p_type="${v_type}";
	fi

	if [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" == 'false' ]; then return 0;

	elif [ "${__BU_MODULE_INIT_STAT_DEBUG,,}" == "true" ]; then
	    # Passing the "${__BU_MAIN_STAT_ECHO}" global status variable's value from "false" to "true".
        if ! BU.Main.Status.CheckStatIsBackupEchoing; then
            local v_BU_MAIN_STAT_ECHO_val="${__BU_MAIN_STAT_ECHO}"; BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "${BASH_SOURCE[0]}" "${LINENO}";
        fi

		BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT}" "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}" "f" || { BU.Main.Echo.__EchoCPLS "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Unable to create the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}") debug log file" 'E' "CPLS"; exit 1; }

		BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" '' "$(( 24 + v_strlen ))";

        if [ "${p_context,,}" == "begin" ]; then
            BU.Main.Echo.__EchoVoid;

            if [ "${p_type^^}" == "E" ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type,,}" == 'm' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'N' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'S' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'W' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}BEGIN DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "BEGIN DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            fi

            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" '' "$(( 24 + v_strlen ))";

            # Reassigning the "${__BU_MAIN_STAT_ECHO}" global status variable's former value.
            if [ -n "${v_BU_MAIN_STAT_ECHO_val}" ]; then
                __BU_MAIN_STAT_ECHO="${v_BU_MAIN_STAT_ECHO_val}"; v_BU_MAIN_STAT_ECHO_val=''
            fi

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

        elif [ "${p_context,,}" == "end" ]; then
            if [ "${p_type^^}" == "E" ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type,,}" == 'm' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'N' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'S' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            elif [ "${p_type^^}" == 'W' ]; then
                BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_}END DEBUGGING TEXT : ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" > "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "In $(BU.Main.Args.PrintFFL "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}") --> Unable to write the $(BU.Main.Decho.Decho "END DEBUGGING TEXT") debug test in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}") file"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
            fi

            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" '' "$(( 24 + v_strlen ))";

            # Reassigning the "${__BU_MAIN_STAT_ECHO}" global status variable's former value.
            if [ -n "${v_BU_MAIN_STAT_ECHO_val}" ]; then
                __BU_MAIN_STAT_ECHO="${v_BU_MAIN_STAT_ECHO_val}"; v_BU_MAIN_STAT_ECHO_val='';
            fi

            BU.Main.Echo.__EchoVoid; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi
    fi
}

# Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
function BU.Main.Echo.__EchoCPLS()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__PRINTING_FORMATTED_STRINGS__DEBUGGING}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : Any        - OPTIONAL | DEFAULT VAL : NULL     - DESC : Text to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.

    shift 2; pa_extraArgs=("${@}"); # VAR TYPE : Array  - DESC : More processing arguments (like the processing of a whole line-long string).

    #**** Code ****
    # DO NOT CALL THE "BU.Main.Args.GetFuncArgsArrayValues()" FUNCTION IN THIS FUNCTION, OR ELSE AN INFINITE LOOP WILL LIKELY OCCUR !!!!!

    for val in "${pa_extraArgs[@]}"; do
        if [ "${val}" == 'nodate' ]; then
            case "${p_option}" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "${p_string}";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "${p_string}";
                    fi
                    ;;
            esac
        elif [ -z "${val}" ]; then
            case "${p_option}" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "${__BU_MAIN_TIME_DATE_DISPLAY} ${p_string}";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "${__BU_MAIN_TIME_DATE_DISPLAY} ${p_string}";
                    fi
                    ;;
            esac
        else
            case "${p_option}" in
                '-n' | 'n')
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" 'n' || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -ne "${__BU_MAIN_TIME_DATE_DISPLAY} ${p_string}";
                    fi
                    ;;
                '' | *)
                    if BU.Main.Status.CheckStatIsInitializing; then
                        BU.ModuleInit.Msg "${p_string}" || BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                    else
                        echo -e "${__BU_MAIN_TIME_DATE_DISPLAY} ${p_string}";
                    fi
                    ;;
            esac
        fi

		if [ -n "${__BU_MAIN_STAT_TIME_HEADER}" ]   && (( $(echo "${__BU_MAIN_STAT_TIME_HEADER} > 0"    | bc -l ) )); then sleep "0"; fi
		if [ -n "${__BU_MAIN_STAT_TIME_NEWLINE}" ]  && (( $(echo "${__BU_MAIN_STAT_TIME_NEWLINE} > 0"   | bc -l ) )); then sleep "0"; fi
		if [ -n "${__BU_MAIN_STAT_TIME_TXT}" ]      && (( $(echo "${__BU_MAIN_STAT_TIME_TXT} > 0"       | bc -l ) )); then sleep "0"; fi
    done
   # if (( $(echo "${num1} > ${num2}" |bc -l) ));

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT DISPLAYING
#### DEBUG ID : echo::text-displaying

__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING="echo::text-displaying";

## DISPLAYING A CONTEXT MESSAGE
## DEBUG ID : displaying-a-context-message

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE="${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}::displaying-a-context-message";

# --> DISPLAYING A COLORED CONTEXT MESSAGE WITH A PAUSE TIME DEPENDING ON THE "${__BU_MAIN_STAT_TIME_TXT}" STATUS VARIABLE.

# Error message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus()                    --> Checkings.lib
function BU.Main.Echo.Error()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};	# ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to print and / or redirect to the log file.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VEchoError='1';

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'E' || { local C="${?}"; [ -n "${VEchoError}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_ERROR}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'E' || { local C="${?}"; [ -n "${VEchoError}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'E' || { local C="${?}"; [ -n "${VEchoError}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_ERROR}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'E' || { local C="${?}"; [ -n "${VEchoError}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
    [ -n "${VEchoError}" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Normal message (without any extra color), with redirection checking.

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus()    --> Checkings.lib
function BU.Main.Echo.Msg()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to print and / or redirect to the log file.
    local p_option=${2:-$'\0'};	# ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'm' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Status.CheckProjectLogStatus "${p_string}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'm' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'm' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Echo.__EchoCPLS "${p_string}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'm' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# New sub-step message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Newstep()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

    echo HELLO

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL    - DESC : String to print and / or redirect to the log file.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL    - DESC : "$(echo)" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'N' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_NEWSTEP}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'N' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'N' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_NEWSTEP}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'N' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Read input values

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#	- BU.Main.Status.CheckProjectLogStatus		--> Checkings.lib
function BU.Main.Echo.Read()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

	#**** Parameters ****
	local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : User's keyboard input.

	#**** Code ****
	if [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ] && [ "${__BU_MAIN_STAT_LOG}" == "true" ] && [ -n "${__BU_MAIN_STAT_LOG_REDIRECT}" ]; then
		echo -e "Keyboard input value : $(BU.Main.Decho.Decho.Var "${p_string}")" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || { BU.Main.Echo.__EchoCPLS "" 'R' "CPLS"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; }
	fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Success message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Success()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to print and / or redirect to the log file.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'S' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_SUCCESS}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} $'p_string'${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'S' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'S' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_SUCCESS}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'S' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Warning message

# Usage :
#	BU.Main.Echo.Error "<Text to write>" "<optional echo argument>" "<Any extra argument supported by the BU.Main.Status.CheckProjectLogStatus() function>";

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
function BU.Main.Echo.Warning()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ECHO_LIB__CAT_DEBUG_ID__TEXT_DISPLAYING}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__TEXT_DISPLAYING__DISPLAYING_A_CONTEXT_MESSAGE}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - Default : NULL	- String to print and / or redirect to the log file.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - Default : NULL	- "$(echo)" command options (it is a string, since the "BU.Main.Status.CheckProjectLogStatus()" function accepts a '-' before the option).
    shift 2;

    local pa_extraArgs=("${@}"); # Array - More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus" or the "BU.Main.Echo.__EchoCPLS" functions.

    #**** Code ****
    BU.Main.Args.GetFuncArgsArrayValues "${FUNCNAME[0]}" "${pa_extraArgs[@]}";

    # If the framework is still initializing when an error occurs.
    BU.ModuleInit.SetInitErrorMsg && local VEchoWarning='1';

    if ! BU.Main.Status.CheckStatIsBackupEchoing; then
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'W' || { local C="${?}"; [ -n "${VEchoWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Status.CheckProjectLogStatus "${__BU_MAIN_COLOR_TXT_WARNING}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'W' || { local C="${?}"; [ -n "${VEchoWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    # Failsafe if any "BU.Echo<...>()" function has to be called in the "BU.Main.Status.CheckProjectLogStatus()" function.
    else
        BU.Main.Echo.__EchoOutput "${p_string}" 'begin' 'W' || { local C="${?}"; [ -n "${VEchoWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        BU.Main.Echo.__EchoCPLS "${__BU_MAIN_COLOR_TXT_WARNING}${__BU_MAIN_TXT_PRINT_TAB}${__BU_MAIN_TXT_PRINT_TAB} ${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

        BU.Main.Echo.__EchoOutput "${p_string}" 'end' 'W' || { local C="${?}"; [ -n "${VEchoWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    fi

    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
    [ -n "${VEchoWarning}" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## DISPLAYING A COLORED MESSAGE

# --> DISPLAYING A COLORED MESSAGE WITH A PAUSE TIME DEPENDING ON THE "${__BU_MAIN_STAT_TIME_TXT}" STATUS VARIABLE.

# Note : These function call the "BU.Main.Echo.Msg()" function in order to avoid rewriting tons of lines that would do the same thing.

# Aqua blue colored message.
function BU.Main.Echo.Aqua()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_AQUA}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Black colored message.
function BU.Main.Echo.Black()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_BLACK}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Blue colored message.
function BU.Main.Echo.Blue()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_BLUE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Cyan colored message.
function BU.Main.Echo.Cyan()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_CYAN}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Fuchsia colored message.
function BU.Main.Echo.Fuchsia()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_FUCHSIA}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Gray colored message.
function BU.Main.Echo.Gray()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_GRAY}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Green colored message.
function BU.Main.Echo.Green()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_GREEN}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Lime green colored message.
function BU.Main.Echo.Lime()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_LIME}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Maroon colored message.
function BU.Main.Echo.Maroon()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_MAROON}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Navy blue colored message.
function BU.Main.Echo.Navy()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_NAVY}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Olive green colored message.
function BU.Main.Echo.Olive()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_OLIVE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Orange colored message.
function BU.Main.Echo.Orange()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_ORANGE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Pink colored message.
function BU.Main.Echo.Pink()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_PINK}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Purple colored message.
function BU.Main.Echo.Purple()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_PURPLE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Red colored message.
function BU.Main.Echo.Red()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_RED}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Salmon colored message.
function BU.Main.Echo.Salmon()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_SALMON}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Silver colored message.
function BU.Main.Echo.Silver()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_SILVER}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Tan colored message.
function BU.Main.Echo.Tan()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TAN}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Teal colored message.
function BU.Main.Echo.Teal()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TEAL}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Turquoise colored message.
function BU.Main.Echo.Turquoise()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_TURQUOISE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Violet colored message.
function BU.Main.Echo.Violet()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_VIOLET}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# White colored message.
function BU.Main.Echo.White()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_WHITE}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# Yellow colored message.
function BU.Main.Echo.Yellow()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : String to display.
    local p_option=${2:-$'\0'}; # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : "$(echo)" command options.
    shift 2;

    local pa_extraArgs=("${@}"); # ARG TYPE : Array     - OPTIONAL | DEFAULT VAL : NULL     - DESC : More processing arguments (like the processing of a whole line-long string) for the "BU.Main.Checkings.CheckProjectLogStatus()" or the "BU.Main.Echo.__EchoCPLS()" functions.

    #**** Code ****
    BU.Main.Echo.Msg "${__BU_MAIN_COLOR_TXT_YELLOW}${p_string}${__BU_MAIN_COLOR_TXT_RESET}" "${p_option}" "${pa_extraArgs[@]}" || return 1;

    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINE BREAKS
#### DEBUG ID : Echo.line-breaks

__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS="Echo::line-breaks";

## LINE BREAKS ACCORDING TO THE "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" VARIABLE VALUE
## DEBUG ID : line-breaks-according-to-the-project-log-file-var-val

__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__LINE_BREAKS__LINE_BREAKS_ACCORDING_TO_THE_PROJECT_LOG_FILE_VAR_VAL="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS}::line-breaks-according-to-the-project-log-file-var-val":

# Redirecting the output of the "echo" command

# Featured functions and files from the "functions" folder :
#   - BU.Main.Status.CheckProjectLogStatus     --> Checkings.lib
#	- BU.Main.Errors.HandleErrors				--> Checkings.lib
function BU.Main.Echo.Newline()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__LINE_BREAKS}" \
        "${__BU_MAIN_ECHO_LIB__SUBCAT_DEBUG_ID__LINE_BREAKS__LINE_BREAKS_ACCORDING_TO_THE_PROJECT_LOG_FILE_VAR_VAL}";

    #**** Parameters ****
    local p_number=${1:-1}; # ARG TYPE : Int    - OPTIONAL | DEFAULT VAL : 1    - DESC : Line breaks iterator.

    #**** Code ****
    if [ -n "${p_number}" ]; then
        if ! BU.Main.Checkings.IsPositiveInt "${p_number}"; then
            BU.Main.Echo.Msg '' '' 'nodate';
            BU.Main.Echo.__EchoCPLS "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : the number of line breaks must be an integer" 'R';
            BU.Main.Echo.Msg '' '' 'nodate';
        else
            # Doing X line breaks according to the number passed as argument.
            for ((i=0; i<p_number; i++)); do
                BU.Main.Echo.Msg '' '' 'nodate';
            done
        fi
    else
        BU.Main.Echo.Msg '' '' 'nodate';
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Errors.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# Errors handling functions.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ERRORS HANDLING FUNCTIONS
#### DEBUG ID : errors::errors-handling-functions

__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS="errors::errors-handling-functions";

## CLASSIC ERRORS HANDLING
## DEBUG ID : classic-errors-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::classic-errors-handling";

# Saving time when displaying a newline, an error message and an exit or a return value.

# WARNING ! DO NOT CALL HERE ANY FUNCTION THAT CALL THIS FUNCTION DIRECTLY OR INDIRECTLY,
# OR THE SCRIPT WILL LOOP FOREVER IN CASE OF AN ERROR DURING THIS FUNCTION CALL !!!
function BU.Main.Errors.HandleSmallErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING}";

    #**** Parameters ****
    local p_type=${1:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Type of message to display ('E' = BU.Main.Echo.Error; 'W' = BU.Main.Echo.Warning)
    local p_string=${2:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to display.
    local p_return=${3:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Exit or return status ('E' = exit; 'R' = return).
    local p_cpls=${4:-$'\0'};   # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Enable the safe text printing mode.

    #**** Variables ****
    if [ "${p_cpls^^}" == 'CPLS' ]; then
        if [ "${__BU_MAIN_STAT_ECHO,,}" == 'false' ]; then
            local v_BU_STAT_ECHO_old="${__BU_MAIN_STAT_ECHO}"; BU.Main.Status.ChangeSTAT_ECHO 'true' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
        fi
    fi

    #**** Code ****
    BU.Main.Echo.Newline >&2;

    BU.ModuleInit.SetInitErrorMsg && local VHandleSmallErrors='1';

    if      [ "${p_type^^}" == 'E' ];    then BU.Main.Echo.Error      "${p_string}" '' '';
    elif    [ "${p_type^^}" == 'W' ];    then BU.Main.Echo.Warning    "${p_string}" '' '';

    # If no type of message to displays is passed as first argument, the script will choose between one of the accepted types.
    else
		local v_advice="Please don't forget to pass a type of message to display as first argument ('E' = BU.Main.Echo.Error; 'W' = BU.Main.Echo.Warning)";

        if [ "$(( RANDOM%2 ))" == "0" ]; then
            BU.Main.Echo.Error "${p_string}     | ${__BU_MAIN_COLOR_TXT_RESET}${v_advice}" '' '';
        else
            BU.Main.Echo.Warning "${p_string}   | ${__BU_MAIN_COLOR_TXT_RESET}${v_advice}" '' '';
        fi
    fi

    BU.Main.Echo.Newline >&2

    # As the "BU.Main.Echo.Warning()" function will be called in case of a missing return or exit code (normally passed as second argument),
    # it's better to reset the value of the "${__BU_MAIN_STAT_ECHO}" status variable condition per condition.
    if [ "${p_return^^}" == 'R' ]; then
        if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then BU.Main.Status.ChangeSTAT_ECHO 'false' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

        # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
        [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return 1;

    elif [ "${p_return^^}" == 'E' ]; then
        if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then BU.Main.Status.ChangeSTAT_ECHO 'false' 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

        # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
        [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        BU.Main.Errors.Exit 1;

    else
        BU.Main.Echo.Warning "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_TXT_WARNING} --> Warning : bad exit or return code given as second argument !"; [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; BU.Main.Errors.Exit 1;
    fi

    if [ "${v_BU_STAT_ECHO_old}" == "true" ]; then __BU_MAIN_STAT_ECHO='false'; fi

    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
    [ -n "${VHandleSmallErrors}" ] && BU.ModuleInit.UnsetInitErrorMsg;

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# -----------------------------------------------

## EXIT AND RETURN CODES HANDLING
## DEBUG ID : exit-and-return-codes-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::exit-and-return-codes-handling";

# Handling exit command from sourced files, as it's impossible to properly exit the script from these.
function BU.Main.Errors.Exit()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__CLASSIC_ERRORS_HANDLING}";

    #**** Parameters ****
    local p_exitcode=${1:-$'\0'};   # ARG TYPE : Int    - REQUIRED | DEFAULT VAL : NULL     - DESC : Exit code.
    local p_behavior=${2:-$'\0'};   # ARG TYPE : Char   - REQUIRED | DEFAULT VAL : NULL     - DESC : Use "exit" or "return" keywords.

    #**** Code ****
    if BU.Main.Checkings.IsPositiveInt "${p_exitcode}"; then

        if [ "${p_behavior^^}" == 'E' ] || [ -z "${p_behavior}" ]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi

        elif [ "${p_behavior^^}" == 'W' ]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${p_exitcode}";

        else
            # shellcheck disable=SC2034
            __BU_MAIN_STAT_DECHO='restrict';

            # shellcheck disable=SC2034
            __BU_MAIN_STAT_ECHO='true';

            BU.Main.Echo.Newline 2 >&2;

            BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Error : No valid character passed as second argument ('E' (exit) or 'W' (warning) expected)";
            BU.Main.Echo.Newline >&2;

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi
        fi
    else
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : unexpected exit code passed as argument";

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; if BU.ModuleInit.IsInScript; then exit "${p_exitcode}" || kill "${__BU_MODULE_INIT__PROJECT_PID}"; else return "${p_exitcode}"; fi
    fi
}

# -----------------------------------------------

## SCRIPT'S ERRORS HANDLING
## DEBUG ID : script-errors-handling

__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__SCRIPT_ERRORS_HANDLING="${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}::script-errors-handling";

# "BU.Main.Errors.HandleErrors()" function --> Handling file name presence.
function BU.Main.Errors.HandleErrors_File()        { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Path "<no specified file>"; else BU.Main.Decho.Decho.Path "${1}"; fi; }

# "BU.Main.Errors.HandleErrors()" function --> Handling function name presence.
function BU.Main.Errors.HandleErrors_Function()    { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Function "<no specified function>"; else BU.Main.Decho.Decho.Function "${1}"; fi; }

# "BU.Main.Errors.HandleErrors()" function --> Handling line number presence.
function BU.Main.Errors.HandleErrors_Line()        { if [ -z "${1}" ]; then BU.Main.Decho.Decho.Highlight "<no specified line>"; else BU.Main.Decho.Decho.Highlight "${1}"; fi; }

# Handling command outputs.
# Featured functions and files from the "basis" category :
#   -
function BU.Main.Errors.HandleErrors()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_ERRORS_LIB__CAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS}" \
        "${__BU_MAIN_ERRORS_LIB__SUBCAT_DEBUG_ID__ERRORS_HANDLING_FUNCTIONS__SCRIPT_ERRORS_HANDLING}";

	#**** Parameters ****
	local p_returnCode=${1:-$'\0'};     # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Return code of the last command executed. If you didn't launched any command before calling this function, you can pass any number different of '0' as first argument.
	local p_errorString=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String of the type of error to display.
	local p_adviceString=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String of characters displaying a tip to direct the user to the best solution to apply in case of a problem.
    local p_badValue=${4:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Incorrect value which caused the error.
	local p_file=${5:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : The name of the file where the error occured.
	local p_function=${6:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : The name of the function where the error occured.
	local p_lineno=${7:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Line on which the error message occured (obtained in a very simple way by calling the POSIX environment variable "${LINENO}").

    #**** Variables ****
    local v_hdrString;                              # VAR TYPE : String     - DESC :
    local v_getSeparatorOccurencesfromAdviceStr;    # VAR TYPE : String     - DESC :
    local v_checkIfErrorStringIsNotNull;            # VAR TYPE : CMD        - DESC :

    # v_checkIfErrorStringIsNotNull="$(BU.Main.Decho.Decho.FMT_I "No string to display as $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()" 'NULL' 'BI') function's error string")";

	# ***** Code *****
	BU.Main.Status.CheckSTAT_ERROR 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

	if [ "${p_returnCode}" -eq 0 ]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    else
        if BU.Main.Status.CheckStatIsInitializing; then
            BU.ModuleInit.HandleErrors "${p_returnCode}" "${p_errorString}" "${p_adviceString}" "${p_badValue}" "${p_file}" "${p_function}" "${p_lineno}" || {

                local C="${?}";

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                return "${C}";
            };
        else

            # If the framework is still initializing when an error occurs.
            BU.ModuleInit.SetInitErrorMsg && local VHandleErrors='1';

            v_hdrString="$(echo -ne "IN $(BU.Main.Errors.HandleErrors_File "${p_file}") FILE, FUNCTION $(BU.Main.Errors.HandleErrors_Function "${p_function}"), LINE $(BU.Main.Errors.HandleErrors_Line "${p_lineno}") -->")";

            # -------- PART 1 : MANAGING THE CALL OF THIS "BU.Main.Errors.HandleErrors()" FUNCTION IF THIS "BU.Main.Errors.HandleErrors()" FUNCTION IS CALLED IN A FUNCTION CALLED BY THIS "BU.Main.Errors.HandleErrors()" FUNCTION

            # If the function needs to be called in the "BU.Main.Status.CheckProjectLogStatus()" function, then
            # this status variable's value MUST be set at "true", or else the script will loop forever.

            # WARNING : DO NOT call a text formatting function to format something else than the text color, or else the script will loop forever.

            if [ "${__BU_MAIN_STAT_ECHO,,}" == "true" ]; then

                if [ -n "${__BU_MAIN_STAT_ERROR}" ] && [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                    if [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "A FATAL ERROR OCCURED DURING A TEST IN THE $(BU.Main.Decho.Decho.Function "BU.Main.Status.CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    else
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "A FATAL ERROR OCCURED DURING THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S PROJECT INITIALIZATION" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    fi
                else
                    if [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "AN ERROR OCCURED DURING A TEST IN THE $(BU.Main.Decho.Decho.Function "BU.Main.Status.CheckProjectLogStatus") FUNCTION OR ANOTHER TEST WHERE THE MENTIONNED FUNCTION CANNOT BE CALLED !" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    else
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                        BU.Main.Echo.Error "AN ERROR OCCURED DURING THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S PROJECT INITIALIZATION" 'strlen';
                        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}" >&2;
                    fi
                fi
            fi


            # -------- PART 2 : PRINTING THE HEADER

            # Redirecting the log messages to the terminal, to show them to the user.
            if [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" == "log" ]; then
                local v_log_old="true"; __BU_MAIN_STAT_LOG_REDIRECT="tee"; BU.Main.Status.CheckSTAT_LOG_REDIRECT 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || {
                    local C="${?}";

                    # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                    [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                    return "${C}";
                };
            fi

            if [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                BU.Main.Headers.Header.Red "${v_hdrString} FATAL ERROR : $(if [ -n "${p_errorString}" ]; then echo "${p_errorString}"; else echo "${v_checkIfErrorStringIsNotNull}"; fi)" >&2;
            else
                BU.Main.Headers.Header.Red "${v_hdrString} ERROR : $(if [ -n "${p_errorString}" ]; then echo "${p_errorString}"; else echo "${v_checkIfErrorStringIsNotNull}"; fi)" >&2;
            fi


            # -------- PART 3 : GIVING AN ADVICE ABOUT THE ORIGIN OF THE ERROR TO THE USER/DEVELOPPER

            if [ -z "${p_adviceString}" ]; then
                BU.Main.Echo.Error "No advice to give."; BU.Main.Echo.Newline >&2;
            else
                v_getSeparatorOccurencesfromAdviceStr="$(BU.Main.Text.GetSubStringOccurences "${p_advice}" "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" '--init')";

                # Checking if the "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" substring composing the delimiter exists only once, as single separator from the advice substring and another comment substring.

                # IMPORTANT : the second argument of the "BU.Main.Text.GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
                if [ -n "${p_adviceString}" ] && [ "${v_getSeparatorOccurencesfromAdviceStr}" -eq 1 ] && [[ "${p_adviceString}" == *[[:space:]]'[/|\]'[[:space:]]* ]]; then

                    local v_string_part_1; v_string_part_1="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f2- | rev)";   # Getting the first sub-string before the delimiter.
                    local v_string_part_2; v_string_part_2="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f 1 | rev)";   # Getting the second sub-string after the delimiter.

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${v_string_part_1}";
                    BU.Main.Echo.Newline >&2;

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Other comments") : ${v_string_part_2}";

                # Checking if the "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" substring composing the delimiter exists more than once, as multiple separators from the advice and every other comments.

                # IMPORTANT : the second argument of the "BU.Main.Text.GetSubStringOccurences" function MUST be SINGLE-quoted, or else the '\' will be interpreted.
                elif [ -n "${p_adviceString}" ] && [ "${v_getSeparatorOccurencesfromAdviceStr}" -gt 1 ] && [[ "${p_adviceString}" == *[[:space:]]'[/|\]'[[:space:]]* ]]; then

                    local v_string_part_1; v_string_part_1="$(echo "${p_adviceString}" | rev | cut -d "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" -f2- | rev)";   # Getting the first sub-string.

                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${v_string_part_1}";
                    BU.Main.Echo.Newline >&2;

                    for ((i=1; i>v_getSeparatorOccurencesfromAdviceStr; i++)); do
                        p_adviceString="$(BU.Main.Text.CutSubStringBeforeNthDelim "${p_adviceString}" "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" 1)";

                        BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice [$(( i + 1 ))]") : ${p_adviceString}";
                        BU.Main.Echo.Newline 2 >&2;
                    done
                else
                    BU.Main.Echo.Error "$(BU.Main.Decho.Decho.Highlight "Advice") : ${p_adviceString}";
                fi
            fi

            BU.Main.Echo.Newline >&2;

            if [ -z "${p_badValue}" ]; then
                BU.Main.Echo.Error "Value(s) that caused this error : $(BU.Main.Decho.Orange 'no value') OR $(BU.Main.Decho.Orange 'an unknown error')"; BU.Main.Echo.Newline >&2;
            else
                BU.Main.Echo.Error "Value(s) that caused this error : $(BU.Main.Decho.Decho.Var "${p_badValue}")"; BU.Main.Echo.Newline >&2;
            fi

            if [ "${__BU_MAIN_STAT_ERROR,,}" == "fatal" ]; then
                BU.Main.Echo.Error "Stopping the execution of $(BU.Main.Decho.Decho.Highlight "$(basename "${0}")")."; BU.Main.Echo.Newline >&2;

                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                exit "${__BU_MAIN_EXIT_NOT_PERMITTED}";
            else
                if [ "${__BU_MAIN_STAT_ERROR,,}" == 'warning' ]; then
                    # Calling the function that processes the given answer.
                    BU.Main.Case.Read_Errors.HandleErrors;
                fi
            fi

            # -------- PART 4 : WRITING THE ERROR REPORT IN THE PROJECT'S LOG FILE IN CASE THE "${__BU_MAIN_STAT_ECHO}" VARIABLE IS SET TO TRUE (SAFE MODE IF THE WRITING FUNCTIONS ARE CALLED FROM THE "BU.Main.Status.CheckProjectLogStatus()" FUNCTION).

            if [ "${__BU_MAIN_STAT_ECHO,,}" == "true" ] && [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
                BU.Main.Echo.Warning "" 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ||
                {
                    BU.Main.Errors.HandleSmallErrors "Unable to write in the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") projectlog file from the $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") function" 'R' 'CPLS';
                }
            fi

            if [ "${v_log_old}" == "true" ]; then
                __BU_MAIN_STAT_LOG_REDIRECT="log"; BU.Main.Status.CheckSTAT_LOG_REDIRECT 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
            fi

            if BU.Main.Checkings.IsInt "${p_returnCode}"; then

                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${p_returnCode}";
            else
                # Restoring the former value of the "${__BU_MODULE_INIT_MSG_ARRAY_PERMISSION}" global variable.
                [ "${VHandleErrors}" == '1' ] && BU.ModuleInit.UnsetInitErrorMsg;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";
            fi
        fi
    fi
}

# -----------------------------------------------
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FILES PROCESSING FUNCTIONS
## DEBUG ID : files::files-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS="files::files-processing-functions";

## PROCESSING FUNCTIONS
## DEBUG ID : processing-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::files-processing-functions";

# This function only repeats some parts of the following function.
function BU.Main.Files.__ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS}";

    #**** Parameters ****
    local p_output=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_name=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_char=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL    - DESC :

    #**** Code ****
    if [ "${p_output}" == 'E' ]; then
        BU.Main.Echo.Error "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}") file";
        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
        BU.Main.Echo.Newline;

        sleep "${__BU_MAIN_STAT_TIME_TXT}";

    elif [ "${p_output}" == 'S' ]; then
        BU.Main.Echo.Success "End of processing the $(BU.Main.Decho.Decho.Path "${p_name}") file";
        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_char}" "${__COL_RESET}")" '-n' 'nodate';
        BU.Main.Echo.Newline;

        sleep "${__BU_MAIN_STAT_TIME_TXT}";
    else
        BU.Main.Echo.Warning "";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Separate processing steps displays from the rest of the main script between two horizontal lines.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Headers.DrawLine      -> Headers.lib
#   - BU.Main.Errors.HandleErrors  -> Headers.lib
function BU.Main.Files.ProcessingFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS}";

    #**** Parameters ****
    local p_function=${1:-$'\0'};   # ARG TYPE : String             - REQUIRED | DEFAULT VAL : NULL    - DESC :
    local p_name=${2:-$'\0'};       # ARG TYPE : String             - REQUIRED | DEFAULT VAL : NULL    - DESC :

    shift; local pa_arr; pa_arr=$("${@}"); # ARG TYPE : String      - REQUIRED | DEFAULT VAL : NULL    - DESC :

    #**** Variables ****
    local v_char="'";   # VAR TYPE : Char   - DESC :

    #**** Code ****
    # Arguments checking.
    if ! BU.Main.Args__Files.ProcessingFile "${p_function}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi;

	sleep "${__BU_MAIN_STAT_TIME_TXT}";
    BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${v_char}" "${__COL_RESET}")" '-n' 'nodate';
    BU.Main.Echo.Newstep "Processing the $(BU.Main.Decho.Decho.Path "${p_name}") file in the $(BU.Main.Decho.Decho.Path "${p_parent}") parent directory.";
    BU.Main.Echo.Newline;

    case "${p_function}" in
        'BU.Main.Files.Make')
            if BU.Main.Files.Make "${pa_arr[@]}"; then
                BU.Main.Files.__ProcessingFile 'S' "${p_name}" "${p_char}";
            else
                BU.Main.Files.__ProcessingFile 'E' "${p_name}" "${p_char}";
            fi
            ;;
        'OverwriteFile')
            if BU.Main.Files.OverwriteFile "${pa_arr[@]}"; then
                BU.Main.Files.__ProcessingFile 'S' "${p_name}" "${p_char}";
            else
                BU.Main.Files.__ProcessingFile 'E' "${p_name}" "${p_char}";
            fi
            ;;
    esac
}

# -----------------------------------------------

## FILE CREATION FUNCTIONS
## DEBUG ID : file-creation-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-creation-functions";

# Overwriting a file

# Featured functions and files from the "functions" folder :
#	- BU.Main.Echo.Error()			-> Main -> Echo.lib
#	- BU.Main.Echo.Newstep()		-> Main -> Echo.lib
#	- BU.Main.Echo.Success()		-> Main -> Echo.lib
#	- BU.Main.Echo.Newline()		-> Main -> Echo.lib
function BU.Main.Files.OverwriteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};           # ARG TYPE : Path   - REQUIRED | DEFAULT VAL : NULL     - DESC :
	local p_authorization=${2:-$'\0'};  # ARG TYPE : Bool   - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    # Checking first if the awaited arguments are given
    if ! BU.Main.Args__Files.OverwriteFile "${p_path}" "${p_authorization}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Checking second if the script is operating at the root directory.
    BU.Main.Directories.TriggerRootDirWarning "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    if [ "${p_authorization}" == "true" ]; then
		BU.Main.Echo.Newstep "The $(BU.Main.Decho.Decho.Path "${p_path}/") file already exists and is not empty.";
		BU.Main.Echo.Newstep "Overwriting data from file $(BU.Main.Decho.Decho.Path "${p_path}/")";
		BU.Main.Echo.Newline;

		true > "${p_path}";
		BU.Main.Errors.HandleErrors "${?}" "THE CONTENT OF THE $(BU.Main.Decho.Decho.Path "${p_path}/") FILE HAD NOT BEEN OVERWRITTEN" "" "${p_path}" \
			"$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
		BU.Main.Echo.Success "The content of the $(BU.Main.Decho.S "${p_path}/") file has been successfully overwritten";
		BU.Main.Echo.Newline;
	else
		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# File creation function, with the parent folder's path and the file's name as separated arguments.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Args__Files.Make()                    -> Main -> Args.lib
#   - BU.Main.Checkings.CheckFilePathWasCreated()   -> Main -> Checkings.lib
#   - BU.Main.Directories.TriggerRootDirWarning()   -> Main -> Directories.lib
#   - BU.Main.Errors.HandleErrors()                 -> Main -> Errors.lib
#   - BU.Main.Files.OverwriteFile()                 -> Main -> Files.lib (this file)
#   - BU.Main.Headers.DrawLine()                    -> Main -> Headers.lib

#   - BU.Main.Decho.Decho.Path()                    -> Main -> Decho.lib
#   - BU.Main.Echo.Error()                          -> Main -> Echo.lib
#   - BU.Main.Echo.Newstep()                        -> Main -> Echo.lib
#   - BU.Main.Echo.Success()                        -> Main -> Echo.lib
function BU.Main.Files.Make()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

	#**** Parameters ****
    local p_parent=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Emplacement of the currently processed file's parent folder from the root directory.
    local p_name=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the file to process (into its parent directory).

    shift 2;

    # shellcheck disable=SC2034
    pa_touchVals=("${@}");      # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : "$(touch)" command's options.

	#**** Variables ****
	local v_path="${p_parent}/${p_name}";	# Path of the file to process.

	#**** Code ****
	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${v_path}" 'create' 'true' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

	# Checking if the awaited arguments are given.
    if ! BU.Main.Args__Files.Make "${p_parent}" "${p_name}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi;

    # Checking second if the script is operating at the root directory.
    BU.Main.Directories.TriggerRootDirWarning "${v_path}" || return 1;

	# If the file to create doesn't exists, ths script creates it with the help of the "touch" command.
	if [ ! -f "${v_path}" ]; then
        BU.Main.Echo.Newstep "Creating the $(BU.Main.Decho.Decho.Path "${p_name}") file in the parent folder $(BU.Main.Decho.Decho.Path "${p_parent}/").";

		touch "${v_path}"; BU.Main.Checkings.CheckFilePathWasCreated "${v_path}";

		# Testing if the file has been created by checking the return code of the "BU.Main.Checkings.CheckFilePathWasCreated" function via the "BU.Main.Errors.HandleErrors" function.
        # An error may come from the fact that the user did not run the script in superuser mode, a script that tried to create a file in a folder
		# where the user is not allowed to create a file without superuser privileges.

		BU.Main.Errors.HandleErrors "${?}" "THE $(BU.Main.Decho.Decho.Path "${p_name}") FILE CANNOT BE CREATED IN THE $(BU.Main.Decho.Decho.Path "${p_parent}/") PARENT FOLDER." \
            "Please check the permissions of the targeted directory" "${v_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

		BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_name}") file was successfully created in the $(BU.Main.Decho.Decho.Path "${p_parent}") folder.";
        BU.Main.Echo.Newline;

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

	# Else, if the file to be created already exists AND it is NOT empty.
	elif [ -f "${p_path}" ] && [ -s "${p_path}" ]; then
        if BU.Main.Files.OverwriteFile "${p_path}"; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi

	# Else, if the file to be created already exists AND it is empty.
	elif [ -f "${p_path}" ] && [ ! -s "${p_path}" ]; then
		BU.Main.Echo.Success "The $(BU.Main.Decho.Decho.Path "${p_path}/") file already exists in the $(BU.Main.Decho.Decho.Path "${p_parent}/") folder and is empty.";
		BU.Main.Echo.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	fi
}

# File creation function, with the parent folder's path and the file's name as unique argument.
function BU.Main.Files.MakePath()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Full path of the file to create.

    #**** Variables ****
    local v_parent;
    local v_target;

    #**** Code ****
    v_parent="$(echo "${p_path}" | rev | cut -d '/' -f2- | rev)"; # Getting the parent directory of the file to create.
    v_target="$(echo "${p_path}" | rev | cut -d '/' -f 1 | rev)"; # Getting the name of the file to create.

	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" 'create' 'true';

    if ! BU.Main.Args__Files.MakePath "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    BU.Main.Files.Make "${v_parent}" "${v_target}" || return 1;

    return 0;
}

# Create a file directly in the computer's memory to redirect the informations that are often updated instead of using the hard drive.
# This method is safer for SSD drives, faster for HDD drives, and no permissions are needed.
function BU.Main.Files.MakeFileInMemory()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_filename=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : name of the file to create in the computer's random access memory.

    #**** Code ****
    echo "${p_filename}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Creating the project's log file.
function BU.Main.Files.CreateProjectLogFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_CREATION_FUNCTIONS}";

	# Checking first if the target partition is not fully used.
	BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" 'create' 'true';

    #**** Variables ****
    local v_terminfo_v; v_terminfo_v="$($(ps -p "$(ps -p "${$}" -o ppid=)" o args=) -v)";

    #**** Code ****
    if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}" "${__BU_MAIN_PROJECT_LOG_FILE_NAME}" 'f'; then BU.Main.Echo.Error "UNABLE TO CREATE THE $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")'S LOG FILE"; BU.Main.Errors.Exit '1'; fi

    BU.Main.Echo.Success "Successfully created the $(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}") file.";

    if [ "${__BU_MAIN_STAT_DECHO,,}" == 'true' ];    then BU.Main.Status.ChangeSTAT_DECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi
    if [ "${__BU_MAIN_STAT_ECHO,}"  == 'true' ];     then BU.Main.Status.ChangeSTAT_ECHO  "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

    # Redirecting the initializer's log file content into the log file.
    BU.Main.Headers.Header.Blue "INITIALIZATION PROCESS LOG OUTPUT";

    BU.Main.Echo.Newstep "Sourced configuration files :"; for val in "${__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY[@]}"; do BU.Main.Echo.Msg "${val}"; done; BU.Main.Echo.Newline;
    BU.Main.Echo.Newstep "Sourced library files : "; for val in "${__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY[@]}"; do BU.Main.Echo.Msg "${val}"; done; BU.Main.Echo.Newline;

	if (( "${#__BU_MODULE_INIT_MSG_ARRAY[@]}" >= 1 )); then
		BU.Main.Echo.Newstep "Initialization log output :"; BU.Main.Echo.Newline;

        for val in "${__BU_MODULE_INIT_MSG_ARRAY[@]}"; do
            BU.Main.Status.CheckProjectLogStatus "${val}";
        done
    fi

    # Gathering informations about the user's operating system, allowing me to correct any bug that could occur on a precise Unix-like operating system.
    BU.Main.Headers.Header.Blue "GETTING INFORMATIONS ABOUT USER'S SYSTEM";

    # Getting operating system family.
    BU.Main.Echo.Newstep "Operating system family : $(BU.Main.Decho.Decho.Highlight "${OSTYPE}")";
    BU.Main.Echo.Newline;

    # Getting operating system's informations (Android's Termux terminal emulator) :
    BU.Main.OS.IsAndroidTermux && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (FreeBSD) :
    BU.Main.OS.IsFreeBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (Linux platforms or Android without the Termux terminal emulator) :
    BU.Main.OS.IsLinux && {
        if [ -f "/etc/os-release" ]; then
            # Getting operating pretty system name.
            BU.Main.Echo.Newstep "Operating system pretty name : $(awk -F= '/PRETTY/ {print $2}' '/etc/os-release')";
            BU.Main.Echo.Newline;

            # Gathering OS informations from the "/etc/os-release" file.
            BU.Main.Echo.Newstep "Operating system general informations :";
            BU.Main.Echo.Msg "$(cat '/etc/os-release')" "" "nodate";
            BU.Main.Echo.Newline;
        else
            BU.Main.Echo.Warning "No available informations ($(BU.Main.Decho.Decho.Highlight '/etc/os-release') file not found)";
            BU.Main.Echo.Newline;
        fi

        # Getting operating system extra informations (Windows Subsystem for Linux, etc...).
        BU.Main.Echo.Newstep "Operating system extra informations :";
        if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]]; then BU.Main.Echo.Msg "Distro running on Windows Subsystem for Linux : $(awk -F= '/^NAME/{print $2}' /etc/os-release)"; fi
        BU.Main.Echo.Newline;
    }

    # Getting operating system's informations (Haiku OS) :
    BU.Main.OS.IsHaiku && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : Haiku OS";
        BU.Main.Echo.Newline;

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (OpenBSD) :
    BU.Main.OS.IsOpenBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (NetBSD) :
    BU.Main.OS.IsNetBSD && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

    # Getting operating system's informations (Mac OS) :
    BU.Main.OS.IsOSX && {
        # Getting operating system pretty name.
        BU.Main.Echo.Newstep "Operating system pretty name : ";

        # Gathering OS informations.
        BU.Main.Echo.Newstep "Operating system general informations :";
    }

	# Getting Bash language's version.
    BU.Main.Echo.Newstep "Bash version : $(BU.Main.Decho.Decho.Highlight "${BASH_VERSION}")";
    BU.Main.Echo.Newline;

	# Getting terminal emulator's name and version.
	# shellcheck disable=SC2016
    BU.Main.Echo.Newstep "Terminal (emulator) version : $(BU.Main.Decho.Decho.Highlight "${v_terminfo_v}")" || BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Highlight '$v_terminfo_v') : bad command call.";
    BU.Main.Echo.Newline;

    BU.Main.Echo.Success "Successfully got the user's system's informations.";

    # Purging the "${__BU_MODULE_INIT_MSG_ARRAY}" variable from the logged messages, after writing its content in the project's log file, in order to free memory.
    __BU_MODULE_INIT_MSG_ARRAY=('');

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE DELETION FUNCTIONS
## DEBUG ID : file-deletion-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_DELETION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-deletion-functions";

# File deletion function.
function BU.Main.Files.DeleteFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_DELETION_FUNCTIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to delete.
    local p_security=${2:-no};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : no       - DESC : Preventing the file to be deleted automatically (default : "no" --> Ask the permission to the user).

    #**** Code ****
    if ! BU.Main.Args__Files.DeleteFile "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    rm "$(if [ "${p_security,,}" == 'yes' ]; then echo '-i'; fi)" "${p_path}";

    BU.Main.Errors.HandleErrors "${?}" "" "" "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

    return 0;
}

# -----------------------------------------------

## CHECKING FILE INFORMATIONS
## DEBUG ID : checking-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::checking-file-informations";

# Checking if a file is in read-only mode.
function BU.Main.Files.IsReadOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (! -w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is readable AND writable.
function BU.Main.Files.IsRW()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (-w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is readable, writable and executable.
function BU.Main.Files.IsRWX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (-w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is in readable AND executable.
function BU.Main.Files.IsRX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (-r "${p_filepath}") && (! -w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is writable only.
function BU.Main.Files.IsWriteOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (-w "${p_filepath}") && (! -x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is writable AND executable.
function BU.Main.Files.IsWX()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (-w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# Checking if a file is in executable only.
function BU.Main.Files.IsExecutableOnly()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__CHECKING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [[ (! -r "${p_filepath}") && (! -w "${p_filepath}") && (-x "${p_filepath}") ]]; then
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------

## GETTING FILE INFORMATIONS
## DEBUG ID : getting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::getting-file-informations";

# Getting the size of a file in bytes.
function BU.Main.Files.GetByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.
    local p_base=${2:-1000};        # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : 1000     - DESC : Byte measure unit base (binary prefix (eg : MiB) or metric prefix (eg : MB)).

    #**** Code ****
    if [ -z "${p_base}" ]; then
        wc --bytes < "${p_filepath}" || \
            { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

    # Else, if a value is passed to the "base" parameter AND this value is an integer.
    elif [ -n "${p_base}" ] && BU.Main.Checkings.IsInt "${p_base}"; then

        # Convert the size from plain number to human readable metric prefix.
        if [ "${p_base}" -ne 1024 ]; then
            BU.Main.BasicMaths.BytesToHuman "$(wc --bytes < "${p_filepath}")" "NULL" "${p_base}" "" || \
                { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };

        # Convert the size from plain number to human readable binary prefix.
        else
            BU.Main.BasicMaths.BytesToHuman "$(wc --bytes < "${p_filepath}")" "NULL" "${p_base}" "" || \
                { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the size in bytes of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; };
        fi
    else
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : The byte measure unit byte $(BU.Main.Decho.Decho.Highlight "${p_base}") is not an integer"; BU.Main.Echo.Newline >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the file's creation date.

# Please note, some file systems don't store the file's creation date. In this case, the "stat" command will return '0'.
function BU.Main.Files.GetCreationDate()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if ! stat -c %W "${p_filepath}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the $(BU.Main.Decho.Decho.Path "${p_filepath}") file's creation date"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    elif [ "$(stat -c %W "${p_filepath}")" -eq 0 ]; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : This filesystem ($(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_FS_NAME}")) does not stores the files creation dates"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}";

    else
        echo -ne "$(stat -c %W "${p_filepath}")";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU.Main.Files.GetCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --chars < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of characters in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's extension.
function BU.Main.Files.GetExtension()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    BU.Main.Text.CutLastFieldAfterDelim "${p_filepath}" '.' || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the $(BU.Main.Decho.Decho.Path "${p_filepath}") file's extension";  }

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's access date.
function BU.Main.Files.GetLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat "${p_filename}" | awk 'FNR == 5 { print $2 " " $3 }' || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the last access date from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the last file's modification date.
function BU.Main.Files.GetLastModification()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    date -r "${p_filename}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the last modification date from the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the target file's mime type.
function BU.Main.Files.GetMIMEType()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    file --mime-type "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the MIME type of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";  };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of lines in a file.
function BU.Main.Files.GetLinesNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --lines < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of lines in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the max line length in a file.
function BU.Main.Files.GetMaxLineLength()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****last access date
    wc --max-line-length < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the max line length in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the owner of a file.
function BU.Main.Files.GetOwnerName()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat -c "%U" "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the name of the owner of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the group of the owner of a file.
function BU.Main.Files.GetOwnerGroup()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    stat -c "%G" "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the group of the owner of the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the total number of characters in a file.
function BU.Main.Files.GetWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__GETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    wc --words < "${p_filepath}" || { BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") : Unable to get the total number of words in the $(BU.Main.Decho.Decho.Path "${p_filepath}") file"; BU.Main.Echo.Warning "Please check the permissions of this file"; BU.Main.Echo.Newline; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NOT_PERMITTED}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## SETTING FILE INFORMATIONS
## DEBUG ID : setting-file-informations

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::setting-file-informations";

# Setting a fake last access date to a file.
function BU.Main.File.SetFileLastAccess()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__SETTING_FILE_INFORMATIONS}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.
    local p_fakedate=${2:-$'\0'}; # ARG TYPE : Date     - REQUIRED | DEFAULT VAL : NULL     - DESC : New date to set as last access date.

    #**** Code ****
    if ! BU.Main.Args__FilesSetFileLastAccess "${p_filepath}" "${p_fakedate}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## FILE SOURCING
## DEBUG ID : file-sourcing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::file-sourcing";

# Sourcing dependencies files.
function BU.Main.Files.SourceFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__FILE_SOURCING}";

    #**** Parameters ****
    local p_filepath=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file to process.

    #**** Code ****
    if [ -f "${p_filepath}" ]; then
		BU.Main.Echo.Newstep "Sourcing the $(BU.Main.Decho.Decho.Path "${p_filepath}") file";
		BU.Main.Echo.Newline

        # shellcheck disable=SC1090
        if source "${p_filepath}"; then
            BU.Main.Echo.Success "Sourced file : $(BU.Main.Decho.Decho.Path "${p_filepath}")";
			BU.Main.Echo.Newline;

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        else
            local C="${?}";

            BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_NOT_PERMITTED}" "UNABLE TO SOURCE THIS FILE : $(BU.Main.Decho.Decho.Path "${p_filepath}")" "Please verify that the file's path passed as argument exists, and that you have read rights on this file." "${p_filepath}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 5 ))";

			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
        fi
    else
        local C="${?}";

        BU.Main.Errors.HandleErrors "${__BU_MAIN_EXIT_NOT_PERMITTED}" "UNABLE TO FIND THIS FILE : $(BU.Main.Decho.Decho.Path "${p_filepath}")" "Please pass a filepath as argument" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";

		return "${C}";
    fi
}

# -----------------------------------------------

## TEXT FILE PARSING
## DEBUG ID : text-file-parsing

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}::text-file-parsing";

# Getting a specific line from a text file.
function BU.Main.Files.GetLineFromTextFile()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__FILES_PROCESSING_FUNCTIONS__TEXT_FILE_PARSING}";

    #**** Parameters ****
#    local p_source=${1:-$'\0'};        # String    - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the file to parse.
#    local p_wanted_line=${2:-$'\0'};   # Int       - REQUIRED | DEFAULT VAL : NULL     - DESC : Line to get in the file

    #**** Variables ****
#    local i=0;     # VAR TYPE : Int    # DESC : Line incrementer

    #**** Code ****
	# shellcheck disable=SC2002
#    cat "${p_source}" | while read -r line; do
#
#        # Incrementing the line incrementer variable's value...
#        i=$(( i + 1 ));

        # ... until it reaches the wanted line.
#        if [ "${i}" -eq "${p_wanted_line}" ]; then

			# shellcheck disable=SC2034
#            __BU_MAIN_TXT_STORE_LINE="${p_wanted_line}";
#        fi
#    done

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ARCHIVES PROCESSING FUNCTIONS
#### DEBUG ID : files::archive-processing-functions

__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS="files::archive-processing-functions";

## (UN)COMPRESSION FUNCTIONS
## DEBUG ID : (un)compression-functions

__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS="${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}::(un)compression-functions";

# Adding files or folders into an archive.
function BU.Main.Files.AddToArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.
    shift 3;

    local p_paths=("${@}");     # Array - Default : NULL    - Paths to the files / folders to add in the archive.

    #**** Code ****
    if BU.Main.Checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to add in the targeted archive (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__FilesCompress "${p_cmd}" "${p_opts}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ "${p_cmd}" == '7z' ]; then
        true;

    elif [ "${p_cmd}" == 'bzip2' ]; then true;

    elif [ "${p_cmd}" == '' ]; then true;

    elif [ "${p_cmd}" == 'gzip' ]; then true;

    elif [ "${p_cmd}" == 'zip' ]; then true;

    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the compression command
function BU.Main.Files.CompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data.
    shift 4;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to archivate.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Compressing archives according to the used compression method.

# Featured functions and files from the "functions" folder :
#   -
function BU.Main.Files.CompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive's name.
    shift 2;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to archivate.

    #**** Code ****
    if BU.Main.Checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to compress (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__FilesCompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!
    if ! BU.Main.Args__Files.CompressFormat "${p_cmd}" "${p_opts}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the 7-Zip compression format is wanted.
    if [ "${p_cmd}" == '7z' ]; then
        7z a "${p_opts}" "${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format 7-Zip.
            return 1;
        }

    # Else, if the BinHex compression format is wanted (works on Apple operating systems).
    elif [ "${p_cmd}" == 'binhex' ]; then
        binhex "${p_opts}" "${p_paths[@]}" > "${p_arch}"|| {
            # TODO : Gérer les cas d'erreur de compression au format BinHex.
            return 1;
        }

    # Else, if the Bzip2 compression format is wanted.
    elif [ "${p_cmd,,}" == 'bzip2' ]; then
        true;

    # Else, if the Bzip2 compression format is wanted for a Tar archive.
    elif [[ "${p_cmd^^}" == TBZ?(2) ]] || [[ "${p_cmd,,}" == tar?(.)bz?(2) ]]; then
        tar "-jcf${p_opts}" "" "" || {
            # TODO : Gérer les cas d'erreur de compression au format Bzip2.
            return 1;
        }

    # Else, if the Gzip compression format is wanted.
    elif [ "${p_cmd,,}" == 'gzip' ]; then
        true;

    # Else, if the Gzip compression format is wanted for a Tar archive.
    elif [ "${p_cmd^^}" == 'TGZ' ] || [[ "${p_cmd,,}" == tar?(.)gz ]]; then
        tar "-zcf${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the LZMA compression is wanted for a Tar archive.
    elif [ "${p_cmd^^}" == 'TXZ' ] || [[ "${p_cmd,,}" == tar?(.)xz ]]; then
        tar "JCxf${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format Gzip.
            return 1;
        }

    # Else, if the zip compression format is wanted.
    elif [ "${p_cmd,,}" == 'zip' ]; then
        zip "${p_opts}" "${p_arch}" "${p_paths[@]}" || {
            # TODO : Gérer les cas d'erreur de compression au format zip.
            return 1;
        }
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Deleting a file or a folder stored in an archive.
function BU.Main.Files.DeleteInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Target archive's path.
    shift 3;

    local p_paths=("${@}");     # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Paths to the files / folders to delete in the archive.

    #**** Code ****
    if BU.Main.checkings.IsArrayEmpty "${p_paths[@]}"; then local lineno="${LINENO}";
        BU.Main.Args.PrintBadOption 'z' \
            "Please pass as fourth argument the path of the directory/ies or the file(s) to delete from the target archive (mandatory argument)${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}$(BU.Main.Args.PrintFFLErrorOccured "${p_funcname}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${lineno}")" \
            'p_path' "${p_paths[@]}" "${p_filename}" "${p_funcname}" "${p_lineno}"; local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Searching for a file or a folder inside an archive.
function BU.Main.Files.SearchInArchive()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_arch=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - Path to the target archive.

    #**** Code ****


    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method AND the (un)compression command's name.

# Featured functions and files from the "functions" folder :
#   - BU.Main.Errors.HandleErrors()     -> Errors.lib
#   - BU.Main.Echo.Success()            -> Echo.lib
#   - BU.Main.Echo.Newline()            -> Echo.lib
function BU.Main.Files.UncompressCMD()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_cmd=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression command.
    local p_opts=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Options of the compression command (in case a command call is not mandatory, please leave an empty string as second argument while calling this function).
    local p_arch=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${4:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data.
    local p_del=${5:-false};    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : false    - DESC : Delete the archive after extracting successfully its content.

    #**** Code ****
    # There is no need to pass the "${p_opts}" parameter as argument for the "BU.Main.Args__Files.Uncompress()", as this is an optional current function's parameter.
    # EVEN IF THIS PARAMETER IS OPTIONAL, ANY OTHER FOLLOWING PARAMETERS ARE MANDATORY, SO USE AN EMPTY STRING BETWEEN QUOTES WHEN YOU CALL THE CURRENT FUNCTION !!!!!
    if ! BU.Main.Args__Files.UncompressCMD "${p_cmd}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the user wishes to use the "7z" command in order to uncompress one of these supported formats : 7z, LZMA2, XZ, ZIP, Zip64, CAB, RAR (if the non-free p7zip-rar package is installed), ARJ, GZIP, BZIP2, TAR, CPIO, RPM, ISO.
    if      [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == '7z' ) && "$(BU.Main.CMDSGetCommandPath '7z')" ]]; then
            7z x "" "" "" "" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to decode a BinHexed file (Apple's BinHex format)
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'hexbin' ) && "$(BU.Main.Files.GetExtension ".hqx")" && "$(BU.Main.CMDSGetCommandPath 'hexbin')" ]]; then
            hexbin "${p_opts}" "${p_arch}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "p7zip" command in order to uncompress ... .
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'p7zip' ) && "$(BU.Main.CMDSGetCommandPath 'p7zip')" ]]; then
            p7zip "" "" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the data to extract is stored in a Microsoft cabinet archive (.cab).
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'cabextract' ) && "$(BU.Main.CMDSGetCommandPath 'cabextract')" ]]; then
            cabextract "${p_opts}" "${p_arch}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "gzip" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'zip' ) && "$(BU.Main.CMDSGetCommandPath 'zip')" ]]; then
            gzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "gunzip" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'gunzip' ) && "$(BU.Main.CMDSGetCommandPath 'gunzip')" ]]; then
            gunzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

    # Else, if the user wishes to use the "unzip" command in order to uncompress
    elif    [[ ( -n "${p_cmd}" ) && ( "${p_cmd,,}" == 'unzip' ) && "$(BU.Main.CMDSGetCommandPath 'unzip')" ]]; then
            unzip "${p_opts}" "${p_arch}" "${p_dest}" || { return 1; }; if [ "${p_del,,}" == 'true' ]; then BU.Main.Files.DeleteFile "${p_arch}"; fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Uncompressing archives according to the used compression method.
function BU.Main.Files.UncompressFormat()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILES_LIB__CAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_FILES_LIB__SUBCAT_DEBUG_ID__ARCHIVES_PROCESSING_FUNCTIONS__UN_COMPRESSION_FUNCTIONS}";

    #**** Parameters ****
    local p_form=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Compression format.
    local p_arch=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the archive to uncompress.
    local p_dest=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Folder destination of the uncompressed data (optional argument).

    #**** Code ****
    if ! BU.Main.Args__Files.UncompressFormat "${p_form}" "${p_arch}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Quick writing of the error message which tells that it's impossible to uncompress the target archive with the default or the specified command.
    function BU.Main.Files.UncompressFormat.ErrorMsg()
    {
        #**** Parameters ****
        local p_fmt=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Archive format.
        local p_arc=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the target archive.
        local p_cmd=${3:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the command used to uncompress the targeted archive.

        #**** Code ****
        BU.Main.Errors.HandleSmallErrors 'W' "Impossible to decompress the $(BU.Main.Decho.Decho.Highlight "${p_fmt}") archive named $(BU.Main.Decho.Decho.Path "${p_arc}") with the $(BU.Main.Decho.Decho.CMD "${p_cmd}") command" 'R';
        BU.Main.Echo.Warning "Please check the permissions of the archive, or use another uncompression command which supports the targeted archive's format";
        BU.Main.Echo.Newline;

        return 1;
    }

    # If the archive to be decompressed is a 7-Zip archive format.
    if [[ "${p_form}" == ?(.)7?(-)[Zz]?([Ii][Pp]) ]]; then
        # If the '7z' command is found in the "${PATH}" environment variable.
        if      BU.Main.CMDSGetCommandPath 7z; then
                7z x "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg '7-Zip' "${p_arch}" '7z'; return 1; };

        # Else, if the '7z' command is found in the "${PATH}" environment variable.
        elif    BU.Main.CMDSGetCommandPath p7zip; then
                p7zip || { BU.Main.Files.UncompressFormat.ErrorMsg '7-Zip' "${p_arch}" 'p7zip'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for 7z uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is an Apple's BinHex file.
    elif [[ "${p_form}" == ?([Aa][Pp][Pp][Ll][Ee]?(\')?([Ss])[[:space:]])[Bb][Ii][Nn][Hh][Ee][Xx] ]]; then
        if      BU.Main.CMDSGetCommandPath hexbin; then
                hexbin "${p_arch}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'BinHex' "${p_arch}" 'hexbin'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Apple BinHex files uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Microsoft cabinet archive (.cab).
    elif [[ "${p_form}" == ?([Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]?(\')?([Ss])?([[:space:]]))?(.)[Cc][Aa][Bb]?([Ii][Nn][Ee][Tt]) ]]; then
        if      BU.Main.CMDSGetCommandPath cabextract; then
                cabextract || { BU.Main.Files.UncompressFormat.ErrorMsg 'Microsoft Cab' "$'p_arch'" 'cabextract'; return 1; };

        elif    BU.Main.CMDSGetCommandPath 7z; then
                7z x "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Microsoft Cab' "${p_arch}" '7z'; return 1; };

        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Microsoft Cabinet archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Gzip archive format.
    elif [[ "${p_form}" == ?(.)[Gg][Zz]?([Ii][Pp]) ]]; then
        if      BU.Main.CMDSGetCommandPath gunzip; then
                gunzip -v "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Gzip' "${p_arch}" 'gunzip'; return 1; };

        elif    BU.Main.CMDSGetCommandPath gzip; then
                gzip -dv "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Gzip' "${p_arch}" 'gzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Gzip archives uncompression found on your system' 'R';
        fi

    # Else, if the archive to be decompressed is a Tar archive compressed with the Gzip compression format.
    elif [[ "${p_form}" == ?(.)[Tt]?([Aa][Rr])?(.)[Gg][Zz] ]]; then
        true;

    # Else, if the archive to be decompressed is a Zip archive format.
    elif [[ "${p_form}" == ?(.)[Zz][Ii][Pp] ]]; then
        if      BU.Main.CMDSGetCommandPath unzip; then
                unzip "${p_arch}" "${p_dest}" || { BU.Main.Files.UncompressFormat.ErrorMsg 'Zip' "${p_arch}" 'unzip'; return 1; };
        else
                BU.Main.Errors.HandleSmallErrors 'W' 'No valid command for Zip archives uncompression found on your system' 'R';
        fi
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Filesystem.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### HARD DRIVE'S FILE SYSTEM PROCESSING
#### DEBUG ID : filesystem::hard-drive-file-system-processing

__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING="filesystem::hard-drive-file-system-processing";

## CHECKING FILE SYSTEM'S INFORMATIONS
## DEBUG ID : checking-filesystem-informations

__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING="${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}::checking-filesystem-informations";

# Checking if the current partition is full.
function BU.Main.Filesystem.IsPartitionFull()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}";

    #**** Parameters ****
    local p_fileFS=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Target file's file system.
    local p_dirfile=${2:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Create the file with the directory if not exists, then erase it, in order to get the target file system.

    #**** Code ****
    if [ -z "${p_fileFS}" ]; then return "${__BU_MAIN_EXIT_INVALID_ARGUMENT}";

    elif    [ ! -d "${p_fileFS}" ] || \
            [ ! -f "${p_fileFS}" ]; then if [ "${p_dirfile,,}" == 'create' ]; then

                local v_parentdir;

                v_parentdir="$(cd "$(dirname "${p_path}")" > /dev/null 2>&1 || { return 1; }; pwd -P)";

                if [ ! -d "${v_parentdir}" ]; then mkdir -p "${v_parentdir}" || return "${?}"; fi

                touch "${p_fileFS}" || return "${?}";

                # rm "${p_fileFS}" || return "${?}";

               # rm -rf "${v_parentdir}" || return "${?}";

            else return "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}"; fi
    fi

	BU.Main.OS.IsAndroidTermux && {
        if [[ "$(df -aH "${p_fileFS}")" == 100% ]]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NO_SPACE_LEFT}";
		else
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
	}

	BU.Main.OS.IsFreeBSD && {
        true;
	}

	BU.Main.OS.IsHaiku && {
		if [[ "$(df -th "${p_fileFS} | awk 'FNR==10 {print ${3}}'")" == 0 ]]; then
            return "${__BU_MAIN_EXIT_NO_SPACE_LEFT}";
		else
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
	}

	BU.Main.OS.IsLinux && {
		if [[ "$(df -Th "${p_fileFS}" | awk 'FNR==2 {print $5}')" == 0[A-Za-z] ]]; then
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${__BU_MAIN_EXIT_NO_SPACE_LEFT}";
		else
			BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
		fi
	}

	BU.Main.OS.IsNetBSD && {
        true;
	}

	BU.Main.OS.IsOpenBSD && {
        true;
	}

	BU.Main.OS.IsOSX && {
		true;
	}
}

# -----------------------------------------------

## GETTING FILE SYSTEM'S INFORMATIONS
## DEBUG ID : getting-filesystem-informations

__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS="${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}::getting-filesystem-informations";

# Getting the file system path.
function BU.Main.Filesystem.GetFSDevice()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's device was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's device";

    BU.Main.OS.IsHaiku && v_cmd="df \"${p_path}\"           | awk 'FNR == 5 {print \$2}' || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$1}' || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the total size in bytes allocated to a given file system.
function BU.Main.Filesystem.GetFSTotalSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's total size in bytes was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's total size in bytes";

    BU.Main.OS.IsHaiku && v_cmd="df \"${p_path}\"           | awk 'FNR == 9 {print \$3\" \"\$4}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$3}'            || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the mounted partition of a given file system.
function BU.Main.Filesystem.GetFSMountPoint()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's mount point was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's mount point";

    BU.Main.OS.IsHaiku && v_cmd="df \"${p_path}\"           | awk 'FNR == 2 {print \$3}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$7}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the used size in bytes of a given file system.
function BU.Main.Filesystem.GetFSUsedSizeBytes()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables *****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's used size in bytes was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's used size in bytes";

    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$4}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Since no used size in bytes is provided by the "$(df)" command on Haiku, it's necessary to check it manually.
    BU.Main.OS.IsHaiku && {
        #**** Haiku variables ****
        declare -i v_totalSize;     # VAR TYPE : Int    - DESC : Getting the file system's total size in bytes.
        declare -i v_availableSize; # VAR TYPE : Int    - DESC : Getting the file system's available size in bytes.
        declare -i v_usedSize;      # VAR TYPE : Int    - DESC : Getting the used size by substracting the available size from the total size.

        #**** Haiku code ****
        v_totalSize="$(BU.Main.Filesystem.GetFSTotalSize "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; })";
        v_availableSize="$(BU.Main.Filesystem.GetFSAvailableSize "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; })";
        v_usedSize="$(( v_totalSize - v_availableSize ))";

        BU.Main.Echo.Msg "${v_usedSize}" '-n' 'nodate';

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
    }

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the percentage of the used space of a given file system.
function BU.Main.Filesystem.GetFSUsedSizePercent()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's used size percentage was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's used size percentage";

    BU.Main.OS.IsAndroidTermux   && v_cmd="df -aH \"${p_path}\"     | awk 'FNR == 2 {print \$5}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux           && v_cmd="df -Th \"${p_path}\"     | awk 'FNR == 2 {print \$6}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Since no used partition size percentage is provided by the "$(df)" command on Haiku, it's necessary to check it manually.
    BU.Main.OS.IsHaiku && {
        #**** Haiku variables ****
        declare -i v_totalSize;     # VAR TYPE : Int    - DESC : Getting the file system's total size in bytes.
        declare -i v_availableSize; # VAR TYPE : Int    - DESC : Getting the file system's available size in bytes.
        declare -i v_usedSize;      # VAR TYPE : Int    - DESC : Getting the used percentage.

        #**** Haiku code ****
        v_totalSize="$(BU.Main.Filesystem.GetFSTotalSize "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; })";
        v_availableSize="$(BU.Main.Filesystem.GetFSAvailableSize "${p_path}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; })";
        v_usedSize="$(( v_totalSize * v_availableSize / 100 ))";

        BU.Main.Echo.Msg "${v_usedSize}%" '-n' 'nodate';

        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
    }

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the available size in bytes of a given file system.
function BU.Main.Filesystem.GetFSAvailableSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's available size was not found.

    #**** Code ****
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's available size in bytes";

    BU.Main.OS.IsHaiku && v_cmd="df \"${p_path}\"           | awk 'FNR == 10 {print \$3}'       || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$5}'        || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# Getting the type of the file system of a directory or a file.
function BU.Main.Filesystem.GetFSType()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__HARD_DRIVE_FILE_SYSTEM_PROCESSING__GETTING_FILE_SYSTEM_INFORMATIONS}";

    #**** Parameters ****
    local p_path=${1:-$'\0'}; # ARG TYPE : String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Path to the file or the folder to process.

    #**** Variables ****
    local v_cmd;    # VAR TYPE : String     - DESC :
    local v_code=0; # VAR TYPE : Int        - DESC : Return code to modify in the "${v_cmd}" string.
    local v_warn;   # VAR TYPE : String     - DESC : Warning message to print if the target file system's type was not found.

    #**** Code ****
    # Disabling a false positive, as the "${v_warn}" variable is not directly intepreted.
    # shellcheck disable=SC2034
    v_warn="$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}") --> Warning : unable to get the target ($(BU.Main.Decho.Decho.Path "${p_path}")) file system's type";

    BU.Main.OS.IsHaiku && v_cmd="df \"${p_path}\"           | awk 'FNR == 4 {print \$3}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";
    BU.Main.OS.IsLinux && v_cmd="df -Th \"${p_path}\"       | awk 'FNR == 2 {print \$2}'    || { BU.Main.Echo.Warning \"\$v_warn\" '-n' 'nodate'; v_code='1'; return \"\$v_code\"; }";

    #**** Code ****
    if ! BU.Main.Args__Filesystem.GetFSInfos "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if ! BU.Main.CMDS.GetCommandReturnOutputValue "${v_cmd}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    eval "${v_cmd}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${v_code}";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### PERMISSION AND OWNERSHIP PROCESSING
#### DEBUG ID : filesystem::permission-and-ownership-processing

__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING="filesystem::permission-and-ownership-processing";

## NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING
## DEBUG ID : non-recursive

__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING__NON_RECURSIVE="${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING}::non-recursive";

# Fonctions d'attribution de propriété de fichier à l'utilisateur.

# Required functions and files into the "Bash-Utils/src/functions" folder :
#   - BU.Main.Checkings.CheckRootEUID() -> Checkings.lib
#   - BU.Main.Echo.Error()              -> Echo.lib
#   - BU.Main.Echo.Newstep()            -> Echo.lib
#   - BU.Main.Echo.Success()            -> Echo.lib
#   - BU.Main.Headers.DrawLine()        -> Headers.lib
#   - BU.Main.Errors.HandleErrors()     -> Headers.lib
function BU.Main.Filesystem.Chown()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING__NON_RECURSIVE}";

    #**** Parameters ****
    p_currentOwner=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC: This parameter is used in the translated messages, stored into their own variables.
    p_newOwner=${2:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : New owner of the directory / file.
    p_path=${3:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Path of the directory / file to process.
    p_option=${4:-$'\0'};       # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Chown command option(s).

    #**** Code ****
    if ! BU.Main.Args__Filesystem.Chown "${p_currentOwner}" "${p_newOwner}" "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # The "chown" command has to be used with super-user privileges,
    if ! BU.Main.Checkings.CheckRootEUID; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the path passed as argument doesn't exists.
    if [ -d "${p_path}" ]; then
        BU.Main.Echo.Newstep "Changing the ownership rights of the  $(BU.Main.Decho.Decho.Path "${p_path}/") folder from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}").";
        BU.Main.Echo.Newline;

        # Changing ownership recursively.
        case "${p_option}" in
            'R')
                if chown -Rv "${p_newOwner}" "${p_path}"; then
                    BU.Main.Echo.Success "The rights of the $(BU.Main.Decho.Decho.Path "${p_path}") folder have been successfully changed from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}")";
                    BU.Main.Echo.Newline;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
                else
                    BU.Main.Errors.HandleErrors "1" "Unable to change the rights of the $(BU.Main.Decho.Decho.Highlight "${p_path}/") folder" "" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 7 ))";
                    BU.Main.Echo.Newline;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                fi
                ;;
            '')
                # Changing ownership non-recursively.
                if chown -v "${p_newOwner}" "${p_path}"; then
                    BU.Main.Echo.Success "The rights of the $(BU.Main.Decho.Decho.Path "${p_path}") folder have been successfully changed from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}")";
                    BU.Main.Echo.Newline;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;

                else
                    BU.Main.Errors.HandleErrors "1" "UNABLE TO CHANGE THE RIGHTS OF THE $(BU.Main.Decho.Decho.Path "${p_path}/") FOLDER" \
                        "Please run the script with the command $(BU.Main.Decho.Decho.Highlight "bash -x ${PROJECT_NAME}") to check what happened" \
                        "${p_option}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 11 ))";
                    BU.Main.Echo.Newline;

                    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
                fi
                ;;
            *)
                BU.Main.Errors.HandleErrors "1" "THE $(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}")'S FUNCTION $(BU.Main.Decho.Decho.Path "${p_option}") OPTION PASSED AS 4TH ARGUMENT IS NOT SUPPORTED" \
                    "The supported options for directory processing are :" "${p_option}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0
            ;;
        esac


    else
        # Checking first if the path is a filepath. If not, then no correct path is passed as argument.
        if [ -f "${p_path}" ]; then
            BU.Main.Echo.Newstep "Changing the ownership rights of the $(BU.Main.Decho.Decho.Path "${p_path}/") file from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}").";
            BU.Main.Echo.Newline;

            # Changing ownership
            if chown -v "${p_newOwner}" "${p_path}"; then
                BU.Main.Echo.Success "The rights of the $(BU.Main.Decho.Decho.Path "${p_path}") file have been successfully changed from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}").";
                BU.Main.Echo.Newline;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
            else
                BU.Main.Errors.HandleErrors "${?}" "Unable to change the rights of the $(BU.Main.Decho.Decho.Path "${p_path}") file !";
                BU.Main.Echo.Newline;

                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
            fi
        else
            BU.Main.Errors.HandleErrors "1" "THE $(BU.Main.Decho.Decho.Path "${p_path}") FILE DOESN'T EXISTS" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
        fi
    fi
}

# -----------------------------------------------

## RECURSIVE PERMISSION AND OWNERSHIP PROCESSING
## DEBUG ID : recursive

__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING__RECURSIVE="${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING}::recursive";

# Calling the "chown" command to change recursively directory ownership

# Required functions and files into the "Bash-Utils/src/functions" folder :
#	- BU.Main.Checkings.CheckRootEUID()     -> Checkings.lib
#	- BU.Main.Echo.Error()			        -> Echo.lib
#	- BU.Main.Echo.Newstep()		        -> Echo.lib
#	- BU.Main.Echo.Success()		        -> Echo.lib
#	- BU.Main.Echo.Newline()			    -> Echo.lib
#	- BU.Main.Errors.HandleErrors()		    -> Headers.lib
function BU.Main.Filesystem.ChownRec()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_FILESYSTEM_LIB__CAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING}" \
        "${__BU_MAIN_FILESYSTEM_LIB__SUBCAT_DEBUG_ID__PERMISSION_AND_OWNERSHIP_PROCESSING__RECURSIVE}";

    #**** Paramètres ****
    local p_currentOwner=${1:-$'\0'};   # ARG TYPE :    - REQUIRED | DEFAULT VAL : NULL     - DESC : This parameter is used in the messages.
    local p_newOwner=${2:-$'\0'};       # ARG TYPE :    - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_path=${3:-$'\0'};           # ARG TYPE :    - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    if ! BU.Main.Args__Filesystem.ChownRec "${p_currentOwner}" "${p_newOwner}" "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # The "chown" command has to be used with super-user privileges,
    if ! BU.Main.Checkings.CheckRootEUID; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # If the path passed as argument doesn't exists.
    if [ ! -d "${p_path}" ]; then
        BU.Main.Errors.HandleErrors "1" "" "" "${p_path}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))";
    fi

    BU.Main.Echo.Newstep "Recursive change of the ownership rights of the new folder $(BU.Main.Decho.Decho.Path "${p_path}/") from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}")";
	BU.Main.Echo.Newline;

    # On change les droits du fichier créé par le script.
	# Comme il est exécuté en mode super-utilisateur, tout dossier ou fichier créé appartient à l'utilisateur root.
	# Pour attribuer les droits de lecture, d'écriture et d'exécution (rwx) à l'utilisateur normal, on appelle
	# la commande chown avec pour arguments :
	#		- Le nom de l'utilisateur à qui donner les droits.
	#		- Le chemin du dossier cible.
	if chown -Rv "${p_newOwner}" "${p_path}"; then
		BU.Main.Echo.Success "The rights of the $(BU.Main.Decho.Decho.Path "${p_path}/") folder have been successfully changed from $(BU.Main.Decho.Decho.Highlight "${p_currentOwner}") to $(BU.Main.Decho.Decho.Highlight "${p_newOwner}")";
		BU.Main.Echo.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
	else
        BU.Main.Echo.Error "Unable to change the rights of the $(BU.Main.Decho.Decho.Path "${p_path}/") folder";
		BU.Main.Echo.Newline;

		BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
    fi
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Headers.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       : 1.0

# ------------------
# FILE DESCRIPTION :

# Displaying text between two horizontal lines, in order to separate two important steps of a script, for example.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FUNCTIONS DEFINITION
#### DEBUG ID : headers::functions-definition

__BU_MAIN_HEADERS_LIB__CAT_DEBUG_ID__FUNCTIONS_DEFINITION="headers::functions-definition";

## HEADERS BASIS CREATION FUNCTIONS
## DEBUG ID : headers-basis-creation-functions

__BU_MAIN_HEADERS_LIB__SUBCAT_DEBUG_ID__FUNCTIONS_DEFINITION__HEADERS_BASIS_CREATION_FUNCTIONS="${__BU_MAIN_HEADERS_LIB__CAT_DEBUG_ID__FUNCTIONS_DEFINITION}::headers-basis-creation-functions";

# Function to create and display rows (decorated or not) according to the number of columns in the terminal's text area.
function BU.Main.Headers.DrawLine()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_HEADERS_LIB__CAT_DEBUG_ID__FUNCTIONS_DEFINITION}" \
        "${__BU_MAIN_HEADERS_LIB__SUBCAT_DEBUG_ID__FUNCTIONS_DEFINITION__HEADERS_BASIS_CREATION_FUNCTIONS}";

	#**** Parameters ****
    local p_lineChar=${1:--};       # Alphanumeric char     - REQUIRED | DEFAULT : '-'      - DESC : First parameter used to define the desired character when calling the function.
    local p_lineColor=${2:-$'\0'};  # String                - OPTIONAL | DEFAULT : NULL     - DESC : Second parameter used to define the desired color of the character when calling the function.
    local p_strlen=${3:-$'\0'};     # Int                   - OPTIONAL | DEFAULT : NULL     - DESC : Getting the lenght of the string, in order to adapt the line's lenght to the string's lenght.
    local p_bgColor=${4:-$'\0'};    # String                - OPTIONAL : NULL               - DESC : Setting a background color behind the line.

    #**** Code ****
	# Checking if the "${p_lineChar}" parameter's value is a string instead of a single character, and getting the first character only.
	if ! BU.Main.Checkings.IsAlphaNumChar "${p_lineChar}"; then
        p_lineChar="${p_lineChar:0:1}";
	fi

    # Defining the color of the wished character for the whole line before displaying the first character.
    # If the value of the "${p_lineColor}" parameter (which stores the text's color encoding) is not empty,
    # then we write the color's encoding into the terminal, which displays the color, and not its encoding in text.

    # The color's encoding can be written via the "tput setaf ${value}" command. The line is empty before the first
    # ASCII characters if the first parameter "${p_lineColor}" is passed as an empty string, which means that no
    # "tput setaf ${value}" command was executed.

    # Since we want to write the characters composing the header line after the color encoding string, we use the options
	# '-n' (no line breaks) and '-e' (interpret backslashes) of the "echo" command to avoid making a line break after the
	# end of the string, to write the next string directly after the line.

	# Since all the columns in the row are used, the following characters will be written in the row, as if a line break has been made.
	if test "${p_lineColor}" != ""; then
        BU.Main.Checkings.IsInt     "${p_lineColor}" && echo -ne "$(BU.Main.TextFormat.SetTextColor "${p_lineColor}")";
        ! BU.Main.Checkings.IsInt   "${p_lineColor}" && echo -ne "${p_lineColor}";
	fi

	if test "${p_bgColor}" != ""; then
        BU.Main.Checkings.IsInt     "${p_bgColor}" && echo -ne "$(BU.Main.TextFormat.SetBGColors "${p_bgColor}")";
        ! BU.Main.Checkings.IsInt   "${p_bgColor}" && echo -ne "${p_bgColor}";
	fi

    # Displaying the desired character on the whole line. To do this, using a "for" loop, we start reading it from
	# the first column (1), then we read the entire line to the end of the terminal's text box. At each call
	# of the "echo" command, a character is displayed and colored according to the encoding defined and written above.

	# The 'i' variable in the "for i in" loop has been replaced by an underscore '_' to stop Shellcheck from sending a warning
	# message due to the non-declaration of the variable 'i', although this does not change anything when the script is executed.

	# Checking if the line must be adapted to the string's lenght.
	if [ -n "${p_strlen}" ]; then
        if BU.Main.Checkings.IsInt "${p_strlen}"; then
            for _ in $(eval echo -e "{1..${p_strlen}}"); do
                echo -n "${p_lineChar}";
            done
        else
            BU.Main.Errors.HandleSmallErrors 'W' "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}${FUNCNAME[0]}${__BU_MAIN_COLOR_TXT_WARNING} --> Warning : The value passed for the $(BU.Main.Decho.Decho.HighlightVar "strlen") parameter is not an integer" 'R' 'CPLS';

            for _ in $(eval echo -e "{1..${__BU_MAIN_TXT_COLS}}"); do
                echo -n "${p_lineChar}";
            done
        fi

	else
        for _ in $(eval echo -e "{1..${__BU_MAIN_TXT_COLS}}"); do
            echo -n "${p_lineChar}";
        done
    fi

    # Definition (here, reinitialization) of the color of the characters following the last character of the header line
	# using the same code snippet as the first condition, to write the terminal's base color encoding (it is recommended
	# to call the "tput sgr0" command to reset the color according to the profile options of the terminal).
	# As with any color encoding, this plain text will not be displayed on the terminal.

	# En pratique, La couleur des caractères suivants est déjà encodée quand ils sont appelés via une des fonctions d'affichage.
	# Cette réinitialisation de la couleur du texte n'est qu'une mini-sécurité permettant d'éviter d'avoir la couleur de l'invite de
	# commandes encodée avec la couleur des headers si l'exécution du script est interrompue de force avec la combinaison "CTRL + C",
	# ou mise en pause avec la combinaison "CTRL + Z", par exemple.
	if test "${p_lineColor}" != ""; then
        echo -ne "${__BU_MAIN_COLOR_TXT_RESET}";
	fi

    if test "${p_bgColor}" != ""; then
        echo -ne "${__BU_MAIN_COLOR_BG_RESET}";
    fi

	# Since we used the '-n' option of the "echo" command, we make a line break to avoid having to repeat
	# it after each call of the command to leave an empty space between the line and the next character.
	echo;

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

# Printing a simple header, without any decorations.
function BU.Main.Headers.Light()
{
    #**** Parameters ****
    local p_msg=${1:-$'\0'};    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Message to print.
    local p_pos=${2:-NULL};     # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Position of the line to print.

    # NULL (default)    : no lines are printed
    # UPPER             : only the upper line is printed
    # LOWER             : only the lower line is printed
    # FULL              : both lines are printed

    #**** Code ****
    # Error handling for the value of the "${p_pos}" argument.
    if [ "${p_pos^^}" != 'NULL' ]; then if [[ ("${p_pos^^}" != 'UPPER') && ("${p_pos^^}" != 'LOWER') && ("${p_pos^^}" != 'FULL') ]]; then p_pos='NULL'; fi; fi

    echo;

    [[ ("${p_pos^^}" == 'FULL') || ("${p_pos^^}" == 'UPPER') ]] && { BU.Main.Headers.BU.Main.Headers.DrawLine; };
    echo "${p_msg}";
    [[ ("${p_pos^^}" == 'FULL') || ("${p_pos^^}" == 'LOWER') ]] && { BU.Main.Headers.BU.Main.Headers.DrawLine; };

    echo;

    return 0;
}

# Printing a simple header, without any decorations.
function BU.Main.Headers.LightDeco()
{
    #**** Parameters ****
    local p_color=${1:-$'\0'};  # ARG TYPE : String | CMD   - REQUIRED | DEFAULT VAL : NULL     - DESC : Color of the line AND the text.
    local p_msg=${2:-$'\0'};    # ARG TYPE : String         - OPTIONAL | DEFAULT VAL : NULL     - DESC : Message to print.
    local p_pos=${3:-NULL};     # ARG TYPE : String         - OPTIONAL | DEFAULT VAL : NULL     - DESC : Position of the line to print.

    # NULL (default)    : no lines are printed
    # UPPER             : only the upper line is printed
    # LOWER             : only the lower line is printed
    # FULL              : both lines are printed

    #**** Code ****
    # Error handling for the value of the "${p_pos}" argument.
    if [ "${p_pos^^}" != 'NULL' ]; then if [[ ("${p_pos^^}" != 'UPPER') && ("${p_pos^^}" != 'LOWER') && ("${p_pos^^}" != 'FULL') ]]; then p_pos='NULL'; fi; fi

    echo;

    [[ ("${p_pos^^}" == 'FULL') || ("${p_pos^^}" == 'UPPER') ]] && { printf "%s" "${p_color}"; PrintLine; printf "%s" "${__RESET}"; };
    echo "${p_color}${p_msg}${__RESET}";
    [[ ("${p_pos^^}" == 'FULL') || ("${p_pos^^}" == 'LOWER') ]] && { printf "%s" "${p_color}"; PrintLine; printf "%s" "${__RESET}"; };

    echo;

    return 0;
}

# Basic header creation function (Background colors, lines characters and colors, and string text and color).

# Since this function can be called in the "BU.Main.Echo.__EchoOutput()" function,
# even if the "${__BU_MAIN_STAT_ECHO}" status variable's value is set to "true",
# it's better to create a failsafe, to avoid experiencing an infinite loop.
function BU.Main.Headers.Base () {
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_HEADERS_LIB__CAT_DEBUG_ID__FUNCTIONS_DEFINITION}" \
        "${__BU_MAIN_HEADERS_LIB__SUBCAT_DEBUG_ID__FUNCTIONS_DEFINITION__HEADERS_BASIS_CREATION_FUNCTIONS}";

    #**** Parameters ****
    local p_lineChar=${1:--};           # ARG TYPE : Alphanum char      - REQUIRED | DEFAULT VAL : '-'      - DESC : Defining the wanted character to display when calling the "BU.Main.Headers.DrawLine()" function.
    local p_lineColor=${2:-$'\0'};      # ARG TYPE : CMD   | String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Defining the wanted character's color to display  servant à définir la couleur souhaitée du caractère lors de l'appel de la fonction "BU.Main.Headers.DrawLine".
    local p_stringColor=${3:-$'\0'};    # ARG TYPE : CMD   | String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Defining the color of the header's string

    local p_stringTxt=${4:-$'\0'};      # ARG TYPE : String             - OPTIONAL | DEFAULT VAL : NULL     - DESC : String displayed between the two lines.
    local p_strlen=${5:-$'\0'};         # ARG TYPE : String             - OPTIONAL | DEFAULT VAL : NULL     - DESC : Getting the lenght of the string, in order to adapt the line's lenght to the string's lenght.
    local p_bgColorCol=${6:-$'\0'};     # ARG TYPE : CMD   | String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Defining the background color.

    local p_bgColorPos=${7:-$'\0'};     # ARG TYPE : Int                - OPTIONAL | DEFAULT VAL : NULL     - DESC : Defining the background color's position (first line, text or second line, or a mix ?).

    #**** Variables ****
    # Sleep command processing
    local v_stat_time_newline="${__BU_MAIN_STAT_TIME_NEWLINE}";   # VAR TYPE : Float    - DESC : Setting the new lines display time's global status variable to 0 seconds, because the header's pause time is already set.
    local v_stat_time_txt="${__BU_MAIN_STAT_TIME_TXT}";           # VAR TYPE : Float    - DESC : Setting the normal text display time's global status variable to 0 seconds, because the header's pause time is already set.

    # ----------
    # Loop error processing (this variable stores the 'error' string if a command or a function call failed during the execution of a loop).
    local v_loop_error;

    # ----------
    # Line's length processing
    if [ -n "${p_strlen}" ] && [ "${p_strlen,,}" == 'strlen' ]; then local v_strlen; v_strlen="${#p_stringTxt}"; fi

    #**** Code ****
	__BU_MAIN_STAT_TIME_NEWLINE="0";
	__BU_MAIN_STAT_TIME_TXT="0";

    BU.Main.Echo.Newline;

    # If no value is passed via the background color's position's parameter.
    if [ -z "${p_bgColorPos}" ]; then
        # Converting the "${p_stringColor}" integer into a command substitution, since this command is directly used in this function's condition.
        if BU.Main.Checkings.IsNotCMD "${p_stringColor}"; then p_stringColor="$(BU.Main.TextFormat.SetTextColor "${p_stringColor}")"; fi

        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_lineChar}" "${p_lineColor}" "${v_strlen}" "${p_bgColorCol}")" '' "nodate";
        BU.Main.Echo.Msg "${p_stringColor}##> ${p_stringTxt}${__BU_MAIN_COLOR_TXT_RESET}${__BU_MAIN_COLOR_BG_RESET}";
        BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_lineChar}" "${p_lineColor}" "${v_strlen}" "${p_bgColorCol}")" '' "nodate";

    # Else, if a value is passed via the background color's position's parameter.
    else
        # Getting the line color code stored in the background color code's file, since this integer is needed for the execution of the "" function.
        BU.Main.Checkings.IsCMD "${p_stringColor}" && p_lineColor="$(BU.Main.TextFormat.GetTextColorFromCMD "${p_lineColor}")";

        # Getting the background color code stored in the background color code's file, since this integer is needed for the execution of the "" function.
        BU.Main.Checkings.IsCMD "${p_bgColorCol}" && p_bgColorCol="$(BU.Main.TextFormat.GetBGColorFromCMD "${p_bgColorCol}")";

        # This value MUST be an integer.
        if BU.Main.Checkings.IsIntPos "${p_bgColorPos}" && [ "${#p_bgColorPos}" -ge 1 ] && [ "${#p_bgColorPos}" -le 3 ]; then

            # Transforming the "${p_bgColorPos}" variable in an array of integers.
            read -ra int_array <<< "${p_bgColorPos}";

            for i in "${int_array[@]}"; do

                if [[ "${i}" == '1'* ]]; then
                    BU.Main.Decho.BGColor "$(BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_lineChar}" "${p_lineColor}" "${v_strlen}" "${p_bgColorCol}")" "nodate")" "${p_stringColor}" "${p_bgColorCol}" || { local C="${?}"; v_loop_error='error'; break; };

                elif [[ "${i}" == *'2'* ]]; then
                    BU.Main.Decho.BGColor "$(BU.Main.Echo.Msg "${p_stringColor}##> ${p_stringTxt}${__BU_MAIN_COLOR_TXT_RESET}")" "${p_stringColor}" "" "${p_bgColorCol}" || { local C="${?}"; v_loop_error='error'; break; };

                elif [[ "${i}" == *'3' ]]; then
                    BU.Main.Decho.BGColor "$(BU.Main.Echo.Msg "$(BU.Main.Headers.DrawLine "${p_lineChar}" "${p_lineColor}" "${v_strlen}" "${p_bgColorCol}")" "nodate")" "${p_stringColor}" "${p_bgColorCol}" || { local C="${?}"; v_loop_error='error'; break; };

                elif [[ "${i}" == *'1'* ]] || [[ "${i}" == *'3'* ]]; then
                    BU.Main.Errors.HandleSmallErrors 'W' "$(BU.Main.Decho.Decho.HighlightFunction "${FUNCNAME[0]}") --> Warning : the values were not arranged in ascending order, like 123, 12, 13 or 23" 'R';

                else
                    BU.Main.Errors.HandleSmallErrors 'W' "$(BU.Main.Decho.Decho.HighlightFunction "${FUNCNAME[0]}") --> Warning : the value passed for the $(BU.Main.Decho.Decho.HighlightVar "p_bgColorPos") parameter is a bad integer (1, 2 AND / OR 3 are supported), " 'R';
                fi
            done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

        elif BU.Main.Checkings.IsIntPos "${p_bgColorPos}" && [ "${#p_bgColorPos}" -gt 3 ]; then
            BU.Main.Errors.HandleSmallErrors 'W' "$(BU.Main.Decho.Decho.HighlightFunction "${FUNCNAME[0]}") --> Warning : the length of the value passed as $(BU.Main.Decho.Decho.HighlightVar "p_bgColorPos") parameter is too big" 'R';

        elif [ "${#p_bgColorPos}" -lt 1 ]; then
            BU.Main.Errors.HandleSmallErrors 'W' "$(BU.Main.Decho.Decho.HighlightFunction "${FUNCNAME[0]}") --> Warning : the length of the value passed as $(BU.Main.Decho.Decho.HighlightVar "p_bgColorPos") parameter is null" 'R';

        else
            BU.Main.Errors.HandleSmallErrors 'W' "$(BU.Main.Decho.Decho.HighlightFunction "${FUNCNAME[0]}") --> Warning : the value passed for the $(BU.Main.Decho.Decho.HighlightVar "p_bgColorPos") parameter is not a positive integer" 'R';
        fi
    fi

    BU.Main.Echo.Newline;

    sleep "${__BU_MAIN_STAT_TIME_HEADER}";

    __BU_MAIN_STAT_TIME_NEWLINE="${v_stat_time_newline}";   # Resetting the new lines display time's global status variable to its original value.
    __BU_MAIN_STAT_TIME_TXT="${v_stat_time_txt}";           # Resetting the normal text display time's global status variable to its original value.

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 0;
}

function BU.Main.Headers.Base.CMD()
{
    BU.Main.Headers.Base "${@}";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

## UNICOLOR HEADERS
## DEBUG ID : unicolor-headers

# Positional parameters, and their correspondences with the parameters of the "BU.Main.Headers.HeaderBase()" function :

# Except for the "${1}" positional parameter, the three other are totally optional.
#   ${1}    --> "${p_stringTxt}";
#   ${2}    --> "${p_strlen}";
#   ${3}    --> "${p_bgColorCol}";
#   ${4}    --> "${p_bgColorPos}";

# Header to display without color.
function BU.Main.Headers.Header                     { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RESET}"          "${__BU_MAIN_COLOR_TXT_RESET}"     	    "${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD                 { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RESET}"          "${__BU_MAIN_COLOR_TXT_RESET}"          "${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display in case of an error.
function BU.Main.Headers.Header.Error               { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ERROR}"         "${__BU_MAIN_COLOR_CODE_ERROR}"      	"${1}" "${2}" "${3}" "${4}" 'false'		    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Error           { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}"          "${__BU_MAIN_COLOR_TXT_ERROR}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display when switching to a new package category during package installation.
function BU.Main.Headers.Header.Install             { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"        "${__BU_MAIN_COLOR_CODE_GREEN}"      	"${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Install         { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"         "${__BU_MAIN_COLOR_TXT_GREEN}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display when changing step.
function BU.Main.Headers.Header.Newstep             { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NEWSTEP}"      	"${__BU_MAIN_COLOR_CODE_NEWSTEP}"    	"${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Newstep         { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NEWSTEP}"       	"${__BU_MAIN_COLOR_TXT_NEWSTEP}"     	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display when changing step.
function BU.Main.Headers.Header.Step                { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}"         	"${__BU_MAIN_COLOR_CODE_CYAN}"       	"${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Step            { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}"          	"${__BU_MAIN_COLOR_TXT_CYAN}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display in case of a successfully done step.
function BU.Main.Headers.Header.Success             { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SUCCESS}"      	"${__BU_MAIN_COLOR_CODE_SUCCESS}"    	"${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Success         { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SUCCESS}"       	"${__BU_MAIN_COLOR_TXT_SUCCESS}"     	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Header to display in case of a minor error.
function BU.Main.Headers.Header.Warning             { BU.Main.Headers.Base      "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WARNING}"      	"${__BU_MAIN_COLOR_CODE_WARNING}"    	"${1}" "${2}" "${3}" "${4}" 'false' 	    || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Warning         { BU.Main.Headers.Base.CMD  "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WARNING}"     	"${__BU_MAIN_COLOR_TXT_WARNING}"     	"${1}" "${2}" "${3}" "${4}" 'true' "${@}"   || return 1; return 0; }

# Copy-paste this function to avoid losing time while creating unicolor headers :
# function BU.Header<col> { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_<COLOR>}" -"${__BU_MAIN_COLOR_<COLOR>}" "${1}" "${2}" "${3}" "${4}" || return 1; return 0; }

# -----------------------------------------------

# OLD COLORS (BEFORE 2022 01 07)

# Strings
function BU.Main.Headers.Header.Black               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}"              "${__BU_MAIN_COLOR_CODE_BLACK}"         "${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Blue                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}"           	"${__BU_MAIN_COLOR_CODE_BLUE}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}"           	"${__BU_MAIN_COLOR_CODE_CYAN}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}"           	"${__BU_MAIN_COLOR_CODE_GRAY}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}"          	"${__BU_MAIN_COLOR_CODE_GREEN}"         "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"         	"${__BU_MAIN_COLOR_CODE_ORANGE}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}"           	"${__BU_MAIN_COLOR_CODE_PINK}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"         	"${__BU_MAIN_COLOR_CODE_PURPLE}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red                 { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}"            	"${__BU_MAIN_COLOR_CODE_RED}"           "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Turquoise           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"   		"${__BU_MAIN_COLOR_CODE_TURQUOISE}"     "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.White               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}"          	"${__BU_MAIN_COLOR_CODE_WHITE}"         "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Yellow              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"     		"${__BU_MAIN_COLOR_CODE_YELLOW}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Black			{ BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}"          		"${__BU_MAIN_COLOR_TXT_BLACK}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}"           		"${__BU_MAIN_COLOR_TXT_BLUE}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}"           		"${__BU_MAIN_COLOR_TXT_CYAN}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Gray            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}"           		"${__BU_MAIN_COLOR_TXT_GRAY}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Green           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}"          		"${__BU_MAIN_COLOR_TXT_GREEN}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"         		"${__BU_MAIN_COLOR_TXT_ORANGE}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}"           		"${__BU_MAIN_COLOR_TXT_PINK}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"         		"${__BU_MAIN_COLOR_TXT_PURPLE}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red            	{ BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}"            		"${__BU_MAIN_COLOR_TXT_RED}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"      		"${__BU_MAIN_COLOR_TXT_TURQUOISE}"   	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}"          		"${__BU_MAIN_COLOR_TXT_WHITE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"         		"${__BU_MAIN_COLOR_TXT_YELLOW}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

# NEW COLORS (SINCE 2022 01 07)

# Strings
function BU.Main.Headers.Header.Aqua                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}"           	"${__BU_MAIN_COLOR_CODE_AQUA}"     	    "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"        	"${__BU_MAIN_COLOR_CODE_FUCHSIA}"       "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Lime                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}"           	"${__BU_MAIN_COLOR_CODE_LIME}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}"         	"${__BU_MAIN_COLOR_CODE_MAROON}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Navy                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}"           	"${__BU_MAIN_COLOR_CODE_NAVY}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"         		"${__BU_MAIN_COLOR_CODE_OLIVE}"         "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}"         	"${__BU_MAIN_COLOR_CODE_SALMON}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}"         	"${__BU_MAIN_COLOR_CODE_SILVER}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan                 { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}"            	"${__BU_MAIN_COLOR_CODE_TAN}"           "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}"           	"${__BU_MAIN_COLOR_CODE_TEAL}"          "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Violet              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"     		"${__BU_MAIN_COLOR_CODE_VIOLET}"        "${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Aqua            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}"          		"${__BU_MAIN_COLOR_TXT_AQUA}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"       		"${__BU_MAIN_COLOR_TXT_FUCHSIA}"     	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Lime            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}"        		"${__BU_MAIN_COLOR_TXT_LIME}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}"        		"${__BU_MAIN_COLOR_TXT_MAROON}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}"          		"${__BU_MAIN_COLOR_TXT_NAVY}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"         		"${__BU_MAIN_COLOR_TXT_OLIVE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}"        		"${__BU_MAIN_COLOR_TXT_SALMON}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}"        		"${__BU_MAIN_COLOR_TXT_SILVER}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}"           		"${__BU_MAIN_COLOR_TXT_TAN}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}"          		"${__BU_MAIN_COLOR_TXT_TEAL}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Violet          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"        		"${__BU_MAIN_COLOR_TXT_VIOLET}"      	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

## BICOLOR HEADERS
## DEBUG ID : bicolor-headers

# Copy-paste this function to avoid losing time while creating bicolor headers :
# function BU.Header<col1><col2>      { BU.Main.Headers.HeaderBase "${__BU_MAIN_COLOR_<COLOR1>}" "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_<COLOR2>}" "${1}" "${2}" "${3}" "${4}" || return 1; return 0; }

## AQUA BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Aqua.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"        	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Aqua.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Aqua.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_AQUA}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Aqua.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_BLACK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_BLUE}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_CYAN}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_GRAY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_GREEN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_LIME}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_MAROON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_NAVY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_OLIVE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_PINK}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_RED}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_SALMON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_SILVER}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_TAN}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_TEAL}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}"  "${__BU_MAIN_COLOR_TXT_TURQUOISE}"        		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Aqua.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_WHITE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Aqua.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## BLACK LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Black.Aqua              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_AQUA}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Blue              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_BLUE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Cyan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_CYAN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Fuchsia           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Gray              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_GRAY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Green             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_GREEN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Lime              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_LIME}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Maroon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_MAROON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Navy              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_NAVY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Olive             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_OLIVE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Orange            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_ORANGE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Pink              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_PINK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Purple            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_PURPLE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Red               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_RED}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Salmon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_SALMON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Silver            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_SILVER}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Tan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Teal              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Turquoise         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"        	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.Violet            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_VIOLET}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Black.White             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_WHITE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Black.Yellow            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLACK}" "${__BU_MAIN_COLOR_CODE_YELLOW}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Black.Aqua          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_AQUA}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Blue          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_BLUE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Cyan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_CYAN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Fuchsia       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Gray          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_GRAY}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Green         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_GREEN}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Lime          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_LIME}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Maroon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_MAROON}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Navy          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_NAVY}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Olive         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_OLIVE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Orange        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_ORANGE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Pink          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_PINK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Purple        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_PURPLE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Red           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_RED}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Salmon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_SALMON}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Silver        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_SILVER}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Tan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_TEAL}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Teal          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_TEAL}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Turquoise     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"        		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.Violet        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_VIOLET}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Black.White         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_WHITE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Black.Yellow        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLACK}" "${__BU_MAIN_COLOR_TXT_YELLOW}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Blue.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_SILVER}"           		"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Blue.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Blue.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_BLUE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Blue.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_AQUA}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_BLACK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_CYAN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_GRAY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_GREEN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_LIME}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_MAROON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_NAVY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_PINK}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_RED}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_SALMON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_SILVER}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_TAN}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_TEAL}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Blue.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_WHITE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Blue.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_BLUE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## CYAN LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Cyan.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_BLACK}"            		"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Cyan.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Cyan.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_CYAN}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitution
function BU.Main.Headers.Header.CMD.Cyan.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_AQUA}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_BLACK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_BLUE}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_GRAY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_GREEN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_LIME}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_MAROON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_NAVY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_PINK}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_RED}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_SALMON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_SILVER}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_TAN}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_TEAL}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Cyan.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_WHITE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Cyan.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_CYAN}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## FUCHSIA LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Fuchsia.Aqua            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_AQUA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Black           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_BLACK}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Blue            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_BLUE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Cyan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_CYAN}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Gray            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_GRAY}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Green           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_GREEN}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Lime            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_LIME}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Maroon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_MAROON}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Navy            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_NAVY}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Olive           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_OLIVE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Orange          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_ORANGE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Pink            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_PINK}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Purple          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_PURPLE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Red             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_RED}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Salmon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_SALMON}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Silver          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_SILVER}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Tan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_TAN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Teal            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_TEAL}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Turquoise       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"      	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.Violet          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_VIOLET}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Fuchsia.White           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_WHITE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Fuchsia.Yellow          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}" "${__BU_MAIN_COLOR_CODE_YELLOW}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Fuchsia.Aqua        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_AQUA}"          		    "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Black       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_BLACK}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Blue        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_BLUE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Cyan        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_CYAN}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Gray        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_GRAY}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Green       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_GREEN}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Lime        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_LIME}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Maroon      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_MAROON}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Navy        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_NAVY}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Olive       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_OLIVE}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Orange      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_ORANGE}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Pink        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_PINK}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Purple      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_PURPLE}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Red         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_RED}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Salmon      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_SALMON}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Silver      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_SILVER}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Tan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_TAN}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Teal        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_TEAL}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Turquoise   { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"      		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.Violet      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_VIOLET}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Fuchsia.White       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_WHITE}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Fuchsia.Yellow      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}" "${__BU_MAIN_COLOR_TXT_YELLOW}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## GRAY LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Gray.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Gray.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Gray.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GRAY}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.CMD.Header.Gray.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_AQUA}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_BLACK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_BLUE}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" | return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_CYAN}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_GREEN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_LIME}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_MAROON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_NAVY}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_PINK}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_RED}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_SALMON}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_SILVER}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_TAN}"               		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_TEAL}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Gray.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_WHITE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Gray.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GRAY}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## LIGHT GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Green.Aqua              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_AQUA}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Black             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_BLACK}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Blue              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_BLUE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Cyan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_CYAN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Fuchsia           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Gray              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_GRAY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Lime              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_LIME}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Maroon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_MAROON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Navy              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_NAVY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Oliv              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_OLIVE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Orange            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_ORANGE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Pink              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_PINK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Purple            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_PURPLE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Red               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_RED}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Salmon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_SALMON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Silver            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_SILVER}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Tan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Teal              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Turquoise         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"        	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.Violet            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_VIOLET}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Green.White             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_WHITE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Green.Yellow            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_GREEN}" "${__BU_MAIN_COLOR_CODE_YELLOW}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.CMD.Header.Green.Aqua          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_AQUA}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Black         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_BLACK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Blue          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_BLUE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Cyan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_CYAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Fuchsia       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Gray          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_GRAY}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Lime          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_LIME}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Maroon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_MAROON}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Navy          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_NAVY}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Oliv          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_OLIVE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Orange        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_ORANGE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Pink          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_PINK}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Purple        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_PURPLE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Red           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_RED}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Salmon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_SALMON}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Silver        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_SILVER}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Tan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Teal          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Turquoise     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"        	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.Violet        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_VIOLET}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Green.White         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_WHITE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Green.Yellow        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_GREEN}" "${__BU_MAIN_COLOR_TXT_YELLOW}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## LIME GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Lime.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Marron             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Silve              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Lime.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Lime.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_LIME}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.CMD.Header.Lime.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Marron         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_RED}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Silve          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.CMD.Header.Lime.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.CMD.Header.Lime.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_LIME}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## MAROON LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Maroon.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_RED}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Silver           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_TAN}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_VIOLET}"         	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Maroon.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Maroon.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_MAROON}" "${__BU_MAIN_COLOR_CODE_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Maroon.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_RED}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Silver       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Maroon.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Maroon.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_MAROON}" "${__BU_MAIN_COLOR_TXT_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## NAVY BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Navy.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Navy.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Navy.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_NAVY}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Navy.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_AQUA}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_BLACK}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_BLUE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_CYAN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_GRAY}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_GREEN}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_OLIVE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_ORANGE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_PINK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_PURPLE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_RED}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_SALMON}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_SILVER}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_TAN}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Navy.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Navy.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_NAVY}" "${__BU_MAIN_COLOR_TXT_YELLOW}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## OLIVE GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Olive.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_AQUA}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_BLACK}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_BLUE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_GRAY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_GREEN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_LIME}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_MAROON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_NAVY}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_PINK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_RED}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_SALMON}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Silver           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_SILVER}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_TAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_TEAL}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"        	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Olive.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_WHITE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Olive.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_OLIVE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Olive.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_AQUA}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_BLACK}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_BLUE}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_CYAN}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"          		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_GRAY}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_GREEN}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_LIME}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_MAROON}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_NAVY}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_PINK}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_RED}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_SALMON}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Silver       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_SILVER}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_TAN}"              		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_TEAL}"             		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"        		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Olive.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_WHITE}"            		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Olive.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_OLIVE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## ORANGE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Orange.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_RED}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Silver           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Orange.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Orange.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_ORANGE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Orange.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_RED}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Silver       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Orange.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Orange.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ORANGE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## PINK LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Pink.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Teal               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Pink.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Pink.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PINK}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Pink.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" | return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_RED}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Teal           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_TEAL}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Pink.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Pink.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PINK}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## PURPLE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Purple.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_RED}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Silver           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Purple.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Purple.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_PURPLE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Purple.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_RED}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Silver       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_SILVER}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Purple.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Purple.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_PURPLE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## RED LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Red.Aqua                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_AQUA}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Black               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_BLACK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Blue                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_BLUE}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Cyan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_CYAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Fuchsia             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Gray                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_GRAY}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Green               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_GREEN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Lime                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_LIME}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Maroon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_MAROON}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Navy                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_NAVY}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Olive               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_OLIVE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Orange              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_ORANGE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Pink                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_PINK}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Purple              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_PURPLE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Salmon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_SALMON}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Silver              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_SILVER}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Tan                 { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_TAN}"                	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Teal                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_TEAL}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Turquoise           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.Violet              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_VIOLET}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Red.White               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_WHITE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Red.Yellow              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_RED}" "${__BU_MAIN_COLOR_CODE_YELLOW}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Red.Aqua            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_AQUA}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Black           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_BLACK}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Blue            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_BLUE}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Cyan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_CYAN}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Fuchsia         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Gray            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_GRAY}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Green           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_GREEN}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Lime            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_LIME}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Maroon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_MAROON}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Navy            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_NAVY}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Olive           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_OLIVE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Orange          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_ORANGE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Pink            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_PINK}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Purple          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_PURPLE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Salmon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_SALMON}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Silver          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_SILVER}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Tan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_TAN}"                	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Teal            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_TEAL}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Turquoise       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.Violet          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_VIOLET}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Red.White           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_WHITE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Red.Yellow          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_RED}" "${__BU_MAIN_COLOR_TXT_YELLOW}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## SALMON LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Salmon.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_RED}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }
function BU.Main.Headers.Header.Salmon.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

function BU.Main.Headers.Header.Salmon.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SALMON}" "${__BU_MAIN_COLOR_CODE_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'false'		|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Salmon.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_RED}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Salmon.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Salmon.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SALMON}" "${__BU_MAIN_COLOR_TXT_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## SILVER LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Silver.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_RED}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Silver.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Silver.Yellow           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_SILVER}" "${__BU_MAIN_COLOR_CODE_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Silver.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_AQUA}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_BLACK}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_BLUE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_CYAN}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_GRAY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_GREEN}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_LIME}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_MAROON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_NAVY}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_OLIVE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_ORANGE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_PINK}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_PURPLE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_RED}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_SALMON}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_TAN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_TEAL}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"       	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_VIOLET}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Silver.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_WHITE}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Silver.Yellow       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_SILVER}" "${__BU_MAIN_COLOR_TXT_YELLOW}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## TAN LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Tan.Aqua                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_AQUA}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Blue                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_BLACK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Black               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_BLUE}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Cyan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_CYAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Fuchsia             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Gray                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_GRAY}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Green               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_GREEN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Lime                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_LIME}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Maroon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_MAROON}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Navy                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_NAVY}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Olive               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_OLIVE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Orange              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_ORANGE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Pink                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_PINK}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Purple              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_PURPLE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Red                 { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_RED}"                	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Salmon              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_SALMON}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Silver              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_SILVER}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Teal                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_TEAL}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Turquoise           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"          	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.Violet              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_VIOLET}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Tan.White               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_WHITE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Tan.Yellow              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TAN}" "${__BU_MAIN_COLOR_CODE_YELLOW}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Tan.Aqua            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_AQUA}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Blue            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_BLACK}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Black           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_BLUE}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Cyan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_CYAN}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Fuchsia         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           		"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Gray            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_GRAY}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Green           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_GREEN}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Lime            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_LIME}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Maroon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_MAROON}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Navy            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_NAVY}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Olive           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_OLIVE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Orange          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_ORANGE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Pink            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_PINK}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Purple          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_PURPLE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Red             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_RED}"                	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Salmon          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_SALMON}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Silver          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_SILVER}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Teal            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_TEAL}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Turquoise       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"          	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.Violet          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_VIOLET}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Tan.White           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_WHITE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Tan.Yellow          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TAN}" "${__BU_MAIN_COLOR_TXT_YELLOW}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## TEAL LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Teal.Aqua               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Black              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Blue               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Cyan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Fuchsia            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Gray               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Green              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Lime               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Maroon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Navy               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Olive              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Orange             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Pink               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Purple             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Red                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_RED}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Salmon             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Silver             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Tan                { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Turquoise          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.Violet             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }
function BU.Main.Headers.Header.Teal.White              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_WHITE}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

function BU.Main.Headers.Header.Teal.Yellow             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TEAL}" "${__BU_MAIN_COLOR_CODE_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'false' 	|| return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Teal.Aqua           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_AQUA}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Black          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_BLACK}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Blue           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_BLUE}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Cyan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_CYAN}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Fuchsia        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"           	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Gray           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_GRAY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Green          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_GREEN}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Lime           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_LIME}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Maroon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_MAROON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Navy           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_NAVY}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Olive          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_OLIVE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Orange         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_ORANGE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Pink           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_PINK}"              	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Purple         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_PURPLE}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Red            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_RED}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Salmon         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_SALMON}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Silver         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_SILVER}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Tan            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_TAN}"               	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Turquoise      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"         	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.Violet         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_VIOLET}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Teal.White          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_WHITE}"             	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Teal.Yellow         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TEAL}" "${__BU_MAIN_COLOR_TXT_YELLOW}"            	"${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## TURQUOISE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Turquoise.Aqua          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_AQUA}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Black         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_BLACK}"          "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Blue          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_BLUE}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Cyan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_CYAN}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Fuchsia       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"        "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Gray          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_GRAY}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Green         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_GREEN}"          "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Lime          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_LIME}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Maroon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_MAROON}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Navy          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_NAVY}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Olive         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"          "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Orange        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Pink          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_PINK}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Purple        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Red           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_RED}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Salmon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_SALMON}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Silver        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_SILVER}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Tan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_TAN}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Teal          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_TEAL}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.Violet        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Turquoise.White         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_WHITE}"          "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Turquoise.Yellow        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Turquoise.Aqua      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_AQUA}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Black     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_BLACK}"            "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Blue      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_BLUE}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Cyan      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_CYAN}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Fuchsia   { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"          "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Gray      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_GRAY}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Green     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_GREEN}"            "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Lime      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_LIME}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Maroon    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_MAROON}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Navy      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_NAVY}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Olive     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"            "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Orange    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Pink      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_PINK}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Purple    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Red       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_RED}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Salmon    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_SALMON}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Silver    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_SILVER}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Tan       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_TAN}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Teal      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_TEAL}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.Violet    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Turquoise.White     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_WHITE}"            "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Turquoise.Yellow    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

# -----------------------------------------------

## WHITE LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.White.Aqua              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_AQUA}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Black             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_BLACK}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Blue              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_BLUE}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Cyan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_CYAN}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Fuchsia           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Gray              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_GRAY}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Green             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_GREEN}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Lime              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_LIME}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Maroon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_MAROON}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Navy              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_NAVY}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Olive             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_OLIVE}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Orange            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_ORANGE}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Pink              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_PINK}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Purple            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_PURPLE}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Red               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_RED}"                "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Salmon            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_SALMON}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Silver            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_SILVER}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Tan               { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_TAN}"                "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Teal              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_TEAL}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Violet            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_VIOLET}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.White.Turquoise         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"          "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.White.Yellow            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_WHITE}" "${__BU_MAIN_COLOR_CODE_YELLOW}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.White.Aqua          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_AQUA}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Black         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_BLACK}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Blue          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_BLUE}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Cyan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_CYAN}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Fuchsia       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Gray          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_GRAY}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Green         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_GREEN}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Lime          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_LIME}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Maroon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_MAROON}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Navy          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_NAVY}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Olive         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_OLIVE}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Orange        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_ORANGE}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Pink          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_PINK}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Purple        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_PURPLE}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Red           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_RED}"                  "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Salmon        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_SALMON}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Silver        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_SILVER}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Tan           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_TAN}"                  "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Teal          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_TEAL}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Violet        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_VIOLET}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.White.Turquoise     { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"            "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.White.Yellow        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_WHITE}" "${__BU_MAIN_COLOR_TXT_YELLOW}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }


# -----------------------------------------------

## YELLOW LINES, DIFFERENTLY COLORED TEXT

# Strings
function BU.Main.Headers.Header.Yellow.Aqua             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_AQUA}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Black            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_BLACK}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Blue             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_BLUE}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Cyan             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_CYAN}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Fuchsia          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_FUCHSIA}"           "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Gray             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_GRAY}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Green            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_GREEN}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Lime             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_LIME}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Maroon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_MAROON}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Navy             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_NAVY}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Olive            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_OLIVE}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Orange           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_ORANGE}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Pink             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_PINK}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Purple           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_PURPLE}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Red              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_RED}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Salmon           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_SALMON}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Silver           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_SILVER}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Tan              { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_TAN}"               "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.Teal             { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_TEAL}"              "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Turquoise        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_TURQUOISE}"         "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }
function BU.Main.Headers.Header.Yellow.Violet           { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_VIOLET}"            "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

function BU.Main.Headers.Header.Yellow.White            { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_CODE_YELLOW}" "${__BU_MAIN_COLOR_CODE_WHITE}"             "${1}" "${2}" "${3}" "${4}" 'false'     || return 1; return 0; }

# Command substitutions
function BU.Main.Headers.Header.CMD.Yellow.Aqua         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_AQUA}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Black        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_BLACK}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Blue         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_BLUE}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Cyan         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_CYAN}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Fuchsia      { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_FUCHSIA}"             "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Gray         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_GRAY}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Green        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_GREEN}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Lime         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_LIME}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Maroon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_MAROON}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Navy         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_NAVY}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Olive        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_OLIVE}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Orange       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_ORANGE}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Pink         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_PINK}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Purple       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_PURPLE}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Red          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_RED}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Salmon       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_SALMON}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Silver       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_SILVER}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Tan          { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_TAN}"                 "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.Teal         { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_TEAL}"                "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Turquoise    { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_TURQUOISE}"           "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
function BU.Main.Headers.Header.CMD.Yellow.Violet       { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_VIOLET}"              "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }

function BU.Main.Headers.Header.CMD.Yellow.White        { BU.Main.Headers.Base "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_YELLOW}" "${__BU_MAIN_COLOR_TXT_WHITE}"               "${1}" "${2}" "${3}" "${4}" 'true' "${@}" || return 1; return 0; }
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Locale.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154,SC2016

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

####
#### DEBUG ID :

##
## DEBUG ID :

# Checking if the language's code matches to a valid ISO 639-1 code.
function BU.Main.Locale.CheckISO_639_1_ValidCode()
{
    [[ ${__BU_MAIN_LOCALE_ISO_639_1_LOCALES_ARRAY[*]} =~ ${1,,} ]] && return 0; return 1;
}

# Printing the language name in English and in its own language.
function BU.Main.Locale.PrintLanguageName()
{
	#**** Parameters ****
	local p_code=${1:-NULL};        # String    - Default : NULL    - Language in which the file must be translated.
    local p_print_code=${2:-yes}    # String    - Default : yes     - Authorization to print the ISO 639-1 code before the language name.

	#**** Code ****
      if [ "${p_code,,}" == 'aa' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Afar | Afaraf";
    elif [ "${p_code,,}" == 'ab' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Abkhazian | Аҧсуа";
    elif [ "${p_code,,}" == 'ae' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Avestan | Avesta";
    elif [ "${p_code,,}" == 'af' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Afrikaans | Afrikaans";
    elif [ "${p_code,,}" == 'ak' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Akan | Akan";
    elif [ "${p_code,,}" == 'am' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Amharic | አማርኛ";
    elif [ "${p_code,,}" == 'an' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Aragonese | Aragonés";
    elif [ "${p_code,,}" == 'ar' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Arabic | العربية";
	elif [ "${p_code,,}" == 'as' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Assamese | অসমীয়া";
	elif [ "${p_code,,}" == 'av' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Avaric | авар мацӀ ; магӀарул мацӀ";
	elif [ "${p_code,,}" == 'ay' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Aymara | Aymar aru";
	elif [ "${p_code,,}" == 'az' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Azerbaijani | Azərbaycan dili";
	elif [ "${p_code,,}" == 'ba' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bashkir | башҡорт теле";
	elif [ "${p_code,,}" == 'be' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Belarusian | Беларуская";
	elif [ "${p_code,,}" == 'bg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bulgarian | български език";
	elif [ "${p_code,,}" == 'bh' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bihari | भोजपुरी";
	elif [ "${p_code,,}" == 'bi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bislama | Bislama";
	elif [ "${p_code,,}" == 'bm' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bambara | Bamanankan";
	elif [ "${p_code,,}" == 'bn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bengali | বাংলা";
	elif [ "${p_code,,}" == 'bo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tibetan | བོད་ཡིག";
	elif [ "${p_code,,}" == 'br' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Breton | Brezhoneg";
	elif [ "${p_code,,}" == 'bs' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Bosnian | Bosanski jezik";
	elif [ "${p_code,,}" == 'ca' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Catalan | Català";
	elif [ "${p_code,,}" == 'ce' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Chechen | нохчийн мотт";
	elif [ "${p_code,,}" == 'ch' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Chamorro | Chamoru";
	elif [ "${p_code,,}" == 'co' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Corsican | Corsu ; lingua corsa";
	elif [ "${p_code,,}" == 'cr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Cree | ᓀᐦᐃᔭᐍᐏᐣ";
	elif [ "${p_code,,}" == 'cs' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Czech | Česky ; čeština";
	elif [ "${p_code,,}" == 'cu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Old Church Slavonic | Словѣньскъ";
	elif [ "${p_code,,}" == 'cv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Chuvash | чӑваш чӗлхи";
	elif [ "${p_code,,}" == 'cy' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Welsh | Cymraeg";
	elif [ "${p_code,,}" == 'da' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Danish | Dansk";
	elif [ "${p_code,,}" == 'de' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') German | Deutsch";
	elif [ "${p_code,,}" == 'dv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Divehi | ދިވެހި";
	elif [ "${p_code,,}" == 'dz' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Dzongkha | རྫོང་ཁ";
	elif [ "${p_code,,}" == 'ee' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ewe | Ɛʋɛgbɛ";
	elif [ "${p_code,,}" == 'el' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Greek | Ελληνικά";
	elif [ "${p_code,,}" == 'en' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') English | English";
	elif [ "${p_code,,}" == 'eo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Esperanto | Esperanto";
	elif [ "${p_code,,}" == 'es' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Spanish | Español";
	elif [ "${p_code,,}" == 'et' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Estonian | Eesti keel";
	elif [ "${p_code,,}" == 'eu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Basque | Euskara";
	elif [ "${p_code,,}" == 'fa' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Persian | فارسی";
	elif [ "${p_code,,}" == 'ff' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Fulah | Fulfulde";
	elif [ "${p_code,,}" == 'fi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Finnish | Suomen kieli";
	elif [ "${p_code,,}" == 'fj' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Fijian | Vosa Vakaviti";
	elif [ "${p_code,,}" == 'fo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Faroese | Føroyskt";
	elif [ "${p_code,,}" == 'fr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') French | Français";
	elif [ "${p_code,,}" == 'fy' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Western Frisian | Frysk";
	elif [ "${p_code,,}" == 'ga' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Irish | Gaeilge";
	elif [ "${p_code,,}" == 'gd' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Scottish Gaelic | Gàidhlig";
	elif [ "${p_code,,}" == 'gl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Galician | Galego";
	elif [ "${p_code,,}" == 'gn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Guarani | Avañe'ẽ";
	elif [ "${p_code,,}" == 'gu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Gujarati | ગુજરાતી";
	elif [ "${p_code,,}" == 'gv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Manx | Ghaelg";
	elif [ "${p_code,,}" == 'ha' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Hausa | هَوُسَ";
	elif [ "${p_code,,}" == 'he' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Hebrew | עברית";
	elif [ "${p_code,,}" == 'hi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Hindi | हिन्दी ; हिंदी";
	elif [ "${p_code,,}" == 'ho' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Hiri Motu | Hiri Motu";
	elif [ "${p_code,,}" == 'hr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Croatian | Hrvatski";
	elif [ "${p_code,,}" == 'ht' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Haitian | Kreyòl ayisyen";
	elif [ "${p_code,,}" == 'hu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Hungarian | magyar ";
	elif [ "${p_code,,}" == 'hy' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Armenian | Հայերեն";
	elif [ "${p_code,,}" == 'hz' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Herero | Otjiherero";
	elif [ "${p_code,,}" == 'ia' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Interlingua | Interlingua";
	elif [ "${p_code,,}" == 'id' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Indonesian | Bahasa Indonesia";
	elif [ "${p_code,,}" == 'ie' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Interlingue | Interlingue";
	elif [ "${p_code,,}" == 'ig' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Igbo | Igbo";
	elif [ "${p_code,,}" == 'ii' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sichuan Yi | ꆇꉙ";
	elif [ "${p_code,,}" == 'ik' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Inupiaq | Iñupiaq ; Iñupiatun";
	elif [ "${p_code,,}" == 'io' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ido | Ido";
	elif [ "${p_code,,}" == 'is' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Icelandic | Íslenska";
	elif [ "${p_code,,}" == 'it' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Italian | Italiano";
	elif [ "${p_code,,}" == 'iu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Inuktitut | ᐃᓄᒃᑎᑐᑦ";
	elif [ "${p_code,,}" == 'ja' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Japanese | 日本語 (にほんご)";
	elif [ "${p_code,,}" == 'jv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Javanese | Basa Jawa";
	elif [ "${p_code,,}" == 'ka' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Georgian | ქართული";
	elif [ "${p_code,,}" == 'kg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kongo | KiKongo";
	elif [ "${p_code,,}" == 'ki' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kikuyu | Gĩkũyũ";
	elif [ "${p_code,,}" == 'kj' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kwanyama | Kuanyama";
	elif [ "${p_code,,}" == 'kk' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kazakh | Қазақ тілі";
	elif [ "${p_code,,}" == 'kl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Greenlandic | Kalaallisut ; kalaallit oqaasii";
	elif [ "${p_code,,}" == 'km' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Khmer | ភាសាខ្មែរ";
	elif [ "${p_code,,}" == 'kn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kannada | ಕನ್ನಡ";
	elif [ "${p_code,,}" == 'ko' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Korean | 한국어 (韓國語) ; 조선말 (朝鮮語)";
	elif [ "${p_code,,}" == 'kr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kanuri | Kanuri";
	elif [ "${p_code,,}" == 'ks' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kashmiri | कश्मीरी ; كشميري";
	elif [ "${p_code,,}" == 'ku' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kurdish | Kurdî ; كوردی";
	elif [ "${p_code,,}" == 'kv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Komi | коми кыв";
	elif [ "${p_code,,}" == 'kw' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Cornish | Kernewek";
	elif [ "${p_code,,}" == 'ky' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kirghiz | кыргыз тили";
	elif [ "${p_code,,}" == 'la' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Latin | Latine ; lingua latina";
	elif [ "${p_code,,}" == 'lb' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Luxembourgish | Lëtzebuergesch";
	elif [ "${p_code,,}" == 'lg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ganda | Luganda";
	elif [ "${p_code,,}" == 'li' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Limburgish | Limburgs";
	elif [ "${p_code,,}" == 'ln' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Lingala | Lingála";
	elif [ "${p_code,,}" == 'lo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Lao | ພາສາລາວ";
	elif [ "${p_code,,}" == 'lt' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Lithuanian | Lietuvių kalba";
	elif [ "${p_code,,}" == 'lu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Luba | tshiluba";
	elif [ "${p_code,,}" == 'lv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Latvian | Latviešu valoda";
	elif [ "${p_code,,}" == 'mg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Malagasy | Fiteny malagasy";
	elif [ "${p_code,,}" == 'mh' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Marshallese | Kajin M̧ajeļ";
	elif [ "${p_code,,}" == 'mi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Māori | Te reo Māori";
	elif [ "${p_code,,}" == 'mk' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Macedonian | македонски јазик";
	elif [ "${p_code,,}" == 'ml' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Malayalam | മലയാളം";
	elif [ "${p_code,,}" == 'mn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Mongolian | Монгол";
	elif [ "${p_code,,}" == 'mo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Moldavian | лимба молдовеняскэ";
	elif [ "${p_code,,}" == 'mr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Marathi | मराठी";
	elif [ "${p_code,,}" == 'ms' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Malay | Bahasa Melayu ; بهاس ملايو";
	elif [ "${p_code,,}" == 'mt' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Maltese | Malti";
	elif [ "${p_code,,}" == 'my' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Burmese | ဗမာစာ";
	elif [ "${p_code,,}" == 'na' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Nauru | Ekakairũ Naoero";
	elif [ "${p_code,,}" == 'nb' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Norwegian Bokmål | Norsk bokmål";
	elif [ "${p_code,,}" == 'nd' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') North Ndebele | isiNdebele";
	elif [ "${p_code,,}" == 'ne' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Nepali | नेपाली";
	elif [ "${p_code,,}" == 'ng' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ndonga | Owambo";
	elif [ "${p_code,,}" == 'nl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Dutch | Nederlands";
	elif [ "${p_code,,}" == 'nn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Norwegian Nynorsk | Norsk nynorsk";
	elif [ "${p_code,,}" == 'no' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Norwegian | Norsk";
	elif [ "${p_code,,}" == 'nr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') South Ndebele | Ndébélé";
	elif [ "${p_code,,}" == 'nv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Navajo | Diné bizaad ; Dinékʼehǰí";
	elif [ "${p_code,,}" == 'ny' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Chichewa | ChiCheŵa ; chinyanja";
	elif [ "${p_code,,}" == 'oc' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Occitan | Occitan";
	elif [ "${p_code,,}" == 'oj' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ojibwa | ᐊᓂᔑᓈᐯᒧᐎᓐ";
	elif [ "${p_code,,}" == 'om' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Oromo | Afaan Oromoo";
	elif [ "${p_code,,}" == 'or' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Oriya | ଓଡ଼ିଆ";
	elif [ "${p_code,,}" == 'os' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ossetian | Ирон ӕвзаг";
	elif [ "${p_code,,}" == 'pa' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Panjabi | ਪੰਜਾਬੀ ; پنجابی";
	elif [ "${p_code,,}" == 'pi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Pāli | पािऴ";
	elif [ "${p_code,,}" == 'pl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Polish | Polski";
	elif [ "${p_code,,}" == 'ps' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Pashto | پښتو";
	elif [ "${p_code,,}" == 'pt' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Portuguese | Português";
	elif [ "${p_code,,}" == 'qu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Quechua | Runa Simi ; Kichwa";
	elif [ "${p_code,,}" == 'rc' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Reunionese | Kréol Rénioné";
	elif [ "${p_code,,}" == 'rm' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Romansh | Rumantsch grischun";
	elif [ "${p_code,,}" == 'rn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kirundi | kiRundi";
	elif [ "${p_code,,}" == 'ro' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Romanian | Română";
	elif [ "${p_code,,}" == 'ru' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Russian | русский язык";
	elif [ "${p_code,,}" == 'rw' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Kinyarwanda | Kinyarwanda";
	elif [ "${p_code,,}" == 'sa' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sanskrit | संस्कृतम्";
	elif [ "${p_code,,}" == 'sc' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sardinian | sardu";
	elif [ "${p_code,,}" == 'sd' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sindhi | सिन्धी ; سنڌي، سندھی";
	elif [ "${p_code,,}" == 'se' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Northern Sami | Davvisámegiella";
	elif [ "${p_code,,}" == 'sg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sango | Yângâ tî sängö";
	elif [ "${p_code,,}" == 'sh' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Serbo-Croatian | srpskohrvatski jezik ; српскохрватски језик";
	elif [ "${p_code,,}" == 'si' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sinhalese| සිංහල";
	elif [ "${p_code,,}" == 'sk' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Slovak | Slovenčina";
	elif [ "${p_code,,}" == 'sl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Slovenian | Slovenščina";
	elif [ "${p_code,,}" == 'sm' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Samoan | Gagana fa'a Samoa";
	elif [ "${p_code,,}" == 'sn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Shona | chiShona";
	elif [ "${p_code,,}" == 'so' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Somali | Soomaaliga ; af Soomaali";
	elif [ "${p_code,,}" == 'sq' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Albanian | Shqip ";
	elif [ "${p_code,,}" == 'sr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Serbian | српски језик";
	elif [ "${p_code,,}" == 'ss' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Swati| SiSwati";
	elif [ "${p_code,,}" == 'st' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sotho | seSotho";
	elif [ "${p_code,,}" == 'su' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Sundanese | Basa Sunda";
	elif [ "${p_code,,}" == 'sv' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Swedish | Svenska";
	elif [ "${p_code,,}" == 'sw' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Swahili | Kiswahili";
	elif [ "${p_code,,}" == 'ta' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tamil | தமிழ்";
	elif [ "${p_code,,}" == 'te' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Telugu | తెలుగు";
	elif [ "${p_code,,}" == 'tg' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tajik | тоҷикӣ ; toğikī ; تاجیکی";
	elif [ "${p_code,,}" == 'th' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Thai | ไทย";
	elif [ "${p_code,,}" == 'ti' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tigrinya | ትግርኛ";
	elif [ "${p_code,,}" == 'tk' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Turkmen | Türkmen ; Түркмен";
	elif [ "${p_code,,}" == 'tl' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tagalog | Tagalog";
	elif [ "${p_code,,}" == 'tn' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tswana | seTswana";
	elif [ "${p_code,,}" == 'to' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tonga | faka Tonga";
	elif [ "${p_code,,}" == 'tr' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Turkish | Türkçe";
	elif [ "${p_code,,}" == 'ts' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tsonga | xiTsonga";
	elif [ "${p_code,,}" == 'tt' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tatar | татарча ; tatarça ; تاتارچا";
	elif [ "${p_code,,}" == 'tw' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Twi | Twi";
	elif [ "${p_code,,}" == 'ty' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Tahitian | Reo Mā\`ohi";
	elif [ "${p_code,,}" == 'ug' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Uighur | Uyƣurqə ; ئۇيغۇرچ";
	elif [ "${p_code,,}" == 'uk' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Ukrainian | українська мова";
	elif [ "${p_code,,}" == 'ur' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Urdu | اردو";
	elif [ "${p_code,,}" == 'uz' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Uzbek | O'zbek ; Ўзбек ; أۇزبېك";
	elif [ "${p_code,,}" == 've' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Venda | tshiVenḓa";
	elif [ "${p_code,,}" == 'vi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Vietnamese | Tiếng Việt";
	elif [ "${p_code,,}" == 'vo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Volapük | Volapük";
	elif [ "${p_code,,}" == 'wa' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Walloon | Walon";
	elif [ "${p_code,,}" == 'wo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Wolof | Wollof";
	elif [ "${p_code,,}" == 'xh' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Xhosa | isiXhosa";
	elif [ "${p_code,,}" == 'yi' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Yiddish | ייִדיש";
	elif [ "${p_code,,}" == 'yo' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Yoruba | Yorùbá";
	elif [ "${p_code,,}" == 'za' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Zhuang | Saɯ cueŋƅ ; Saw cuengh";
	elif [ "${p_code,,}" == 'zh' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Chinese | 中文, 汉语, 漢語";
	elif [ "${p_code,,}" == 'zu' ]; then echo -n "$([ "${p_print_code,,}" == 'yes' ] && printf "%s :" "${p_code,,}" || printf '') Zulu | isiZulu";
	  fi;

	return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : OS.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       : beta

# ------------------
# FILE DESCRIPTION :

# Operating systems types and versions management.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### ANDROID
#### DEBUG ID : "os::android"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__ANDROID="os::android";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__ANDROID__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__ANDROID}::checking-informations";

# Checking if current OS is Android, running with the Termux terminal emulator.
function BU.Main.OS.IsAndroidTermux()               { if [[ "${OSTYPE}" == 'linux-android' ]];                          then    return 0; else  return 1; fi }

# Checking the current Android version.
function BU.Main.OS.IsAndroid4()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid5()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid6()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid7()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid8()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid9()                    { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid10()                   { BU.Main.OS.IsAndroidTermux && return 0; return 1; }
function BU.Main.OS.IsAndroid11()                   { BU.Main.OS.IsAndroidTermux && return 0; return 1; }

# Checking if the current Android device is a smartphone.
function BU.Main.OS.IsAndroidDeviceSmartphone()     { return 0; }

# Checking if the current Android device is a Tablet.
function BU.Main.OS.IsAndroidDeviceTablet()         { return 0; }

# Checking if the Android device is rooted.
function BU.Main.OS.IsAndroidRooted()               { return 0; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__ANDROID__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__ANDROID}::gathering-informations";

# Getting the Android device model.
function BU.Main.OS.GetAndroidDevice()
{
    return 0;
}

# Getting the Android operating system version.
function BU.Main.OS.GetAndroidVersion()
{
    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BSD (GENERAL)
#### DEBUG ID : "os::bsd"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__BSD="os::bsd";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__BSD__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__BSD}::checking-informations";

# Checking if the current OS is BSD (general types).
function BU.Main.OS.IsBSD()                         { if BU.Main.OS.IsFreeBSD || BU.Main.OS.IsNetBSD || BU.Main.OS.IsOpenBSD; then return 0; else return 1; fi }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__BSD__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__BSD}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BSD (FREE BSD)
#### DEBUG ID : "os::free-bsd"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__FREE_BSD="os::free-bsd";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__FREE_BSD__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__FREE_BSD}::checking-informations";

# Checking if current OS is FreeBSD.
function BU.Main.OS.IsFreeBSD()                   	{ if [[ "${OSTYPE}" == 'FreeBSD' ]];                                then    return 0; else  return 1; fi }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__FREE_BSD__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__FREE_BSD}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BSD (NET BSD)
#### DEBUG ID : "os::free-bsd"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__NET_BSD="os::net-bsd";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__NET_BSD__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__NET_BSD}::checking-informations";

# Checking if current OS is NetBSD.
function BU.Main.OS.IsNetBSD()                    	{ if [[ "${OSTYPE}" == '' ]];                                       then    return 0; else  return 1; fi }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__NET_BSD__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__NET_BSD}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BSD (OPEN BSD)
#### DEBUG ID : "os::open-bsd"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OPEN_BSD="os::open-bsd";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-information

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__OPEN_BSD__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OPEN_BSD}::checking-informations";

# Checking if current OS is OpenBSD.
function BU.Main.OS.IsOpenBSD()                   	{ if [[ "${OSTYPE}" == 'openbsd'* ]];                               then    return 0; else  return 1; fi }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__OPEN_BSD__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OPEN_BSD}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CHROME OS
#### DEBUG ID : "os::chrome"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__CHROME_OS="os::chrome";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__CHROME_OS__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__CHROME_OS}::checking-informations";

# Checking if current OS is Chrome OS.
function BU.Main.OS.IsChromeOS()					{ true; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__CHROME_OS__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__CHROME_OS}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### HAIKU
#### DEBUG ID : "os::haiku"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__HAIKU="os::haiku";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__HAIKU__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__HAIKU}::checking-informations";

# Checking if current OS is Haiku OS.
function BU.Main.OS.IsHaiku()                     	{ if [[ "${OSTYPE}" == 'haiku' ]];                                  then    return 0; else  return 1; fi }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__HAIKU__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__HAIKU}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### GENERAL OS FUNCTIONS
#### DEBUG ID : "os::general-os-functions"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__GENERAL_OS_FNCT="os::general-os-functions";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__GENERAL_OS_FNCT__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__GENERAL_OS_FNCT}::checking-informations";

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__GENERAL_OS_FNCT__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__GENERAL_OS_FNCT}::gathering-informations";

# Checking the current operating system, by using the functions declared above.
function BU.Main.OS.GetCurrentOS()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the Fedoramain script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__GENERAL_OS_FNCT}" "${__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__GENERAL_OS_FNCT__GATHERING_INFORMATIONS}";

    #**** Code ****
    BU.Main.OS.IsAndroidTermux        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
	BU.Main.OS.IsChromeOS				&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsFreeBSD              	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsHaiku                	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsOpenBSD             	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsLinux                	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsLinuxWSLWin10        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsLinuxWSLWin11        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsLinuxWSL             	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsNetBSD               	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsOSX                    && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsWindows10            	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
    BU.Main.OS.IsWindows11            	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

    # Return an error code if the OS is not supported.
    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

    return 1;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINUX
#### DEBUG ID : os::linux

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__LINUX="os::linux";

## SPECIFIC OS VERSIONS CHECKINGS FUNCTIONS
## DEBUG ID : specific-os-versions-checkings

## CHECKING INFORMATIONS
## DEBUG ID :

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__LINUX__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__LINUX}::checking-informations";

# Checking the name of the currently used Linux distribution.
function BU.Main.OS.CheckLinuxDistro()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__LINUX}" "${__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__LINUX__CHECKING_INFORMATIONS}";

    #**** Parameters ****
    local v_distro=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the Linux distribution.

    #**** Code ****

    BU.Main.OS.IsLinux && {
        if [ -n "${v_distro}" ]; then                      	if BU.Main.OS.GetLinuxDistro "${v_distro}"; then return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi

        else
            BU.Main.OS.IsLinuxDistroArchLinux             	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            BU.Main.OS.IsLinuxDistroDebian                	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            BU.Main.OS.IsLinuxDistroFedora                	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            BU.Main.OS.IsLinuxDistroLinuxMint             	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            BU.Main.OS.IsLinuxDistroManjaro               	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            BU.Main.OS.IsLinuxDistroUbuntu                	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

            # Returning an error code if the distribution is not found.
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return 1;
        fi
    }
}

# Checking the version of the currently used Linux distribution.
function BU.Main.OS.CheckLinuxDistroVersion()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__LINUX}" "${__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__LINUX__CHECKING_INFORMATIONS}";

    #**** Parameters ****
	local p_distro=${1:-$'\0'};     # ARG TYPE : String         - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the Linux distribution.
    local p_version=${2:-$'\0'};    # ARG TYPE : Int | String   - REQUIRED | DEFAULT VAL : NULL     - DESC : Linux distribution's version (can be an integer or a string (like 'Focal Fossa' for Ubuntu 20.04)).

    #**** Code ****
    BU.Main.OS.IsLinux && {
        if [ -n "${p_distro}" ] && [ -n "${p_version}" ]; then
            if BU.Main.OS.GetLinuxDistro "${p_distro}"      	&& BU.Main.OS.GetLinuxDistroVersion "${p_version}"; then return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi

        else
            BU.Main.OS.IsLinuxDistroDebian && {
                BU.Main.OS.IsLinuxDistroDebian5             && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian6             && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian7             && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian8             && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian9             && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian10            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroDebian11            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
            }

            BU.Main.OS.IsLinuxDistroFedora && {
                BU.Main.OS.IsLinuxDistroFedora18            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora19            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora20            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora21            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora22            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora23            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora24            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora25            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora26            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora27            && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora28          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora29          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora30          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora31          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora32          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora33          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora34          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora35          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroFedora36          	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

                # Returning an error code if the specific version is not found.
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                return 1;
            }

            BU.Main.OS.IsLinuxDistroUbuntu && {
                BU.Main.OS.IsLinuxDistroUbuntu10_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu10_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu11_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu11_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu12_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu12_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu13_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu13_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu14_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu14_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu15_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu15_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu16_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu16_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu17_04         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu17_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu18_04        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu18_10        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu19_04        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu19_10        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu20_04        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu20_10        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu21_04        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu21_10        	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu22_04       	&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
                BU.Main.OS.IsLinuxDistroUbuntu22_10         && { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

                # Returning an error code if the specific version is not found.
                BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

                return 1;
            }

            # Returning an error code if the distribution is not found.
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return 1;
        fi
    }
}

# Checking the major version of the Kernel of the currently used Linux distribution
function BU.Main.OS.CheckLinuxKernelMajorVersion() { return 0; }

# Checking the minor version of the Kernel of the currently used Linux distribution
function BU.Main.OS.CheckLinuxKernelMinorVersion() { return 0; }

# Checking the version of the Kernel of the currently used Linux distribution.
function BU.Main.OS.CheckLinuxKernelVersion() { return 0; }

# Checking if current OS is Linux (or Android without the Termux terminal emulator).
function BU.Main.OS.IsLinux()                           { [[ "${OSTYPE}" == 'linux'* ]]                             &&      return 0;       return 1; }

# Checking if current Linux distribuion is Arch Linux.
function BU.Main.OS.IsLinuxDistroArchLinux()          	{ BU.Main.OS.GetLinuxDistro ARCH                            &&      return 0;       return 1; }

# Checking Arch Linux versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).


# --------------------
# Checking if current Linux distribution is Debian.
function BU.Main.OS.IsLinuxDistroDebian()             	{ BU.Main.OS.GetLinuxDistro debian                          &&      return 0;       return 1; }

# Checking debian versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).
function BU.Main.OS.IsLinuxDistroDebian4()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '4'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian5()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '5'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian6()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '6'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian7()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '7'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian8()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '8'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian9()            	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '9'           &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian10()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '10'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroDebian11()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Debian' '11'          &&      return 0;       return 1; }


# --------------------
# Checking if current Linux distribution is Fedora.
function BU.Main.OS.IsLinuxDistroFedora()             	{ BU.Main.OS.GetLinuxDistro Fedora                          &&      return 0;       return 1; }

# Checking Fedora versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).
function BU.Main.OS.IsLinuxDistroFedora18()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '18'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora19()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '19'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora20()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '20'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora21()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '21'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora22()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '22'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora23()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '23'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora24()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '24'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora25()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '25'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora26()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '26'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora27()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '27'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora28()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '28'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora29()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '29'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora30()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '30'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora31()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '31'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora32()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '32'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora33()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '33'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora34()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '34'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora35()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '35'          &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroFedora36()           	{ BU.Main.OS.CheckLinuxDistroVersion 'Fedora' '36'          &&      return 0;       return 1; }


# --------------------
# Checking if current Linux distribution is Manjaro.
function BU.Main.OS.IsLinuxDistroManjaro()           	{ BU.Main.OS.GetLinuxDistro Manjaro                       	&&      return 0;       return 1; }

# Checking Manjaro versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).


# --------------------
# Checking if current Linux distribution is Linux Mint.
function BU.Main.OS.IsLinuxDistroLinuxMint()          	{ BU.Main.OS.GetLinuxDistro ''                              &&      return 0;       return 1; }

# Checking Linux Mint versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).


# --------------------
# Checking if current Linux distribution is SUSE.
function BU.Main.OS.IsLinuxDistroSUSE()               	{ BU.Main.OS.GetLinuxDistro ''                              &&      return 0;       return 1; }

# Checking SUSE versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop)


# --------------------
# Checking if current Linux distribution is Ubuntu.
function BU.Main.OS.IsLinuxDistroUbuntu()             	{ BU.Main.OS.GetLinuxDistro Ubuntu                          &&      return 0;       return 1; }

# Checking Ubuntu versions (WARNING : verify that you correctly pass the second mandatory argument, or else the script will be stuck in an infinite loop).
function BU.Main.OS.IsLinuxDistroUbuntu10_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '10.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu10_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '10.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu11_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '11.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu11_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '11.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu12_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '12.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu12_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '12.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu13_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '13.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu13_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '13.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu14_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '14.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu14_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '14.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu15_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '15.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu15_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '15.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu16_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '16.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu16_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '16.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu17_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '17.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu17_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '17.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu18_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '18.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu18_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '18.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu19_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '19.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu19_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '19.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu20_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '20.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu20_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '20.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu21_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '21.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu21_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '21.10'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu22_04()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '22.04'       &&      return 0;       return 1; }
function BU.Main.OS.IsLinuxDistroUbuntu22_10()         	{ BU.Main.OS.CheckLinuxDistroVersion 'Ubuntu' '22.10'       &&      return 0;       return 1; }

# --------------------

# Checking the current major Linux kernel version.
function BU.Main.OS.IsLinuxKernelMajor3()               { return 0; }
function BU.Main.OS.IsLinuxKernelMajor4()               { return 0; }
function BU.Main.OS.IsLinuxKernelMajor5()               { return 0; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__LINUX__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__LINUX}::gathering-informations";

# Getting the name of the currently used Linux distribution, by reading the content of the "/proc/version" file on Linux.
function BU.Main.OS.GetLinuxDistro()
{
    #**** Parameters ****
    local v_distro=${1:-NULL}; # ARG TYPE : String      - REQUIRED | DEFAULT VAL : NULL     - DESC : Linux distribution's version (can be an integer or a string (like 'Focal Fossa' for Ubuntu 20.04)).

    #**** Code ****
    if BU.Main.OS.IsLinux; then [ -r /proc/version ] && {
            local X;

            X="$(cat '/proc/version')";

            echo "${X}" | grep -qi "${v_distro}" || return 1;

            return 0;
        };

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Warning "${FUNCNAME[0]}") : Unable to find or to read the $(BU.Main.Decho.Decho.Path '/proc/version') file";
        BU.Main.Echo.Newline;

        BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        return 1;
    else
        return 1;
    fi
}

# Getting the name of the currently used Linux distribution, by reading the content of the "/proc/version" file on Linux.
function BU.Main.OS.GetLinuxDistroVersion()
{
    BU.Main.OS.GetLinuxDistro "${1}" || return 1; return 0;
}

# Getting the major version of the Kernel of the currently used Linux distribution
function BU.Main.OS.GetLinuxKernelMajorVersion()
{
    #**** Parameters ****
    local v_major=${1:-NULL}; # ARG TYPE : Int   - REQUIRED | DEFAULT VAL : NULL    - DESC : Linux kernel's major version.

    #**** Code ****
    if BU.Main.OS.IsLinux; then [ -r /proc/version ] && {
            local X;

            X="$(cat '/proc/version')";

            echo "${X}" | grep -qi "${v_major}" || return 1;

            return 0;
        };

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Warning "${FUNCNAME[0]}") : Unable to find or to read the $(BU.Main.Decho.Decho.Path '/proc/version') file";
        BU.Main.Echo.Newline;

        BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        return 1;
    else
        return 1;
    fi
}

# Getting the minor version of the Kernel of the currently used Linux distribution
function BU.Main.OS.GetLinuxKernelMinorVersion()
{
    #**** Parameters ****
    local v_minor=${1:-NULL}; # ARG TYPE : Int      - REQUIRED | DEFAULT VAL : NULL     - DESC : Linux kernel's minor version.

    #**** Code ****
    if BU.Main.OS.IsLinux; then [ -r /proc/version ] && {
            local X;

            X="$(cat '/proc/version')";

            echo "${X}" | grep -qi "${v_minor}" || return 1;

            return 0;
        };

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Warning "${FUNCNAME[0]}") : Unable to find or to read the $(BU.Main.Decho.Decho.Path '/proc/version') file";
        BU.Main.Echo.Newline;

        BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        return 1;
    else
        return 1;
    fi
}

# Getting the version of the Kernel of the currently used Linux distribution by reading the content of the "/proc/version" file on Linux.
function BU.Main.OS.GetLinuxKernelVersion()
{
    #**** Parameters ****
    local v_kernelVer=${1:-NULL}; # ARG TYPE : Int | String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Linux kernel's version (can be passed like this : '5.15.0-53', or this : '5.15.0-53-generic').

    #**** Code ****
    if BU.Main.OS.IsLinux; then [ -r /proc/version ] && {
            local X;

            X="$(cat '/proc/version')";

            echo "${X}" | grep -qi "${v_kernelVer}" || return 1;

            return 0;
        };

        BU.Main.Status.ChangeSTAT_ECHO "true" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Warning "${FUNCNAME[0]}") : Unable to find or to read the $(BU.Main.Decho.Decho.Path '/proc/version') file";
        BU.Main.Echo.Newline;

        BU.Main.Status.ChangeSTAT_ECHO "false" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";

        return 1;
    else
        return 1;
    fi
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### OSX
#### DEBUG ID : "os::osx"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OSX="os::osx";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__OSX__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OSX}::checking-informations";

# Checking the version of the currently used OS X operating system.
function BU.Main.OS.CheckOSXVersion()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OSX}" "${__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__OSX__CHECKING_INFORMATIONS}";

	#**** Parameters ****
    local p_version=${1:-$'\0'}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : OS X version (can be an integer or a string (like 'Yosemite' for Mac OS X 10.10)).

	#**** Code ****
	BU.Main.OS.IsOSX && {
		# TODO : Manage the dots between the major and the minor versions.
		if [ -n "${p_version}" ]; then if BU.Main.Checkings.IsInt "${p_version}"; then sw_vers | grep -q "${p_version}"; return 0; fi;

		else
			BU.Main.OS.IsOSXMavericks					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXYosemite					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXElCapitan					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXSierra						&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXHighSierra					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXMojave						&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXCatalina					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXBigSur						&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }
			BU.Main.OS.IsOSXMonterey					&& { BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

            # Returning an error code if the specific version is not found.
            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

            return 1;
		fi
	}
}

# Checking if current OS is OSx.
function BU.Main.OS.IsOSX()                             { if [[ "${OSTYPE}" == 'darwin'* ]];                                    then return 0; else return 1; fi;                    }

# Checking OSX versions.
function BU.Main.OS.IsOSXMavericks()					{ if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.9; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXYosemite()                    	{ if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.10; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXElCapitan()                    { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.11; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXSierra()                       { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.12; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXHighSierra()                   { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.13; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXMojave()                       { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.14; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXCatalina()                     { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 10.15; 	then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXBigSur() 	                    { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 11;		then return 0; else return 1; fi; else return 1; fi; }
function BU.Main.OS.IsOSXMonterey()                     { if command -v sw_vers > /dev/null; then if sw_vers | grep -q 12;		then return 0; else return 1; fi; else return 1; fi; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__OSX__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__OSX}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### VIRTUAL MACHINES
#### DEBUG ID : "os::vms"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__VMS="os::vms";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__VMS__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__VMS}::checking-informations";

# Checking if the system is running in Qemu()
function BU.Main.OS.IsRunningInQemu()               { true; }

# Checking if the system is running in VMware.
function BU.Main.OS.IsRunningInVMware()             { if dmesg | grep -i VMware     > /dev/null; then return 0; else return 1; fi; }

# Checking if the system is running in VirtualBox.
function BU.Main.OS.IsRunningInVirtualBox()         { if dmesg | grep -i VirtualBox > /dev/null; then return 0; else return 1; fi; }

# Checking if the system is running in a virtual machine.
function BU.Main.OS.IsVirtualized()                 { true; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__VMS__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__VMS}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### WINDOWS
#### DEBUG ID : "os::windows"

__BU_MAIN_OS_LIB__CAT_DEBUG_ID__WINDOWS="os::windows";

## CHECKING INFORMATIONS
## DEBUG ID : "checking-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__WINDOWS__CHECKING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__WINDOWS}::checking-informations";

# Checking the Microsoft Windows version.
function BU.Main.Checkings.CheckOSWindowsVersion()
{
    #**** Parameters ****
    local p_versionNumber=${1:-NULL};   # Int       - Default : NULL    - Microsoft Windows operating system's version number.

    #**** Code ****
    if [ -z "${__BU_MAIN_OS_LIB__WINDOWS_MAJOR_VERSION_NUMBER}" ]; then __BU_MAIN_OS_LIB__WINDOWS_MAJOR_VERSION_NUMBER="$(if command -v powershell.exe > /dev/null; then powershell.exe '[System.Environment]OSVersion.Version' | awk 'FNR == 4 {print $1}'; fi)"; fi

    if [ "${p_versionNumber}" -eq "${__BU_MAIN_OS_LIB__WINDOWS_MAJOR_VERSION_NUMBER}" ]; then return 0; else return 1; fi
}

# Checking if the current Windows' architecture is 32 bits.
function BU.Main.OS.IsWindows32bits()					{ if command -v powershell.exe > /dev/null; then if powershell.exe '(Get-WmiObject Win32_OperatingSystem).OSArchitecture' | grep -q 32; then return 0; else return 1; fi else return 1; fi; }

# Checking if the current Windows' architecture is 64 bits.
function BU.Main.OS.IsWindows64bits()					{ if command -v powershell.exe > /dev/null; then if powershell.exe '(Get-WmiObject Win32_OperatingSystem).OSArchitecture' | grep -q 64; then return 0; else return 1; fi else return 1; fi; }

# Checking if the current Windows licence is the Family licence.
function BU.Main.OS.IsWindowsFamily()					{ if BU.Main.OS.IsWindows10Family   || BU.Main.OS.IsWindows11Family;                        then    return 0; else  return 1; fi; }

# Checking if the current Windows licence is the Professionnal licence.
function BU.Main.OS.IsWindowsPro()						{ if BU.Main.OS.IsWindows10Pro      || BU.Main.OS.IsWindows11Pro;                           then    return 0; else  return 1; fi; }

# Checking if the current Windows licence is the Enterprise licence.
function BU.Main.OS.IsWindowsLTSC() 					{ if BU.Main.OS.IsWindows10LTSC     || BU.Main.OS.IsWindows11LTSC;                          then    return 0; else  return 1; fi; }

# Checking if the currently used version of Windows is the 10th version.
function BU.Main.OS.IsWindows10()                    	{ if BU.Main.Checkings.CheckOSWindowsVersion '10';          								then    return 0; else  return 1; fi; }

# Checking if the currently used version of Windows is the Windows 10 Family version.
function BU.Main.OS.IsWindows10Family()					{ if BU.Main.Checkings.CheckOSWindowsVersion '10' 			&& BU.Main.OS.IsWindowsFamily;	then 	return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the Windows 10 Professionnal version.
function BU.Main.OS.IsWindows10Pro()					{ if BU.Main.Checkings.CheckOSWindowsVersion '10' 			&& BU.Main.OS.IsWindowsPro;		then 	return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the Windows 10 LTSC version.
function BU.Main.OS.IsWindows10LTSC()					{ if BU.Main.Checkings.CheckOSWindowsVersion '10' 			&& BU.Main.OS.IsWindowsLTSC;	then 	return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the 11th.
function BU.Main.OS.IsWindows11()                     	{ if BU.Main.Checkings.CheckOSWindowsVersion '11';          								then    return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the Windows 11 Family version.
function BU.Main.OS.IsWindows11Family()					{ if BU.Main.Checkings.CheckOSWindowsVersion '11' 			&& BU.Main.OS.IsWindowsFamily;	then 	return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the Windows 11 Professionnal version.
function BU.Main.OS.IsWindows11Pro()					{ if BU.Main.Checkings.CheckOSWindowsVersion '11' 			&& BU.Main.OS.IsWindowsPro;		then 	return 0; else 	return 1; fi; }

# Checking if the currently used version of Windows is the Windows 11 LTSC version.
function BU.Main.OS.IsWindows11LTSC()					{ if BU.Main.Checkings.CheckOSWindowsVersion '11' 			&& BU.Main.OS.IsWindowsLTSC;	then 	return 0; else 	return 1; fi; }

# Checking if current OS is a Linux distribution running on Windows Subsystem for Linux, on any Windows version.
function BU.Main.OS.IsLinuxWSL()                        { if [[ "$(< /proc/sys/kernel/osrelease)" == *[M-m]icrosoft* ]];    						then    return 0; else  return 1; fi; }

# Checking if current OS is a Linux distribution running on Windows Subsystem for Linux version 1, on any Windows version (WARNING : here, the 'M' from the "Microsoft" string MUST be in uppercase, as the 'm' in lower case is form the WSL version 2).
function BU.Main.OS.IsLinuxWSL1()                     	{ uname -r | grep Microsoft                                 &&      								return 0;       return 1; }

# Checking if current OS is a Linux distribution running on Windows Subsystem for Linux version 2, on any Windows version (WARNING : here, the 'm' from the "microsoft" string MUST be in lowercase, as the 'M' in upper case is form the WSL version 1).
function BU.Main.OS.IsLinuxWSL2()                     	{ uname -r | grep microsoft                                 &&      								return 0;       return 1; }

# -----------------------------------------------

## GATHERING INFORMATIONS
## DEBUG ID : "gathering-informations"

__BU_MAIN_OS_LIB__SUBCAT_DEBUG_ID__WINDOWS__GATHERING_INFORMATIONS="${__BU_MAIN_OS_LIB__CAT_DEBUG_ID__WINDOWS}::gathering-informations";

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Terminal.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# Functions specially made for POSIX terminal interaction.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TERMINAL INTERACTION FUNCTIONS
#### DEBUG ID : "posixterm::terminal-interaction-functions"

__BU_MAIN_POSIXTERM_LIB__CAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS="posixterm::terminal-interaction-functions";

## DISPLAYING TEXT AND MORE WHILE A TASK IS ONGOING
## DEBUG ID : "displaying-text-and-more-while-a-task-is-ongoing"

__BU_MAIN_POSIXTERM_LIB__SUBCAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS__DISPLAYING_TEXT_AND_MORE_WHILE_A_TASK_IS_ONGOIG="${__BU_MAIN_POSIXTERM_LIB__CAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS}::displaying-text-and-more-while-a-task-is-ongoing";

# Display a countdown while a task is ongoing.
function BU.Main.PosixTerm.DisplayCountdown()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_POSIXTERM_LIB__CAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS}" \
        "${__BU_MAIN_POSIXTERM_LIB__SUBCAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS__DISPLAYING_TEXT_AND_MORE_WHILE_A_TASK_IS_ONGOIG}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Display a progress bar while a task is ongoing.
function BU.Main.PosixTerm.DisplayProgressBar()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_POSIXTERM_LIB__CAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS}" \
        "${__BU_MAIN_POSIXTERM_LIB__SUBCAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS__DISPLAYING_TEXT_AND_MORE_WHILE_A_TASK_IS_ONGOIG}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Display a spinner while a task is ongoing.
function BU.Main.PosixTerm.DisplaySpinner()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_POSIXTERM_LIB__CAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS}" \
        "${__BU_MAIN_POSIXTERM_LIB__SUBCAT_DEBUG_ID__TERMINAL_INTERACTION_FUNCTIONS__DISPLAYING_TEXT_AND_MORE_WHILE_A_TASK_IS_ONGOIG}";

    #**** Parameters ****
    p_string=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC :
    # p_countdown=${2:-$'\0'};  # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC :
    p_pid=${3:-$'\0'};          # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Variables ****
    i=1;
    sp="/-\|";

    #**** Code ****
    echo -n ' ';

    BU.Main.Echo.Msg "${__BU_MAIN_TXT_TAB} ${p_string}";

    while [ -d "/proc/${p_pid}" ]; do
        printf "%s" "\b${sp:i++%${#sp}:1}";
    done

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : CheckSTAT.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### VARIABLES VALUES FUNCTIONS
#### DEBUG ID : "status::variables-values-functions"

__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS="status::variables-values-functions";

## CHECKING VALUES
## DEBUG ID : "checking-values"

__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKING_VALUES="${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}::checking-values";

# Easy writing text function.
function BU.Main.Status.ConfEcho()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKING_VALUES}";

    #**** Parameters ****
    local p_module=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called (mainly from the "BU.Main.StatusCheckSTAT<...>()" functions).
    local p_file=${2:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called (mainly from the "BU.Main.StatusCheckSTAT<...>()" functions).
    local p_lineno=${3:-$'\0'};         # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called (mainly from the "BU.Main.StatusCheckSTAT<...>()" functions).
    local p_bad_value=${4:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Bad value passed as "BU.Main.StatusCheckSTAT<...>()" function's argument.
    local p_var_name=${5:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Name of the variable that stores the bad value.

    # Shifting the same number of time as the former arguments number
    # to avoid including these arguments values in the allowed values array.
    shift 4;
    local pa_correctValues=("${@}");    # ARG TYPE : Array      - REQUIRED | DEFAULT VAL : NULL     - DESC : Array of correct values for the processed status global variable.

    #**** Variables ****
    local i=0;      # VAR TYPE : Int    - DESC : Values counter.

    #**** Code ****
    # Sourcing the "Status.conf" file to reset every status global variables values
    BU.Main.Files.SourceFile "${__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH}";

    # Setting the "${__BU_MAIN_STAT_DECHO}" status global variable to "allow" in order to display correctly the formatted text.
    __BU_MAIN_STAT_DECHO='allow';

    # Since the "${__BU_MAIN_STAT_ECHO}" status global variable is reset to "true", it's totally safe to call an "Echo<...>()" function here.
    if [ -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
        {
			BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}";

			BU.Main.Echo.Error "AN ERROR OCCURED DURING THIS STATUS VARIABLE CHECKING --> ${p_var_name}    |    VALUE : ${p_bad_value} !!!";

			BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}";
		} 2>&1 | tee -a "${__BU_MAIN_PROJECT_LOG_FILE_PATH}";

    else
        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}";

        BU.Main.Echo.Error "AN ERROR OCCURED DURING A STATUS VARIABLE CHECKING !!!";

        BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_ERROR}";
    fi

    BU.Main.Echo.Error "In $(BU.Main.Decho.Decho.Highlight "${p_module}") module, $(BU.Main.Decho.Decho.Path "${p_file}") file, line $(BU.Main.Decho.Decho.Highlight "${p_lineno}") --> " '-n' >&2;
    BU.Main.Echo.Error "Error : the $(BU.Main.Decho.Decho.Var "${p_var_name}") variable's value is incorrect." >&2;

    if [ -z "${p_bad_value}" ]; then
        echo >&2; BU.Main.Echo.Error "Bad value : $(BU.Main.Decho.Yellow 'An empty string')." >&2;
    else
        echo >&2; BU.Main.Echo.Error "Bad value : $(BU.Main.Decho.Decho.Var "${p_bad_value}")." >&2;
    fi

    echo >&2; BU.Main.Echo.Error "The allowed values are :" >&2;

    # Displaying the list of every allowed arguments.
    for val in "${pa_correctValues[@]}"; do
        i=$(( i + 1 ));

        # If an empty argument is allowed.
        if [ -z "${val}" ]; then
            BU.Main.Echo.Error "${i}/${#pa_correctValues[@]}   --> $(BU.Main.Decho.Decho.Var 'An empty argument')" >&2;
        else
            BU.Main.Echo.Error "${i}/${#pa_correctValues[@]}   --> $(BU.Main.Decho.Decho.Highlight "${val}")" >&2;
        fi
    done

    echo >&2; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; exit 1;
}

# -----------------------------------------------

## CHECKINGS
## DEBUG ID : "checkings"

__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS="${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}::checkings";

# Check the "${__BU_MAIN_STAT_DECHO}" status variable's value.
function BU.Main.Status.CheckSTAT_DECHO()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("authorize" "forbid" "restrict"); # VAR TYPE : Array            - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ "${__BU_MAIN_STAT_DECHO,,}" != "authorize" ] && [ "${__BU_MAIN_STAT_DECHO,,}" != "forbid" ] && [ "${__BU_MAIN_STAT_DECHO,,}" != "restrict" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_DECHO}" "__BU_MAIN_STAT_DECHO" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Check the "${__BU_MAIN_STAT_ECHO}" status variable's value.
function BU.Main.Status.CheckSTAT_ECHO()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("true" "false"); # VAR TYPE : Array                             - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ "${__BU_MAIN_STAT_ECHO,,}" != "true" ] && [ "${__BU_MAIN_STAT_ECHO,,}" != "false" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_ECHO}" "__BU_MAIN_STAT_ECHO" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_ERROR}" status variable's value.
function BU.Main.Status.CheckSTAT_ERROR()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("" "fatal" "warning"); # VAR TYPE : Array                       - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ -n "${__BU_MAIN_STAT_ERROR}" ] && [ "${__BU_MAIN_STAT_ERROR,,}" != "fatal" ] && [ "${__BU_MAIN_STAT_ERROR,,}" != "warning" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_ERROR}" "__BU_MAIN_STAT_ERROR" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_INITIALIZING}" status variable's value.
function BU.Main.Status.CheckSTAT_INITIALIZING()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("true" "false"); # VAR TYPE : Array                             - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ "${__BU_MAIN_STAT_INITIALIZING,,}" != "true" ] && [ "${__BU_MAIN_STAT_INITIALIZING,,}" != "false" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_INITIALIZING}" "__BU_MAIN_STAT_INITIALIZING" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_LOG}" status variable's value.
function BU.Main.Status.CheckSTAT_LOG()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("true" "false"); # VAR TYPE : Array                             - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ "${__BU_MAIN_STAT_LOG,,}" != "true" ] && [ "${__BU_MAIN_STAT_LOG,,}" != "false" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_LOG}" "__BU_MAIN_STAT_LOG" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";

    elif [ "${__BU_MAIN_STAT_LOG,,}" == "true" ] && [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
        BU.Main.Files.CreateProjectLogFile || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_LOG_REDIRECT}" status variable's value.
function BU.Main.Status.CheckSTAT_LOG_REDIRECT()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("" "log" "tee"); # VAR TYPE : Array                             - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ -n "${__BU_MAIN_STAT_LOG_REDIRECT}" ] && [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" != 'log' ] && [ "${__BU_MAIN_STAT_LOG_REDIRECT,,}" != 'tee' ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_LOG_REDIRECT}" "__BU_MAIN_STAT_LOG_REDIRECT" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_OPERATE_ROOT}" status variable's value.
function BU.Main.Status.CheckSTAT_OPERATE_ROOT()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

	#**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

	#**** Variables ****
	local va_correctValues=("authorized" "forbidden" "restricted"); # VAR TYPE : Array      - DESC : Array of correct values for this global status variable.

	#**** Code ****
	if [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" != "authorized" ] && [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" != "forbidden" ] && [ "${__BU_MAIN_STAT_OPERATE_ROOT,,}" != "restricted" ]; then
		BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_OPERATE_ROOT}" "__BU_MAIN_STAT_OPERATE_ROOT" "${va_correctValues[@]}";

		local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
	fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_TIME_HEADER}" status variable's value.
function BU.Main.Status.CheckSTAT_TIME_HEADER()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("${__BU_MAIN_COLOR_TXT_VAR}An integer or a floating number"); # VAR TYPE : Array | DESC : Array of correct values for this global status variable.

    #**** Code ****
    # If the status variable's value is not a float or an integer.
    if ! BU.Main.Checkings.IsFloat "${__BU_MAIN_STAT_TIME_HEADER}"; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_TIME_HEADER}" "__BU_MAIN_STAT_TIME_HEADER" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_TIME_NEWLINE}" status variable's value.
function BU.Main.Status.CheckSTAT_TIME_NEWLINE()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("${__BU_MAIN_COLOR_TXT_VAR}An integer or a floating number"); # VAR TYPE : Array | DESC : Array of correct values for this global status variable.

    #**** Code ****
    # If the status variable's value is not a float or an integer.
    if ! BU.Main.Checkings.IsFloat "${__BU_MAIN_STAT_TIME_HEADER}"; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_TIME_NEWLINE}" "__BU_MAIN_STAT_TIME_NEWLINE" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_TIME_TXT}" status variable's value.
function BU.Main.Status.CheckSTAT_TIME_TXT()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("${__BU_MAIN_COLOR_TXT_VAR}An integer or a floating number"); # VAR TYPE : Array | DESC : Array of correct values for this global status variable.

    #**** Code ****
    # If the status variable's value is not a float or an integer.
    if ! BU.Main.Checkings.IsFloat "${__BU_MAIN_STAT_TIME_TXT}"; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_TIME_TXT}" "__BU_MAIN_STAT_TIME_TXT" "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_TXT_FMT}" status variable's value.
function BU.Main.Status.CheckSTAT_TXT_FMT()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local va_correctValues=("true" "false"); # VAR TYPE : Array                             - DESC : Array of correct values for this global status variable.

    #**** Code ****
    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" != "true" ] && [ "${__BU_MAIN_STAT_TXT_FMT,,}" != "false" ]; then
        BU.Main.Status.ConfEcho "${p_module}" "${p_file}" "${p_lineno}" "${__BU_MAIN_STAT_TXT_FMT}" '__BU_MAIN_STAT_TXT_FMT' "${va_correctValues[@]}";

        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Checking the "${__BU_MAIN_STAT_USER_OS}" status variable's value.
# This function is empty now, as the OS handling is still in work.
function BU.Main.Status.CheckSTAT_USER_OS()
{
    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.
    shift 2;

    # local pa_supported_os=("${@}") # VAR TYPE : Array                                     - DESC : Array storing the list of the operating systems which support a feature to be deployed.

    #**** Variables ****

    #**** Code ****
    return 0;
}

# Checking all the project's status variables values if multiple values had been modified.
function BU.Main.Status.CheckProjectStatusVars()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}";

    #**** Parameters ****
    local p_module=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${2:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${3:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Code ****
    # Processing first the "${__BU_MAIN_STAT_LOG_REDIRECT}" variable, to make sure the following error messages will be correctly displayed if another error happened.
    BU.Main.Status.CheckSTAT_LOG_REDIRECT       'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_DECHO              'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_ECHO               'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_ERROR              'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_INITIALIZING       'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_LOG                'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_OPERATE_ROOT       'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_TIME_HEADER        'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_TIME_NEWLINE       'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_TIME_TXT           'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_TXT_FMT            'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
    BU.Main.Status.CheckSTAT_USER_OS            'main' "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## CHANGING VALUES MORE EASILY
## DEBUG ID : "changing-values-more-easily"

__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY="${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}::changing-values-more-easily";

# Positionnal parameters :
#   ${1}    --> Any     : new value.
#   ${2}    --> String  : file where the change was made.
#   ${3}    --> Int     : line where the change was made.

# Changing the "$'__BU_MAIN_STAT_DECHO'" status variable's value.
function BU.Main.Status.ChangeSTAT_DECHO() { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHECKINGS}"; __BU_MAIN_STAT_DECHO="${1:-$'\0'}"; BU.Main.Status.CheckSTAT_DECHO "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "$'__BU_MAIN_STAT_ECHO'" status variable's value, and provide a log redirection support.

## VERY IMPORTANT : DO NOT CALL ANY "BU.Main.Decho.Decho<...>()" FUNCTION HERE (THE COMPLETE ONE), OR ELSE THE SCRIPT WILL BE STUCK IN AN INFINITE LOOP !!!!!!!!!!!!!!!
function BU.Main.Status.ChangeSTAT_ECHO()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" \
        "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}";

    #**** Parameters ****
    local p_value=${1:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Value to be changed.
    local p_module=${2:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Module where the current function is called.
    local p_file=${3:-$'\0'};   # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : File where the current function is called.
    local p_lineno=${4:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Line where the current function is called.

    #**** Variables ****
    local v_log_file_path="${__BU_MAIN_PROJECT_LOG_FILE_PATH}"; # VAR TYPE : Filepath       - DESC : Storing the path of the log file in another variable, in order to avoid reading and writing in the same pipeline.
    local v_loop_error; # VAR TYPE : String     - DESC : This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #*** Code ****
    if [ "true" == "${p_value,,}" ] && BU.Main.Checkings.IsArrayEmpty "${__BU_MAIN_STATVAR_ECHO_MSG_ARRAY[@]}"; then

        # Declare an array of strings, which will store the messages
        if BU.Main.Status.CheckStatIsLogging; then
            declare __BU_MAIN_STATVAR_ECHO_MSG_ARRAY=();

            # Modifying and checking the global variable's value first, before
            __BU_MAIN_STAT_ECHO="${p_value}";

            BU.Main.Status.CheckSTAT_ECHO "${p_module}" "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}";
            BU.Main.Echo.Green "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}'__BU_MAIN_STAT_ECHO : true'${__BU_MAIN_COLOR_TXT_GREEN} --> BEGINNING REDIRECTING TEXT TO THE ${__BU_MAIN_COLOR_PATH}${v_log_file_path}${__BU_MAIN_COLOR_GREEN} LOG FILE" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}";
            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}";
            BU.Main.Echo.Newline;
        fi

    elif [ 'false' == "${p_value,,}" ]; then
        if BU.Main.Checkings.IsArrayNotEmpty "${__BU_MAIN_STATVAR_ECHO_MSG_ARRAY[@]}" && BU.Main.Status.CheckStatIsLogging; then

            for i in "${__BU_MAIN_STATVAR_ECHO_MSG_ARRAY[@]}"; do
                echo "${i}" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" || \
                {
                    local __bu_main_stat_log_redirect_backup="${__BU_MAIN_STAT_LOG_REDIRECT}"; __BU_MAIN_STAT_LOG_REDIRECT="";

                    echo >&2;

                    BU.Main.Echo.Error "In ${__BU_MAIN_COLOR_PATH}$(basename "${BASH_SOURCE[0]}")${__BU_MAIN_COLOR_ERROR} file, function ${__BU_MAIN_COLOR_FUNCTION}${FUNCNAME[0]}${__BU_MAIN_COLOR_ERROR}, line ${__BU_MAIN_COLOR_HIGHLIGHT}${LINENO}${__BU_MAIN_COLOR_ERROR} --> Error :" >&2;
                    BU.Main.Echo.Error "Unable to write in the ${__BU_MAIN_COLOR_PATH}${__BU_MAIN_PROJECT_LOG_FILE_PATH}${__BU_MAIN_COLOR_ERROR} log file" >&2;
                    echo >&2;

                    BU.Main.Echo.Error "Please check the cause of this bug" >&2;
                    BU.Main.Echo.Error "The cause may be a problem of read and / or write permission" >&2;
                    echo >&2;

                    __BU_MAIN_STAT_LOG_REDIRECT="${__bu_main_stat_log_redirect_backup}";

                    local C="${__BU_MAIN_EXIT_NOT_PERMITTED}"; v_loop_error='error'; break;
                }
            done; if [ "${v_loop_error,,}" == 'error' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}";
            BU.Main.Echo.Green "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}'__BU_MAIN_STAT_ECHO : true'${__BU_MAIN_COLOR_TXT_GREEN} --> ENDED REDIRECTING TEXT TO THE ${__BU_MAIN_COLOR_PATH}${v_log_file_path}${__BU_MAIN_COLOR_GREEN} LOG FILE" >> "${__BU_MAIN_PROJECT_LOG_FILE_PATH}";
            BU.Main.Headers.DrawLine "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_TXT_AQUA}";
            BU.Main.Echo.Newline;

            # Emptying the array of strings.
            __BU_MAIN_STATVAR_ECHO_MSG_ARRAY=();
        fi
    fi

    __BU_MAIN_STAT_ECHO="${p_value}";

    BU.Main.Status.CheckSTAT_ECHO "${p_module}" "${p_file}" "${p_lineno}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Changing the "${__BU_MAIN_STAT_ERROR}" status variable's value.
function BU.Main.Status.ChangeSTAT_ERROR()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}";

    __BU_MAIN_STAT_ERROR="${1:-$'\0'}";

    BU.Main.Status.CheckSTAT_ERROR "${2}" "${3}" "${4}" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}";

        return "${C}";
    }

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Changing the "${__BU_MAIN_STAT_INITIALIZING}" status variable's value.
# WARNING : Do NOT change it's value from 'false' to 'true'. Otherwise, expect bugs.
function BU.Main.Status.ChangeSTAT_INITIALIZING()    {
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}";

	if [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ] && [ 'true' == "${1}" ]; then
		BU.Main.Echo.Warning "WARNING : It's strongly discouraged to change the $(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_STAT_INITIALIZING}") value from $(BU.Main.Decho.Decho.Var 'false') to $(BU.Main.Decho.Decho.Var 'true')"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1;
	else
		__BU_MAIN_STAT_INITIALIZING="${1:-$'\0'}";     BU.Main.Status.CheckSTAT_INITIALIZING "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; };
	fi; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Changing the "${__BU_MAIN_STAT_LOG}" status variable's value.
function BU.Main.Status.ChangeSTAT_LOG()             { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_LOG="${1:-$'\0'}";          BU.Main.Status.CheckSTAT_LOG            "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_LOG_REDIRECT}" status variable's value.
function BU.Main.Status.ChangeSTAT_LOG_REDIRECT()    { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_LOG_REDIRECT="${1:-$'\0'}"; BU.Main.Status.CheckSTAT_LOG_REDIRECT   "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_OPERATE_ROOT}" status variable's value.
function BU.Main.Status.ChangeSTAT_OPERATE_ROOT()    { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_OPERATE_ROOT="${1:-$'\0'}"; BU.Main.Status.CheckSTAT_OPERATE_ROOT   "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_TIME_HEADER}" status variable's value.
function BU.Main.Status.ChangeSTAT_TIME_HEADER()     { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_TIME_HEADER="${1:-$'\0'}";  BU.Main.Status.CheckSTAT_TIME_HEADER    "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_TIME_NEWLINE}" status variable's value.
function BU.Main.Status.ChangeSTAT_TIME_NEWLINE()    { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_TIME_NEWLINE="${1:-$'\0'}"; BU.Main.Status.CheckSTAT_TIME_NEWLINE   "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_TIME_TXT}" status variable's value.
function BU.Main.Status.ChangeSTAT_TIME_TXT()        { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_TIME_TXT="${1:-$'\0'}";     BU.Main.Status.CheckSTAT_TIME_TXT       "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Changing the "${__BU_MAIN_STAT_TXT_FMT}" status variable's value.
function BU.Main.Status.ChangeSTAT_TXT_FMT()         { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__CHANGING_VALUES_MORE_EASILY}"; __BU_MAIN_STAT_TXT_FMT="${1:-$'\0'}";      BU.Main.Status.CheckSTAT_TXT_FMT        "${2}" "${3}" "${4}" || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# -----------------------------------------------

## EASIER BOOLEAN VALUES CHECKINGS
## DEBUG ID : "easier-boolean-values-checkings"

__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS="${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}::easier-boolean-values-checkings";

# Checking if the "BU.Echo<...>()" functions can call the "BU.Main.Status.CheckProjectLogStatus()" function without provoking an infinite loop.
function BU.Main.Status.CheckStatIsBackupEchoing() { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS}"; if [ "${__BU_MAIN_STAT_ECHO,,}"           == 'true' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi; }

# Checking if the library is into its initialization process (${__BU_MAIN_STAT_INITIALIZING}).
function BU.Main.Status.CheckStatIsInitializing()  { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS}"; if [ "${__BU_MAIN_STAT_INITIALIZING,,}"   == 'true' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi; }

# Checking if the log redirection mode is active.
function BU.Main.Status.CheckStatIsLogging()       { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS}"; if [ "${__BU_MAIN_STAT_LOG,,}"            == 'true' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi; }

# Checking if the initialization logs can be printed on the terminal.
function BU.Main.Status.CheckStatIsPrintingInit()  { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS}"; if [ "${__BU_MAIN_STAT_PRINT_INIT_LOG,,}" == 'true' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi; }

# Checking if the text formatting is allowed.
function BU.Main.Status.CheckStatAllowFormatting() { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_STATUS_LIB__CAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS}" "${__BU_MAIN_STATUS_LIB__SUBCAT_DEBUG_ID__VARIABLES_VALUES_FUNCTIONS__EASIER_BOOLEAN_VALUES_CHECKINGS}"; if [ "${__BU_MAIN_STAT_TXT_FMT,,}"        == 'true' ]; then BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; else BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 1; fi; }
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Files.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### COLORS
#### DEBUG ID : colors::setting-colors

__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS="textformat::colors";

## GETTING COLOR CODES FROM FILES
## DEBUG ID : getting-color-codes-from-files

__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__SETTING_COLORS__GETTING_COLOR_CODES_FROM_FILES="${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS}::getting-color-codes-from-files";

# Writing the error messages in a single location.
function BU.Main.TextFormat.CannotCreateRessource()
{
    #**** Parameters ****
    local p_file=${1:-NULL}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_fnct=${2:-NULL}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_line=${3:-NULL}; # ARG TYPE : Int       - REQUIRED | DEFAULT VAL : NULL     - DESC :

    local p_path=${4:-NULL}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC :
    local p_type=${5:-NULL}; # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC :

    #**** Code ****
    echo "IN ${p_file}, FUNCTION ${p_fnct}, LINE ${p_line} --> ERROR : THE ${p_path} $( [[ "${p_type,,}" == 'dir' ]] && printf 'DIRECTORY' || printf 'FILE' ) CANNOT BE CREATED" >&2;
    echo "Please check what is preventing this $( [[ "${p_type,,}" == 'dir' ]] && printf 'directory' || printf 'file' ) directory from being created. It may be a directory permission issue." >&2;
    echo >&2;

    echo "Aborting the script's execution" >&2;
    echo >&2;

    if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi
}

# Getting the current background color from a command substitution.
function BU.Main.TextFormat.GetBGColorFromCMD()
{
    #**** Parameters ****
    local p_cmd=${1:-$'\0'}; # ARG TYPE : CMD   - REQUIRED | DEFAULT VAL : NULL     - DESC : The command which executes the code which colors the terminal's background.

    #**** Variables ****
    local v_code;   # VAR TYPE : CMD    - DESC : This variable stores the content of the file which contains the ANSi raw escape sequence.

    #**** Code ****
    if [ ! -d "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}" ]; then mkdir -p "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}" || {
            BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}" 'dir';

            return 1;
        };
    fi

    if [ ! -f "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}" ]; then touch "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}" || {
            BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}" 'file';

            return 1;
        }
    fi

    # Storing the background color's ANSI escape sequence in the file.
    echo "${p_cmd}" > "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}";

    # Getting the ANSI color code from the "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}" file.
    v_code="$(BU.Main.Text.CutSubStringBeforeNthDelim "$(cat "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}")" ";" 2)";

    # Printing the code.
    echo "${v_code:0:1}";

    return 0;
}

# Getting the current text color from a command substitution.
function BU.Main.TextFormat.GetTextColorFromCMD()
{
    #**** Parameters ****
    local p_cmd=${1:-$'\0'}; # ARG TYPE : CMD    - REQUIRED | DEFAULT VAL : NULL     - DESC : The command which executes the code which colors the terminal's text.

    #**** Variables ****
    local v_code;   # VAR TYPE : CMD    - DESC : This variable stores the content of the file which contains the ANSi raw escape sequence.

    #**** Code ****
    if [ ! -d "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}" ]; then mkdir -p  "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}" || {
            BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}" 'dir';

            return 1;
        }
    fi

    if [ ! -f "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}" ]; then touch "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}" || {
            BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}" 'file';

            return 1;
        }
    fi

    # Storing the text color's ANSI escape sequence in the file.
    echo "${p_cmd}" > "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}";

    # Getting the ANSI color code from the "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}" file.
    v_code="$(BU.Main.Text.CutSubStringBeforeNthDelim "$(cat "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}")" ";" 2)";

    # Printing the code.
    echo "${v_code:0:1}";

    return 0;
}

# -----------------------------------------------

## SETTING COLOR CODES IN FILES
## DEBUG ID : setting-color-codes-in-files

__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__COLORS__SETTING_COLOR_CODES_IN_FILES="${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS}::setting-color-codes-in-files";

# Writing the text zone's background color into a file, to be processed by any function which needs to know what is the current color.

## WARNING !! DO NOT CALL THESE FUNCTIONS HERE, THEY CALL THE "BU.Main.Decho.__Decho()" AND "BU.Main.Decho.Decho()" FUNCTIONS, AND SO THE FOLLOWING FUNCTION :
#   - BU.Main.Checkings.CheckProjectRelatedFile()
#   - BU.Main.Errors.HandleSmallErrors()
#   - BU.Main.Errors.HandleErrors()
function BU.Main.TextFormat.SetBGColor()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__COLORS__SETTING_COLOR_CODES_IN_FILES}";

	#**** Parameters ****
	local p_color_code=${1:-$'\0'};     # ARG TYPE : Int        # REQUIRED | DEFAULT VAL : NULL     - DESC : Color code
	local p_init_ctrl=${2:-$'\0'};      # ARG TYPE : String     # CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the creation of the background color's temporary file.

	#**** Code ****
	# Checking first if the target partition is not fully used. The file is created by the "BU.Main.Checkings.CheckDiskUsedSpace()" function if the framework is not initialized.
	if [[ "${p_init_ctrl,,}" == ?(-?(-))no?(-)function ]] && [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" 'create' 'false' || { local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; }; fi

	# If the script is allowed to format text.
    if BU.Main.Status.CheckStatAllowFormatting; then
        # Checking the existence of the "bgcolor.tmp" (background color) file's parent directory, and creating it if it doesn't exists.
        if [ ! -d "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" ]; then mkdir -p "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" || {
                BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" 'dir';

                return 1;
            };
        fi

        # Checking the existence of the "bgcolor.tmp" (background color) file in its defined path, and creating it if it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then touch "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" || {
                BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}" 'file';

                return 1;
            };
        fi

        # Redirecting the background's color code in its dedicated temporary file.
        echo "${p_color_code}" > "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}"; local X="${?}";

        [ "${X}" -ne 0 ] && {
            echo -e >&2; echo -e "The $(BU.Main.Checkings.CheckFilePathExists "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" 'false') (bgcolor.tmp) file doesn't exists" >&2; echo -e >&2;

            if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi
        }

        # Finally, the background color is displayed on the terminal.
        if command -v tput &> /dev/null; then tput setab "${p_color_code}" || { echo -ne "\e[48;5;${1}m" && echo "${p_color_code}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0; }; fi
    else
        echo -ne "\e[48;5;${1}m"; echo "${p_color_code}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# Writing the text's color code into a file, to be processed by any function which needs to know what is the current text color.

## WARNING !! DO NOT CALL THESE FUNCTIONS HERE, THEY CALL THE "BU.Main.Decho.__Decho()" AND "BU.Main.Decho.Decho()" FUNCTIONS, AND SO THE FOLLOWING FUNCTION :
#   - BU.Main.Checkings.CheckProjectRelatedFile()
#   - BU.Main.Errors.HandleSmallErrors
#   - BU.Main.Errors.HandleErrors
function BU.Main.TextFormat.SetTextColor()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__COLORS__SETTING_COLOR_CODES_IN_FILES}";

	#**** Parameters ****
	local p_color_code=${1:-$'\0'};     # ARG TYPE : Int        # REQUIRED | DEFAULT VAL : NULL     - DESC : Color code
	local p_init_ctrl=${2:-$'\0'};      # ARG TYPE : String     # CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the creation of the text color's temporary file.

	#**** Code ****
    shopt -s extglob;

    # Checking first if the target partition is not fully used. The file is created by the "BU.Main.Checkings.CheckDiskUsedSpace()" function if the framework is not initialized.
    if [[ "${p_init_ctrl,,}" != ?(-?(-))no?(-)function ]] && [ "${__BU_MAIN_STAT_INITIALIZING,,}" == 'false' ]; then BU.Main.Checkings.CheckDiskUsedSpace "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" 'create' 'false' || { local C="${?}"; shopt -u extglob; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; exit "${C}"; }; fi

    shopt -u extglob;

    # If the script is allowed to format text.
	if BU.Main.Status.CheckStatAllowFormatting; then
        # Checking the existence of the "fgcolor.tmp" (foreground / text color) file's parent directory, and creating it if it doesn't exists.
        if [ ! -d "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" ]; then mkdir -p "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" || {
                BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" 'dir';

                return 1;
            };
        fi

        # Checking the existence of the "fgcolor.tmp" (foreground / text color) file in its defined path, and creating it if it doesn't exists.
        if [ ! -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then touch "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" || {
                BU.Main.TextFormat.CannotCreateRessource "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 1 ))" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" 'file';

                return 1;
            };
        fi

        # Redirecting the text's color code in its dedicated temporary file.
        echo "${p_color_code}" > "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}"; local X="${?}";

        [ "${X}" -ne 0 ] && {
            echo -e >&2; echo -e "The $(BU.Main.Checkings.CheckFilePathExists "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" 'false') (fgcolor.tmp) file doesn't exists" >&2; echo -e >&2;

            if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi
        }

        # Finally, the foreground color is displayed on the terminal.
        if command -v tput &> /dev/null; then tput setaf "${p_color_code}" || { echo -ne "\e[38;5;${1}m" && echo "${p_color_code}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0; }; fi
    else
        echo -ne "\e[38;5;${1}m"; echo "${p_color_code}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}

# -----------------------------------------------

## COLORS STRINGS PROCESSING FUNCTIONS
## DEBUG ID : colors-strings-processing-functions

__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__COLORS_PROCESSING_FUNCTIONS__PROCESSING_FUNCTIONS="${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__COLORS}::colors-strings-processing-functions";

# Conversion of color name (string) to color code (int).
function BU.Main.TextFormat.Atoi()
{
    #**** Parameters ****
    local p_str=${1:-white};                    # String - Default : NULL - Color name

    #**** Code ****
    # Basic colors
    if      [ "${p_str,,}" == "aqua" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__AQUA,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_AQUA};
    elif    [ "${p_str,,}" == "black" ]         || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__BLACK,,}" ];       then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_BLACK};
    elif    [ "${p_str,,}" == "blue" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__BLUE,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_BLUE};

    elif    [ "${p_str,,}" == "cyan" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__CYAN,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_CYAN};
    elif    [ "${p_str,,}" == "fuchsia" ]       || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__FUCHSIA,,}" ];     then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_FUCHSIA};
    elif    [ "${p_str,,}" == "gray" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__GRAY,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_GRAY};

    elif    [ "${p_str,,}" == "green" ]         || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__GREEN,,}" ];       then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_GREEN};
    elif    [ "${p_str,,}" == "lime" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__LIME,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_LIME};
    elif    [ "${p_str,,}" == "maroon" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__MAROON,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_MAROON};

    elif    [ "${p_str,,}" == "navy" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__NAVY,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_NAVY};
    elif    [ "${p_str,,}" == "olive" ]         || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__OLIVE,,}" ];       then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_OLIVE};
    elif    [ "${p_str,,}" == "orange" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__ORANGE,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_ORANGE};

    elif    [ "${p_str,,}" == "pink" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__PINK,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_PINK};
    elif    [ "${p_str,,}" == "purple" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__PURPLE,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_PURPLE};
    elif    [ "${p_str,,}" == "red" ]           || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__RED,,}" ];         then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_RED};

    elif    [ "${p_str,,}" == "salmon" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__SALMON,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_SALMON};
    elif    [ "${p_str,,}" == "silver" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__SILVER,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_SILVER};
    elif    [ "${p_str,,}" == "tan" ]           || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__TAN,,}" ];         then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_TAN};

    elif    [ "${p_str,,}" == "teal" ]          || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__TEAL,,}" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_TEAL};
    elif    [ "${p_str,,}" == "turquoise" ]     || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__TURQUOISE,,}" ];   then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_TURQUOISE};
    elif    [ "${p_str,,}" == "violet" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__VIOLET,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_VIOLET};

    elif    [ "${p_str,,}" == "white" ]         || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__WHITE,,}" ];       then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_WHITE};
    elif    [ "${p_str,,}" == "yellow" ]        || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__YELLOW,,}" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_YELLOW};
    elif    [ "${p_str,,}" == "reset" ]         || [ "${p_str,,}" == "${__BU_MAIN_TEXT_FORMAT_LIB__MSG__LOCALIZED_COLOR__RESET,,}" ];       then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_RESET};

    # Specific colors for text encoding
    elif    [ "${p_str^^}" == "CMD" ];          then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_CMD};
    elif    [ "${p_str^^}" == "ERROR" ];        then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_ERROR};
    elif    [ "${p_str^^}" == "FUNCTION" ];     then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_FUNCTION};

    elif    [ "${p_str^^}" == "HIGHLIGHT" ];    then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_HIGHLIGHT};
    elif    [ "${p_str^^}" == "NEWSTEP" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_NEWSTEP};
    elif    [ "${p_str^^}" == "PATH" ];         then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_PATH};

    elif    [ "${p_str^^}" == "SUCCESS" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_SUCCESS};
    elif    [ "${p_str^^}" == "VAR" ];          then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_VAR};
    elif    [ "${p_str^^}" == "WARNING" ];      then __BU_MAIN_COLORS_ATOI_COLOR=${__BU_MAIN_COLOR_CODE_WARNING};

    fi

    return 0;
}

# Conversion of color code (int) to color code (string).
function BU.Main.TextFormat.Itoa()
{
    #**** Parameters ****
    local p_code=${1:-0};   # Int       - Default : NULL            - Color code
    local p_fmt=${2:-$'\0'} # String    - Default : NULL            - Text format

    #**** Code ****
    # Basic colors
    if      [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_AQUA}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="aqua";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_BLACK}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="black";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_BLUE}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="blue";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_CYAN}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="cyan";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_FUCHSIA}" ];       then __BU_MAIN_COLORS_ITOA_COLOR="fuchsia";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_GRAY}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="gray";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_GREEN}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="green";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_LIME}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="lime";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_MAROON}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="maroon";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_NAVY}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="navy";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_OLIVE}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="olive";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_ORANGE}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="orange";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_PINK}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="pink";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_PURPLE}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="purple";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_RED}" ];           then __BU_MAIN_COLORS_ITOA_COLOR="red";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_SALMON}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="salmon";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_SILVER}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="silver";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_TAN}" ];           then __BU_MAIN_COLORS_ITOA_COLOR="tan";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_TEAL}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="teal";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_TURQUOISE}" ];     then __BU_MAIN_COLORS_ITOA_COLOR="turquoise";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_VIOLET}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="violet";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_WHITE}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="white";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_YELLOW}" ];        then __BU_MAIN_COLORS_ITOA_COLOR="yellow";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_RESET}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="reset";

    # Specific colors for text encoding
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_CMD}" ];           then __BU_MAIN_COLORS_ITOA_COLOR="CMD";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_ERROR}" ];         then __BU_MAIN_COLORS_ITOA_COLOR="ERROR";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_FUNCTION}" ];      then __BU_MAIN_COLORS_ITOA_COLOR="FUNCTION";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}" ];     then __BU_MAIN_COLORS_ITOA_COLOR="HIGHLIGHT";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_NEWSTEP}" ];       then __BU_MAIN_COLORS_ITOA_COLOR="NEWSTEP";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_PATH}" ];          then __BU_MAIN_COLORS_ITOA_COLOR="PATH";

    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_SUCCESS}" ];       then __BU_MAIN_COLORS_ITOA_COLOR="SUCCESS";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_VAR}" ];           then __BU_MAIN_COLORS_ITOA_COLOR="VAR";
    elif    [ "${p_code}" == "${__BU_MAIN_COLOR_CODE_WARNING}" ];       then __BU_MAIN_COLORS_ITOA_COLOR="WARNING";

    fi

    # Formatting the text according to the user's preference.
    if      [ -z "${p_fmt}" ]; then return 0;
    elif    [[ "${p_fmt^^}" == UP?(PER)?([[:space:]])?(CASE) ]];    then BU.Main.Text.ToUppercase "${__BU_MAIN_COLORS_ITOA_COLOR}"; return 0;
    elif    [[ "${p_fmt,,}" == low?(er)?([[:space:]])?(case) ]];    then BU.Main.Text.ToLowercase "${__BU_MAIN_COLORS_ITOA_COLOR}"; return 0;

    fi;

    return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT
#### DEBUG ID : text

__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__TEXT='textformat:text';

## SETTING TEXT FORMAT
## DEBUG ID : setting-text-format

__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__TEXT__SETTING_TEXT_FORMAT="${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__TEXT}:setting-text-format":

# Checking if the "${__BU_MAIN_STAT_TXT_FMT}" status value is set to "true".
function BU.Main.TextFormat.SetTextFormat()
{
    #**** Parameters ****
    #   ${1}    -> "$(tput)" command's text formatting option.
    #   ${2}    -> Corresponding ANSI escape sequence (useful if the "$(tput)" command is not detected or unavailable).

    #**** Code ****
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "$(bash -x)".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__CAT_DEBUG_ID__TEXT}" \
        "${__BU_MAIN_TEXTFORMAT_LIB__SUBCAT_DEBUG_ID__TEXT__SETTING_TEXT_FORMAT}";

    if [ "${__BU_MAIN_STAT_TXT_FMT,,}" == "true" ]; then
        if [ -n "${1}" ]; then
			if command -v "tput" &> /dev/null; then

				# Formatting text with the tput command or directly with the backslash escapes.
				tput "${1}" || echo -ne "\e[${2}m";	# If the "$(tput)" command fails, then the text is encoded with ANSI control sequences.

				BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
			else
				echo -ne "\e[${2}m"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
			fi

        # In case there's no value passed as first argument (like if the wanted "$(tput)" command's option is unknown), the script only echoes its ANSI escape sequence.
        else
            echo -ne "\e[${2}m";

            BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
        fi

    else
        BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
    fi
}
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Text.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

# Functions specially made for text processing (cutting fields / characters, ).

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### TEXT PROCESSING FUNCTIONS
#### DEBUG ID : "text::text-processing-functions"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS="text::text-processing-functions";

## CUTTING TEXT
## DEBUG ID : "cutting-text"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::cutting-text";

# Cut the date displayed before a string.
function BU.Main.Text.CutLogDateFromString()     { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}"; BU.Main.Text.CutSubStringAfterNthDelim "${1}" '] ';  BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Cut the dash written before a command option call (to be improved).
function BU.Main.Text.CutDashFromOption()        { BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}"; BU.Main.Text.CutSubStringAfterNthDelim "${1}" '-';   BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0; }

# Cut every part of a string after and with the delimiter, which can be both a single character or a string.
function BU.Main.Text.CutSubStringAfterNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations.
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.

    #**** Variables ****
    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

	local v_fieldtmp="";            # VAR TYPE : String     - DESC : Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_newString="";           # VAR TYPE : String     - DESC : Let this variable empty, it is used to store the new string with every fields cut from the original string.
	local x;                        # VAR TYPE : Int        - DESC :

    #**** Code ****
    if ! BU.Main.Args__Text.CutSubStringAfterNthDelim "${p_string}" "${p_delimiter}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
	x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_delimiter}")";

    for ((i=0; i<x; i++)); do
		if [ "${i}" == "${p_iterations}" ]; then break; fi

        v_fieldtmp="${p_string%%"${p_delimiter}"*}";
		v_fieldtmp="${v_fieldtmp#*"${p_delimiter}"}";

		if [ -z "${v_newString}" ]; then
			v_newString="${v_fieldtmp}";
		else
			v_newString="${v_newString}${p_delimiter}${v_fieldtmp}";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

	if [ "${p_count,,}" != 'count' ]; then echo -ne "${v_newString}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Cut every part of a string before and with the delimiter, which can be both a single character or a string.
function BU.Main.Text.CutSubStringBeforeNthDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delimiter=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations.
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.

    #**** Variables ****
    local p_string_tmp;             # VAR TYPE : String     - DESC :

    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

    #**** Code ****
    if ! BU.Main.Args__Text.CutSubStringBeforeNthDelim "${p_string}" "${p_delimiter}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
        BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
    fi

    for ((i=0; i<p_iterations; i++)); do

        #shellcheck disable=SC2001
        p_string="$(sed "s/^[^${p_delimiter}]*${p_delimiter}//" <<< "${p_string}")";

        # This variable's purpose is to avoid assigning the "${p_string}" variable to itself, because if so, the assignment would have done nothing.
        p_string_tmp="${p_string}";
        p_string="${p_string_tmp}";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ "${p_count,,}" != 'count' ]; then echo -ne "${p_string}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Cut the very first field of a string, before the delimiter, in order to get everything that follows the first field.
function BU.Main.Text.CutFirstFieldBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo "${p_string%"${p_delim}"*}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Cut the very last field of a string, in order to get everything that preceeds the last field.
function BU.Main.Text.CutLastFieldAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};  # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo "${p_string#*"${p_delim}"}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Deleting letters and sub-strings in a main string.
function BU.Main.Text.DeleteLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_chars=${2:-$'\0'};      # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Letters and / or strings to replace.
    local p_occurences=${3:-one}    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : one      - DESC : Replace one occurence (default) or every occurences (value : all)
    local p_replacement=${4:-' '};  # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : ' '      - DESC : Replacing the former character / sub-string by an empty space (default (' ')) OR deleting them by remplacing them with an empty character ('').

    #**** Code ****
    if ! BU.Main.Args__Text.DeleteLettersInString "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    BU.Main.Text.BU.Main.Text.ReplaceLettersInString "${p_string}" "${p_chars}" "$([ "${p_replacement}" == '' ] && printf '' || printf ' ')" || {
        local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}";
    };

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Replacing letters and sub-strings in a main string.
function BU.Main.Text.ReplaceLettersInString()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__CUTTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};         # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};          # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Letters and / or strings to replace.
    local p_occurences=${3:-one}        # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : one      - DESC : Replace one occurence (default) or every occurences (value : all)
    local p_replacement=${4:-$'\0'};    # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Replacing the former character / sub-strings by another character / sub-string.

    #**** Code ****
    if [ "${p_occurences,,}" == 'all' ]; then
        echo "${p_string//${p_replacement}/"${p_delim}"}";
    else
        echo "${p_string/${p_replacement}/"${p_delim}"}";
    fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# -----------------------------------------------

## FORMATTING TEXT
## DEBUG ID : "formatting-text"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}.formatting-text";

# Keep the same text format between lowercased or uppercased text printed by a formatting text function ("BU.Main.Text.ToLowercase()" OR "BU.Main.Text.ToUppercase()") or a parameter expansion.
# This function is planned to be used between force-uppered/lowered text, to keep the original text formatting of the wanted string excerpt.
function BU.Main.Text.KeepFormatting()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
#	p_string=${1:-$'\0'};           # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to display.
#	p_old_formatting=${2:-$'\0'};   # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Former text formatting.

	#**** Code ****
# 	echo -ne &>/dev/null; echo -ne "${p_string}";
#
# 	if [ "${p_old_formatting,,}" == 'l' ]; then
#         echo -ne "$(BU.Main.Text.ToLowercase "${p_string}")";
# 	elif [ "${p_old_formatting^^}" == 'U' ]; then
#         echo -ne "$(BU.Main.Text.ToUppercase "${p_string}")";
# 	else
#         echo -ne "<<|| No reformatting precised in the $(BU.Main.Text.ToLowercase "${FUNCNAME[0]}()") function ||>>";
# 	fi

	BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Print a lowercased text.

# Usage :
#	BU.Main.Text.ToLowercase "<Text to write>"
function BU.Main.Text.ToLowercase()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

	#**** Code ****
	echo "${p_string}" | tr '[:upper:]' '[:lower:]'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Print an uppercased text.

# Usage :
#	BU.Main.Text.ToUppercase "<Text to write>"
function BU.Main.Text.ToUppercase()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__FORMATTING_TEXT}";

	#**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

	#**** Code ****
	echo "${p_string}" | tr '[:lower:]' '[:upper:]'; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## GETTING TEXT
## DEBUG ID : "getting-text"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::getting-text";

# Getting the occurences of a character in a main string.
function BU.Main.Text.GetCharacterOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Variables ****
    local v_occurences="${p_string//[^${p_target}]}";

    #**** Code ****
    if ! BU.Main.Args__Text.GetCharacterOccurences "${p_string}" "${p_target}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${?}"; fi

    echo -ne "${#v_occurences}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Get the very first character of a string, and cut everything that follows this character.
function BU.Main.Text.GetFirstCharacter()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    if ! BU.Main.Args__Text.GetFirstLastCharacter "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    echo "${p_string:0:1}"; return 0;
}

# Get the very first field of a string, and cut everything that follows the first delimiter.
function BU.Main.Text.GetFirstFieldBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    echo "${p_string%%"${p_delim}"*}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Get the very last character of a string, and cut the preceding characters.
function BU.Main.Text.GetLastCharacter()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Variables ****
    declare -i v_length;        # VAR TYPE : Int        - DESC : Storing the length of the character.

    #**** Code ****
    if ! BU.Main.Args__Text.GetFirstLastCharacter "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Getting the number of characters from this string.
    v_length="${#p_string}";

    # Printing the wanted character.
    echo "${p_string:$(( v_length - 1 )):1}"; return 0;
}

# Get the very last field of a string, and cut everything that preceeds the last delimiter.
function BU.Main.Text.GetLastFieldAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'}; # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted character.

    #**** Code ****
	if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

	echo "${p_string##*"${p_delim}"}" && BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Getting substring after a delimiter, which can be both a single character or a string.
function BU.Main.Text.GetSubStringAfterDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL    - Delimiter
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1       - Iterations
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL    - Allow to set a counter of skipped delimiters.
    local p_init=${5:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL    - RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.GetSubStringAfterDelim "${p_string}" "${p_delim}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    fi

    # WARNING ! DO NOT put double quotes between the "$(seq "${p_iterations}")", or else it will not word split, and the loop will only run once !
    for i in $(seq "${p_iterations}"); do
        p_string="${p_string#*"${p_delim}"}";

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done;

    if [ "${p_count,,}" != 'count' ]; then echo -ne "${p_string}"; else echo -ne "${v_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}" && return 0;
}

# Getting substring before a delimiter, which can be both a single character or a string.
function BU.Main.Text.GetSubStringBeforeDelim()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};      # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_iterations=${3:-1};     # ARG TYPE : Int        - OPTIONAL | DEFAULT VAL : 1        - DESC : Iterations
    local p_count=${4:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Allow to set a counter of skipped delimiters.
    local p_init=${5:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module.

    #**** Variables ****
    if [ -n "${p_count}" ] && [ "${p_count,,}" == 'count' ]; then local v_count=0; fi

	local v_fieldtmp="";            # VAR TYPE : String     - DESC : Leave this variable empty, it is used to store temporarily the first field cut from the original string at each loop iteration.
	local v_newString="";           # VAR TYPE : String     - DESC : Let this variable empty, it is used to store the new string with every fields cut from the original string.
	local x;                        # VAR TYPE : INT        - DESC :

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.GetSubStringBeforeDelim "${p_string}" "${p_delim}" "${p_iterations}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

        if [ -n "${p_iterations}" ] && ! BU.Main.Checkings.IsInt "${p_iterations}"; then
            BU.Main.Echo.Warning "$(BU.Main.Decho.Decho.Function "${FUNCNAME[0]}()") --> Warning : this function's third argument must be an integer."; p_iterations='1';
        fi
    fi

	# Getting the number of occurences of the character / string targeted as delimiter.
    if [ "${p_init,,}" == '--init' ]; then
        x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_target}" "--init")";
	else
        x="$(BU.Main.Text.GetSubStringOccurences "${p_string}" "${p_target}")";
    fi

    for ((i=0; i<x; i++)); do
		if [ "${i}" == "${p_iterations}" ]; then break; fi

        v_fieldtmp="${p_string##*"${p_delim}"}";
		v_fieldtmp="${v_fieldtmp%"${p_delim}"*}";

		if [ -z "${v_newString}" ]; then
			v_newString="${v_fieldtmp}";
		else
			v_newString="${v_newString}${p_delim}${v_fieldtmp}";
		fi

        if [ "${p_count,,}" != 'count' ]; then v_count="$(( v_count + 1 ))"; fi
    done

    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
	    v_newString="$(BU.Main.Text.ReverseStringWordsOrder "${v_newString}" "${p_delim}")";
    else
        v_newString="$(BU.Main.Text.ReverseStringWordsOrder "${v_newString}" "${p_delim}" 'rm --first+last' '--init')";
    fi

	if [ "${p_count,,}" != 'count' ]; then echo -e "${v_newString}"; else echo "${p_count}"; fi

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the occurences of a sub-string in a main string (it also works with a single character).
function BU.Main.Text.GetSubStringOccurences()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_target=${2:-$'\0'};  # ARG TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : Targeted sub-string.
    local p_init=${3:-$'\0'};    # ARG TYPE : String    - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module (this function is called by the "BU.Main.Text.GetSubStringBeforeDelim()" function, which is called in the "BU.ModuleInit.ParseCSVLang()" function).

	#**** Variables ****
	local tmp;      # VAR TYPE :
	local count;    # VAR TYPE :

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.GetSubStringOccurences "${p_string}" "${p_target}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    fi

	# https://stackoverflow.com/a/50601141

	# This removes all occurrences of "${p_target}" from "${p_string}" and places it in tmp.
	# Actually we're using substring replacement here with replacement string missing.

	# Syntax for substring replacement is "${p_string//substring/replacement}" (this replaces all occurrences of substring with replacement).
	tmp="${p_string//${p_target}}";

	# This gives us the number of occurrences of "${p_target}" in "${p_string}".

	# ${#p_string} gives string length so (${#p_string} - ${#tmp]) is length of all occurrences of "${p_target}" (remember, we removed all occurrences of "${p_target}" from "${p_string}" and placed the result in "${tmp}").
	count="$(((${#p_string} - ${#tmp}) / ${#p_target}))";

	echo -e "${count}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the size of a string in byte.
function BU.Main.Text.GetStringByteSize()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --bytes; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the size of a string in characters.
function BU.Main.Text.GetStringCharactersNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # VAR TYPE : String    - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --chars; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Getting the number of words in a string.
function BU.Main.Text.GetStringWordsNumber()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__GETTING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};  # ARG : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo -ne "${p_string}" | wc --words; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# -----------------------------------------------

## PRINTING TEXT
## DEBUG ID : "printing-text"

__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__PRINTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::printing-text";

# Printing a single character or a string X times.
function BU.Main.Text.PrintCharXTimes()
{
	#**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
	local p_nb=${2:-1};			    # ARG TYPE : Int		- REQUIRED | DEFAULT VAL : 1		- DESC : Number of characters to print.
	local p_newline=${3:-false}	    # ARG TYPE : Bool       - OPTIONAL | DEFAULT VAL : false    - DESC : If true, prints a line break.

	#**** Variables ****
	local i;	    # VAR TYPE : Int    - DESC : Iterations

	#**** Code ****
	for((i=0; i<p_nb; i++)); do
		printf "%s" "${p_str}";
	done

	if [ "${p_newline,,}" == 'true' ]; then BU.Main.Echo.Newstep; fi

	return 0;
}

# -----------------------------------------------

## REVERSING TEXT
## DEBUG ID : "reversing-text"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::reversing-text";

# Reverse words order of a string according to a delimiter.

# Examples with the '|' and '/' delimiter:
# animal | big | car | donut    --> donut | car | big | animal
# /home/user/Documents          --> Documents/user/home
function BU.Main.Text.ReverseStringWordsOrder()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'};     # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
    local p_delim=${2:-$'\0'};	    # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter
    local p_keepd=${3:-$'\0'};      # ARG TYPE : String     - OPTIONAL | DEFAULT VAL : NULL     - DESC : Keep or remove first or last delimiters, or both together, if they are the first and / or the last character of the string.
    local p_init=${4:-$'\0'};       # ARG TYPE : String     - CCONTEXT | DEFAULT VAL : NULL     - DESC : RESERVED FOR THE INITIALIZATION PROCESS OF THE MAIN MODULE OF THE BASH UTILS FRAMEWORK : Forbids the call of any function that calls translated text for the main module (this function is called by the "BU.Main.Text.GetSubStringAfterDelim()" function, which is called in the "BU.ModuleInit.ParseCSVLang()" function).


    #**** Variables ****
    # Leave this variable empty, it will store the reversed string.
    local reversed="";
    local line;

    #**** Code ****
    if [ -z "${p_init}" ] || [ -n "${p_init}" ] && [[ "${p_init,,}" != ?(-)?(-)init ]]; then
        if ! BU.Main.Args__Text.CutBeforeAndAfterFirstAndLastDelims "${p_string}" "${p_delim}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi
    fi

    # shellcheck disable=SC2219
    let x="${#line[@]}-1";

    while [ "${x}" -ge 0 ]; do
        if [ "${x}" -gt 1 ]; then reversed="${reversed}${line[x]}${p_delim}"; else reversed="${reversed}${line[x]}"; fi

        (( x-- ));
    done

    if     [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))f?(irst) ]];              then reversed="${p_delim}${reversed}";
    elif   [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))l?(ast) ]];               then reversed="${reversed}${p_delim}";
    elif   [[ "${p_keepd,,}" == k?(eep)?([[:space:]])?(-?(-))f?(irst)?(-)l?(ast) ]];   then reversed="${p_delim}${reversed}${p_delim}"; fi

    echo -e "${reversed}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Reverse the order of characters in a string.
function BU.Main.Text.ReverseCharactersOrder()
{
    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.

    #**** Code ****
    echo "${p_string}" | rev;

    return 0;
}

# -----------------------------------------------

## SPLITTING TEXT AND SPLITTED TEXT PROCESSING
## DEBUG ID : "splitting-text"

# shellcheck disable=SC2034
__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT="${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}::splitting-text";

# String to words array.

# Pass a string as argument, and after calling this function, copy the content of the generated array into another array, like this : your_array_name=("${__BU_MAIN_TEXT_LIB__STR_TO_WORD_ARR[@]}")
function BU.Main.Text.StrToWordArray()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    local p_string=${1:-$'\0'}; # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to convert in a word array.

    #**** Code ****
    if ! BU.Main.Args__Text.StrToWordArray "${p_string}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; then local C="${?}"; BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return "${C}"; fi

    # Since the "${__BU_MAIN_TEXT_LIB__STR_TO_WORD_ARR}" array is not used in this file, it's better to ignore the returned Shellcheck warning,
    # in order to avoid displaying a useless warning during the checkings with the Shellcheck debugger.

    # shellcheck disable=SC2034
    read -ra __BU_MAIN_TEXT_LIB__STR_TO_WORD_ARR <<< "${p_string}";

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Words array to string.
function BU.Main.Text.WordArrayToStr()
{
    # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
    BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
        "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
        "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__REVERSING_TEXT}";

    #**** Parameters ****
    # local p_array=${1:-$'\0'};

    #**** Code ****

    BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
}

# Splitting a string from a given delimiter, in order to store it in an array.
# function BU.Main.Text.SplitStringFromDelim()
# {
#     # This function makes it easier for the user to find the current function and its executed content if it is called during the execution of the main script with the command "bash -x".
#     BU.Main.Echo.Debug "main" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" \
#         "${__BU_MAIN_TEXT_LIB__CAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS}" \
#         "${__BU_MAIN_TEXT_LIB__SUBCAT_DEBUG_ID__TEXT_PROCESSING_FUNCTIONS__SPLITTING_TEXT}";
#
#     #**** Parameters ****
#     local p_string=${1:-$'\0'};       # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : String to process.
#     local p_delim=${2:-$'\0'};        # ARG TYPE : String     - REQUIRED | DEFAULT VAL : NULL     - DESC : Delimiter.
#     local p_order=${3:-$'\0'};        # ARG TYPE : Char       - REQUIRED | DEFAULT VAL : NULL     - DESC : Splitting order (L|l = left to right, R|r = right to left).
#     local p_iterations=${4:-$'\0'};   # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of delimiters to process.
#     local p_ignore_delim=${5:-$'\0'}; # ARG TYPE : Int        - REQUIRED | DEFAULT VAL : NULL     - DESC : Number of delimiters to ignore before splitting the string.
#
#     #**** Code ****
#     if [ -z "${p_iterations}" ] || [ "${p_iterations}" -eq 0 ]; then
#         p_iterations='1';
#     fi
#
#     # If the string has to be processed from left to right.
#     if [ "${p_order^^}" == 'L|l' ]; then
#         for ((i=0; i<{p_iterations}; i++)); do
#             if [ -z "${p_ignore_delim}" ] || [ "${p_ignore_delim}" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if the string has to be processed from right to left.
#     elif [ "${p_order^^}" == 'R|r' ]; then
#         for ((i=0; i<p_iterations; i++)); do
#             if [ -z "${p_ignore_delim}" ] || [ "${p_ignore_delim}" -eq 0 ]; then
#                 true
#             else
#                 for ((j=0; j<p_ignore_delim; i++)); do
#                     true
#                 done
#             fi
#         done
#
#     # Else, if no value is passed to the order processer.
#     elif [ -z "${p_order}" ]; then
#         false
#
#     # Else, if an unsupported value is passed to the order processer.
#     else
#         false
#     fi
#
#     BU.Main.Echo.DebugEnd "${FUNCNAME[0]}"; return 0;
# }
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Time.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       :

# ------------------
# FILE DESCRIPTION :

#

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Usage.lib
# Module        : Main
# Author(s)     : Dimitri OBEID
# Version       : 1.0

# ------------------
# FILE DESCRIPTION :

# Printing the way to use each main module's functions.

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ----------------------------------------------------------------------------------------------------------------------------------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it by calling the "${__BU_MAIN_FUNCTIONS_FILES_PATH}" array in the initializer file.

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every aliases for the main module's functions.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### DEFINING THE NEEDED FUNCTIONS

## DEFINING THE NEEDED FUNCTIONS

# Feel free to define any needed resources (aliases, functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - ARGS #####################################

#### CATEGORY : ""

## SUB-CATEGORY : ""



# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING ALIASES - BASICMATHS ##################################

#### CATEGORY : "CONVERSIONS"

## SUB-CATEGORY : "NUMERIC CONVERSIONS"

alias BU.BytesToHuman='BU.Main.BasicMaths.BytesToHuman';
alias BU.NegativeToPositive='BU.Main.BasicMaths.NegativeToPositive';
alias BU.PositiveToNegative='BU.Main.BasicMaths.PositiveToNegative';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - CASE #####################################

#### CATEGORY : "READING CASE STATEMENTS BY FUNCTIONS"

## SUB-CATEGORY : "'Directories.lib' FILE"

alias BU.Read_DirectoriesTriggerRootDirWarning='BU.Main.Case.Read_DirectoriesTriggerRootDirWarning';

# -----------------------------------------------

## SUB-CATEGORY : "'Errors.lib' FILE"

alias BU.Read_Errors.HandleErrors='BU.Main.Case.Read_Errors.HandleErrors';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################### DEFINING ALIASES - CHECKINGS ##################################

#### CATEGORY : "VARIABLES VALUES CHECKINGS"

## SUB-CATEGORY : "ARRAYS CHECKINGS"

alias BU.IsArray='BU.Main.Checkings.IsArray';
alias BU.IsArrayEmpty='BU.Main.Checkings.IsArrayEmpty';
alias BU.IsArrayNotEmpty='BU.Main.Checkings.IsArrayNotEmpty';

# -----------------------------------------------

## SUB-CATEGORY : "COMMAND SUBSTITUTIONS"

alias BU.IsCMD='BU.Main.Checkings.IsCMD';
alias BU.IsCmd='BU.Main.Checkings.IsCMD';

alias BU.IsNotCMD='BU.Main.Checkings.IsNotCMD';
alias BU.IsNotCmd='BU.Main.Checkings.IsNotCMD';

# -----------------------------------------------

## SUB-CATEGORY : "DATE FORMAT"

alias BU.IsDateHMS='BU.Main.Checkings.IsDateHMS';
alias BU.IsDateYMD='BU.Main.Checkings.IsDateYMD';
alias BU.IsDateYMD_HMS='BU.Main.Checkings.IsDateYMD_HMS';

# -----------------------------------------------

## SUB-CATEGORY : "NUMBER VALUES"

alias BU.IsFloat='BU.Main.Checkings.IsFloat';
alias BU.IsNegativeFloat='BU.Main.Checkings.IsNegativeFloat';
alias BU.IsPositiveFloat='BU.Main.Checkings.IsPositiveFloat';
alias BU.IsInt='BU.Main.Checkings.IsInt';
alias BU.IsNegativeInt='BU.Main.Checkings.IsNegativeInt';
alias BU.IsPositiveInt='BU.Main.Checkings.IsPositiveInt';

# -----------------------------------------------

## SUB-CATEGORY : "CHARACTERS AND STRING VALUES"

alias BU.IsAphaChar='BU.Main.Checkings.IsAlphaChar';
alias BU.IsAlphaString='BU.Main.Checkings.IsAlphaString';
alias BU.IsIsAlphaStringOnly='BU.Main.Checkings.IsIsAlphaStringOnly';
alias BU.IsAlphaNumChar='BU.Main.Checkings.IsAlphaNumChar';
alias BU.IsAlphaNumString='BU.Main.Checkings.IsAlphaNumString';
alias BU.IsAlphaNumStringOnly='BU.Main.Checkings.IsAlphaNumStringOnly';

# -----------------------------------------------

## OTHER VARIABLES CHECKINGS

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "DIFFERENT CHECKINGS"

## SUB-CATEGORY : "CHECKING FOR IDENTIFIANTS"

# -----------------------------------------------

## SUB-CATEGORY : "BASIC HARDWARE CHECKINGS"

alias BU.CheckDiskUsedSpace='BU.Main.Checkings.CheckDiskUsedSpace';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SUB-CATEGORY : "PATHS CHECKINGS"

alias BU.CheckDirPathExists='BU.Main.Checkings.CheckDirPathExists';
alias BU.CheckDirPathWasCreated='BU.Main.Checkings.CheckDirPathWasCreated';

# -----------------------------------------------

## SUB-CATEGORY : "FILES PATHS CHECKINGS"

alias BU.CheckFilePathExists='BU.Main.Checkings.CheckFilePathExists';
alias BU.CheckFilePathWasCreated='BU.Main.Checkings.CheckFilePathWasCreated';
alias BU.CheckProjectLogPath='BU.Main.Checkings.CheckProjectLogPath';
alias BU.CheckProjectLogStatus='BU.Main.Status.CheckProjectLogStatus';
alias BU.CheckProjectRelatedFile='BU.Main.Checkings.CheckProjectRelatedFile';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### SUB-CATEGORY : "TEXT CHECKINGS"

alias BU.CheckDecho='BU.Main.Checkings.CheckDecho';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "PATHS CHECKINGS"

## SUB-CATEGORY : "FILES PATHS CHECKINGS"

alias BU.CheckProjectLogStatus='BU.Main.Checkings.CheckProjectLogStatus';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - CMDS #####################################

#### CATEGORY : "PROCCESSING COMMANDS"

## SUB-CATEGORY : "GETTING COMMAND OUTPUTS"

alias BU.GetCommandPath='BU.Main.CMDS.GetCommandPath';
alias BU.GetCommandReturnOutputValue='BU.Main.CMDS.GetCommandReturnOutputValue';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING ALIASES - COLORS ####################################

#### CATEGORY : "COLORS"

## SUB-CATEGORY : "GETTING COLOR CODES FROM FILES"

alias BU.Col.CannotCreateRessource='BU.Main.TextFormat.CannotCreateRessource';
alias BU.GetBGColorCMD='BU.Main.TextFormat.GetBGColorFromCMD';
alias BU.GetTextColorFromCMD='BU.Main.TextFormat.GetTextColorFromCMD';

# -----------------------------------------------

## SUB-CATEGORY : "SETTING COLOR CODES IN FILES"

alias BU.SetBGColor='BU.Main.TextFormat.SetBGColor';
alias BU.SetTextColor='BU.Main.TextFormat.SetTextColor';

# -----------------------------------------------

## SUB-CATEGORY : "COLORS STRINGS PROCESSING FUNCTIONS"

alias BU.ColAtoi='BU.Main.TextFormat.Atoi';
alias BU.ColItoa='BU.Main.TextFormat.Itoa';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "TEXT"

## SUB-CATEGORY : SETTING TEXT FORMAT

alias BU.CheckTextFormat='BU.Main.TextFormat.SetTextFormat';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - DECHO ####################################

#### CATEGORY : "TEXT WRITING AND DECORATION (FORMATTING)"

## SUB-CATEGORY : "WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - BASIS"

#
alias BU.Main.Decho.Decho='BU.Main.Decho.Decho';

# -----------------------------------------------

## SUB-CATEGORY : "WRITING DIFFERENTLY COLORED/FORMATTED TEXT BETWEEN TEXT - LIST"

alias BU.DechoAqua='BU.Main.Decho.Decho.Aqua';
alias BU.DechoBlue='BU.Main.Decho.Decho.Blue';

alias BU.DechoCyan='BU.Main.Decho.Decho.Cyan';
alias BU.DechoFuchsia='BU.Main.Decho.Decho.Fuchsia';
alias BU.DechoGray='BU.Main.Decho.Decho.Gray';

alias BU.DechoGreen='BU.Main.Decho.Decho.Green';
alias BU.DechoLime='BU.Main.Decho.Decho.Lime';
alias BU.DechoMaroon='BU.Main.Decho.Decho.Maroon';

alias BU.DechoNavy='BU.Main.Decho.Decho.Navy';
alias BU.DechoOlive='BU.Main.Decho.Decho.Olive';
alias BU.DechoOrange='BU.Main.Decho.Decho.Orange';

alias BU.DechoPink='BU.Main.Decho.Decho.Pink';
alias BU.DechoPurple='BU.Main.Decho.Decho.Purple';
alias BU.DechoRed='BU.Main.Decho.Decho.Red';

alias BU.DechoSalmon='BU.Main.Decho.Decho.Salmon';
alias BU.DechoSilver='BU.Main.Decho.Decho.Silver';
alias BU.DechoTan='BU.Main.Decho.Decho.Tan';

alias BU.DechoTeal='BU.Main.Decho.Decho.Teal';
alias BU.DechoTurquoise='BU.Main.Decho.Decho.Turquoise';
alias BU.DechoViolet='BU.Main.Decho.Decho.Violet';

alias BU.DechoWhite='BU.Main.Decho.Decho.White';
alias BU.DechoYellow='BU.Main.Decho.Decho.Yellow';


alias BU.DechoHighlight='BU.Main.Decho.Decho.Highlight';
alias BU.DechoHighlightCMD='BU.Main.Decho.Decho.CMD';
alias BU.DechoHighlightError='BU.Main.Decho.Decho.Error';

alias BU.DechoHighlightFunction='BU.Main.Decho.Decho.Function';
alias BU.DechoHighlightNewstep='BU.Main.Decho.Decho.Newstep';
alias BU.DechoHighlightPath='BU.Main.Decho.Decho.Path';

alias BU.DechoHighlightSuccess='BU.Main.Decho.Decho.Success';
alias BU.DechoHighlightVar='BU.Main.Decho.Decho.Var';
alias BU.DechoHighlightWarning='BU.Main.Decho.Decho.Warning';


alias BU.DechoBGColor='BU.Main.Headers.Header.';

# Easy "BU.__Decho()" alias calls with colors.
alias BU.__DechoAqua='BU.Main.Decho.__Decho.Aqua';
alias BU.__DechoBlack='BU.Main.Decho.__Decho.Black';
alias BU.__DechoBlue='BU.Main.Decho.__Decho.Blue';

alias BU.__DechoCyan='BU.Main.Decho.__Decho.Cyan';
alias BU.__DechoFuchsia='BU.Main.Decho.__Decho.Fuchsia';
alias BU.__DechoGray='BU.Main.Decho.__Decho.Gray';

alias BU.__DechoGreen='BU.Main.Decho.__Decho.Green';
alias BU.__DechoLime='BU.Main.Decho.__Decho.Lime';
alias BU.__DechoMaroon='BU.Main.Decho.__Decho.Maroon';

alias BU.__DechoNavy='BU.Main.Decho.__Decho.Navy';
alias BU.__DechoOlive='BU.Main.Decho.__Decho.Olive';
alias BU.__DechoOrange='BU.Main.Decho.__Decho.Orange';

alias BU.__DechoPink='BU.Main.Decho.__Decho.Pink';
alias BU.__DechoPurple='BU.Main.Decho.__Decho.Purple';
alias BU.__DechoRed='BU.Main.Decho.__Decho.Red';

alias BU.__DechoSalmon='BU.Main.Decho.__Decho.Salmon';
alias BU.__DechoSilver='BU.Main.Decho.__Decho.Silver';
alias BU.__DechoTan='BU.Main.Decho.__Decho.Tan';

alias BU.__DechoTeal='BU.Main.Decho.__Decho.Teal';
alias BU.__DechoTurquoise='BU.Main.Decho.__Decho.Turquoise';
alias BU.__DechoViolet='BU.Main.Decho.__Decho.Violet';

alias BU.__DechoWhite='BU.Main.Decho.__Decho.White';
alias BU.__DechoYellow='BU.Main.Decho.__Decho.Yellow';

# Easy "BU.__Decho()" alias calls with specific text display colors.
alias BU.__DechoHighlight='BU.Main.Decho.__Decho.Highlight';
alias BU.__DechoHighlightCMD='BU.Main.Decho.__Decho.CMD';
alias BU.__DechoHighlightError='BU.Main.Decho.__Decho.Error';

alias BU.__DechoHighlightFunction='BU.Main.Decho.__Decho.Function';
alias BU.__DechoHighlightNewstep='BU.Main.Decho.__Decho.Newstep';
alias BU.__DechoHighlightPath='BU.Main.Decho.__Decho.Path';

alias BU.__DechoHighlightSuccess='BU.Main.Decho.__Decho.Success';
alias BU.__DechoHighlightVar='BU.Main.Decho.__Decho.Var';
alias BU.__DechoHighlightWarning='BU.Main.Decho.__Decho.Warning';

# Blink formatting.
alias BU.Decho_FMT_Blink='BU.Main.Decho.Decho.FMT_Blink';
alias BU.Decho_FMT_BlinkBold='BU.Main.Decho.Decho.FMT_BlinkBold';
alias BU.Decho_FMT_BlinkBoldD='BU.Main.Decho.Decho.FMT_BlinkBoldD';
alias BU.Decho_FMT_BlinkBoldDI='BU.Main.Decho.Decho.FMT_BlinkBoldDI';
alias BU.Decho_FMT_BlinkBoldDIS='BU.Main.Decho.Decho.FMT_BlinkBoldDIS';
alias BU.Decho_FMT_BlinkBoldDISU='BU.Main.Decho.Decho.FMT_BlinkBoldDISU';
alias BU.Decho_FMT_BlinkBoldDIU='BU.Main.Decho.Decho.FMT_BlinkBoldDIU';
alias BU.Decho_FMT_BlinkBoldDS='BU.Main.Decho.Decho.FMT_BlinkBoldDS';
alias BU.Decho_FMT_BlinkBoldDSU='BU.Main.Decho.Decho.FMT_BlinkBoldDSU';
alias BU.Decho_FMT_BlinkBoldDU='BU.Main.Decho.Decho.FMT_BlinkBoldDU';
alias BU.Decho_FMT_BlinkBoldI='BU.Main.Decho.Decho.FMT_BlinkBoldI';
alias BU.Decho_FMT_BlinkBoldIS='BU.Main.Decho.Decho.FMT_BlinkBoldIS';
alias BU.Decho_FMT_BlinkBoldISU='BU.Main.Decho.Decho.FMT_BlinkBoldISU';
alias BU.Decho_FMT_BlinkBoldIU='BU.Main.Decho.Decho.FMT_BlinkBoldIU';
alias BU.Decho_FMT_BlinkBoldS='BU.Main.Decho.Decho.FMT_BlinkBoldS';
alias BU.Decho_FMT_BlinkBoldSU='BU.Main.Decho.Decho.FMT_BlinkBoldSU';
alias BU.Decho_FMT_BlinkBoldU='BU.Main.Decho.Decho.FMT_BlinkBoldU';
alias BU.Decho_FMT_BlinkD='BU.Main.Decho.Decho.FMT_BlinkD';
alias BU.Decho_FMT_BlinkDI='BU.Main.Decho.Decho.FMT_BlinkDI';
alias BU.Decho_FMT_BlinkDIS='BU.Main.Decho.Decho.FMT_BlinkDIS';
alias BU.Decho_FMT_BlinkDISU='BU.Main.Decho.Decho.FMT_BlinkDISU';
alias BU.Decho_FMT_BlinkDIU='BU.Main.Decho.Decho.FMT_BlinkDIU';
alias BU.Decho_FMT_BlinkDS='BU.Main.Decho.Decho.FMT_BlinkDS';
alias BU.Decho_FMT_BlinkDSU='BU.Main.Decho.Decho.FMT_BlinkDSU';
alias BU.Decho_FMT_BlinkDU='BU.Main.Decho.Decho.FMT_BlinkDU';
alias BU.Decho_FMT_BlinkI='BU.Main.Decho.Decho.FMT_BlinkI';
alias BU.Decho_FMT_BlinkIS='BU.Main.Decho.Decho.FMT_BlinkIS';
alias BU.Decho_FMT_BlinkISU='BU.Main.Decho.Decho.FMT_BlinkISU';
alias BU.Decho_FMT_BlinkIU='BU.Main.Decho.Decho.FMT_BlinkIU';
alias BU.Decho_FMT_BlinkS='BU.Main.Decho.Decho.FMT_BlinkS';
alias BU.Decho_FMT_BlinkSU='BU.Main.Decho.Decho.FMT_BlinkSU';
alias BU.Decho_FMT_BlinkU='BU.Main.Decho.Decho.FMT_BlinkU';

# Bold formatting.
alias BU.Decho_FMT_Bold='BU.Main.Decho.Decho.FMT_Bold';
alias BU.Decho_FMT_BoldD='BU.Main.Decho.Decho.FMT_BoldD';
alias BU.Decho_FMT_BoldDI='BU.Main.Decho.Decho.FMT_BoldDI';
alias BU.Decho_FMT_BoldDIS='BU.Main.Decho.Decho.FMT_BoldDIS';
alias BU.Decho_FMT_BoldDISU='BU.Main.Decho.Decho.FMT_BoldDISU';
alias BU.Decho_FMT_BoldDIU='BU.Main.Decho.Decho.FMT_BoldDIU';
alias BU.Decho_FMT_BoldDS='BU.Main.Decho.Decho.FMT_BoldDS';
alias BU.Decho_FMT_BoldDSU='BU.Main.Decho.Decho.FMT_BoldDSU';
alias BU.Decho_FMT_BoldDU='BU.Main.Decho.Decho.FMT_BoldU';
alias BU.Decho_FMT_BoldI='BU.Main.Decho.Decho.FMT_BoldI';
alias BU.Decho_FMT_BoldIS='BU.Main.Decho.Decho.FMT_BoldIS';
alias BU.Decho_FMT_BoldISU='BU.Main.Decho.Decho.FMT_BoldISU';
alias BU.Decho_FMT_BoldIU='BU.Main.Decho.Decho.FMT_BoldIU';
alias BU.Decho_FMT_BoldS='BU.Main.Decho.Decho.FMT_BoldS';
alias BU.Decho_FMT_BoldSU='BU.Main.Decho.Decho.FMT_BoldSU';
alias BU.Decho_FMT_BoldU='BU.Main.Decho.Decho.FMT_BoldU';

# Dim formatting
alias BU.Decho_FMT_D='BU.Main.Decho.Decho.FMT_D';
alias BU.Decho_FMT_DI='BU.Main.Decho.Decho.FMT_DI';
alias BU.Decho_FMT_DIS='BU.Main.Decho.Decho.FMT_DIS';
alias BU.Decho_FMT_DISU='BU.Main.Decho.Decho.FMT_DISU';
alias BU.Decho_FMT_DIU='BU.Main.Decho.Decho.FMT_DIU';
alias BU.Decho_FMT_DS='BU.Main.Decho.Decho.FMT_DS';
alias BU.Decho_FMT_DSU='BU.Main.Decho.Decho.FMT_DSU';
alias BU.Decho_FMT_DU='BU.Main.Decho.Decho.FMT_DU';

# Italic formatting.
alias BU.Decho_FMT_I='BU.Main.Decho.Decho.FMT_I';
alias BU.Decho_FMT_IS='BU.Main.Decho.Decho.FMT_IS';
alias BU.Decho_FMT_ISU='BU.Main.Decho.Decho.FMT_ISU';
alias BU.Decho_FMT_IU='BU.Main.Decho.Decho.FMT_IU';

# Strikethrough formatting.
alias BU.Decho_FMT_S='BU.Main.Decho.Decho.FMT_S';
alias BU.Decho_FMT_SU='BU.Main.Decho.Decho.FMT_SU';

# Underline formatting.
alias BU.Decho_FMT_U='BU.Main.Decho.Decho.FMT_U';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING ALIASES - DIRECTORIES #################################

#### CATEGORY : "DIRECTORIES FUNCTIONS"

## SUB-CATEGORY : "PROCESSING FUNCTIONS"

alias BU.ProcessingDir='BU.Main.Directories.ProcessingDir';
alias BU.OverwriteDir='BU.Main.Directories.OverwriteDir';
alias BU.Make='BU.Main.Directories.Make';
alias BU.MakePath='BU.Main.Directories.MakePath';
alias BU.MkTmpDir='BU.Main.Directories.MkTmpDir';

# -----------------------------------------------

## SUB-CATEGORY : "PATH PROCESSING"
alias BU.GetDirectoryName='BU.Main.Directories.GetDirectoryName';
alias BU.GetDirectoryPath='BU.Main.Directories.GetDirectoryPath';
alias BU.GetParentDirectoryName='BU.Main.Directories.GetParentDirectoryName';
alias BU.GetParentDirectoryPath='BU.Main.Directories.GetParentDirectoryPath';
alias BU.TriggerRootDirWarning='BU.Main.Directories.TriggerRootDirWarning';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - ECHO #####################################

#### CATEGORY : "PRINTING FORMATTED STRINGS"

## SUB-CATEGORY : "DEBUGGING"

alias BU.__Debug='BU.Main.Echo.__Debug';
alias BU.DebugEnd='BU.Main.Echo.DebugEnd';
alias BU.Debug='BU.Main.Echo.Debug';
alias BU.__EchoVoid='BU.Main.Echo.__EchoVoid';
alias BU.__EchoOutput='BU.Main.Echo.__EchoOutput';
alias BU.__EchoCPLS='BU.Main.Echo.__EchoCPLS';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "TEST DISPLAYING"

## SUB-CATEGORY : "DISPLAYING A CONTEXT MESSAGE"

alias BU.EchoError='BU.Main.Echo.Error';
alias BU.EchoMsg='BU.Main.Echo.Msg';
alias BU.EchoNewstep='BU.Main.Echo.Newstep';
alias BU.EchoSuccess='BU.Main.Echo.Success';
alias BU.EchoWarning='BU.Main.Echo.Warning';
alias BU.Newline='BU.Main.Echo.Newline';

# -----------------------------------------------

## SUB-CATEGORY : "DISPLAYING A COLORED MESSAGE"

alias BU.EchoAqua='BU.Main.Echo.Aqua';
alias BU.EchoBlack='BU.Main.Echo.Black';
alias BU.EchoBlue='BU.Main.Echo.Blue';

alias BU.EchoCyan='BU.Main.Echo.Cyan';
alias BU.EchoFuchsia='BU.Main.Echo.Fuchsia';
alias BU.EchoGray='BU.Main.Echo.Gray';

alias BU.EchoGreen='BU.Main.Echo.Green';
alias BU.EchoLime='BU.Main.Echo.Lime';
alias BU.EchoMaroon='BU.Main.Echo.Maroon';

alias BU.EchoNavy='BU.Main.Echo.Navy';
alias BU.EchoOlive='BU.Main.Echo.Olive';
alias BU.EchoOrange='BU.Main.Echo.Orange';

alias BU.EchoPink='BU.Main.Echo.Pink';
alias BU.EchoPurple='BU.Main.Echo.Purple';
alias BU.EchoRed='BU.Main.Echo.Red';

alias BU.EchoSalmon='BU.Main.Echo.Salmon';
alias BU.EchoSilver='BU.Main.Echo.Silver';
alias BU.EchoTan='BU.Main.Echo.Tan';

alias BU.EchoTeal='BU.Main.Echo.Teal';
alias BU.EchoTurquoise='BU.Main.Echo.Turquoise';
alias BU.EchoViolet='BU.Main.Echo.Violet';

alias BU.EchoWhite='BU.Main.Echo.White';
alias BU.EchoYellow='BU.Main.Echo.Yellow';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "LINE BREAKS"

## SUB-CATEGORY : "LINE BREAKS ACCORDING TO THE ''${__BU_MAIN_PROJECT_LOG_FILE_PATH}'' VARIABLE VALUE"

alias BU.Newline='BU.Main.Echo.Newline';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING ALIASES - ERRORS ####################################

#### CATEGORY : "ERRORS HANDLING FUNCTIONS"

## SUB-CATEGORY : "CLASSIC ERRORS HANDLING"

alias BU.HandleSmallErrors='BU.Main.Errors.HandleSmallErrors';

# -----------------------------------------------

## SUB-CATEGORY : "EXIT AND RETURN CODES HANDLING"

alias BU.Exit='BU.Main.Errors.Exit';

# -----------------------------------------------

## SUB-CATEGORY : "SCRIPT'S ERRORS HANDLING"

alias BU.HandleErrors_File='BU.Main.Errors.HandleErrors_File';
alias BU.HandleErrors_Function='BU.Main.Errors.HandleErrors_Function';
alias BU.HandleErrors_Line='BU.Main.Errors.HandleErrors_Line';
alias BU.HandleErrors='BU.Main.Errors.HandleErrors';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - FILES ####################################

#### CATEGORY : "FILES PROCESSING FUNCTIONS"

## SUB-CATEGORY : "PROCESSING FUNCTIONS"

alias BU.__ProcessingFile='BU.Main.Files.__ProcessingFile';
alias BU.ProcessingFile='BU.Main.Files.ProcessingFile';

# -----------------------------------------------

## SUB-CATEGORY : "FILE CREATION FUNCTIONS"

alias BU.OverwriteFile='BU.Main.Files.OverwriteFile';
alias BU.Make='BU.Main.Files.Make';
alias BU.MakePath='BU.Main.Files.MakePath';
alias BU.MakeFileInMemory='BU.Main.Files.MakeFileInMemory';
alias BU.CreateProjectLogFile='BU.Main.Files.CreateProjectLogFile';

# -----------------------------------------------

## SUB-CATEGORY : "FILE DELETION FUNCTIONS"

alias BU.DeleteFile='BU.Main.Files.DeleteFile';

# -----------------------------------------------

## CHECKING FILE INFORMATIONS
## DEBUG ID : checking-file-informations

alias BU.IsFileReadOnly='BU.Main.Files.IsReadOnly';
alias BU.IsFileRW='BU.Main.Files.IsRW';
alias BU.IsFileRWX='BU.Main.Files.IsRWX';
alias BU.IsFileRX='BU.Main.Files.IsRX';
alias BU.IsFileWriteOnly='BU.Main.Files.IsWriteOnly';
alias BU.IsFileWX='BU.Main.Files.IsWX';
alias BU.IsFileExecutableOnly='BU.Main.Files.IsExecutableOnly';

# -----------------------------------------------

## SUB-CATEGORY : "GETTING FILE INFORMATIONS"

alias BU.GetByteSize='BU.Main.Files.GetByteSize';
alias BU.GetCreationDate='BU.Main.Files.GetCreationDate';
alias BU.GetCharactersNumber='BU.Main.Files.GetCharactersNumber';
alias BU.GetExtension='BU.Main.Files.GetExtension';
alias BU.GetLastAccess='BU.Main.Files.GetLastAccess';
alias BU.GetLastModification='BU.Main.Files.GetLastModification';
alias BU.GetMIMEType='BU.Main.Files.GetMIMEType';
alias BU.GetLinesNumber='BU.Main.Files.GetLinesNumber';
alias BU.GetMaxLineLength='BU.Main.Files.GetMaxLineLength';
alias BU.GetOwnerName='BU.Main.Files.GetOwnerName';
alias BU.GetOwnerGroup='BU.Main.Files.GetOwnerGroup';
alias BU.GetWordsNumber='BU.Main.Files.GetWordsNumber';

# -----------------------------------------------

## SUB-CATEGORY : "SETTING FILE INFORMATIONS"

alias BU.SetFileLastAccess='BU.Main.File.SetFileLastAccess';

# -----------------------------------------------

## SUB-CATEGORY : "FILE SOURCING"

alias BU.SourceFile='BU.Main.Files.SourceFile';

# -----------------------------------------------

## SUB-CATEGORY : "TEXT FILE PARSING"

alias BU.GetLineFromTextFile='BU.Main.Files.GetLineFromTextFile';

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "ARCHIVES PROCESSING FUNCTIONS"

## SUB-CATEGORY : "(UN)COMPRESSION FUNCTIONS"

alias BU.AddToArchive='BU.Main.Files.AddToArchive';
alias BU.CompressCMD='BU.Main.Files.CompressCMD';
alias BU.CompressFormat='BU.Main.Files.CompressFormat';
alias BU.DeleteInArchive='BU.Main.Files.DeleteInArchive';
alias BU.SearchInArchive='BU.Main.Files.SearchInArchive';
alias BU.UncompressCMD='BU.Main.Files.UncompressCMD';
alias BU.UncompressFormat='BU.Main.Files.UncompressFormat';
alias BU.UncompressFormat.ErrorMsg='BU.Main.Files.UncompressFormat.ErrorMsg';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING ALIASES - FILESYSTEM ##################################

#### CATEGORY : "HARD DRIVE'S FILE SYSTEM PROCESSING"

## SUB-CATEGORY : "CHECKING FILE SYSTEM'S INFORMATIONS"

alias BU.IsPartitionFull='BU.Main.Filesystem.IsPartitionFull';
alias BU.GetFSDevice='BU.Main.Filesystem.GetFSDevice';
alias BU.GetFSTotalSize='BU.Main.Filesystem.GetFSTotalSize';
alias BU.GetFSMountPoint='BU.Main.Filesystem.GetFSMountPoint';
alias BU.GetFSUsedSizeBytes='BU.Main.Filesystem.GetFSUsedSizeBytes';
alias BU.GetFSUsedSizePercent='BU.Main.Filesystem.GetFSUsedSizePercent';
alias BU.GetFSAvailableSize='BU.Main.Filesystem.GetFSAvailableSize';
alias BU.GetFSType='BU.Main.Filesystem.GetFSType';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "PERMISSION AND OWNERSHIP PROCESSING"

## SUB-CATEGORY : "NON-RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"

alias BU.Chown='BU.Main.Filesystem.Chown';

# -----------------------------------------------

## SUB-CATEGORY : "RECURSIVE PERMISSION AND OWNERSHIP PROCESSING"

alias BU.ChownRec='BU.Main.Filesystem.ChownRec';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING ALIASES - HEADERS ###################################

#### CATEGORY : ""

# SUB-CATEGORY : "UNICOLOR HEADERS"

alias BU.Header='BU.Main.Headers.Header.';
alias BU.HeaderError='BU.Main.Headers.Header.Error';
alias BU.HeaderInstall='BU.Main.Headers.Header.Install';
alias BU.HeaderNewstep='BU.Main.Headers.Header.Newstep';
alias BU.HeaderStep='BU.Main.Headers.Header.Step';
alias BU.HeaderSuccess='BU.Main.Headers.Header.Success';
alias BU.HeaderWarning='BU.Main.Headers.Header.Warning';

# -----------------------------------------------

# OLD COLORS (BEFORE 2022 01 07)

# Strings
alias BU.HeaderBlack='BU.Main.Headers.Header.Black';
alias BU.HeaderBlue='BU.Main.Headers.Header.Blue';
alias BU.HeaderCyan='BU.Main.Headers.Header.Cyan';

alias BU.HeaderGray='BU.Main.Headers.Header.Gray';
alias BU.HeaderGreen='BU.Main.Headers.Header.Green';
alias BU.HeaderOrange='BU.Main.Headers.Header.Orange';

alias BU.HeaderPink='BU.Main.Headers.Header.Pink';
alias BU.HeaderPurple='BU.Main.Headers.Header.Purple';
alias BU.HeaderRed='BU.Main.Headers.Header.Red';

alias BU.HeaderTurquoise='BU.Main.Headers.Header.Turquoise';
alias BU.HeaderWhite='BU.Main.Headers.Header.White';
alias BU.HeaderYellow='BU.Main.Headers.Header.Yellow';

# Command substitutions
alias BU.HeaderBlackCMD='BU.Main.Headers.Header.CMD.Black';
alias BU.HeaderBlueCMD='BU.Main.Headers.Header.CMD.Blue';
alias BU.HeaderCyanCMD='BU.Main.Headers.Header.CMD.Cyan';

alias BU.HeaderGrayCMD='BU.Main.Headers.Header.CMD.Gray';
alias BU.HeaderGreenCMD='BU.Main.Headers.Header.CMD.Green';
alias BU.HeaderOrangeCMD='BU.Main.Headers.Header.CMD.Orange';

alias BU.HeaderPinkCMD='BU.Main.Headers.Header.CMD.Pink';
alias BU.HeaderPurpleCMD='BU.Main.Headers.Header.CMD.Purple';
alias BU.HeaderRedCMD='BU.Main.Headers.Header.CMD.Red';

alias BU.HeaderTurquoiseCMD='BU.Main.Headers.Header.CMD.Turquoise';
alias BU.HeaderWhiteCMD='BU.Main.Headers.Header.CMD.White';
alias BU.HeaderYellowCMD='BU.Main.Headers.Header.CMD.Yellow';

# -----------------------------------------------

# NEW COLORS (SINCE 2022 01 07)

# Strings
alias BU.HeaderAqua='BU.Main.Headers.Header.Aqua';
alias BU.HeaderFuchsia='BU.Main.Headers.Header.Fuchsia';
alias BU.HeaderLime='BU.Main.Headers.Header.Lime';

alias BU.HeaderMaroon='BU.Main.Headers.Header.Maroon';
alias BU.HeaderNavy='BU.Main.Headers.Header.Navy';
alias BU.HeaderOlive='BU.Main.Headers.Header.Olive';

alias BU.HeaderSalmon='BU.Main.Headers.Header.Salmon';
alias BU.HeaderSilver='BU.Main.Headers.Header.Silver';
alias BU.HeaderTan='BU.Main.Headers.Header.Tan';

alias BU.HeaderTeal='BU.Main.Headers.Header.Teal';
alias BU.HeaderViolet='BU.Main.Headers.Header.Violet';

# Command substitutions
alias BU.HeaderAquaCMD='BU.Main.Headers.Header.CMD.Aqua';
alias BU.HeaderFuchsiaCMD='BU.Main.Headers.Header.CMD.Fuchsia';
alias BU.HeaderLimeCMD='BU.Main.Headers.Header.CMD.Lime';

alias BU.HeaderMaroonCMD='BU.Main.Headers.Header.CMD.Maroon';
alias BU.HeaderNavyCMD='BU.Main.Headers.Header.CMD.Navy';
alias BU.HeaderOliveCMD='BU.Main.Headers.Header.CMD.Olive';

alias BU.HeaderSalmonCMD='BU.Main.Headers.Header.CMD.Salmon';
alias BU.HeaderSilverCMD='BU.Main.Headers.Header.CMD.Silver';
alias BU.HeaderTanCMD='BU.Main.Headers.Header.CMD.Tan';

alias BU.HeaderTealCMD='BU.Main.Headers.Header.CMD.Teal';
alias BU.HeaderVioletCMD='BU.Main.Headers.Header.CMD.Violet';

# -----------------------------------------------

## BICOLOR HEADERS

# Copy-paste this alias to avoid losing time while creating bicolor headers :
# alias BU.Header<col1><col2>   { BU.HeaderBase "${__BU_MAIN_COLOR_<COLOR1>}" "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" "${__BU_MAIN_COLOR_<COLOR2>}"

## AQUA BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderAquaBlack='BU.Main.Headers.Header.Aqua.Black';
alias BU.HeaderAquaBlue='BU.Main.Headers.Header.Aqua.Blue';
alias BU.HeaderAquaCyan='BU.Main.Headers.Header.Aqua.Cyan';

alias BU.HeaderAquaFuchsia='BU.Main.Headers.Header.Aqua.Fuchsia';
alias BU.HeaderAquaGray='BU.Main.Headers.Header.Aqua.Gray';
alias BU.HeaderAquaGreen='BU.Main.Headers.Header.Aqua.Green';

alias BU.HeaderAquaLime='BU.Main.Headers.Header.Aqua.Lime';
alias BU.HeaderAquaMaroon='BU.Main.Headers.Header.Aqua.Maroon';
alias BU.HeaderAquaNavy='BU.Main.Headers.Header.Aqua.Navy';

alias BU.HeaderAquaOlive='BU.Main.Headers.Header.Aqua.Olive';
alias BU.HeaderAquaOrange='BU.Main.Headers.Header.Aqua.Orange';
alias BU.HeaderAquaPink='BU.Main.Headers.Header.Aqua.Pink';

alias BU.HeaderAquaPurple='BU.Main.Headers.Header.Aqua.Purple';
alias BU.HeaderAquaRed='BU.Main.Headers.Header.Aqua.Red';
alias BU.HeaderAquaSalmon='BU.Main.Headers.Header.Aqua.Salmon';

alias BU.HeaderAquaSilver='BU.Main.Headers.Header.Aqua.Silver';
alias BU.HeaderAquaTan='BU.Main.Headers.Header.Aqua.Tan';
alias BU.HeaderAquaTeal='BU.Main.Headers.Header.Aqua.Teal';

alias BU.HeaderAquaTurquoise='BU.Main.Headers.Header.Aqua.Turquoise';
alias BU.HeaderAquaViolet='BU.Main.Headers.Header.Aqua.Violet';
alias BU.HeaderAquaWhite='BU.Main.Headers.Header.Aqua.White';

alias BU.HeaderAquaYellow='BU.Main.Headers.Header.Aqua.Yellow';

# Command substitutions
alias BU.HeaderAquaBlackCMD='BU.Main.Headers.Header.CMD.Aqua.Black';
alias BU.HeaderAquaBlueCMD='BU.Main.Headers.Header.CMD.Aqua.Blue';
alias BU.HeaderAquaCyanCMD='BU.Main.Headers.Header.CMD.Aqua.Cyan';

alias BU.HeaderAquaFuchsiaCMD='BU.Main.Headers.Header.CMD.Aqua.Fuchsia';
alias BU.HeaderAquaGrayCMD='BU.Main.Headers.Header.CMD.Aqua.Gray';
alias BU.HeaderAquaGreenCMD='BU.Main.Headers.Header.CMD.Aqua.Green';

alias BU.HeaderAquaLimeCMD='BU.Main.Headers.Header.CMD.Aqua.Lime';
alias BU.HeaderAquaMaroonCMD='BU.Main.Headers.Header.CMD.Aqua.Maroon';
alias BU.HeaderAquaNavyCMD='BU.Main.Headers.Header.CMD.Aqua.Navy';

alias BU.HeaderAquaOliveCMD='BU.Main.Headers.Header.CMD.Aqua.Olive';
alias BU.HeaderAquaOrangeCMD='BU.Main.Headers.Header.CMD.Aqua.Orange';
alias BU.HeaderAquaPinkCMD='BU.Main.Headers.Header.CMD.Aqua.Pink';

alias BU.HeaderAquaPurpleCMD='BU.Main.Headers.Header.CMD.Aqua.Purple';
alias BU.HeaderAquaRedCMD='BU.Main.Headers.Header.CMD.Aqua.Red';
alias BU.HeaderAquaSalmonCMD='BU.Main.Headers.Header.CMD.Aqua.Salmon';

alias BU.HeaderAquaSilverCMD='BU.Main.Headers.Header.CMD.Aqua.Silver';
alias BU.HeaderAquaTanCMD='BU.Main.Headers.Header.CMD.Aqua.Tan';
alias BU.HeaderAquaTealCMD='BU.Main.Headers.Header.CMD.Aqua.Teal';

alias BU.HeaderAquaTurquoiseCMD='BU.Main.Headers.Header.CMD.Aqua.Turquoise';
alias BU.HeaderAquaVioletCMD='BU.Main.Headers.Header.CMD.Aqua.Violet';
alias BU.HeaderAquaWhiteCMD='BU.Main.Headers.Header.CMD.Aqua.White';

alias BU.HeaderAquaYellowCMD='BU.Main.Headers.Header.CMD.Aqua.Yellow';

# -----------------------------------------------

## BLACK LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderBlackAqua='BU.Main.Headers.Header.Black.Aqua';
alias BU.HeaderBlackBlue='BU.Main.Headers.Header.Black.Blue';
alias BU.HeaderBlackCyan='BU.Main.Headers.Header.Black.Cyan';

alias BU.HeaderBlackFuchsia='BU.Main.Headers.Header.Black.Fuchsia';
alias BU.HeaderBlackGray='BU.Main.Headers.Header.Black.Gray';
alias BU.HeaderBlackGreen='BU.Main.Headers.Header.Black.Green';

alias BU.HeaderBlackLime='BU.Main.Headers.Header.Black.Lime';
alias BU.HeaderBlackMaroon='BU.Main.Headers.Header.Black.Maroon';
alias BU.HeaderBlackNavy='BU.Main.Headers.Header.Black.Navy';

alias BU.HeaderBlackOlive='BU.Main.Headers.Header.Black.Olive';
alias BU.HeaderBlackOrange='BU.Main.Headers.Header.Black.Orange';
alias BU.HeaderBlackPink='BU.Main.Headers.Header.Black.Pink';

alias BU.HeaderBlackPurple='BU.Main.Headers.Header.Black.Purple';
alias BU.HeaderBlackRed='BU.Main.Headers.Header.Black.Red';
alias BU.HeaderBlackSalmon='BU.Main.Headers.Header.Black.Salmon';

alias BU.HeaderBlackSilver='BU.Main.Headers.Header.Black.Silver';
alias BU.HeaderBlackTan='BU.Main.Headers.Header.Black.Tan';
alias BU.HeaderBlackTeal='BU.Main.Headers.Header.Black.Teal';

alias BU.HeaderBlackTurquoise='BU.Main.Headers.Header.Black.Turquoise';
alias BU.HeaderBlackViolet='BU.Main.Headers.Header.Black.Violet';
alias BU.HeaderBlackWhite='BU.Main.Headers.Header.Black.White';

alias BU.HeaderBlackYellow='BU.Main.Headers.Header.Black.Yellow';

# Command substitutions
alias BU.HeaderBlackAquaCMD='BU.Main.Headers.Header.CMD.Black.Aqua';
alias BU.HeaderBlackBlueCMD='BU.Main.Headers.Header.CMD.Black.Blue';
alias BU.HeaderBlackCyanCMD='BU.Main.Headers.Header.CMD.Black.Cyan';

alias BU.HeaderBlackFuchsiaCMD='BU.Main.Headers.Header.CMD.Black.Fuchsia';
alias BU.HeaderBlackGrayCMD='BU.Main.Headers.Header.CMD.Black.Gray';
alias BU.HeaderBlackGreenCMD='BU.Main.Headers.Header.CMD.Black.Green';

alias BU.HeaderBlackLimeCMD='BU.Main.Headers.Header.CMD.Black.Lime';
alias BU.HeaderBlackMaroonCMD='BU.Main.Headers.Header.CMD.Black.Maroon';
alias BU.HeaderBlackNavyCMD='BU.Main.Headers.Header.CMD.Black.Navy';

alias BU.HeaderBlackOliveCMD='BU.Main.Headers.Header.CMD.Black.Olive';
alias BU.HeaderBlackOrangeCMD='BU.Main.Headers.Header.CMD.Black.Orange';
alias BU.HeaderBlackPinkCMD='BU.Main.Headers.Header.CMD.Black.Pink';

alias BU.HeaderBlackPurpleCMD='BU.Main.Headers.Header.CMD.Black.Purple';
alias BU.HeaderBlackRedCMD='BU.Main.Headers.Header.CMD.Black.Red';
alias BU.HeaderBlackSalmonCMD='BU.Main.Headers.Header.CMD.Black.Salmon';

alias BU.HeaderBlackSilverCMD='BU.Main.Headers.Header.CMD.Black.Silver';
alias BU.HeaderBlackTanCMD='BU.Main.Headers.Header.CMD.Black.Tan';
alias BU.HeaderBlackTealCMD='BU.Main.Headers.Header.CMD.Black.Teal';

alias BU.HeaderBlackTurquoiseCMD='BU.Main.Headers.Header.CMD.Black.Turquoise';
alias BU.HeaderBlackVioletCMD='BU.Main.Headers.Header.CMD.Black.Violet';
alias BU.HeaderBlackWhiteCMD='BU.Main.Headers.Header.CMD.Black.White';

alias BU.HeaderBlackYellowCMD='BU.Main.Headers.Header.CMD.Black.Yellow';

# -----------------------------------------------

## BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderBlueAqua='BU.Main.Headers.Header.Blue.Aqua';
alias BU.HeaderBlueBlack='BU.Main.Headers.Header.Blue.Black';
alias BU.HeaderBlueCyan='BU.Main.Headers.Header.Blue.Cyan';

alias BU.HeaderBlueFuchsia='BU.Main.Headers.Header.Blue.Fuchsia';
alias BU.HeaderBlueGray='BU.Main.Headers.Header.Blue.Gray';
alias BU.HeaderBlueGreen='BU.Main.Headers.Header.Blue.Green';

alias BU.HeaderBlueLime='BU.Main.Headers.Header.Blue.Lime';
alias BU.HeaderBlueMaroon='BU.Main.Headers.Header.Blue.Maroon';
alias BU.HeaderBlueNavy='BU.Main.Headers.Header.Blue.Navy';

alias BU.HeaderBlueOlive='BU.Main.Headers.Header.Blue.Olive';
alias BU.HeaderBlueOrange='BU.Main.Headers.Header.Blue.Orange';
alias BU.HeaderBluePink='BU.Main.Headers.Header.Blue.Pink';

alias BU.HeaderBluePurple='BU.Main.Headers.Header.Blue.Purple';
alias BU.HeaderBlueRed='BU.Main.Headers.Header.Blue.Red';
alias BU.HeaderBlueSalmon='BU.Main.Headers.Header.Blue.Salmon';

alias BU.HeaderBlueSilver='BU.Main.Headers.Header.Blue.Silver';
alias BU.HeaderBlueTan='BU.Main.Headers.Header.Blue.Tan';
alias BU.HeaderBlueTeal='BU.Main.Headers.Header.Blue.Teal';

alias BU.HeaderBlueTurquoise='BU.Main.Headers.Header.Blue.Turquoise';
alias BU.HeaderBlueViolet='BU.Main.Headers.Header.Blue.Violet';
alias BU.HeaderBlueWhite='BU.Main.Headers.Header.Blue.White';

alias BU.HeaderBlueYellow='BU.Main.Headers.Header.Blue.Yellow';

# Command substitutions
alias BU.HeaderBlueAquaCMD='BU.Main.Headers.Header.CMD.Blue.Aqua';
alias BU.HeaderBlueBlackCMD='BU.Main.Headers.Header.CMD.Blue.Black';
alias BU.HeaderBlueCyanCMD='BU.Main.Headers.Header.CMD.Blue.Cyan';

alias BU.HeaderBlueFuchsiaCMD='BU.Main.Headers.Header.CMD.Blue.Fuchsia';
alias BU.HeaderBlueGrayCMD='BU.Main.Headers.Header.CMD.Blue.Gray';
alias BU.HeaderBlueGreenCMD='BU.Main.Headers.Header.CMD.Blue.Green';

alias BU.HeaderBlueLimeCMD='BU.Main.Headers.Header.CMD.Blue.Lime';
alias BU.HeaderBlueMaroonCMD='BU.Main.Headers.Header.CMD.Blue.Maroon';
alias BU.HeaderBlueNavyCMD='BU.Main.Headers.Header.CMD.Blue.Navy';

alias BU.HeaderBlueOliveCMD='BU.Main.Headers.Header.CMD.Blue.Olive';
alias BU.HeaderBlueOrangeCMD='BU.Main.Headers.Header.CMD.Blue.Orange';
alias BU.HeaderBluePinkCMD='BU.Main.Headers.Header.CMD.Blue.Pink';

alias BU.HeaderBluePurpleCMD='BU.Main.Headers.Header.CMD.Blue.Purple';
alias BU.HeaderBlueRedCMD='BU.Main.Headers.Header.CMD.Blue.Red';
alias BU.HeaderBlueSalmonCMD='BU.Main.Headers.Header.CMD.Blue.Salmon';

alias BU.HeaderBlueSilverCMD='BU.Main.Headers.Header.CMD.Blue.Silver';
alias BU.HeaderBlueTanCMD='BU.Main.Headers.Header.CMD.Blue.Tan';
alias BU.HeaderBlueTealCMD='BU.Main.Headers.Header.CMD.Blue.Teal';

alias BU.HeaderBlueTurquoiseCMD='BU.Main.Headers.Header.CMD.Blue.Turquoise';
alias BU.HeaderBlueVioletCMD='BU.Main.Headers.Header.CMD.Blue.Violet';
alias BU.HeaderBlueWhiteCMD='BU.Main.Headers.Header.CMD.Blue.White';

alias BU.HeaderBlueYellowCMD='BU.Main.Headers.Header.CMD.Blue.Yellow';

# -----------------------------------------------

## CYAN LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderCyanAqua='BU.Main.Headers.Header.Cyan.Aqua';
alias BU.HeaderCyanBlack='BU.Main.Headers.Header.Cyan.Black';
alias BU.HeaderCyanBlue='BU.Main.Headers.Header.Cyan.Blue';

alias BU.HeaderCyanFuchsia='BU.Main.Headers.Header.Cyan.Fuchsia';
alias BU.HeaderCyanGray='BU.Main.Headers.Header.Cyan.Gray';
alias BU.HeaderCyanGreen='BU.Main.Headers.Header.Cyan.Green';

alias BU.HeaderCyanLime='BU.Main.Headers.Header.Cyan.Lime';
alias BU.HeaderCyanMaroon='BU.Main.Headers.Header.Cyan.Maroon';
alias BU.HeaderCyanNavy='BU.Main.Headers.Header.Cyan.Navy';

alias BU.HeaderCyanOlive='BU.Main.Headers.Header.Cyan.Olive';
alias BU.HeaderCyanOrange='BU.Main.Headers.Header.Cyan.Orange';
alias BU.HeaderCyanPink='BU.Main.Headers.Header.Cyan.Pink';

alias BU.HeaderCyanPurple='BU.Main.Headers.Header.Cyan.Purple';
alias BU.HeaderCyanRed='BU.Main.Headers.Header.Cyan.Red';
alias BU.HeaderCyanSalmon='BU.Main.Headers.Header.Cyan.Salmon';

alias BU.HeaderCyanSilver='BU.Main.Headers.Header.Cyan.Silver';
alias BU.HeaderCyanTan='BU.Main.Headers.Header.Cyan.Tan';
alias BU.HeaderCyanTeal='BU.Main.Headers.Header.Cyan.Teal';

alias BU.HeaderCyanTurquoise='BU.Main.Headers.Header.Cyan.Turquoise';
alias BU.HeaderCyanViolet='BU.Main.Headers.Header.Cyan.Violet';
alias BU.HeaderCyanWhite='BU.Main.Headers.Header.Cyan.White';

alias BU.HeaderCyanYellow='BU.Main.Headers.Header.Cyan.Yellow';

# Command substitutions
alias BU.HeaderCyanAquaCMD='BU.Main.Headers.Header.CMD.Cyan.Aqua';
alias BU.HeaderCyanBlackCMD='BU.Main.Headers.Header.CMD.Cyan.Black';
alias BU.HeaderCyanBlueCMD='BU.Main.Headers.Header.CMD.Cyan.Blue';

alias BU.HeaderCyanFuchsiaCMD='BU.Main.Headers.Header.CMD.Cyan.Fuchsia';
alias BU.HeaderCyanGrayCMD='BU.Main.Headers.Header.CMD.Cyan.Gray';
alias BU.HeaderCyanGreenCMD='BU.Main.Headers.Header.CMD.Cyan.Green';

alias BU.HeaderCyanLimeCMD='BU.Main.Headers.Header.CMD.Cyan.Lime';
alias BU.HeaderCyanMaroonCMD='BU.Main.Headers.Header.CMD.Cyan.Maroon';
alias BU.HeaderCyanNavyCMD='BU.Main.Headers.Header.CMD.Cyan.Navy';

alias BU.HeaderCyanOliveCMD='BU.Main.Headers.Header.CMD.Cyan.Olive';
alias BU.HeaderCyanOrangeCMD='BU.Main.Headers.Header.CMD.Cyan.Orange';
alias BU.HeaderCyanPinkCMD='BU.Main.Headers.Header.CMD.Cyan.Pink';

alias BU.HeaderCyanPurpleCMD='BU.Main.Headers.Header.CMD.Cyan.Purple';
alias BU.HeaderCyanRedCMD='BU.Main.Headers.Header.CMD.Cyan.Red';
alias BU.HeaderCyanSalmonCMD='BU.Main.Headers.Header.CMD.Cyan.Salmon';

alias BU.HeaderCyanSilverCMD='BU.Main.Headers.Header.CMD.Cyan.Silver';
alias BU.HeaderCyanTanCMD='BU.Main.Headers.Header.CMD.Cyan.Tan';
alias BU.HeaderCyanTealCMD='BU.Main.Headers.Header.CMD.Cyan.Teal';

alias BU.HeaderCyanTurquoiseCMD='BU.Main.Headers.Header.CMD.Cyan.Turquoise';
alias BU.HeaderCyanVioletCMD='BU.Main.Headers.Header.CMD.Cyan.Violet';
alias BU.HeaderCyanWhiteCMD='BU.Main.Headers.Header.CMD.Cyan.White';

alias BU.HeaderCyanYellowCMD='BU.Main.Headers.Header.CMD.Cyan.Yellow';

# -----------------------------------------------

## FUCHSIA LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderFuchsiaAqua='BU.Main.Headers.Header.Fuchsia.Aqua';
alias BU.HeaderFuchsiaBlack='BU.Main.Headers.Header.Fuchsia.Black';
alias BU.HeaderFuchsiaBlue='BU.Main.Headers.Header.Fuchsia.Blue';

alias BU.HeaderFuchsiaCyan='BU.Main.Headers.Header.Fuchsia.Cyan';
alias BU.HeaderFuchsiaGray='BU.Main.Headers.Header.Fuchsia.Gray';
alias BU.HeaderFuchsiaGreen='BU.Main.Headers.Header.Fuchsia.Green';

alias BU.HeaderFuchsiaLime='BU.Main.Headers.Header.Fuchsia.Lime';
alias BU.HeaderFuchsiaMaroon='BU.Main.Headers.Header.Fuchsia.Maroon';
alias BU.HeaderFuchsiaNavy='BU.Main.Headers.Header.Fuchsia.Navy';

alias BU.HeaderFuchsiaOlive='BU.Main.Headers.Header.Fuchsia.Olive';
alias BU.HeaderFuchsiaOrange='BU.Main.Headers.Header.Fuchsia.Orange';
alias BU.HeaderFuchsiaPink='BU.Main.Headers.Header.Fuchsia.Pink';

alias BU.HeaderFuchsiaPurple='BU.Main.Headers.Header.Fuchsia.Purple';
alias BU.HeaderFuchsiaRed='BU.Main.Headers.Header.Fuchsia.Red';
alias BU.HeaderFuchsiaSalmon='BU.Main.Headers.Header.Fuchsia.Salmon';

alias BU.HeaderFuchsiaSilver='BU.Main.Headers.Header.Fuchsia.Silver';
alias BU.HeaderFuchsiaTan='BU.Main.Headers.Header.Fuchsia.Tan';
alias BU.HeaderFuchsiaTeal='BU.Main.Headers.Header.Fuchsia.Teal';

alias BU.HeaderFuchsiaTurquoise='BU.Main.Headers.Header.Fuchsia.Turquoise';
alias BU.HeaderFuchsiaViolet='BU.Main.Headers.Header.Fuchsia.Violet';
alias BU.HeaderFuchsiaWhite='BU.Main.Headers.Header.Fuchsia.White';

alias BU.HeaderFuchsiaYellow='BU.Main.Headers.Header.Fuchsia.Yellow';

# Command substitutions
alias BU.HeaderFuchsiaAquaCMD='BU.Main.Headers.Header.CMD.Fuchsia.Aqua';
alias BU.HeaderFuchsiaBlackCMD='BU.Main.Headers.Header.CMD.Fuchsia.Black';
alias BU.HeaderFuchsiaBlueCMD='BU.Main.Headers.Header.CMD.Fuchsia.Blue';

alias BU.HeaderFuchsiaCyanCMD='BU.Main.Headers.Header.CMD.Fuchsia.Cyan';
alias BU.HeaderFuchsiaGrayCMD='BU.Main.Headers.Header.CMD.Fuchsia.Gray';
alias BU.HeaderFuchsiaGreenCMD='BU.Main.Headers.Header.CMD.Fuchsia.Green';

alias BU.HeaderFuchsiaLimeCMD='BU.Main.Headers.Header.CMD.Fuchsia.Lime';
alias BU.HeaderFuchsiaMaroonCMD='BU.Main.Headers.Header.CMD.Fuchsia.Maroon';
alias BU.HeaderFuchsiaNavyCMD='BU.Main.Headers.Header.CMD.Fuchsia.Navy';

alias BU.HeaderFuchsiaOliveCMD='BU.Main.Headers.Header.CMD.Fuchsia.Olive';
alias BU.HeaderFuchsiaOrangeCMD='BU.Main.Headers.Header.CMD.Fuchsia.Orange';
alias BU.HeaderFuchsiaPinkCMD='BU.Main.Headers.Header.CMD.Fuchsia.Pink';

alias BU.HeaderFuchsiaPurpleCMD='BU.Main.Headers.Header.CMD.Fuchsia.Purple';
alias BU.HeaderFuchsiaRedCMD='BU.Main.Headers.Header.CMD.Fuchsia.Red';
alias BU.HeaderFuchsiaSalmonCMD='BU.Main.Headers.Header.CMD.Fuchsia.Salmon';

alias BU.HeaderFuchsiaSilverCMD='BU.Main.Headers.Header.CMD.Fuchsia.Silver';
alias BU.HeaderFuchsiaTanCMD='BU.Main.Headers.Header.CMD.Fuchsia.Tan';
alias BU.HeaderFuchsiaTealCMD='BU.Main.Headers.Header.CMD.Fuchsia.Teal';

alias BU.HeaderFuchsiaTurquoiseCMD='BU.Main.Headers.Header.CMD.Fuchsia.Turquoise';
alias BU.HeaderFuchsiaVioletCMD='BU.Main.Headers.Header.CMD.Fuchsia.Violet';
alias BU.HeaderFuchsiaWhiteCMD='BU.Main.Headers.Header.CMD.Fuchsia.White';

alias BU.HeaderFuchsiaYellowCMD='BU.Main.Headers.Header.CMD.Fuchsia.Yellow';

# -----------------------------------------------

## GRAY LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderGrayAqua='BU.Main.Headers.Header.Gray.Aqua';
alias BU.HeaderGrayBlack='BU.Main.Headers.Header.Gray.Black';
alias BU.HeaderGrayBlue='BU.Main.Headers.Header.Gray.Blue';

alias BU.HeaderGrayCyan='BU.Main.Headers.Header.Gray.Cyan';
alias BU.HeaderGrayFuchsia='BU.Main.Headers.Header.Gray.Fuchsia';
alias BU.HeaderGrayGreen='BU.Main.Headers.Header.Gray.Green';

alias BU.HeaderGrayLime='BU.Main.Headers.Header.Gray.Lime';
alias BU.HeaderGrayMaroon='BU.Main.Headers.Header.Gray.Maroon';
alias BU.HeaderGrayNavy='BU.Main.Headers.Header.Gray.Navy';

alias BU.HeaderGrayOlive='BU.Main.Headers.Header.Gray.Olive';
alias BU.HeaderGrayOrange='BU.Main.Headers.Header.Gray.Orange';
alias BU.HeaderGrayPink='BU.Main.Headers.Header.Gray.Pink';

alias BU.HeaderGrayPurple='BU.Main.Headers.Header.Gray.Purple';
alias BU.HeaderGrayRed='BU.Main.Headers.Header.Gray.Red';
alias BU.HeaderGraySalmon='BU.Main.Headers.Header.Gray.Salmon';

alias BU.HeaderGraySilver='BU.Main.Headers.Header.Gray.Silver';
alias BU.HeaderGrayTan='BU.Main.Headers.Header.Gray.Tan';
alias BU.HeaderGrayTeal='BU.Main.Headers.Header.Gray.Teal';

alias BU.HeaderGrayTurquoise='BU.Main.Headers.Header.Gray.Turquoise';
alias BU.HeaderGrayViolet='BU.Main.Headers.Header.Gray.Violet';
alias BU.HeaderGrayWhite='BU.Main.Headers.Header.Gray.White';

alias BU.HeaderGrayYellow='BU.Main.Headers.Header.Gray.Yellow';

# Command substitutions
alias BU.HeaderGrayAquaCMD='BU.Main.Headers.Header.CMD.Gray.Aqua';
alias BU.HeaderGrayBlackCMD='BU.Main.Headers.Header.CMD.Gray.Black';
alias BU.HeaderGrayBlueCMD='BU.Main.Headers.Header.CMD.Gray.Blue';

alias BU.HeaderGrayCyanCMD='BU.Main.Headers.Header.CMD.Gray.Cyan';
alias BU.HeaderGrayFuchsiaCMD='BU.Main.Headers.Header.CMD.Gray.Fuchsia';
alias BU.HeaderGrayGreenCMD='BU.Main.Headers.Header.CMD.Gray.Green';

alias BU.HeaderGrayLimeCMD='BU.Main.Headers.Header.CMD.Gray.Lime';
alias BU.HeaderGrayMaroonCMD='BU.Main.Headers.Header.CMD.Gray.Maroon';
alias BU.HeaderGrayNavyCMD='BU.Main.Headers.Header.CMD.Gray.Navy';

alias BU.HeaderGrayOliveCMD='BU.Main.Headers.Header.CMD.Gray.Olive';
alias BU.HeaderGrayOrangeCMD='BU.Main.Headers.Header.CMD.Gray.Orange';
alias BU.HeaderGrayPinkCMD='BU.Main.Headers.Header.CMD.Gray.Pink';

alias BU.HeaderGrayPurpleCMD='BU.Main.Headers.Header.CMD.Gray.Purple';
alias BU.HeaderGrayRedCMD='BU.Main.Headers.Header.CMD.Gray.Red';
alias BU.HeaderGraySalmonCMD='BU.Main.Headers.Header.CMD.Gray.Salmon';

alias BU.HeaderGraySilverCMD='BU.Main.Headers.Header.CMD.Gray.Silver';
alias BU.HeaderGrayTanCMD='BU.Main.Headers.Header.CMD.Gray.Tan';
alias BU.HeaderGrayTealCMD='BU.Main.Headers.Header.CMD.Gray.Teal';

alias BU.HeaderGrayTurquoiseCMD='BU.Main.Headers.Header.CMD.Gray.Turquoise';
alias BU.HeaderGrayVioletCMD='BU.Main.Headers.Header.CMD.Gray.Violet';
alias BU.HeaderGrayWhiteCMD='BU.Main.Headers.Header.CMD.Gray.White';

alias BU.HeaderGrayYellowCMD='BU.Main.Headers.Header.CMD.Gray.Yellow';

# -----------------------------------------------

## LIGHT GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderGreenAqua='BU.Main.Headers.Header.Green.Aqua';
alias BU.HeaderGreenBlack='BU.Main.Headers.Header.Green.Black';
alias BU.HeaderGreenBlue='BU.Main.Headers.Header.Green.Blue';

alias BU.HeaderGreenCyan='BU.Main.Headers.Header.Green.Cyan';
alias BU.HeaderGreenFuchsia='BU.Main.Headers.Header.Green.Fuchsia';
alias BU.HeaderGreenGray='BU.Main.Headers.Header.Green.Gray';

alias BU.HeaderGreenLime='BU.Main.Headers.Header.Green.Lime';
alias BU.HeaderGreenMaroon='BU.Main.Headers.Header.Green.Maroon';
alias BU.HeaderGreenNavy='BU.Main.Headers.Header.Green.Navy';

alias BU.HeaderGreenOlive='BU.Main.Headers.Header.Green.Olive';
alias BU.HeaderGreenOrange='BU.Main.Headers.Header.Green.Orange';
alias BU.HeaderGreenPink='BU.Main.Headers.Header.Green.Pink';

alias BU.HeaderGreenPurple='BU.Main.Headers.Header.Green.Purple';
alias BU.HeaderGreenRed='BU.Main.Headers.Header.Green.Red';
alias BU.HeaderGreenSalmon='BU.Main.Headers.Header.Green.Salmon';

alias BU.HeaderGreenSilver='BU.Main.Headers.Header.Green.Silver';
alias BU.HeaderGreenTan='BU.Main.Headers.Header.Green.Tan';
alias BU.HeaderGreenTeal='BU.Main.Headers.Header.Green.Teal';

alias BU.HeaderGreenTurquoise='BU.Main.Headers.Header.Green.Turquoise';
alias BU.HeaderGreenViolet='BU.Main.Headers.Header.Green.Violet';
alias BU.HeaderGreenWhite='BU.Main.Headers.Header.Green.White';

alias BU.HeaderGreenYellow='BU.Main.Headers.Header.Green.Yellow';

# Command substitutions
alias BU.HeaderGreenAquaCMD='BU.Main.Headers.Header.CMD.Green.Aqua';
alias BU.HeaderGreenBlackCMD='BU.Main.Headers.Header.CMD.Green.Black';
alias BU.HeaderGreenBlueCMD='BU.Main.Headers.Header.CMD.Green.Blue';

alias BU.HeaderGreenCyanCMD='BU.Main.Headers.Header.CMD.Green.Cyan';
alias BU.HeaderGreenFuchsiaCMD='BU.Main.Headers.Header.CMD.Green.Fuchsia';
alias BU.HeaderGreenGrayCMD='BU.Main.Headers.Header.CMD.Green.Gray';

alias BU.HeaderGreenLimeCMD='BU.Main.Headers.Header.CMD.Green.Lime';
alias BU.HeaderGreenMaroonCMD='BU.Main.Headers.Header.CMD.Green.Maroon';
alias BU.HeaderGreenNavyCMD='BU.Main.Headers.Header.CMD.Green.Navy';

alias BU.HeaderGreenOliveCMD='BU.Main.Headers.Header.CMD.Green.Olive';
alias BU.HeaderGreenOrangeCMD='BU.Main.Headers.Header.CMD.Green.Orange';
alias BU.HeaderGreenPinkCMD='BU.Main.Headers.Header.CMD.Green.Pink';

alias BU.HeaderGreenPurpleCMD='BU.Main.Headers.Header.CMD.Green.Purple';
alias BU.HeaderGreenRedCMD='BU.Main.Headers.Header.CMD.Green.Red';
alias BU.HeaderGreenSalmonCMD='BU.Main.Headers.Header.CMD.Green.Salmon';

alias BU.HeaderGreenSilverCMD='BU.Main.Headers.Header.CMD.Green.Silver';
alias BU.HeaderGreenTanCMD='BU.Main.Headers.Header.CMD.Green.Tan';
alias BU.HeaderGreenTealCMD='BU.Main.Headers.Header.CMD.Green.Teal';

alias BU.HeaderGreenTurquoiseCMD='BU.Main.Headers.Header.CMD.Green.Turquoise';
alias BU.HeaderGreenVioletCMD='BU.Main.Headers.Header.CMD.Green.Violet';
alias BU.HeaderGreenWhiteCMD='BU.Main.Headers.Header.CMD.Green.White';

alias BU.HeaderGreenYellowCMD='BU.Main.Headers.Header.CMD.Green.Yellow';

# -----------------------------------------------

## LIME GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderLimeAqua='BU.Main.Headers.Header.Lime.Aqua';
alias BU.HeaderLimeBlack='BU.Main.Headers.Header.Lime.Black';
alias BU.HeaderLimeBlue='BU.Main.Headers.Header.Lime.Blue';

alias BU.HeaderLimeCyan='BU.Main.Headers.Header.Lime.Cyan';
alias BU.HeaderLimeFuchsia='BU.Main.Headers.Header.Lime.Fuchsia';
alias BU.HeaderLimeGray='BU.Main.Headers.Header.Lime.Gray';

alias BU.HeaderLimeGreen='BU.Main.Headers.Header.Lime.Green';
alias BU.HeaderLimeMarron='BU.Main.Headers.Header.Lime.Maroon';
alias BU.HeaderLimeNavy='BU.Main.Headers.Header.Lime.Navy';

alias BU.HeaderLimeOlive='BU.Main.Headers.Header.Lime.Olive';
alias BU.HeaderLimeOrange='BU.Main.Headers.Header.Lime.Orange';
alias BU.HeaderLimePink='BU.Main.Headers.Header.Lime.Pink';

alias BU.HeaderLimePurple='BU.Main.Headers.Header.Lime.Purple';
alias BU.HeaderLimeRed='BU.Main.Headers.Header.Lime.Red';
alias BU.HeaderLimeSalmon='BU.Main.Headers.Header.Lime.Salmon';

alias BU.HeaderLimeSilver='BU.Main.Headers.Header.Lime.Silver';
alias BU.HeaderLimeTan='BU.Main.Headers.Header.Lime.Tan';
alias BU.HeaderLimeTeal='BU.Main.Headers.Header.Lime.Teal';

alias BU.HeaderLimeTurquoise='BU.Main.Headers.Header.Lime.Turquoise';
alias BU.HeaderLimeViolet='BU.Main.Headers.Header.Lime.Violet';
alias BU.HeaderLimeWhite='BU.Main.Headers.Header.Lime.White';

alias BU.HeaderLimeYellow='BU.Main.Headers.Header.Lime.Yellow';

# Command substitutions
alias BU.HeaderLimeAquaCMD='BU.Main.Headers.Header.CMD.Lime.Aqua';
alias BU.HeaderLimeBlackCMD='BU.Main.Headers.Header.CMD.Lime.Black';
alias BU.HeaderLimeBlueCMD='BU.Main.Headers.Header.CMD.Lime.Blue';

alias BU.HeaderLimeCyanCMD='BU.Main.Headers.Header.CMD.Lime.Cyan';
alias BU.HeaderLimeFuchsiaCMD='BU.Main.Headers.Header.CMD.Lime.Fuchsia';
alias BU.HeaderLimeGrayCMD='BU.Main.Headers.Header.CMD.Lime.Gray';

alias BU.HeaderLimeGreenCMD='BU.Main.Headers.Header.CMD.Lime.Green';
alias BU.HeaderLimeMarronCMD='BU.Main.Headers.Header.CMD.Lime.Maroon';
alias BU.HeaderLimeNavyCMD='BU.Main.Headers.Header.CMD.Lime.Navy';

alias BU.HeaderLimeOliveCMD='BU.Main.Headers.Header.CMD.Lime.Olive';
alias BU.HeaderLimeOrangeCMD='BU.Main.Headers.Header.CMD.Lime.Orange';
alias BU.HeaderLimePinkCMD='BU.Main.Headers.Header.CMD.Lime.Pink';

alias BU.HeaderLimePurpleCMD='BU.Main.Headers.Header.CMD.Lime.Purple';
alias BU.HeaderLimeRedCMD='BU.Main.Headers.Header.CMD.Lime.Red';
alias BU.HeaderLimeSalmonCMD='BU.Main.Headers.Header.CMD.Lime.Salmon';

alias BU.HeaderLimeSilverCMD='BU.Main.Headers.Header.CMD.Lime.Silver';
alias BU.HeaderLimeTanCMD='BU.Main.Headers.Header.CMD.Lime.Tan';
alias BU.HeaderLimeTealCMD='BU.Main.Headers.Header.CMD.Lime.Teal';

alias BU.HeaderLimeTurquoiseCMD='BU.Main.Headers.Header.CMD.Lime.Turquoise';
alias BU.HeaderLimeVioletCMD='BU.Main.Headers.Header.CMD.Lime.Violet';
alias BU.HeaderLimeWhiteCMD='BU.Main.Headers.Header.CMD.Lime.White';

alias BU.HeaderLimeYellowCMD='BU.Main.Headers.Header.CMD.Lime.Yellow';

# -----------------------------------------------

## MAROON LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderMaroonAqua='BU.Main.Headers.Header.Maroon.Aqua';
alias BU.HeaderMaroonBlack='BU.Main.Headers.Header.Maroon.Black';
alias BU.HeaderMaroonBlue='BU.Main.Headers.Header.Maroon.Blue';

alias BU.HeaderMaroonCyan='BU.Main.Headers.Header.Maroon.Cyan';
alias BU.HeaderMaroonFuchsia='BU.Main.Headers.Header.Maroon.Fuchsia';
alias BU.HeaderMaroonGray='BU.Main.Headers.Header.Maroon.Gray';

alias BU.HeaderMaroonGreen='BU.Main.Headers.Header.Maroon.Green';
alias BU.HeaderMaroonLime='BU.Main.Headers.Header.Maroon.Lime';
alias BU.HeaderMaroonNavy='BU.Main.Headers.Header.Maroon.Navy';

alias BU.HeaderMaroonOlive='BU.Main.Headers.Header.Maroon.Olive';
alias BU.HeaderMaroonOrange='BU.Main.Headers.Header.Maroon.Orange';
alias BU.HeaderMaroonPink='BU.Main.Headers.Header.Maroon.Pink';

alias BU.HeaderMaroonPurple='BU.Main.Headers.Header.Maroon.Purple';
alias BU.HeaderMaroonRed='BU.Main.Headers.Header.Maroon.Red';
alias BU.HeaderMaroonSalmon='BU.Main.Headers.Header.Maroon.Salmon';

alias BU.HeaderMaroonSilver='BU.Main.Headers.Header.Maroon.Silver';
alias BU.HeaderMaroonTan='BU.Main.Headers.Header.Maroon.Tan';
alias BU.HeaderMaroonTeal='BU.Main.Headers.Header.Maroon.Teal';

alias BU.HeaderMaroonTurquoise='BU.Main.Headers.Header.Maroon.Turquoise';
alias BU.HeaderMaroonViolet='BU.Main.Headers.Header.Maroon.Violet';
alias BU.HeaderMaroonWhite='BU.Main.Headers.Header.Maroon.White';

alias BU.HeaderMaroonYellow='BU.Main.Headers.Header.Maroon.Yellow';

# Command substitutions
alias BU.HeaderMaroonAquaCMD='BU.Main.Headers.Header.CMD.Maroon.Aqua';
alias BU.HeaderMaroonBlackCMD='BU.Main.Headers.Header.CMD.Maroon.Black';
alias BU.HeaderMaroonBlueCMD='BU.Main.Headers.Header.CMD.Maroon.Blue';

alias BU.HeaderMaroonCyanCMD='BU.Main.Headers.Header.CMD.Maroon.Cyan';
alias BU.HeaderMaroonFuchsiaCMD='BU.Main.Headers.Header.CMD.Maroon.Fuchsia';
alias BU.HeaderMaroonGrayCMD='BU.Main.Headers.Header.CMD.Maroon.Gray';

alias BU.HeaderMaroonGreenCMD='BU.Main.Headers.Header.CMD.Maroon.Green';
alias BU.HeaderMaroonLimeCMD='BU.Main.Headers.Header.CMD.Maroon.Lime';
alias BU.HeaderMaroonNavyCMD='BU.Main.Headers.Header.CMD.Maroon.Navy';

alias BU.HeaderMaroonOliveCMD='BU.Main.Headers.Header.CMD.Maroon.Olive';
alias BU.HeaderMaroonOrangeCMD='BU.Main.Headers.Header.CMD.Maroon.Orange';
alias BU.HeaderMaroonPinkCMD='BU.Main.Headers.Header.CMD.Maroon.Pink';

alias BU.HeaderMaroonPurpleCMD='BU.Main.Headers.Header.CMD.Maroon.Purple';
alias BU.HeaderMaroonRedCMD='BU.Main.Headers.Header.CMD.Maroon.Red';
alias BU.HeaderMaroonSalmonCMD='BU.Main.Headers.Header.CMD.Maroon.Salmon';

alias BU.HeaderMaroonSilverCMD='BU.Main.Headers.Header.CMD.Maroon.Silver';
alias BU.HeaderMaroonTanCMD='BU.Main.Headers.Header.CMD.Maroon.Tan';
alias BU.HeaderMaroonTealCMD='BU.Main.Headers.Header.CMD.Maroon.Teal';

alias BU.HeaderMaroonTurquoiseCMD='BU.Main.Headers.Header.CMD.Maroon.Turquoise';
alias BU.HeaderMaroonVioletCMD='BU.Main.Headers.Header.CMD.Maroon.Violet';
alias BU.HeaderMaroonWhiteCMD='BU.Main.Headers.Header.CMD.Maroon.White';

alias BU.HeaderMaroonYellowCMD='BU.Main.Headers.Header.CMD.Maroon.Yellow';

# -----------------------------------------------

## NAVY BLUE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderNavyAqua='BU.Main.Headers.Header.Navy.Aqua';
alias BU.HeaderNavyBlack='BU.Main.Headers.Header.Navy.Black';
alias BU.HeaderNavyBlue='BU.Main.Headers.Header.Navy.Blue';

alias BU.HeaderNavyCyan='BU.Main.Headers.Header.Navy.Cyan';
alias BU.HeaderNavyFuchsia='BU.Main.Headers.Header.Navy.Fuchsia';
alias BU.HeaderNavyGray='BU.Main.Headers.Header.Navy.Gray';

alias BU.HeaderNavyGreen='BU.Main.Headers.Header.Navy.Green';
alias BU.HeaderNavyLime='BU.Main.Headers.Header.Navy.Lime';
alias BU.HeaderNavyMaroon='BU.Main.Headers.Header.Navy.Maroon';

alias BU.HeaderNavyOlive='BU.Main.Headers.Header.Navy.Olive';
alias BU.HeaderNavyOrange='BU.Main.Headers.Header.Navy.Orange';
alias BU.HeaderNavyPink='BU.Main.Headers.Header.Navy.Pink';

alias BU.HeaderNavyPurple='BU.Main.Headers.Header.Navy.Purple';
alias BU.HeaderNavyRed='BU.Main.Headers.Header.Navy.Red';
alias BU.HeaderNavySalmon='BU.Main.Headers.Header.Navy.Salmon';

alias BU.HeaderNavySilver='BU.Main.Headers.Header.Navy.Silver';
alias BU.HeaderNavyTan='BU.Main.Headers.Header.Navy.Tan';
alias BU.HeaderNavyTeal='BU.Main.Headers.Header.Navy.Teal';

alias BU.HeaderNavyTurquoise='BU.Main.Headers.Header.Navy.Turquoise';
alias BU.HeaderNavyViolet='BU.Main.Headers.Header.Navy.Violet';
alias BU.HeaderNavyWhite='BU.Main.Headers.Header.Navy.White';

alias BU.HeaderNavyYellow='BU.Main.Headers.Header.Navy.Yellow';

# Command substitutions
alias BU.HeaderNavyAquaCMD='BU.Main.Headers.Header.CMD.Navy.Aqua';
alias BU.HeaderNavyBlackCMD='BU.Main.Headers.Header.CMD.Navy.Black';
alias BU.HeaderNavyBlueCMD='BU.Main.Headers.Header.CMD.Navy.Blue';

alias BU.HeaderNavyCyanCMD='BU.Main.Headers.Header.CMD.Navy.Cyan';
alias BU.HeaderNavyFuchsiaCMD='BU.Main.Headers.Header.CMD.Navy.Fuchsia';
alias BU.HeaderNavyGrayCMD='BU.Main.Headers.Header.CMD.Navy.Gray';

alias BU.HeaderNavyGreenCMD='BU.Main.Headers.Header.CMD.Navy.Green';
alias BU.HeaderNavyLimeCMD='BU.Main.Headers.Header.CMD.Navy.Lime';
alias BU.HeaderNavyMaroonCMD='BU.Main.Headers.Header.CMD.Navy.Maroon';

alias BU.HeaderNavyOliveCMD='BU.Main.Headers.Header.CMD.Navy.Olive';
alias BU.HeaderNavyOrangeCMD='BU.Main.Headers.Header.CMD.Navy.Orange';
alias BU.HeaderNavyPinkCMD='BU.Main.Headers.Header.CMD.Navy.Pink';

alias BU.HeaderNavyPurpleCMD='BU.Main.Headers.Header.CMD.Navy.Purple';
alias BU.HeaderNavyRedCMD='BU.Main.Headers.Header.CMD.Navy.Red';
alias BU.HeaderNavySalmonCMD='BU.Main.Headers.Header.CMD.Navy.Salmon';

alias BU.HeaderNavySilverCMD='BU.Main.Headers.Header.CMD.Navy.Silver';
alias BU.HeaderNavyTanCMD='BU.Main.Headers.Header.CMD.Navy.Tan';
alias BU.HeaderNavyTealCMD='BU.Main.Headers.Header.CMD.Navy.Teal';

alias BU.HeaderNavyTurquoiseCMD='BU.Main.Headers.Header.CMD.Navy.Turquoise';
alias BU.HeaderNavyVioletCMD='BU.Main.Headers.Header.CMD.Navy.Violet';
alias BU.HeaderNavyWhiteCMD='BU.Main.Headers.Header.CMD.Navy.White';

alias BU.HeaderNavyYellowCMD='BU.Main.Headers.Header.CMD.Navy.Yellow';

# -----------------------------------------------

## OLIVE GREEN LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderOliveAqua='BU.Main.Headers.Header.Olive.Aqua';
alias BU.HeaderOliveBlack='BU.Main.Headers.Header.Olive.Black';
alias BU.HeaderOliveBlue='BU.Main.Headers.Header.Olive.Blue';

alias BU.HeaderOliveCyan='BU.Main.Headers.Header.Olive.Cyan';
alias BU.HeaderOliveFuchsia='BU.Main.Headers.Header.Olive.';
alias BU.HeaderOliveGray='BU.Main.Headers.Header.Olive.Gray';

alias BU.HeaderOliveGreen='BU.Main.Headers.Header.Olive.Green';
alias BU.HeaderOliveLime='BU.Main.Headers.Header.Olive.Lime';
alias BU.HeaderOliveMaroon='BU.Main.Headers.Header.Olive.Maroon';

alias BU.HeaderOliveNavy='BU.Main.Headers.Header.Olive.Navy';
alias BU.HeaderOliveOrange='BU.Main.Headers.Header.Olive.Orange';
alias BU.HeaderOlivePink='BU.Main.Headers.Header.Olive.Pink';

alias BU.HeaderOlivePurple='BU.Main.Headers.Header.Olive.Purple';
alias BU.HeaderOliveRed='BU.Main.Headers.Header.Olive.Red';
alias BU.HeaderOliveSalmon='BU.Main.Headers.Header.Olive.Salmon';

alias BU.HeaderOliveSilver='BU.Main.Headers.Header.Olive.Silver';
alias BU.HeaderOliveTan='BU.Main.Headers.Header.Olive.Tan';
alias BU.HeaderOliveTeal='BU.Main.Headers.Header.Olive.Teal';

alias BU.HeaderOliveTurquoise='BU.Main.Headers.Header.Olive.Turquoise';
alias BU.HeaderOliveViolet='BU.Main.Headers.Header.Olive.Violet';
alias BU.HeaderOliveWhite='BU.Main.Headers.Header.Olive.White';

alias BU.HeaderOliveYellow='BU.Main.Headers.Header.Olive.Yellow';

# Command substitutions
alias BU.HeaderOliveAquaCMD='BU.Main.Headers.Header.CMD.Olive.Aqua';
alias BU.HeaderOliveBlackCMD='BU.Main.Headers.Header.CMD.Olive.Black';
alias BU.HeaderOliveBlueCMD='BU.Main.Headers.Header.CMD.Olive.Blue';

alias BU.HeaderOliveCyanCMD='BU.Main.Headers.Header.CMD.Olive.Cyan';
alias BU.HeaderOliveFuchsiaCMD='BU.Main.Headers.Header.CMD.Olive.';
alias BU.HeaderOliveGrayCMD='BU.Main.Headers.Header.CMD.Olive.Gray';

alias BU.HeaderOliveGreenCMD='BU.Main.Headers.Header.CMD.Olive.Green';
alias BU.HeaderOliveLimeCMD='BU.Main.Headers.Header.CMD.Olive.Lime';
alias BU.HeaderOliveMaroonCMD='BU.Main.Headers.Header.CMD.Olive.Maroon';

alias BU.HeaderOliveNavyCMD='BU.Main.Headers.Header.CMD.Olive.Navy';
alias BU.HeaderOliveOrangeCMD='BU.Main.Headers.Header.CMD.Olive.Orange';
alias BU.HeaderOlivePinkCMD='BU.Main.Headers.Header.CMD.Olive.Pink';

alias BU.HeaderOlivePurpleCMD='BU.Main.Headers.Header.CMD.Olive.Purple';
alias BU.HeaderOliveRedCMD='BU.Main.Headers.Header.CMD.Olive.Red';
alias BU.HeaderOliveSalmonCMD='BU.Main.Headers.Header.CMD.Olive.Salmon';

alias BU.HeaderOliveSilverCMD='BU.Main.Headers.Header.CMD.Olive.Silver';
alias BU.HeaderOliveTanCMD='BU.Main.Headers.Header.CMD.Olive.Tan';
alias BU.HeaderOliveTealCMD='BU.Main.Headers.Header.CMD.Olive.Teal';

alias BU.HeaderOliveTurquoiseCMD='BU.Main.Headers.Header.CMD.Olive.Turquoise';
alias BU.HeaderOliveVioletCMD='BU.Main.Headers.Header.CMD.Olive.Violet';
alias BU.HeaderOliveWhiteCMD='BU.Main.Headers.Header.CMD.Olive.White';

alias BU.HeaderOliveYellowCMD='BU.Main.Headers.Header.CMD.Olive.Yellow';

# -----------------------------------------------

## ORANGE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderOrangeAqua='BU.Main.Headers.Header.Orange.Aqua';
alias BU.HeaderOrangeBlack='BU.Main.Headers.Header.Orange.Black';
alias BU.HeaderOrangeBlue='BU.Main.Headers.Header.Orange.Blue';

alias BU.HeaderOrangeCyan='BU.Main.Headers.Header.Orange.Cyan';
alias BU.HeaderOrangeFuchsia='BU.Main.Headers.Header.Orange.Fuchsia';
alias BU.HeaderOrangeGray='BU.Main.Headers.Header.Orange.Gray';

alias BU.HeaderOrangeGreen='BU.Main.Headers.Header.Orange.Green';
alias BU.HeaderOrangeLime='BU.Main.Headers.Header.Orange.Lime';
alias BU.HeaderOrangeMaroon='BU.Main.Headers.Header.Orange.Maroon';

alias BU.HeaderOrangeNavy='BU.Main.Headers.Header.Orange.Navy';
alias BU.HeaderOrangeOlive='BU.Main.Headers.Header.Orange.Olive';
alias BU.HeaderOrangePink='BU.Main.Headers.Header.Orange.Pink';

alias BU.HeaderOrangePurple='BU.Main.Headers.Header.Orange.Purple';
alias BU.HeaderOrangeRed='BU.Main.Headers.Header.Orange.Red';
alias BU.HeaderOrangeSalmon='BU.Main.Headers.Header.Orange.Salmon';

alias BU.HeaderOrangeSilver='BU.Main.Headers.Header.Orange.Silver';
alias BU.HeaderOrangeTan='BU.Main.Headers.Header.Orange.Tan';
alias BU.HeaderOrangeTeal='BU.Main.Headers.Header.Orange.Teal';

alias BU.HeaderOrangeTurquoise='BU.Main.Headers.Header.Orange.Turquoise';
alias BU.HeaderOrangeViolet='BU.Main.Headers.Header.Orange.Violet';
alias BU.HeaderOrangeWhite='BU.Main.Headers.Header.Orange.White';

alias BU.HeaderOrangeYellow='BU.Main.Headers.Header.Orange.Yellow';

# Command substitutions
alias BU.HeaderOrangeAquaCMD='BU.Main.Headers.Header.CMD.Orange.Aqua';
alias BU.HeaderOrangeBlackCMD='BU.Main.Headers.Header.CMD.Orange.Black';
alias BU.HeaderOrangeBlueCMD='BU.Main.Headers.Header.CMD.Orange.Blue';

alias BU.HeaderOrangeCyanCMD='BU.Main.Headers.Header.CMD.Orange.Cyan';
alias BU.HeaderOrangeFuchsiaCMD='BU.Main.Headers.Header.CMD.Orange.Fuchsia';
alias BU.HeaderOrangeGrayCMD='BU.Main.Headers.Header.CMD.Orange.Gray';

alias BU.HeaderOrangeGreenCMD='BU.Main.Headers.Header.CMD.Orange.Green';
alias BU.HeaderOrangeLimeCMD='BU.Main.Headers.Header.CMD.Orange.Lime';
alias BU.HeaderOrangeMaroonCMD='BU.Main.Headers.Header.CMD.Orange.Maroon';

alias BU.HeaderOrangeNavyCMD='BU.Main.Headers.Header.CMD.Orange.Navy';
alias BU.HeaderOrangeOliveCMD='BU.Main.Headers.Header.CMD.Orange.Olive';
alias BU.HeaderOrangePinkCMD='BU.Main.Headers.Header.CMD.Orange.Pink';

alias BU.HeaderOrangePurpleCMD='BU.Main.Headers.Header.CMD.Orange.Purple';
alias BU.HeaderOrangeRedCMD='BU.Main.Headers.Header.CMD.Orange.Red';
alias BU.HeaderOrangeSalmonCMD='BU.Main.Headers.Header.CMD.Orange.Salmon';

alias BU.HeaderOrangeSilverCMD='BU.Main.Headers.Header.CMD.Orange.Silver';
alias BU.HeaderOrangeTanCMD='BU.Main.Headers.Header.CMD.Orange.Tan';
alias BU.HeaderOrangeTealCMD='BU.Main.Headers.Header.CMD.Orange.Teal';

alias BU.HeaderOrangeTurquoiseCMD='BU.Main.Headers.Header.CMD.Orange.Turquoise';
alias BU.HeaderOrangeVioletCMD='BU.Main.Headers.Header.CMD.Orange.Violet';
alias BU.HeaderOrangeWhiteCMD='BU.Main.Headers.Header.CMD.Orange.White';

alias BU.HeaderOrangeYellowCMD='BU.Main.Headers.Header.CMD.Orange.Yellow';

# -----------------------------------------------

## PINK LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderPinkAqua='BU.Main.Headers.Header.Pink.Aqua';
alias BU.HeaderPinkBlack='BU.Main.Headers.Header.Pink.Black';
alias BU.HeaderPinkBlue='BU.Main.Headers.Header.Pink.Blue';

alias BU.HeaderPinkCyan='BU.Main.Headers.Header.Pink.Cyan';
alias BU.HeaderPinkFuchsia='BU.Main.Headers.Header.Pink.Fuchsia';
alias BU.HeaderPinkGray='BU.Main.Headers.Header.Pink.Gray';

alias BU.HeaderPinkGreen='BU.Main.Headers.Header.Pink.Green';
alias BU.HeaderPinkLime='BU.Main.Headers.Header.Pink.Lime';
alias BU.HeaderPinkMaroon='BU.Main.Headers.Header.Pink.Maroon';

alias BU.HeaderPinkNavy='BU.Main.Headers.Header.Pink.Navy';
alias BU.HeaderPinkOlive='BU.Main.Headers.Header.Pink.Olive';
alias BU.HeaderPinkOrange='BU.Main.Headers.Header.Pink.Orange';

alias BU.HeaderPinkPurple='BU.Main.Headers.Header.Pink.Purple';
alias BU.HeaderPinkRed='BU.Main.Headers.Header.Pink.Red';
alias BU.HeaderPinkSalmon='BU.Main.Headers.Header.Pink.Salmon';

alias BU.HeaderPinkSilver='BU.Main.Headers.Header.Pink.Silver';
alias BU.HeaderPinkTan='BU.Main.Headers.Header.Pink.Tan';
alias BU.HeaderPinkTeal='BU.Main.Headers.Header.Pink.Teal';

alias BU.HeaderPinkTurquoise='BU.Main.Headers.Header.Pink.Turquoise';
alias BU.HeaderPinkViolet='BU.Main.Headers.Header.Pink.Violet';
alias BU.HeaderPinkWhite='BU.Main.Headers.Header.Pink.White';

alias BU.HeaderPinkYellow='BU.Main.Headers.Header.Pink.Yellow';

# Command substitutions
alias BU.HeaderPinkAquaCMD='BU.Main.Headers.Header.CMD.Pink.Aqua';
alias BU.HeaderPinkBlackCMD='BU.Main.Headers.Header.CMD.Pink.Black';
alias BU.HeaderPinkBlueCMD='BU.Main.Headers.Header.CMD.Pink.Blue';

alias BU.HeaderPinkCyanCMD='BU.Main.Headers.Header.CMD.Pink.Cyan';
alias BU.HeaderPinkFuchsiaCMD='BU.Main.Headers.Header.CMD.Pink.Fuchsia';
alias BU.HeaderPinkGrayCMD='BU.Main.Headers.Header.CMD.Pink.Gray';

alias BU.HeaderPinkGreenCMD='BU.Main.Headers.Header.CMD.Pink.Green';
alias BU.HeaderPinkLimeCMD='BU.Main.Headers.Header.CMD.Pink.Lime';
alias BU.HeaderPinkMaroonCMD='BU.Main.Headers.Header.CMD.Pink.Maroon';

alias BU.HeaderPinkNavyCMD='BU.Main.Headers.Header.CMD.Pink.Navy';
alias BU.HeaderPinkOliveCMD='BU.Main.Headers.Header.CMD.Pink.Olive';
alias BU.HeaderPinkOrangeCMD='BU.Main.Headers.Header.CMD.Pink.Orange';

alias BU.HeaderPinkPurpleCMD='BU.Main.Headers.Header.CMD.Pink.Purple';
alias BU.HeaderPinkRedCMD='BU.Main.Headers.Header.CMD.Pink.Red';
alias BU.HeaderPinkSalmonCMD='BU.Main.Headers.Header.CMD.Pink.Salmon';

alias BU.HeaderPinkSilverCMD='BU.Main.Headers.Header.CMD.Pink.Silver';
alias BU.HeaderPinkTanCMD='BU.Main.Headers.Header.CMD.Pink.Tan';
alias BU.HeaderPinkTealCMD='BU.Main.Headers.Header.CMD.Pink.Teal';

alias BU.HeaderPinkTurquoiseCMD='BU.Main.Headers.Header.CMD.Pink.Turquoise';
alias BU.HeaderPinkVioletCMD='BU.Main.Headers.Header.CMD.Pink.Violet';
alias BU.HeaderPinkWhiteCMD='BU.Main.Headers.Header.CMD.Pink.White';

alias BU.HeaderPinkYellowCMD='BU.Main.Headers.Header.CMD.Pink.Yellow';

# -----------------------------------------------

## PURPLE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderPurpleAqua='BU.Main.Headers.Header.Purple.Aqua';
alias BU.HeaderPurpleBlack='BU.Main.Headers.Header.Purple.Black';
alias BU.HeaderPurpleBlue='BU.Main.Headers.Header.Purple.Blue';

alias BU.HeaderPurpleCyan='BU.Main.Headers.Header.Purple.Cyan';
alias BU.HeaderPurpleFuchsia='BU.Main.Headers.Header.Purple.Fuchsia';
alias BU.HeaderPurpleGray='BU.Main.Headers.Header.Purple.Gray';

alias BU.HeaderPurpleGreen='BU.Main.Headers.Header.Purple.Green';
alias BU.HeaderPurpleLime='BU.Main.Headers.Header.Purple.Lime';
alias BU.HeaderPurpleMaroon='BU.Main.Headers.Header.Purple.Maroon';

alias BU.HeaderPurpleNavy='BU.Main.Headers.Header.Purple.Navy';
alias BU.HeaderPurpleOlive='BU.Main.Headers.Header.Purple.Olive';
alias BU.HeaderPurpleOrange='BU.Main.Headers.Header.Purple.Orange';

alias BU.HeaderPurplePink='BU.Main.Headers.Header.Purple.Pink';
alias BU.HeaderPurpleRed='BU.Main.Headers.Header.Purple.Red';
alias BU.HeaderPurpleSalmon='BU.Main.Headers.Header.Purple.Salmon';

alias BU.HeaderPurpleSilver='BU.Main.Headers.Header.Purple.Silver';
alias BU.HeaderPurpleTan='BU.Main.Headers.Header.Purple.Tan';
alias BU.HeaderPurpleTeal='BU.Main.Headers.Header.Purple.Teal';

alias BU.HeaderPurpleTurquoise='BU.Main.Headers.Header.Purple.Turquoise';
alias BU.HeaderPurpleViolet='BU.Main.Headers.Header.Purple.Violet';
alias BU.HeaderPurpleWhite='BU.Main.Headers.Header.Purple.White';

alias BU.HeaderPurpleYellow='BU.Main.Headers.Header.Purple.Yellow';

# Command substitutions
alias BU.HeaderPurpleAquaCMD='BU.Main.Headers.Header.CMD.Purple.Aqua';
alias BU.HeaderPurpleBlackCMD='BU.Main.Headers.Header.CMD.Purple.Black';
alias BU.HeaderPurpleBlueCMD='BU.Main.Headers.Header.CMD.Purple.Blue';

alias BU.HeaderPurpleCyanCMD='BU.Main.Headers.Header.CMD.Purple.Cyan';
alias BU.HeaderPurpleFuchsiaCMD='BU.Main.Headers.Header.CMD.Purple.Fuchsia';
alias BU.HeaderPurpleGrayCMD='BU.Main.Headers.Header.CMD.Purple.Gray';

alias BU.HeaderPurpleGreenCMD='BU.Main.Headers.Header.CMD.Purple.Green';
alias BU.HeaderPurpleLimeCMD='BU.Main.Headers.Header.CMD.Purple.Lime';
alias BU.HeaderPurpleMaroonCMD='BU.Main.Headers.Header.CMD.Purple.Maroon';

alias BU.HeaderPurpleNavyCMD='BU.Main.Headers.Header.CMD.Purple.Navy';
alias BU.HeaderPurpleOliveCMD='BU.Main.Headers.Header.CMD.Purple.Olive';
alias BU.HeaderPurpleOrangeCMD='BU.Main.Headers.Header.CMD.Purple.Orange';

alias BU.HeaderPurplePinkCMD='BU.Main.Headers.Header.CMD.Purple.Pink';
alias BU.HeaderPurpleRedCMD='BU.Main.Headers.Header.CMD.Purple.Red';
alias BU.HeaderPurpleSalmonCMD='BU.Main.Headers.Header.CMD.Purple.Salmon';

alias BU.HeaderPurpleSilverCMD='BU.Main.Headers.Header.CMD.Purple.Silver';
alias BU.HeaderPurpleTanCMD='BU.Main.Headers.Header.CMD.Purple.Tan';
alias BU.HeaderPurpleTealCMD='BU.Main.Headers.Header.CMD.Purple.Teal';

alias BU.HeaderPurpleTurquoiseCMD='BU.Main.Headers.Header.CMD.Purple.Turquoise';
alias BU.HeaderPurpleVioletCMD='BU.Main.Headers.Header.CMD.Purple.Violet';
alias BU.HeaderPurpleWhiteCMD='BU.Main.Headers.Header.CMD.Purple.White';

alias BU.HeaderPurpleYellowCMD='BU.Main.Headers.Header.CMD.Purple.Yellow';

# -----------------------------------------------

## RED LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderRedAqua='BU.Main.Headers.Header.Red.Aqua';
alias BU.HeaderRedBlack='BU.Main.Headers.Header.Red.Black';
alias BU.HeaderRedBlue='BU.Main.Headers.Header.Red.Blue';

alias BU.HeaderRedCyan='BU.Main.Headers.Header.Red.Cyan';
alias BU.HeaderRedFuchsia='BU.Main.Headers.Header.Red.Fuchsia';
alias BU.HeaderRedGray='BU.Main.Headers.Header.Red.Gray';

alias BU.HeaderRedGreen='BU.Main.Headers.Header.Red.Green';
alias BU.HeaderRedLime='BU.Main.Headers.Header.Red.Lime';
alias BU.HeaderRedMaroon='BU.Main.Headers.Header.Red.Maroon';

alias BU.HeaderRedNavy='BU.Main.Headers.Header.Red.Navy';
alias BU.HeaderRedOlive='BU.Main.Headers.Header.Red.Olive';
alias BU.HeaderRedOrange='BU.Main.Headers.Header.Red.Orange';

alias BU.HeaderRedPink='BU.Main.Headers.Header.Red.Pink';
alias BU.HeaderRedPurple='BU.Main.Headers.Header.Red.Purple';
alias BU.HeaderRedSalmon='BU.Main.Headers.Header.Red.Salmon';

alias BU.HeaderRedSilver='BU.Main.Headers.Header.Red.Silver';
alias BU.HeaderRedTan='BU.Main.Headers.Header.Red.Tan';
alias BU.HeaderRedTeal='BU.Main.Headers.Header.Red.Teal';

alias BU.HeaderRedTurquoise='BU.Main.Headers.Header.Red.Turquoise';
alias BU.HeaderRedViolet='BU.Main.Headers.Header.Red.Violet';
alias BU.HeaderRedWhite='BU.Main.Headers.Header.Red.White';

alias BU.HeaderRedYellow='BU.Main.Headers.Header.Red.Yellow';

# Command substitutions
alias BU.HeaderRedAquaCMD='BU.Main.Headers.Header.CMD.Red.Aqua';
alias BU.HeaderRedBlackCMD='BU.Main.Headers.Header.CMD.Red.Black';
alias BU.HeaderRedBlueCMD='BU.Main.Headers.Header.CMD.Red.Blue';

alias BU.HeaderRedCyanCMD='BU.Main.Headers.Header.CMD.Red.Cyan';
alias BU.HeaderRedFuchsiaCMD='BU.Main.Headers.Header.CMD.Red.Fuchsia';
alias BU.HeaderRedGrayCMD='BU.Main.Headers.Header.CMD.Red.Gray';

alias BU.HeaderRedGreenCMD='BU.Main.Headers.Header.CMD.Red.Green';
alias BU.HeaderRedLimeCMD='BU.Main.Headers.Header.CMD.Red.Lime';
alias BU.HeaderRedMaroonCMD='BU.Main.Headers.Header.CMD.Red.Maroon';

alias BU.HeaderRedNavyCMD='BU.Main.Headers.Header.CMD.Red.Navy';
alias BU.HeaderRedOliveCMD='BU.Main.Headers.Header.CMD.Red.Olive';
alias BU.HeaderRedOrangeCMD='BU.Main.Headers.Header.CMD.Red.Orange';

alias BU.HeaderRedPinkCMD='BU.Main.Headers.Header.CMD.Red.Pink';
alias BU.HeaderRedPurpleCMD='BU.Main.Headers.Header.CMD.Red.Purple';
alias BU.HeaderRedSalmonCMD='BU.Main.Headers.Header.CMD.Red.Salmon';

alias BU.HeaderRedSilverCMD='BU.Main.Headers.Header.CMD.Red.Silver';
alias BU.HeaderRedTanCMD='BU.Main.Headers.Header.CMD.Red.Tan';
alias BU.HeaderRedTealCMD='BU.Main.Headers.Header.CMD.Red.Teal';

alias BU.HeaderRedTurquoiseCMD='BU.Main.Headers.Header.CMD.Red.Turquoise';
alias BU.HeaderRedVioletCMD='BU.Main.Headers.Header.CMD.Red.Violet';
alias BU.HeaderRedWhiteCMD='BU.Main.Headers.Header.CMD.Red.White';

alias BU.HeaderRedYellowCMD='BU.Main.Headers.Header.CMD.Red.Yellow';

# -----------------------------------------------

## SALMON LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderSalmonAqua='BU.Main.Headers.Header.Salmon.Aqua';
alias BU.HeaderSalmonBlack='BU.Main.Headers.Header.Salmon.Black';
alias BU.HeaderSalmonBlue='BU.Main.Headers.Header.Salmon.Blue';

alias BU.HeaderSalmonCyan='BU.Main.Headers.Header.Salmon.Cyan';
alias BU.HeaderSalmonFuchsia='BU.Main.Headers.Header.Salmon.Fuchsia';
alias BU.HeaderSalmonGray='BU.Main.Headers.Header.Salmon.Gray';

alias BU.HeaderSalmonGreen='BU.Main.Headers.Header.Salmon.Green';
alias BU.HeaderSalmonLime='BU.Main.Headers.Header.Salmon.Lime';
alias BU.HeaderSalmonMaroon='BU.Main.Headers.Header.Salmon.Maroon';

alias BU.HeaderSalmonNavy='BU.Main.Headers.Header.Salmon.Navy';
alias BU.HeaderSalmonOlive='BU.Main.Headers.Header.Salmon.Olive';
alias BU.HeaderSalmonOrange='BU.Main.Headers.Header.Salmon.Orange';

alias BU.HeaderSalmonPink='BU.Main.Headers.Header.Salmon.Pink';
alias BU.HeaderSalmonPurple='BU.Main.Headers.Header.Salmon.Purple';
alias BU.HeaderSalmonRed='BU.Main.Headers.Header.Salmon.Red';

alias BU.HeaderSalmonSilver='BU.Main.Headers.Header.Salmon.Silver';
alias BU.HeaderSalmonTan='BU.Main.Headers.Header.Salmon.Tan';
alias BU.HeaderSalmonTeal='BU.Main.Headers.Header.Salmon.Teal';

alias BU.HeaderSalmonTurquoise='BU.Main.Headers.Header.Salmon.Turquoise';
alias BU.HeaderSalmonViolet='BU.Main.Headers.Header.Salmon.Violet';
alias BU.HeaderSalmonWhite='BU.Main.Headers.Header.Salmon.White';

alias BU.HeaderSalmonYellow='BU.Main.Headers.Header.Salmon.Yellow';

# Command substitutions
alias BU.HeaderSalmonAquaCMD='BU.Main.Headers.Header.CMD.Salmon.Aqua';
alias BU.HeaderSalmonBlackCMD='BU.Main.Headers.Header.CMD.Salmon.Black';
alias BU.HeaderSalmonBlueCMD='BU.Main.Headers.Header.CMD.Salmon.Blue';

alias BU.HeaderSalmonCyanCMD='BU.Main.Headers.Header.CMD.Salmon.Cyan';
alias BU.HeaderSalmonFuchsiaCMD='BU.Main.Headers.Header.CMD.Salmon.Fuchsia';
alias BU.HeaderSalmonGrayCMD='BU.Main.Headers.Header.CMD.Salmon.Gray';

alias BU.HeaderSalmonGreenCMD='BU.Main.Headers.Header.CMD.Salmon.Green';
alias BU.HeaderSalmonLimeCMD='BU.Main.Headers.Header.CMD.Salmon.Lime';
alias BU.HeaderSalmonMaroonCMD='BU.Main.Headers.Header.CMD.Salmon.Maroon';

alias BU.HeaderSalmonNavyCMD='BU.Main.Headers.Header.CMD.Salmon.Navy';
alias BU.HeaderSalmonOliveCMD='BU.Main.Headers.Header.CMD.Salmon.Olive';
alias BU.HeaderSalmonOrangeCMD='BU.Main.Headers.Header.CMD.Salmon.Orange';

alias BU.HeaderSalmonPinkCMD='BU.Main.Headers.Header.CMD.Salmon.Pink';
alias BU.HeaderSalmonPurpleCMD='BU.Main.Headers.Header.CMD.Salmon.Purple';
alias BU.HeaderSalmonRedCMD='BU.Main.Headers.Header.CMD.Salmon.Red';

alias BU.HeaderSalmonSilverCMD='BU.Main.Headers.Header.CMD.Salmon.Silver';
alias BU.HeaderSalmonTanCMD='BU.Main.Headers.Header.CMD.Salmon.Tan';
alias BU.HeaderSalmonTealCMD='BU.Main.Headers.Header.CMD.Salmon.Teal';

alias BU.HeaderSalmonTurquoiseCMD='BU.Main.Headers.Header.CMD.Salmon.Turquoise';
alias BU.HeaderSalmonVioletCMD='BU.Main.Headers.Header.CMD.Salmon.Violet';
alias BU.HeaderSalmonWhiteCMD='BU.Main.Headers.Header.CMD.Salmon.White';

alias BU.HeaderSalmonYellowCMD='BU.Main.Headers.Header.CMD.Salmon.Yellow';

# -----------------------------------------------

## SILVER LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderSilverAqua='BU.Main.Headers.Header.Silver.Aqua';
alias BU.HeaderSilverBlack='BU.Main.Headers.Header.Silver.Black';
alias BU.HeaderSilverBlue='BU.Main.Headers.Header.Silver.Blue';

alias BU.HeaderSilverCyan='BU.Main.Headers.Header.Silver.Cyan';
alias BU.HeaderSilverFuchsia='BU.Main.Headers.Header.Silver.Fuchsia';
alias BU.HeaderSilverGray='BU.Main.Headers.Header.Silver.Gray';

alias BU.HeaderSilverGreen='BU.Main.Headers.Header.Silver.Green';
alias BU.HeaderSilverLime='BU.Main.Headers.Header.Silver.Lime';
alias BU.HeaderSilverMaroon='BU.Main.Headers.Header.Silver.Maroon';

alias BU.HeaderSilverNavy='BU.Main.Headers.Header.Silver.Navy';
alias BU.HeaderSilverOlive='BU.Main.Headers.Header.Silver.Olive';
alias BU.HeaderSilverOrange='BU.Main.Headers.Header.Silver.Orange';

alias BU.HeaderSilverPink='BU.Main.Headers.Header.Silver.Pink';
alias BU.HeaderSilverPurple='BU.Main.Headers.Header.Silver.Purple';
alias BU.HeaderSilverRed='BU.Main.Headers.Header.Silver.Red';

alias BU.HeaderSilverSalmon='BU.Main.Headers.Header.Silver.Salmon';
alias BU.HeaderSilverTan='BU.Main.Headers.Header.Silver.Tan';
alias BU.HeaderSilverTeal='BU.Main.Headers.Header.Silver.Teal';

alias BU.HeaderSilverTurquoise='BU.Main.Headers.Header.Silver.Turquoise';
alias BU.HeaderSilverViolet='BU.Main.Headers.Header.Silver.Violet';
alias BU.HeaderSilverWhite='BU.Main.Headers.Header.Silver.White';

alias BU.HeaderSilverYellow='BU.Main.Headers.Header.Silver.Yellow';

# Command substitutions
alias BU.HeaderSilverAquaCMD='BU.Main.Headers.Header.CMD.Silver.Aqua';
alias BU.HeaderSilverBlackCMD='BU.Main.Headers.Header.CMD.Silver.Black';
alias BU.HeaderSilverBlueCMD='BU.Main.Headers.Header.CMD.Silver.Blue';

alias BU.HeaderSilverCyanCMD='BU.Main.Headers.Header.CMD.Silver.Cyan';
alias BU.HeaderSilverFuchsiaCMD='BU.Main.Headers.Header.CMD.Silver.Fuchsia';
alias BU.HeaderSilverGrayCMD='BU.Main.Headers.Header.CMD.Silver.Gray';

alias BU.HeaderSilverGreenCMD='BU.Main.Headers.Header.CMD.Silver.Green';
alias BU.HeaderSilverLimeCMD='BU.Main.Headers.Header.CMD.Silver.Lime';
alias BU.HeaderSilverMaroonCMD='BU.Main.Headers.Header.CMD.Silver.Maroon';

alias BU.HeaderSilverNavyCMD='BU.Main.Headers.Header.CMD.Silver.Navy';
alias BU.HeaderSilverOliveCMD='BU.Main.Headers.Header.CMD.Silver.Olive';
alias BU.HeaderSilverOrangeCMD='BU.Main.Headers.Header.CMD.Silver.Orange';

alias BU.HeaderSilverPinkCMD='BU.Main.Headers.Header.CMD.Silver.Pink';
alias BU.HeaderSilverPurpleCMD='BU.Main.Headers.Header.CMD.Silver.Purple';
alias BU.HeaderSilverRedCMD='BU.Main.Headers.Header.CMD.Silver.Red';

alias BU.HeaderSilverSalmonCMD='BU.Main.Headers.Header.CMD.Silver.Salmon';
alias BU.HeaderSilverTanCMD='BU.Main.Headers.Header.CMD.Silver.Tan';
alias BU.HeaderSilverTealCMD='BU.Main.Headers.Header.CMD.Silver.Teal';

alias BU.HeaderSilverTurquoiseCMD='BU.Main.Headers.Header.CMD.Silver.Turquoise';
alias BU.HeaderSilverVioletCMD='BU.Main.Headers.Header.CMD.Silver.Violet';
alias BU.HeaderSilverWhiteCMD='BU.Main.Headers.Header.CMD.Silver.White';

alias BU.HeaderSilverYellowCMD='BU.Main.Headers.Header.CMD.Silver.Yellow';

# -----------------------------------------------

## TAN LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.TanAqua='BU.Main.Headers.Header.Tan.Aqua';
alias BU.TanBlue='BU.Main.Headers.Header.Tan.Blue';
alias BU.TanBlack='BU.Main.Headers.Header.Tan.Black';

alias BU.TanCyan='BU.Main.Headers.Header.Tan.Cyan';
alias BU.TanFuchsia='BU.Main.Headers.Header.Tan.Fuchsia';
alias BU.TanGray='BU.Main.Headers.Header.Tan.Gray';

alias BU.TanGreen='BU.Main.Headers.Header.Tan.Green';
alias BU.TanLime='BU.Main.Headers.Header.Tan.Lime';
alias BU.TanMaroon='BU.Main.Headers.Header.Tan.Maroon';

alias BU.TanNavy='BU.Main.Headers.Header.Tan.Navy';
alias BU.TanOlive='BU.Main.Headers.Header.Tan.Olive';
alias BU.TanOrange='BU.Main.Headers.Header.Tan.Orange';

alias BU.TanPink='BU.Main.Headers.Header.Tan.Pink';
alias BU.TanPurple='BU.Main.Headers.Header.Tan.Purple';
alias BU.TanRed='BU.Main.Headers.Header.Tan.Red';

alias BU.TanSalmon='BU.Main.Headers.Header.Tan.Salmon';
alias BU.TanSilver='BU.Main.Headers.Header.Tan.Silver';
alias BU.TanTeal='BU.Main.Headers.Header.Tan.Teal';

alias BU.TanTurquoise='BU.Main.Headers.Header.Tan.Turquoise';
alias BU.TanViolet='BU.Main.Headers.Header.Tan.Violet';
alias BU.TanWhite='BU.Main.Headers.Header.Tan.White';

alias BU.TanYellow='BU.Main.Headers.Header.Tan.Yellow';

# Command substitutions
alias BU.TanAquaCMD='BU.Main.Headers.Header.CMD.Tan.Aqua';
alias BU.TanBlueCMD='BU.Main.Headers.Header.CMD.Tan.Blue';
alias BU.TanBlackCMD='BU.Main.Headers.Header.CMD.Tan.Black';

alias BU.TanCyanCMD='BU.Main.Headers.Header.CMD.Tan.Cyan';
alias BU.TanFuchsiaCMD='BU.Main.Headers.Header.CMD.Tan.Fuchsia';
alias BU.TanGrayCMD='BU.Main.Headers.Header.CMD.Tan.Gray';

alias BU.TanGreenCMD='BU.Main.Headers.Header.CMD.Tan.Green';
alias BU.TanLimeCMD='BU.Main.Headers.Header.CMD.Tan.Lime';
alias BU.TanMaroonCMD='BU.Main.Headers.Header.CMD.Tan.Maroon';

alias BU.TanNavyCMD='BU.Main.Headers.Header.CMD.Tan.Navy';
alias BU.TanOliveCMD='BU.Main.Headers.Header.CMD.Tan.Olive';
alias BU.TanOrangeCMD='BU.Main.Headers.Header.CMD.Tan.Orange';

alias BU.TanPinkCMD='BU.Main.Headers.Header.CMD.Tan.Pink';
alias BU.TanPurpleCMD='BU.Main.Headers.Header.CMD.Tan.Purple';
alias BU.TanRedCMD='BU.Main.Headers.Header.CMD.Tan.Red';

alias BU.TanSalmonCMD='BU.Main.Headers.Header.CMD.Tan.Salmon';
alias BU.TanSilverCMD='BU.Main.Headers.Header.CMD.Tan.Silver';
alias BU.TanTealCMD='BU.Main.Headers.Header.CMD.Tan.Teal';

alias BU.TanTurquoiseCMD='BU.Main.Headers.Header.CMD.Tan.Turquoise';
alias BU.TanVioletCMD='BU.Main.Headers.Header.CMD.Tan.Violet';
alias BU.TanWhiteCMD='BU.Main.Headers.Header.CMD.Tan.White';

alias BU.TanYellowCMD='BU.Main.Headers.Header.CMD.Tan.Yellow';

# -----------------------------------------------

## TEAL LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderTealAqua='BU.Main.Headers.Header.Teal.Aqua';
alias BU.HeaderTealBlack='BU.Main.Headers.Header.Teal.Black';
alias BU.HeaderTealBlue='BU.Main.Headers.Header.Teal.Blue';

alias BU.HeaderTealCyan='BU.Main.Headers.Header.Teal.Cyan';
alias BU.HeaderTealFuchsia='BU.Main.Headers.Header.Teal.Fuchsia';
alias BU.HeaderTealGray='BU.Main.Headers.Header.Teal.Gray';

alias BU.HeaderTealGreen='BU.Main.Headers.Header.Teal.Green';
alias BU.HeaderTealLime='BU.Main.Headers.Header.Teal.Lime';
alias BU.HeaderTealMaroon='BU.Main.Headers.Header.Teal.Maroon';

alias BU.HeaderTealNavy='BU.Main.Headers.Header.Teal.Navy';
alias BU.HeaderTealOlive='BU.Main.Headers.Header.Teal.Olive';
alias BU.HeaderTealOrange='BU.Main.Headers.Header.Teal.Orange';

alias BU.HeaderTealPink='BU.Main.Headers.Header.Teal.Pink';
alias BU.HeaderTealPurple='BU.Main.Headers.Header.Teal.Purple';
alias BU.HeaderTealRed='BU.Main.Headers.Header.Teal.Red';

alias BU.HeaderTealSalmon='BU.Main.Headers.Header.Teal.Salmon';
alias BU.HeaderTealSilver='BU.Main.Headers.Header.Teal.Silver';
alias BU.HeaderTealTan='BU.Main.Headers.Header.Teal.Tan';

alias BU.HeaderTealTurquoise='BU.Main.Headers.Header.Teal.Turquoise';
alias BU.HeaderTealViolet='BU.Main.Headers.Header.Teal.Violet';
alias BU.HeaderTealWhite='BU.Main.Headers.Header.Teal.White';

alias BU.HeaderTealYellow='BU.Main.Headers.Header.Teal.Yellow';

# Command substitutions
alias BU.HeaderTealAquaCMD='BU.Main.Headers.Header.CMD.Teal.Aqua';
alias BU.HeaderTealBlackCMD='BU.Main.Headers.Header.CMD.Teal.Black';
alias BU.HeaderTealBlueCMD='BU.Main.Headers.Header.CMD.Teal.Blue';

alias BU.HeaderTealCyanCMD='BU.Main.Headers.Header.CMD.Teal.Cyan';
alias BU.HeaderTealFuchsiaCMD='BU.Main.Headers.Header.CMD.Teal.Fuchsia';
alias BU.HeaderTealGrayCMD='BU.Main.Headers.Header.CMD.Teal.Gray';

alias BU.HeaderTealGreenCMD='BU.Main.Headers.Header.CMD.Teal.Green';
alias BU.HeaderTealLimeCMD='BU.Main.Headers.Header.CMD.Teal.Lime';
alias BU.HeaderTealMaroonCMD='BU.Main.Headers.Header.CMD.Teal.Maroon';

alias BU.HeaderTealNavyCMD='BU.Main.Headers.Header.CMD.Teal.Navy';
alias BU.HeaderTealOliveCMD='BU.Main.Headers.Header.CMD.Teal.Olive';
alias BU.HeaderTealOrangeCMD='BU.Main.Headers.Header.CMD.Teal.Orange';

alias BU.HeaderTealPinkCMD='BU.Main.Headers.Header.CMD.Teal.Pink';
alias BU.HeaderTealPurpleCMD='BU.Main.Headers.Header.CMD.Teal.Purple';
alias BU.HeaderTealRedCMD='BU.Main.Headers.Header.CMD.Teal.Red';

alias BU.HeaderTealSalmonCMD='BU.Main.Headers.Header.CMD.Teal.Salmon';
alias BU.HeaderTealSilverCMD='BU.Main.Headers.Header.CMD.Teal.Silver';
alias BU.HeaderTealTanCMD='BU.Main.Headers.Header.CMD.Teal.Tan';

alias BU.HeaderTealTurquoiseCMD='BU.Main.Headers.Header.CMD.Teal.Turquoise';
alias BU.HeaderTealVioletCMD='BU.Main.Headers.Header.CMD.Teal.Violet';
alias BU.HeaderTealWhiteCMD='BU.Main.Headers.Header.CMD.Teal.White';

alias BU.HeaderTealYellowCMD='BU.Main.Headers.Header.CMD.Teal.Yellow';

# -----------------------------------------------

## TURQUOISE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderTurquoiseAqua='BU.Main.Headers.Header.Turquoise.Aqua';
alias BU.HeaderTurquoiseBlack='BU.Main.Headers.Header.Turquoise.Black';
alias BU.HeaderTurquoiseBlue='BU.Main.Headers.Header.Turquoise.Blue';

alias BU.HeaderTurquoiseCyan='BU.Main.Headers.Header.Turquoise.Cyan';
alias BU.HeaderTurquoiseFuchsia='BU.Main.Headers.Header.Turquoise.Fuchsia';
alias BU.HeaderTurquoiseGray='BU.Main.Headers.Header.Turquoise.Gray';

alias BU.HeaderTurquoiseGreen='BU.Main.Headers.Header.Turquoise.Green';
alias BU.HeaderTurquoiseLime='BU.Main.Headers.Header.Turquoise.Lime';
alias BU.HeaderTurquoiseMaroon='BU.Main.Headers.Header.Turquoise.Maroon';

alias BU.HeaderTurquoiseNavy='BU.Main.Headers.Header.Turquoise.Navy';
alias BU.HeaderTurquoiseOlive='BU.Main.Headers.Header.Turquoise.Olive';
alias BU.HeaderTurquoiseOrange='BU.Main.Headers.Header.Turquoise.Orange';

alias BU.HeaderTurquoisePink='BU.Main.Headers.Header.Turquoise.Pink';
alias BU.HeaderTurquoisePurple='BU.Main.Headers.Header.Turquoise.Purple';
alias BU.HeaderTurquoiseRed='BU.Main.Headers.Header.Turquoise.Red';

alias BU.HeaderTurquoiseSalmon='BU.Main.Headers.Header.Turquoise.Salmon';
alias BU.HeaderTurquoiseSilver='BU.Main.Headers.Header.Turquoise.Silver';
alias BU.HeaderTurquoiseTan='BU.Main.Headers.Header.Turquoise.Tan';

alias BU.HeaderTurquoiseTeal='BU.Main.Headers.Header.Turquoise.Teal';
alias BU.HeaderTurquoiseViolet='BU.Main.Headers.Header.Turquoise.Violet';
alias BU.HeaderTurquoiseWhite='BU.Main.Headers.Header.Turquoise.White';

alias BU.HeaderTurquoiseYellow='BU.Main.Headers.Header.Turquoise.Yellow';

# Command substitutions
alias BU.HeaderTurquoiseAquaCMD='BU.Main.Headers.Header.CMD.Turquoise.Aqua';
alias BU.HeaderTurquoiseBlackCMD='BU.Main.Headers.Header.CMD.Turquoise.Black';
alias BU.HeaderTurquoiseBlueCMD='BU.Main.Headers.Header.CMD.Turquoise.Blue';

alias BU.HeaderTurquoiseCyanCMD='BU.Main.Headers.Header.CMD.Turquoise.Cyan';
alias BU.HeaderTurquoiseFuchsiaCMD='BU.Main.Headers.Header.CMD.Turquoise.Fuchsia';
alias BU.HeaderTurquoiseGrayCMD='BU.Main.Headers.Header.CMD.Turquoise.Gray';

alias BU.HeaderTurquoiseGreenCMD='BU.Main.Headers.Header.CMD.Turquoise.Green';
alias BU.HeaderTurquoiseLimeCMD='BU.Main.Headers.Header.CMD.Turquoise.Lime';
alias BU.HeaderTurquoiseMaroonCMD='BU.Main.Headers.Header.CMD.Turquoise.Maroon';

alias BU.HeaderTurquoiseNavyCMD='BU.Main.Headers.Header.CMD.Turquoise.Navy';
alias BU.HeaderTurquoiseOliveCMD='BU.Main.Headers.Header.CMD.Turquoise.Olive';
alias BU.HeaderTurquoiseOrangeCMD='BU.Main.Headers.Header.CMD.Turquoise.Orange';

alias BU.HeaderTurquoisePinkCMD='BU.Main.Headers.Header.CMD.Turquoise.Pink';
alias BU.HeaderTurquoisePurpleCMD='BU.Main.Headers.Header.CMD.Turquoise.Purple';
alias BU.HeaderTurquoiseRedCMD='BU.Main.Headers.Header.CMD.Turquoise.Red';

alias BU.HeaderTurquoiseSalmonCMD='BU.Main.Headers.Header.CMD.Turquoise.Salmon';
alias BU.HeaderTurquoiseSilverCMD='BU.Main.Headers.Header.CMD.Turquoise.Silver';
alias BU.HeaderTurquoiseTanCMD='BU.Main.Headers.Header.CMD.Turquoise.Tan';

alias BU.HeaderTurquoiseTealCMD='BU.Main.Headers.Header.CMD.Turquoise.Teal';
alias BU.HeaderTurquoiseVioletCMD='BU.Main.Headers.Header.CMD.Turquoise.Violet';
alias BU.HeaderTurquoiseWhiteCMD='BU.Main.Headers.Header.CMD.Turquoise.White';

alias BU.HeaderTurquoiseYellowCMD='BU.Main.Headers.Header.CMD.Turquoise.Yellow';

# -----------------------------------------------

## WHITE LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderWhiteAqua='BU.Main.Headers.Header.White.Aqua';
alias BU.HeaderWhiteBlack='BU.Main.Headers.Header.White.Black';
alias BU.HeaderWhiteBlue='BU.Main.Headers.Header.White.Blue';

alias BU.HeaderWhiteCyan='BU.Main.Headers.Header.White.Cyan';
alias BU.HeaderWhiteFuchsia='BU.Main.Headers.Header.White.Fuchsia';
alias BU.HeaderWhiteGray='BU.Main.Headers.Header.White.Gray';

alias BU.HeaderWhiteGreen='BU.Main.Headers.Header.White.Green';
alias BU.HeaderWhiteLime='BU.Main.Headers.Header.White.Lime';
alias BU.HeaderWhiteMaroon='BU.Main.Headers.Header.White.Maroon';

alias BU.HeaderWhiteNavy='BU.Main.Headers.Header.White.Navy';
alias BU.HeaderWhiteOlive='BU.Main.Headers.Header.White.Olive';
alias BU.HeaderWhiteOrange='BU.Main.Headers.Header.White.Orange';

alias BU.HeaderWhitePink='BU.Main.Headers.Header.White.Pink';
alias BU.HeaderWhitePurple='BU.Main.Headers.Header.White.Purple';
alias BU.HeaderWhiteRed='BU.Main.Headers.Header.White.Red';

alias BU.HeaderWhiteSalmon='BU.Main.Headers.Header.White.Salmon';
alias BU.HeaderWhiteSilver='BU.Main.Headers.Header.White.Silver';
alias BU.HeaderWhiteTan='BU.Main.Headers.Header.White.Tan';

alias BU.HeaderWhiteTeal='BU.Main.Headers.Header.White.Teal';
alias BU.HeaderWhiteTurquoise='BU.Main.Headers.Header.White.Turquoise';
alias BU.HeaderWhiteViolet='BU.Main.Headers.Header.White.Violet';

alias BU.HeaderWhiteYellow='BU.Main.Headers.Header.White.Yellow';

# Command substitutions
alias BU.HeaderWhiteAquaCMD='BU.Main.Headers.Header.CMD.White.Aqua';
alias BU.HeaderWhiteBlackCMD='BU.Main.Headers.Header.CMD.White.Black';
alias BU.HeaderWhiteBlueCMD='BU.Main.Headers.Header.CMD.White.Blue';

alias BU.HeaderWhiteCyanCMD='BU.Main.Headers.Header.CMD.White.Cyan';
alias BU.HeaderWhiteFuchsiaCMD='BU.Main.Headers.Header.CMD.White.Fuchsia';
alias BU.HeaderWhiteGrayCMD='BU.Main.Headers.Header.CMD.White.Gray';

alias BU.HeaderWhiteGreenCMD='BU.Main.Headers.Header.CMD.White.Green';
alias BU.HeaderWhiteLimeCMD='BU.Main.Headers.Header.CMD.White.Lime';
alias BU.HeaderWhiteMaroonCMD='BU.Main.Headers.Header.CMD.White.Maroon';

alias BU.HeaderWhiteNavyCMD='BU.Main.Headers.Header.CMD.White.Navy';
alias BU.HeaderWhiteOliveCMD='BU.Main.Headers.Header.CMD.White.Olive';
alias BU.HeaderWhiteOrangeCMD='BU.Main.Headers.Header.CMD.White.Orange';

alias BU.HeaderWhitePinkCMD='BU.Main.Headers.Header.CMD.White.Pink';
alias BU.HeaderWhitePurpleCMD='BU.Main.Headers.Header.CMD.White.Purple';
alias BU.HeaderWhiteRedCMD='BU.Main.Headers.Header.CMD.White.Red';

alias BU.HeaderWhiteSalmonCMD='BU.Main.Headers.Header.CMD.White.Salmon';
alias BU.HeaderWhiteSilverCMD='BU.Main.Headers.Header.CMD.White.Silver';
alias BU.HeaderWhiteTanCMD='BU.Main.Headers.Header.CMD.White.Tan';

alias BU.HeaderWhiteTealCMD='BU.Main.Headers.Header.CMD.White.Teal';
alias BU.HeaderWhiteTurquoiseCMD='BU.Main.Headers.Header.CMD.White.Turquoise';
alias BU.HeaderWhiteVioletCMD='BU.Main.Headers.Header.CMD.White.Violet';

alias BU.HeaderWhiteYellowCMD='BU.Main.Headers.Header.CMD.White.Yellow';

# -----------------------------------------------

## YELLOW LINES, DIFFERENTLY COLORED TEXT

# Strings
alias BU.HeaderYellowAqua='BU.Main.Headers.Header.Yellow.Aqua';
alias BU.HeaderYellowBlack='BU.Main.Headers.Header.Yellow.Black';
alias BU.HeaderYellowBlue='BU.Main.Headers.Header.Yellow.Blue';

alias BU.HeaderYellowCyan='BU.Main.Headers.Header.Yellow.Cyan';
alias BU.HeaderYellowFuchsia='BU.Main.Headers.Header.Yellow.Fuchsia';
alias BU.HeaderYellowGray='BU.Main.Headers.Header.Yellow.Gray';

alias BU.HeaderYellowGreen='BU.Main.Headers.Header.Yellow.Green';
alias BU.HeaderYellowLime='BU.Main.Headers.Header.Yellow.Lime';
alias BU.HeaderYellowMaroon='BU.Main.Headers.Header.Yellow.Maroon';

alias BU.HeaderYellowNavy='BU.Main.Headers.Header.Yellow.Navy';
alias BU.HeaderYellowOlive='BU.Main.Headers.Header.Yellow.Olive';
alias BU.HeaderYellowOrange='BU.Main.Headers.Header.Yellow.Orange';

alias BU.HeaderYellowPink='BU.Main.Headers.Header.Yellow.Pink';
alias BU.HeaderYellowPurple='BU.Main.Headers.Header.Yellow.Purple';
alias BU.HeaderYellowRed='BU.Main.Headers.Header.Yellow.Red';

alias BU.HeaderYellowSalmon='BU.Main.Headers.Header.Yellow.Salmon';
alias BU.HeaderYellowSilver='BU.Main.Headers.Header.Yellow.Silver';
alias BU.HeaderYellowTan='BU.Main.Headers.Header.Yellow.Tan';

alias BU.HeaderYellowTeal='BU.Main.Headers.Header.Yellow.Teal';
alias BU.HeaderYellowTurquoise='BU.Main.Headers.Header.Yellow.Turquoise';
alias BU.HeaderYellowViolet='BU.Main.Headers.Header.Yellow.Violet';

alias BU.HeaderYellowWhite='BU.Main.Headers.Header.Yellow.White';

# Command substitutions
alias BU.HeaderYellowAquaCMD='BU.Main.Headers.Header.CMD.Yellow.Aqua';
alias BU.HeaderYellowBlackCMD='BU.Main.Headers.Header.CMD.Yellow.Black';
alias BU.HeaderYellowBlueCMD='BU.Main.Headers.Header.CMD.Yellow.Blue';

alias BU.HeaderYellowCyanCMD='BU.Main.Headers.Header.CMD.Yellow.Cyan';
alias BU.HeaderYellowFuchsiaCMD='BU.Main.Headers.Header.CMD.Yellow.Fuchsia';
alias BU.HeaderYellowGrayCMD='BU.Main.Headers.Header.CMD.Yellow.Gray';

alias BU.HeaderYellowGreenCMD='BU.Main.Headers.Header.CMD.Yellow.Green';
alias BU.HeaderYellowLimeCMD='BU.Main.Headers.Header.CMD.Yellow.Lime';
alias BU.HeaderYellowMaroonCMD='BU.Main.Headers.Header.CMD.Yellow.Maroon';

alias BU.HeaderYellowNavyCMD='BU.Main.Headers.Header.CMD.Yellow.Navy';
alias BU.HeaderYellowOliveCMD='BU.Main.Headers.Header.CMD.Yellow.Olive';
alias BU.HeaderYellowOrangeCMD='BU.Main.Headers.Header.CMD.Yellow.Orange';

alias BU.HeaderYellowPinkCMD='BU.Main.Headers.Header.CMD.Yellow.Pink';
alias BU.HeaderYellowPurpleCMD='BU.Main.Headers.Header.CMD.Yellow.Purple';
alias BU.HeaderYellowRedCMD='BU.Main.Headers.Header.CMD.Yellow.Red';

alias BU.HeaderYellowSalmonCMD='BU.Main.Headers.Header.CMD.Yellow.Salmon';
alias BU.HeaderYellowSilverCMD='BU.Main.Headers.Header.CMD.Yellow.Silver';
alias BU.HeaderYellowTanCMD='BU.Main.Headers.Header.CMD.Yellow.Tan';

alias BU.HeaderYellowTealCMD='BU.Main.Headers.Header.CMD.Yellow.Teal';
alias BU.HeaderYellowTurquoiseCMD='BU.Main.Headers.Header.CMD.Yellow.Turquoise';
alias BU.HeaderYellowVioletCMD='BU.Main.Headers.Header.CMD.Yellow.Violet';

alias BU.HeaderYellowWhiteCMD='BU.Main.Headers.Header.CMD.Yellow.White';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

###################################### DEFINING ALIASES - OS ######################################

#### CATEGORY : "ANDROID"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSAndroidTermux='BU.Main.OS.IsAndroidTermux';

alias BU.IsAndroid4='BU.Main.OS.IsAndroid4';
alias BU.IsAndroid5='BU.Main.OS.IsAndroid5';
alias BU.IsAndroid6='BU.Main.OS.IsAndroid6';
alias BU.IsAndroid7='BU.Main.OS.IsAndroid7';
alias BU.IsAndroid8='BU.Main.OS.IsAndroid8';
alias BU.IsAndroid9='BU.Main.OS.IsAndroid9';
alias BU.IsAndroid10='BU.Main.OS.IsAndroid10';
alias BU.IsAndroid11='BU.Main.OS.IsAndroid11';

alias BU.IsAndroidDeviceSmartphone='function BU.Main.OS.IsAndroidDeviceSmartphone';
alias BU.IsAndroidDeviceTablet='BU.Main.OS.IsAndroidDeviceTablet';

alias BU.IsAndroidRooted='BU.Main.OS.IsAndroidRooted';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

alias BU.GetAndroidDevice='BU.Main.OS.GetAndroidDevice';
alias BU.GetAndroidVersion='BU.Main.OS.GetAndroidVersion';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "BSD (GENERAL)"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSBSD='BU.Main.OS.IsBSD';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "BSD (FREE BSD)"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSFreeBSD='BU.Main.OS.IsFreeBSD';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "BSD (NET BSD)"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSNetBSD='BU.Main.OS.IsNetBSD';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "OPEN BSD"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSOpenBSD='BU.Main.OS.IsOpenBSD';

# -----------------------------------------------

## SUB-CATEGORY : GATHERING INFORMATIONS

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "CHROME OS"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSChromeOS='BU.Main.OS.IsChromeOS';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "HAIKU"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.IsOSHaiku='BU.Main.OS.IsHaiku';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "GENERAL OS FUNCTIONS"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.GetCurrentOS='BU.Main.OS.GetCurrentOS';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : "LINUX"

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.CheckLinuxDistro='BU.Main.OS.CheckLinuxDistro';
alias BU.CheckLinuxDistroVersion='BU.Main.OS.CheckLinuxDistroVersion';

alias BU.CheckLinuxKernelMajorVersion='BU.Main.OS.CheckLinuxKernelMajorVersion';
alias BU.CheckLinuxKernelMinorVersion='BU.Main.OS.CheckLinuxKernelMinorVersion';
alias BU.CheckLinuxKernelVersion='BU.Main.OS.CheckLinuxKernelVersion';

alias BU.IsOSLinux='BU.Main.OS.IsLinux';

# --------------------
alias BU.IsOSLinuxDistroArchLinux='BU.Main.OS.IsLinuxDistroArchLinux';


# --------------------
# Checking if current Linux distribution is Debian.
alias BU.IsOSLinuxDistroDebian='BU.Main.OS.IsLinuxDistroDebian';

# Checking debian versions.
alias BU.IsOSLinuxDistroDebian4='BU.Main.OS.IsLinuxDistroDebian4';
alias BU.IsOSLinuxDistroDebian5='BU.Main.OS.IsLinuxDistroDebian5';
alias BU.IsOSLinuxDistroDebian6='BU.Main.OS.IsLinuxDistroDebian6';
alias BU.IsOSLinuxDistroDebian7='BU.Main.OS.IsLinuxDistroDebian7';
alias BU.IsOSLinuxDistroDebian8='BU.Main.OS.IsLinuxDistroDebian8';
alias BU.IsOSLinuxDistroDebian9='BU.Main.OS.IsLinuxDistroDebian9';
alias BU.IsOSLinuxDistroDebian10='BU.Main.OS.IsLinuxDistroDebian10';
alias BU.IsOSLinuxDistroDebian11='BU.Main.OS.IsLinuxDistroDebian11';


# --------------------
# Checking if current Linux distribution is Fedora.
alias BU.IsOSLinuxDistroFedora='BU.Main.OS.IsLinuxDistroFedora';

# Checking Fedora versions.
alias BU.IsOSLinuxDistroFedora18='BU.Main.OS.IsLinuxDistroFedora18';
alias BU.IsOSLinuxDistroFedora19='BU.Main.OS.IsLinuxDistroFedora19';
alias BU.IsOSLinuxDistroFedora20='BU.Main.OS.IsLinuxDistroFedora20';
alias BU.IsOSLinuxDistroFedora21='BU.Main.OS.IsLinuxDistroFedora21';
alias BU.IsOSLinuxDistroFedora22='BU.Main.OS.IsLinuxDistroFedora22';
alias BU.IsOSLinuxDistroFedora23='BU.Main.OS.IsLinuxDistroFedora23';
alias BU.IsOSLinuxDistroFedora24='BU.Main.OS.IsLinuxDistroFedora24';
alias BU.IsOSLinuxDistroFedora25='BU.Main.OS.IsLinuxDistroFedora25';
alias BU.IsOSLinuxDistroFedora26='BU.Main.OS.IsLinuxDistroFedora26';
alias BU.IsOSLinuxDistroFedora27='BU.Main.OS.IsLinuxDistroFedora27';
alias BU.IsOSLinuxDistroFedora28='BU.Main.OS.IsLinuxDistroFedora28';
alias BU.IsOSLinuxDistroFedora29='BU.Main.OS.IsLinuxDistroFedora29';
alias BU.IsOSLinuxDistroFedora30='BU.Main.OS.IsLinuxDistroFedora30';
alias BU.IsOSLinuxDistroFedora31='BU.Main.OS.IsLinuxDistroFedora31';
alias BU.IsOSLinuxDistroFedora32='BU.Main.OS.IsLinuxDistroFedora32';
alias BU.IsOSLinuxDistroFedora33='BU.Main.OS.IsLinuxDistroFedora33';
alias BU.IsOSLinuxDistroFedora34='BU.Main.OS.IsLinuxDistroFedora34';
alias BU.IsOSLinuxDistroFedora35='BU.Main.OS.IsLinuxDistroFedora35';
alias BU.IsOSLinuxDistroFedora36='BU.Main.OS.IsLinuxDistroFedora36';


# --------------------
# Checking if current Linux distribution is Linux Mint.
alias BU.IsOSLinuxDistroLinuxMint='BU.Main.OS.IsLinuxDistroLinuxMint';


# --------------------
# Checking if current Linux distribution is Manjaro.
alias BU.IsOSLinuxDistroManjaro='BU.Main.OS.IsLinuxDistroManjaro';


# --------------------
# Checking if current Linux distribution is SUSE.
alias BU.IsOSLinuxDistroSUSE='BU.Main.OS.IsLinuxDistroSUSE';


# --------------------
# Checking if current Linux distribution is Ubuntu.
alias BU.IsOSLinuxDistroUbuntu='BU.Main.OS.IsLinuxDistroUbuntu';

# Checking Ubuntu versions.
alias BU.IsOSLinuxDistroUbuntu1004='BU.Main.OS.IsLinuxDistroUbuntu1004';
alias BU.IsOSLinuxDistroUbuntu1010='BU.Main.OS.IsLinuxDistroUbuntu1010';
alias BU.IsOSLinuxDistroUbuntu1104='BU.Main.OS.IsLinuxDistroUbuntu1104';
alias BU.IsOSLinuxDistroUbuntu1110='BU.Main.OS.IsLinuxDistroUbuntu1110';
alias BU.IsOSLinuxDistroUbuntu1204='BU.Main.OS.IsLinuxDistroUbuntu1204';
alias BU.IsOSLinuxDistroUbuntu1210='BU.Main.OS.IsLinuxDistroUbuntu1210';
alias BU.IsOSLinuxDistroUbuntu1304='BU.Main.OS.IsLinuxDistroUbuntu1304';
alias BU.IsOSLinuxDistroUbuntu1310='BU.Main.OS.IsLinuxDistroUbuntu1310';
alias BU.IsOSLinuxDistroUbuntu1404='BU.Main.OS.IsLinuxDistroUbuntu1404';
alias BU.IsOSLinuxDistroUbuntu1410='BU.Main.OS.IsLinuxDistroUbuntu1410';
alias BU.IsOSLinuxDistroUbuntu1504='BU.Main.OS.IsLinuxDistroUbuntu1504';
alias BU.IsOSLinuxDistroUbuntu1510='BU.Main.OS.IsLinuxDistroUbuntu1510';
alias BU.IsOSLinuxDistroUbuntu1604='BU.Main.OS.IsLinuxDistroUbuntu1604';
alias BU.IsOSLinuxDistroUbuntu1610='BU.Main.OS.IsLinuxDistroUbuntu1610';
alias BU.IsOSLinuxDistroUbuntu1704='BU.Main.OS.IsLinuxDistroUbuntu1704';
alias BU.IsOSLinuxDistroUbuntu1710='BU.Main.OS.IsLinuxDistroUbuntu1710';
alias BU.IsOSLinuxDistroUbuntu1804='BU.Main.OS.IsLinuxDistroUbuntu1804';
alias BU.IsOSLinuxDistroUbuntu1810='BU.Main.OS.IsLinuxDistroUbuntu1810';
alias BU.IsOSLinuxDistroUbuntu1904='BU.Main.OS.IsLinuxDistroUbuntu1904';
alias BU.IsOSLinuxDistroUbuntu1910='BU.Main.OS.IsLinuxDistroUbuntu1910';
alias BU.IsOSLinuxDistroUbuntu2004='BU.Main.OS.IsLinuxDistroUbuntu2004';
alias BU.IsOSLinuxDistroUbuntu2010='BU.Main.OS.IsLinuxDistroUbuntu2010';
alias BU.IsOSLinuxDistroUbuntu2104='BU.Main.OS.IsLinuxDistroUbuntu2104';
alias BU.IsOSLinuxDistroUbuntu2110='BU.Main.OS.IsLinuxDistroUbuntu2110';
alias BU.IsOSLinuxDistroUbuntu2204='BU.Main.OS.IsLinuxDistroUbuntu2204';
alias BU.IsOSLinuxDistroUbuntu2210='BU.Main.OS.IsLinuxDistroUbuntu2210';

# --------------------

# Checking the current major Linux kernel version.
alias BU.IsLinuxKernelMajor3='BU.Main.OS.IsLinuxKernelMajor3';
alias BU.IsLinuxKernelMajor4='BU.Main.OS.IsLinuxKernelMajor4';
alias BU.IsLinuxKernelMajor5='BU.Main.OS.IsLinuxKernelMajor5';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"


# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : OSX

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.CheckOSXVersion='BU.Main.OS.CheckOSXVersion';

alias BU.IsOSX='BU.Main.OS.IsOSX';

alias BU.IsOSXYosemite='BU.Main.OS.IsOSXYosemite';
alias BU.IsOSXElCapitan='BU.Main.OS.IsOSXElCapitan';
alias BU.IsOSXSierra='BU.Main.OS.IsOSXSierra';
alias BU.IsOSXHighSierra='BU.Main.OS.IsOSXHighSierra';
alias BU.IsOSXMojave='BU.Main.OS.IsOSXMojave';
alias BU.IsOSXCatalina='BU.Main.OS.IsOSXCatalina';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : VIRTUAL MACHINES

## SUB-CATEGORY : CHECKING INFORMATIONS

alias BU.IsRunningInQemu='BU.Main.OS.IsRunningInQemu';
alias BU.IsRunningInVMware='BU.Main.OS.IsRunningInVMware';
alias BU.IsRunningInVirtualBox='BU.Main.OS.IsRunningInVirtualBox';
alias BU.IsVirtualized='BU.Main.OS.IsVirtualized';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### CATEGORY : WINDOWS

## SUB-CATEGORY : "CHECKING INFORMATIONS"

alias BU.CheckOSWindowsVersion='BU.Main.OS.CheckOSWindowsVersion';

alias BU.IsWindows32bits='BU.Main.OS.IsWindows32bits';
alias BU.IsWindows64bits='BU.Main.OS.IsWindows64bits';
alias BU.IsWindowsFamily='BU.Main.OS.IsWindowsFamily';
alias BU.IsWindowsPro='BU.Main.OS.IsWindowsPro';
alias BU.IsWindowsLTSC='BU.Main.OS.IsWindowsLTSC';

alias BU.IsOSWindows10='BU.Main.OS.IsWindows10';
alias BU.IsOSWindows10Family='BU.Main.OS.IsWindows10Family';
alias BU.IsOSWindows10Pro='BU.Main.OS.IsWindows10Pro';
alias BU.IsOSWindows10LTSC='BU.Main.OS.IsWindows10LTSC';

alias BU.IsOSWindows11='BU.Main.OS.IsWindows11';
alias BU.IsOSWindows11Family='BU.Main.OS.IsWindows11Family';
alias BU.IsOSWindows11Pro='BU.Main.OS.IsWindows11Pro';
alias BU.IsOSWindows11LTSC='BU.Main.OS.IsWindows11LTSC';

alias BU.IsOSLinuxWSL='BU.Main.OS.IsLinuxWSL';
alias BU.IsOSLinuxWSL1='BU.Main.OS.IsLinuxWSL1';
alias BU.IsOSLinuxWSL2='BU.Main.OS.IsLinuxWSL2';

# -----------------------------------------------

## SUB-CATEGORY : "GATHERING INFORMATIONS"

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################### DEFINING ALIASES - POSIXTERM ##################################

#### CATEGORY : "TERMINAL INTERACTION FUNCTIONS"

## SUB-CATEGORY : "DISPLAYING TEXT AND MORE WHILE A TASK IS ONGOING"

alias BU.DisplayCountdown='BU.Main.PosixTerm.DisplayCountdown';
alias BU.DisplayProgressBar='BU.Main.PosixTerm.DisplayProgressBar';
alias BU.DisplaySpinner='BU.Main.PosixTerm.DisplaySpinner';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING ALIASES - STATUS ####################################

#### CATEGORY : "VARIABLES VALUES FUNCTIONS"

## SUB-CATEGORY : "CHECKING VALUES"

alias BU.ConfEcho='BU.Main.Status.ConfEcho';

# -----------------------------------------------

# SUB-CATEGORY : "CHECKINGS"

alias BU.CheckSTAT_DECHO='BU.Main.Status.CheckSTAT_DECHO';
alias BU.CheckSTAT_ECHO='BU.Main.Status.CheckSTAT_ECHO';
alias BU.CheckSTAT_ERROR='BU.Main.Status.CheckSTAT_ERROR';
alias BU.CheckSTAT_INITIALIZING='BU.Main.Status.CheckSTAT_INITIALIZING';
alias BU.CheckSTAT_LOG='BU.Main.Status.CheckSTAT_LOG';
alias BU.CheckSTAT_LOG_REDIRECT='BU.Main.Status.CheckSTAT_LOG_REDIRECT';
alias BU.CheckSTAT_OPERATE_ROOT='BU.Main.Status.CheckSTAT_OPERATE_ROOT';
alias BU.CheckSTAT_TIME_HEADER='BU.Main.Status.CheckSTAT_TIME_HEADER';
alias BU.CheckSTAT_TIME_NEWLINE='BU.Main.Status.CheckSTAT_TIME_NEWLINE';
alias BU.CheckSTAT_TIME_TXT='BU.Main.Status.CheckSTAT_TIME_TXT';
alias BU.CheckSTAT_TXT_FMT='BU.Main.Status.CheckSTAT_TXT_FMT';
alias BU.CheckSTAT_USER_OS='BU.Main.Status.CheckSTAT_USER_OS';

alias BU.CheckProjectStatusVars='BU.Main.Status.CheckProjectStatusVars';

# -----------------------------------------------

## SUB-CATEGORY : "CHANGING VALUES MORE EASILY"

alias BU.ChangeSTAT_DECHO='BU.Main.Status.ChangeSTAT_DECHO';
alias BU.ChangeSTAT_ECHO='BU.Main.Status.ChangeSTAT_ECHO';
alias BU.ChangeSTAT_ERROR='BU.Main.Status.ChangeSTAT_ERROR';
alias BU.ChangeSTAT_INITIALIZING='BU.Main.Status.ChangeSTAT_INITIALIZING';
alias BU.ChangeSTAT_LOG='BU.Main.Status.ChangeSTAT_LOG';
alias BU.ChangeSTAT_LOG_REDIRECT='BU.Main.Status.ChangeSTAT_LOG_REDIRECT';
alias BU.ChangeSTAT_OPERATE_ROOT='BU.Main.Status.ChangeSTAT_OPERATE_ROOT';
alias BU.ChangeSTAT_TIME_HEADER='BU.Main.Status.ChangeSTAT_TIME_HEADER';
alias BU.ChangeSTAT_TIME_NEWLINE='BU.Main.Status.ChangeSTAT_TIME_NEWLINE';
alias BU.ChangeSTAT_TIME_TXT='BU.Main.Status.ChangeSTAT_TIME_TXT';
alias BU.ChangeSTAT_TXT_FMT='BU.Main.Status.ChangeSTAT_TXT_FMT';

# -----------------------------------------------

## SUB-CATEGORY : "EASIER BOOLEAN VALUES CHECKINGS"

alias BU.CheckStatIsBackupEchoing='BU.Main.Status.CheckStatIsBackupEchoing';
alias BU.CheCheckStatIsInitializingckStat='BU.Main.Status.CheckStatIsInitializing';
alias BU.CheckStatIsLogging='BU.Main.Status.CheckStatIsLogging';
alias BU.CheckStatIsPrintingInit='BU.Main.Status.CheckStatIsPrintingInit';
alias BU.CheckStatAllowFormatting='BU.Main.Status.CheckStatAllowFormatting';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - TEXT #####################################

#### CATEGORY : "TEXT PROCESSING FUNCTIONS"

## SUB-CATEGORY : "CUTTING TEXT"

alias BU.CutLogDateFromString='BU.Main.Text.CutLogDateFromString';
alias BU.CutDashFromOption='BU.Main.Text.CutDashFromOption';
alias BU.CutSubStringAfterNthDelim='BU.Main.Text.CutSubStringAfterNthDelim';
alias BU.CutSubStringBeforeNthDelim='BU.Main.Text.CutSubStringBeforeNthDelim';
alias BU.CutFirstFieldBeforeDelim='BU.Main.Text.CutFirstFieldBeforeDelim';
alias BU.CutLastFieldAfterDelim='BU.Main.Text.CutLastFieldAfterDelim';
alias BU.DeleteLettersInString='BU.Main.Text.DeleteLettersInString';

# -----------------------------------------------

## SUB-CATEGORY : "FORMATTING TEXT"

alias BU.KeepFormatting='BU.Main.Text.KeepFormatting';
alias BU.ToLowercase='BU.Main.Text.ToLowercase';
alias BU.ToUppercase='BU.Main.Text.ToUppercase';

# -----------------------------------------------

## SUB-CATEGORY : "GETTING TEXT"

alias BU.GetCharacterOccurences='BU.Main.Text.GetCharacterOccurences';
alias BU.GetFirstFieldBeforeDelim='BU.Main.Text.GetFirstFieldBeforeDelim';
alias BU.GetLastFieldAfterDelim='BU.Main.Text.GetLastFieldAfterDelim';
alias BU.GetSubStringAfterDelim='BU.Main.Text.GetSubStringAfterDelim';
alias BU.GetSubStringBeforeDelim='BU.Main.Text.GetSubStringBeforeDelim';
alias BU.GetSubStringOccurences='BU.Main.Text.GetSubStringOccurences';
alias BU.GetStringByteSize='BU.Main.Text.GetStringByteSize';
alias BU.GetStringCharactersNumber='BU.Main.Text.GetStringCharactersNumber';
alias BU.GetStringWordsNumber='BU.Main.Text.GetStringWordsNumber';

# -----------------------------------------------

## SUB-CATEGORY : "PRINTING TEXT"

alias BU.PrintCharXTimes='BU.Main.Text.PrintCharXTimes';

# -----------------------------------------------

## SUB-CATEGORY : "REVERSING TEXT"

alias BU.ReverseStringWordsOrder='BU.Main.Text.ReverseStringWordsOrder';
alias BU.ReverseCharactersOrder='BU.Main.Text.ReverseCharactersOrder';

# -----------------------------------------------

## SUB-CATEGORY : "SPLITTING TEXT AND SPLITTED TEXT PROCESSING"

alias BU.StrToWordArray='BU.Main.Text.StrToWordArray';
alias BU.WordArrayToStr='BU.Main.Text.WordArrayToStr';

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

##################################### DEFINING ALIASES - TIME #####################################

#### CATEGORY : ""

## SUB-CATEGORY : ""

#

# Sub-category : ""

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING ALIASES - USAGE  ####################################

#### CATEGORY : ""

## SUB-CATEGORY : ""

#

# Sub-category : ""

# -----------------------------------------------
#!/usr/bin/env bash
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every background color-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### ENCODING WITH THE "$(tput)" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetBGColor()" FUNCTION

## BACKGROUND ENCODING

# Writing the command substitution text for the background coloration

# Don't call the "BU.Main.Decho.Decho.Function()" function to color the function name, it must stay perfectly visible on every colors, and the default,
# and the "$[__BU_MAIN_STAT_DECHO]" function's value is still set as its default value (in order to avoid bugs during the main module's initialization) : forbid

# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub()
{
    case "${2^^}" in
        'A')        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_BG__PrintColorVarNameCmdSub_FNCT_A}" "${1}";;
        'C' | *)    printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_BG__PrintColorVarNameCmdSub_FNCT_C}" "${1}";;
    esac
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ENCODING WITH THE "tput" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetBGColor" FUNCTIONS

## BACKGROUND ENCODING

declare -i ____BU_MAIN_MOD_BG_COLOR_DEF_LINENO;

# -----------------------------
# Aqua blue colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_AQUA="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_AQUA}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_AQUA' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_AQUA}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_AQUA'  "${__BU_MAIN_COLOR_BG_AQUA}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_AQUA}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------------------------
# Black colored background.
# -------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_BLACK="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_BLACK}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_BLACK' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_BLACK}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_BLACK' "${__BU_MAIN_COLOR_BG_BLACK}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLACK}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -----------------------------
# Deep blue colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_BLUE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_BLUE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_BLUE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

     BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_BLUE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_BLUE'  "${__BU_MAIN_COLOR_BG_BLUE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLUE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# -----------------------------
# Cyan blue colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_CYAN="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_CYAN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_CYAN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_CYAN}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_CYAN'  "${__BU_MAIN_COLOR_BG_CYAN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_CYAN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# ---------------------------
# Fuchsia colored background.
# ---------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_FUCHSIA="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_FUCHSIA}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_FUCHSIA' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_FUCHSIA}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_FUCHSIA'   "${__BU_MAIN_COLOR_BG_FUCHSIA}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_FUCHSIA}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};

# ------------------------
# Gray colored background.
# ------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_GRAY="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_GRAY}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_GRAY' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_GRAY}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_GRAY'  "${__BU_MAIN_COLOR_BG_GRAY}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GRAY}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# -------------------------------
# Light green colored background.
# -------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_GREEN="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_GREEN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_GREEN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_GREEN}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_GREEN' "${__BU_MAIN_COLOR_BG_GREEN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GREEN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# ------------------------------
# Lime green colored background.
# ------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_LIME="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_LIME}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_LIME' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_LIME}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_LIME'  "${__BU_MAIN_COLOR_BG_LIME}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_LIME}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# --------------------------
# Marron colored background.
# --------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_MAROON="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_MAROON}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_MAROON' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_MAROON}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_MAROON'    "${__BU_MAIN_COLOR_BG_MAROON}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_MAROON}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# -----------------------------
# Navy blue colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_NAVY="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_NAVY}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_NAVY' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_NAVY}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_NAVY' "${__BU_MAIN_COLOR_BG_NAVY}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_NAVY}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------------------------------
# Green olive colored background.
# -------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_OLIVE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_OLIVE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_OLIVE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_OLIVE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_OLIVE' "${__BU_MAIN_COLOR_BG_OLIVE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_OLIVE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};

# --------------------------
# Orange colored background.
# --------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_ORANGE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_ORANGE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_ORANGE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_ORANGE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_ORANGE'    "${__BU_MAIN_COLOR_BG_ORANGE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_ORANGE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# ------------------------
# Pink colored background.
# ------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_PINK="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_PINK}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_PINK' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_PINK}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_PINK'  "${__BU_MAIN_COLOR_BG_PINK}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PINK}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};

# --------------------------
# Purple colored background.
# --------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_PURPLE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_PURPLE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_PURPLE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_PURPLE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_PURPLE'    "${__BU_MAIN_COLOR_BG_PURPLE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PURPLE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};

# -----------------------------
# Light red colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_RED="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_RED}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_RED' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_RED}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_RED'   "${__BU_MAIN_COLOR_BG_RED}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_RED}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# --------------------------
# Salmon colored background.
# --------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_SALMON="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_SALMON}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_SALMON' "$(basename "${BASH_SOURCE[0]}")"   "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;  BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_SALMON}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_SALMON'    "${__BU_MAIN_COLOR_BG_SALMON}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SALMON}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------------------------------
# Silver gray colored background.
# -------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_SILVER="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_SILVER}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_SILVER' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_SILVER}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_SILVER'    "${__BU_MAIN_COLOR_BG_SILVER}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GRAY}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -----------------------------
# Brown tan colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_TAN="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_TAN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_TAN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_TAN}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_TAN'   "${__BU_MAIN_COLOR_BG_TAN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TAN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# ------------------------
# Teal colored background.
# ------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_TEAL="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_TEAL}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_TEAL' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;  BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_TEAL}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_TEAL'  "${__BU_MAIN_COLOR_BG_TEAL}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TEAL}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -----------------------------
# Turquoise colored background.
# -----------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_TURQUOISE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_TURQUOISE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_TURQUOISE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_TURQUOISE}";    printf "%s"     "${__BU_MAIN_COLOR_TXT_BLACK}";
     BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_TURQUOISE'    "${__BU_MAIN_COLOR_BG_TURQUOISE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub                  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TURQUOISE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# --------------------------
# Violet colored background.
# --------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_VIOLET="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_VIOLET}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_VIOLET' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_VIOLET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_VIOLET'    "${__BU_MAIN_COLOR_BG_VIOLET}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_VIOLET}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# -------

# -------------------------
# White colored background.
# -------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_WHITE="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_WHITE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_WHITE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_WHITE}";
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_WHITE' "${__BU_MAIN_COLOR_BG_WHITE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub          "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_WHITE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};


# --------------------------------
# Light yellow colored background.
# --------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_YELLOW="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_YELLOW}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_YELLOW' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_YELLOW}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_YELLOW'    "${__BU_MAIN_COLOR_BG_YELLOW}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub              "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_YELLOW}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
};

printf "%s" "${__BU_MAIN_COLOR_TXT_RESET}";

# -----------------------------------------------

## SPECIFIC BACKGROUND COLORS ENCODING

# Note : You can check their default color in the "Colors.conf" configuration file.

# ----------------------------------------------------------------------------
# Background color display context : highlighting the name of a system command
# ----------------------------------------------------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_CMD="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_CMD}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_CMD' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_CMD}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_CMD' "${__BU_MAIN_COLOR_BG_CMD}" 'CMD' \
    "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_CMD}" 'A')" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# ----------------------------------------------------------------
# Background color display context : highlighting an error message
# ----------------------------------------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_ERROR="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_ERROR}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_ERROR' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_ERROR}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_ERROR' "${__BU_MAIN_COLOR_BG_ERROR}" 'CMD' \
    "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_ERROR}" 'A')" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# ---------------------------------------------------------------
# Background color display context : highlighting a function name
# ---------------------------------------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_FUNCTION="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_FUNCTION}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_FUNCTION' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_FUNCTION}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_FUNCTION' "${__BU_MAIN_COLOR_BG_FUNCTION}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_FUNCTION}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# ---------------------------------------------------------------------------
# Background color display context : highlighting important part(s) of a text
# ---------------------------------------------------------------------------

# Setting a readable text color for this background color.
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_HIGHLIGHT="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_HIGHLIGHT' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_HIGHLIGHT}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_HIGHLIGHT' "${__BU_MAIN_COLOR_BG_HIGHLIGHT}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_HIGHLIGHT}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# ------------------------------------------------------------------
# Background color display context : highlighting a new step message
# ------------------------------------------------------------------

# Setting a readable text color for this background color.
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_NEWSTEP="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_NEWSTEP}" '--no-function')" || {

    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_NEWSTEP' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_NEWSTEP}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_NEWSTEP' "${__BU_MAIN_COLOR_BG_NEWSTEP}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_NEWSTEP}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# ----------------------------------------------------------------------------
# Background color display context : highlighting a path to a file or a folder
# ----------------------------------------------------------------------------

# Setting a readable text color for this background color.
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_PATH="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_PATH}" '--no-function')" || {

    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_PATH' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_PATH}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_PATH' "${__BU_MAIN_COLOR_BG_PATH}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_PATH}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# -----------------------------------------------------------------
# Background color display context : highlighting a success message
# -----------------------------------------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_SUCCESS="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_SUCCESS}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_SUCCESS' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_SUCCESS}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_SUCCESS' "${__BU_MAIN_COLOR_BG_SUCCESS}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_SUCCESS}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# --------------------------------------------------------------------------------------------------
# Background color display context : highlighting the name of a variable, a parameter or an argument
# --------------------------------------------------------------------------------------------------

# Setting a readable text color for this background color.
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_VAR="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_VAR}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_VAR' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_VAR}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_VAR' "${__BU_MAIN_COLOR_BG_VAR}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_VAR}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# -----------------------------------------------------------------
# Background color display context : highlighting a warning message
# -----------------------------------------------------------------

# Setting a readable text color for this background color.
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_WARNING="$(BU.Main.TextFormat.SetBGColor "${__BU_MAIN_COLOR_CODE_WARNING}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_BG_WARNING' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_WARNING}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_WARNING' "${__BU_MAIN_COLOR_BG_WARNING}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.BG.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_WARNING}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# -----------------------------------------------------------------------
# Resetting the text's background color to terminal's default text color.
# -----------------------------------------------------------------------

____BU_MAIN_MOD_BG_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_BG_RESET="${__BU_MAIN_COLOR_CODE_RESET}";

[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_BG_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_BG_RESET' "${__BU_MAIN_COLOR_BG_RESET}" 'CMD' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_RESET}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}";
}


# Deleting the "${____BU_MAIN_MOD_BG_COLOR_DEF_LINENO}" variable, since its presence is not useful anymore.
unset ____BU_MAIN_MOD_BG_COLOR_DEF_LINENO;

# -----------------------------------------------
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every color-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### RAW CODES DATA

## COLOR CODES

# Writing the message for the variables which store a raw color code.

# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName()
{
    case "${2^^}" in
        'A')        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintRawColorCodeVarsName_FNCT_A}" "${1}";;
        'C' | *)    printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintRawColorCodeVarsName_FNCT_C}" "${1}";;
    esac
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### OTHER FUNCTIONS

## ERROR FUNCTIONS

# Writing the name of the variable that could not be initialized with it's command substitution.

# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize() {
    # ${1} -> Variable's name | ${2} -> "$(basename "${BASH_SOURCE[0]}")" | ${3} -> LINENO (line number)
    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${3}" 'E_BUINIT__BU_MAIN_MODCONFIG__COLOR_VAR_NOT_INIT';

    case "${4^^}" in
        'A')        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintVariableNameFailedToInitialize_FNCT_A}\n" "${2}" "${3}" "${1}";;
        'C' | *)    printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__PrintVariableNameFailedToInitialize_FNCT_C}\n" "${2}" "${3}" "${1}";;

    esac
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Feel free to define any other needed resources (functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### COLOR ENCODING

## COLOR CODES FOR TEXT ENCODING (SYSTEM)

declare -i __BU_MAIN_COLOR_CODE_BLACK='0';
declare -i __BU_MAIN_COLOR_CODE_MAROON='1';
declare -i __BU_MAIN_COLOR_CODE_GREEN='2';
declare -i __BU_MAIN_COLOR_CODE_OLIVE='3';

declare -i __BU_MAIN_COLOR_CODE_NAVY='4';
declare -i __BU_MAIN_COLOR_CODE_PURPLE='5';
declare -i __BU_MAIN_COLOR_CODE_TEAL='6';
declare -i __BU_MAIN_COLOR_CODE_SILVER='7';

declare -i __BU_MAIN_COLOR_CODE_GRAY="8";
declare -i __BU_MAIN_COLOR_CODE_RED='9';
declare -i __BU_MAIN_COLOR_CODE_LIME='10';
declare -i __BU_MAIN_COLOR_CODE_YELLOW='11';

declare -i __BU_MAIN_COLOR_CODE_BLUE='12';
declare -i __BU_MAIN_COLOR_CODE_FUCHSIA='13';
declare -i __BU_MAIN_COLOR_CODE_AQUA='14';
declare -i __BU_MAIN_COLOR_CODE_WHITE='15';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_BLACK'       "${__BU_MAIN_COLOR_CODE_BLACK}"     'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLACK}" 'C')"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_MAROON'      "${__BU_MAIN_COLOR_CODE_MAROON}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_MAROON}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_GREEN'       "${__BU_MAIN_COLOR_CODE_GREEN}"     'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GREEN}" 'C')"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_OLIVE'       "${__BU_MAIN_COLOR_CODE_OLIVE}"     'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_OLIVE}" 'C')"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_NAVY'        "${__BU_MAIN_COLOR_CODE_NAVY}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_NAVY}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_PURPLE'      "${__BU_MAIN_COLOR_CODE_PURPLE}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PURPLE}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_TEAL'        "${__BU_MAIN_COLOR_CODE_TEAL}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TEAL}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_SILVER'      "${__BU_MAIN_COLOR_CODE_SILVER}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SILVER}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_GRAY'        "${__BU_MAIN_COLOR_CODE_GRAY}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GRAY}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_RED'         "${__BU_MAIN_COLOR_CODE_RED}"       'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_RED}" 'C')"       "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_LIME'        "${__BU_MAIN_COLOR_CODE_LIME}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_LIME}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_YELLOW'      "${__BU_MAIN_COLOR_CODE_YELLOW}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_YELLOW}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_BLUE'        "${__BU_MAIN_COLOR_CODE_BLUE}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLUE}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_FUCHSIA'     "${__BU_MAIN_COLOR_CODE_FUCHSIA}"   'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_FUCHSIA}" 'C')"   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_AQUA'        "${__BU_MAIN_COLOR_CODE_AQUA}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_AQUA}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_WHITE'       "${__BU_MAIN_COLOR_CODE_WHITE}"     'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_WHITE}" 'C')"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 20 ))";

# -----------------------------------------------

## COLOR CODES FOR TEXT ENCODING (OTHERS)

declare -i __BU_MAIN_COLOR_CODE_CYAN='51';
declare -i __BU_MAIN_COLOR_CODE_ORANGE='166';
declare -i __BU_MAIN_COLOR_CODE_PINK='200';
declare -i __BU_MAIN_COLOR_CODE_SALMON='209';
declare -i __BU_MAIN_COLOR_CODE_TAN='180';
declare -i __BU_MAIN_COLOR_CODE_TURQUOISE='51';
declare -i __BU_MAIN_COLOR_CODE_VIOLET='177';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_CYAN'        "${__BU_MAIN_COLOR_CODE_CYAN}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_CYAN}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_ORANGE'      "${__BU_MAIN_COLOR_CODE_ORANGE}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_ORANGE}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_PINK'        "${__BU_MAIN_COLOR_CODE_PINK}"      'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PINK}" 'C')"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_SALMON'      "${__BU_MAIN_COLOR_CODE_SALMON}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SALMON}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_TAN'         "${__BU_MAIN_COLOR_CODE_TAN}"       'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TAN}" 'C')"       "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_TURQUOISE'   "${__BU_MAIN_COLOR_CODE_TURQUOISE}" 'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TURQUOISE}" 'C')" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_VIOLET'      "${__BU_MAIN_COLOR_CODE_VIOLET}"    'Int'   "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_VIOLET}" 'C')"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 8 ))";

# -----------------------------------------------

## COLOR CODES FOR SPECIFIC TEXT DISPLAY, PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetTextColor" FUNCTIONS, THEN ENCODED WITH THE "tput" COMMAND

# Commands text display color           | Default color : gray
__BU_MAIN_COLOR_CODE_CMD="${__BU_MAIN_COLOR_CODE_GRAY}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_CMD' "${__BU_MAIN_COLOR_CODE_CMD}"               'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_CMD}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Error text display color				| Default color : Red
__BU_MAIN_COLOR_CODE_ERROR="${__BU_MAIN_COLOR_CODE_RED}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_ERROR' "${__BU_MAIN_COLOR_CODE_ERROR}"           'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_ERROR}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Function name display color           | Default color : Purple
__BU_MAIN_COLOR_CODE_FUNCTION="${__BU_MAIN_COLOR_CODE_PURPLE}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_FUNCTION' "${__BU_MAIN_COLOR_CODE_FUNCTION}"     'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_FUNCTION}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Highlighted text display color		| Default color : Cyan
__BU_MAIN_COLOR_CODE_HIGHLIGHT="${__BU_MAIN_COLOR_CODE_CYAN}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_HIGHLIGHT' "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}"   'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_HIGHLIGHT}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Newstep text display color            | Default color : Orange
__BU_MAIN_COLOR_CODE_NEWSTEP="${__BU_MAIN_COLOR_CODE_ORANGE}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_NEWSTEP' "${__BU_MAIN_COLOR_CODE_NEWSTEP}"       'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_NEWSTEP}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Directories and files paths display color     | Default color : Lime
__BU_MAIN_COLOR_CODE_PATH="${__BU_MAIN_COLOR_CODE_LIME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_PATH' "${__BU_MAIN_COLOR_CODE_PATH}"             'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_PATH}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Reset color to terminal's default text color  | Always the "$(tput sgr0)" command.
__BU_MAIN_COLOR_CODE_RESET="$(tput sgr0)"; printf "%s" "${__BU_MAIN_COLOR_CODE_RESET}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_RESET' "${__BU_MAIN_COLOR_CODE_RESET}"           'CMD' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_RESET}" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Success text display color			| Default color : Green
__BU_MAIN_COLOR_CODE_SUCCESS="${__BU_MAIN_COLOR_CODE_GREEN}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_SUCCESS' "${__BU_MAIN_COLOR_CODE_SUCCESS}"       'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_SUCCESS}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Variable, parameter or argument name  | Default color : Orange
__BU_MAIN_COLOR_CODE_VAR="${__BU_MAIN_COLOR_CODE_ORANGE}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_VAR' "${__BU_MAIN_COLOR_CODE_VAR}"               'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_VAR}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Warning text display color			| Default color : Yellow
__BU_MAIN_COLOR_CODE_WARNING="${__BU_MAIN_COLOR_CODE_YELLOW}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_CODE_WARNING' "${__BU_MAIN_COLOR_CODE_WARNING}"       'Int' "$(BU.Main.ModConfig.Colors.PrintRawColorCodeVarsName "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_WARNING}" 'A')" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}"            "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every text color-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### ENCODING WITH THE "$(tput)" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetTextColor()" FUNCTION

## TEXT ENCODING

# Writing the command substitution text for the text coloration.

# Don't call the "BU.Main.Decho.Decho.Function()" function to color the function name, it must stay perfectly visible on every colors, and the default,
# and the "${__BU_MAIN_STAT_DECHO}" function's value is still set as its default value (in order to avoid bugs during the main module's initialization) : forbid

# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub()
{
    case "${2^^}" in
        'A')        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_TEXT__PrintColorVarNameCmdSub_FNCT_A}" "${1}";;
        'C' | *)    printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS_TEXT__PrintColorVarNameCmdSub_FNCT_C}" "${1}";;
    esac
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### ENCODING WITH THE "$(tput)" COMMAND AND PRINTED AND REDIRECTED WITH THE "BU.Main.TextFormat.SetTextColor()" FUNCTION

## TEXT ENCODING

# Note : The "TEXT ENCODING" subsection is defined first in order to color the text according to the background color in the "BACKGROUND ENCODING" subsection.

# Encodage des couleurs (codes de la commande "$(tput setaf)") pour mieux lire les étapes de l'exécution du script.

declare -i ____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO;

# -----------------------
# Aqua blue colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_AQUA="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_AQUA}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_AQUA' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_AQUA}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_AQUA' "${__BU_MAIN_COLOR_TXT_AQUA}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_AQUA}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------------------
# Black colored text.
# -------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_BLACK="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_BLACK}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_BLACK' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLACK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_BLACK'    "${__BU_MAIN_COLOR_TXT_BLACK}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLACK}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -----------------------
# Deep blue colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_BLUE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_BLUE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_BLUE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_BLUE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_BLUE' "${__BU_MAIN_COLOR_TXT_BLUE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_BLUE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# -----------------------
# Cyan blue colored text.
# ------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_CYAN="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_CYAN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_CYAN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_CYAN}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_CYAN' "${__BU_MAIN_COLOR_TXT_CYAN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_CYAN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# ---------------------
# Fuchsia colored text.
# ---------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_FUCHSIA="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_FUCHSIA}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_FUCHSIA' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_FUCHSIA}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_FUCHSIA'  "${__BU_MAIN_COLOR_TXT_FUCHSIA}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_FUCHSIA}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# ------------------
# Gray colored text.
# ------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_GRAY="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_GRAY}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_GRAY' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_GRAY}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_GRAY' "${__BU_MAIN_COLOR_TXT_GRAY}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GRAY}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# -------------------------
# Light green colored text.
# -------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_GREEN="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_GREEN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_GREEN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_GREEN}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_GREEN'    "${__BU_MAIN_COLOR_TXT_GREEN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_GREEN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# ------------------------
# Lime green colored text.
# ------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_LIME="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_LIME}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_LIME' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_LIME}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_LIME' "${__BU_MAIN_COLOR_TXT_LIME}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_LIME}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# --------------------
# Maroon colored text.
# --------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_MAROON="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_MAROON}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_MAROON' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_MAROON}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_MAROON'   "${__BU_MAIN_COLOR_TXT_MAROON}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_MAROON}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# -----------------------
# Navy blue colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_NAVY="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_NAVY}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_NAVY' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_NAVY}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_NAVY' "${__BU_MAIN_COLOR_TXT_NAVY}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_NAVY}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------------------------
# Green olive colored text.
# -------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_OLIVE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_OLIVE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_OLIVE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_OLIVE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_OLIVE'    "${__BU_MAIN_COLOR_TXT_OLIVE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_OLIVE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# --------------------
# Orange colored text.
# --------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_ORANGE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_ORANGE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_ORANGE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_ORANGE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_ORANGE'   "${__BU_MAIN_COLOR_TXT_ORANGE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_ORANGE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# ------------------
# Pink colored text.
# ------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_PINK="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_PINK}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_PINK' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_PINK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_PINK' "${__BU_MAIN_COLOR_TXT_PINK}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PINK}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# --------------------
# Purple colored text.
# --------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_PURPLE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_PURPLE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_PURPLE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_PURPLE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_PURPLE'   "${__BU_MAIN_COLOR_TXT_PURPLE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_PURPLE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -----------------------
# Light red colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_RED="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_RED}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_RED' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_RED}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_RED'  "${__BU_MAIN_COLOR_TXT_RED}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_RED}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# --------------------
# Salmon colored text.
# --------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_SALMON="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_SALMON}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_SALMON' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_SALMON}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_SALMON'   "${__BU_MAIN_COLOR_TXT_SALMON}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SALMON}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------------------------
# Silver gray colored text.
# -------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_SILVER="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_SILVER}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_SILVER' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_SILVER}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_SILVER'   "${__BU_MAIN_COLOR_TXT_SILVER}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_SILVER}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -----------------------
# Brown tan colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_TAN="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_TAN}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_TAN' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_TAN}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_TAN'  "${__BU_MAIN_COLOR_TXT_TAN}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TAN}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# ------------------
# Teal colored text.
# ------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_TEAL="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_TEAL}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_TEAL' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_TEAL}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_TEAL' "${__BU_MAIN_COLOR_TXT_TEAL}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TEAL}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -----------------------
# Turquoise colored text.
# -----------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_TURQUOISE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_TURQUOISE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_TURQUOISE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_TURQUOISE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_TURQUOISE'    "${__BU_MAIN_COLOR_TXT_TURQUOISE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub                "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_TURQUOISE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# --------------------
# Violet colored text.
# --------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_VIOLET="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_VIOLET}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_VIOLET' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_VIOLET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_VIOLET'   "${__BU_MAIN_COLOR_TXT_VIOLET}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_VIOLET}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# -------

# -------------------
# White colored text.
# -------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_WHITE="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_WHITE}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_WHITE' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_WHITE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_WHITE'    "${__BU_MAIN_COLOR_TXT_WHITE}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_WHITE}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};


# --------------------------
# Light yellow colored text.
# --------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_YELLOW="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_YELLOW}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_YELLOW' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'C';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_YELLOW}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_YELLOW'   "${__BU_MAIN_COLOR_TXT_YELLOW}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__COL_YELLOW}" 'C')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "$(basename "${BASH_SOURCE[0]}")" \
        "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
};

# Resetting the text color, since the text generated by the "BU.ModuleInit.DisplayInitGlobalVarsInfos()" function is colored.
printf "%s" "${__BU_MAIN_COLOR_CODE_RESET}";

# -----------------------------------------------

## SPECIFIC TEXT COLORS ENCODING

# Note : You can check their default color in the "Colors.conf" configuration file.

# ----------------------------------------------------------------------
# Text color display context : highlighting the name of a system command
# ----------------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_CMD="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_CMD}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_CMD' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_CMD}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_CMD' "${__BU_MAIN_COLOR_TXT_CMD}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_CMD}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")"   "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ----------------------------------------------------------
# Text color display context : highlighting an error message
# ----------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_ERROR="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_ERROR}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_ERROR' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_ERROR}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_ERROR' "${__BU_MAIN_COLOR_TXT_ERROR}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_ERROR}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ---------------------------------------------------------
# Text color display context : highlighting a function name
# ---------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_FUNCTION="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_FUNCTION}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_FUNCTION' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_FUNCTION}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_FUNCTION' "${__BU_MAIN_COLOR_TXT_FUNCTION}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_FUNCTION}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ---------------------------------------------------------------------
# Text color display context : highlighting important part(s) of a text
# ---------------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_HIGHLIGHT="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_HIGHLIGHT}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_HIGHLIGHT' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_HIGHLIGHT' "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_HIGHLIGHT}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ------------------------------------------------------------
# Text color display context : highlighting a new step message
# ------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_NEWSTEP="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_NEWSTEP}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_NEWSTEP' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_NEWSTEP}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_NEWSTEP' "${__BU_MAIN_COLOR_TXT_NEWSTEP}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_NEWSTEP}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ----------------------------------------------------------------------
# Text color display context : highlighting a path to a file or a folder
# ----------------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_PATH="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_PATH}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_PATH' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_PATH}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_PATH' "${__BU_MAIN_COLOR_TXT_PATH}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_PATH}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# -----------------------------------------------------------
# Text color display context : highlighting a success message
# -----------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_SUCCESS="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_SUCCESS}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_SUCCESS' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_SUCCESS}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_SUCCESS' "${__BU_MAIN_COLOR_TXT_SUCCESS}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_SUCCESS}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "$(basename  "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# --------------------------------------------------------------------------------------------
# Text color display context : highlighting the name of a variable, a parameter or an argument
# --------------------------------------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_VAR="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_VAR}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_VAR' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_VAR}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_VAR' "${__BU_MAIN_COLOR_TXT_VAR}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_VAR}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# -----------------------------------------------------------
# Text color display context : highlighting a warning message
# -----------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_WARNING="$(BU.Main.TextFormat.SetTextColor "${__BU_MAIN_COLOR_CODE_WARNING}" '--no-function')" || {
    printf "%s\n" "${__BU_MAIN_COLOR_CODE_RESET}";

    BU.Main.ModConfig.Colors.PrintVariableNameFailedToInitialize '__BU_MAIN_COLOR_TXT_WARNING' "$(basename "${BASH_SOURCE[0]}")" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" 'A';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi

}; [ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_WARNING}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_WARNING' "${__BU_MAIN_COLOR_TXT_WARNING}" 'CMD' \
        "$(BU.Main.ModConfig.Colors.Text.PrintColorVarNameCmdSub "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_WARNING}" 'A')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# ------------------------------------------------------------
# Resetting the text's color to terminal's default text color.
# ------------------------------------------------------------

____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO="$(( LINENO + 2 ))";

__BU_MAIN_COLOR_TXT_RESET="${__BU_MAIN_COLOR_CODE_RESET}";
[ "${__BU_MODULE_INIT_MSG_ARRAY_MODE}" == '--mode-log-full' ] && {
    printf "%s" "${__BU_MAIN_COLOR_TXT_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_COLOR_TXT_RESET' \
        "${__BU_MAIN_COLOR_TXT_RESET}" 'CMD' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__COLORS__ACT_RESET}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}";
}


# Deleting the "${____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO}" variable, since its presence is not useful anymore.
unset ____BU_MAIN_MOD_TEXT_COLOR_DEF_LINENO;

# -----------------------------------------------
#!/usr/bin/env bash

# Debug function that displays function and file name (not used in the script and deprecated).
function debug()
{
	#**** Parameters ****
	p_function=${1:-$'\0'};
	p_file=${2:-$'\0'};
	p_line=${3:-$'\0'};

	#**** Code ****
	if [ "${__BU_MODULE_INIT_STAT_DEBUG}" = 'true' ]; then
		echo -ne "${__BU_MAIN_COLOR_TXT_PINK}";

		for _ in $(eval echo -e "{1..${__BU_MAIN_TXT_COLS}}"); do
			echo -ne "+";
		done

		echo -ne "${__BU_MAIN_COLOR_TXT_RESET}"; echo -e; echo -e;

		echo -e "${__BU_MAIN_COLOR_TXT_YELLOW}FUNCTION ${__BU_MAIN_COLOR_TXT_PINK}${p_function}${__BU_MAIN_COLOR_TXT_YELLOW} IN ${__BU_MAIN_COLOR_TXT_PINK}${p_file}${__BU_MAIN_COLOR_TXT_YELLOW}, ON ${__BU_MAIN_COLOR_TXT_PINK}${p_line}${__BU_MAIN_COLOR_TXT_RESET}";

		echo -ne "${__BU_MAIN_COLOR_TXT_PINK}";

		for _ in $(eval echo -e "{1..${__BU_MAIN_TXT_COLS}}"); do
                        echo -ne "+";
		done

		echo -ne "${__BU_MAIN_COLOR_TXT_RESET}"; echo -e; echo -e;
	fi
}
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every exit codes used in this framework.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### OTHER FUNCTIONS

## TEXT PRINTING

# Writing the command substitution text for the return values definitions.
# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.PrintReturnValue { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__PrintReturnValue_FNCT}" "${1}"; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Feel free to define any other needed resources (functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### BASH-UTILS EXIT CODES PROCESSING

## EXIT CODES LIST

# Operation not permitted.
__BU_MAIN_EXIT_NOT_PERMITTED='1';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_NOT_PERMITTED' "${__BU_MAIN_EXIT_NOT_PERMITTED}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NOT_PERMITTED__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# No such file or directory.
__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND='2';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND' "${__BU_MAIN_EXIT_DIR_FILE_NOT_FOUND}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__DIR_FILE_NOT_FOUND__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Permission denied.
__BU_MAIN_EXIT_PERMISSION_DENIED='13';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_PERMISSION_DENIED' "${__BU_MAIN_EXIT_PERMISSION_DENIED}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__PERMISSION_DENIED__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# File exists.
__BU_MAIN_EXIT_FILE_EXISTS='17';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_FILE_EXISTS' "${__BU_MAIN_EXIT_FILE_EXISTS}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILE_EXISTS__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Not a directory.
__BU_MAIN_EXIT_NOT_DIR='20';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_NOT_DIR' "${__BU_MAIN_EXIT_NOT_DIR}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NOT_DIR__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Target is a directory.
__BU_MAIN_EXIT_IS_DIR='21';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_IS_DIR' "${__BU_MAIN_EXIT_IS_DIR}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__IS_DIR__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Invalid argument
__BU_MAIN_EXIT_INVALID_ARGUMENT="22";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_INVALID_ARGUMENT' "${__BU_MAIN_EXIT_INVALID_ARGUMENT}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__INVALID_ARGUMENT__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# File too large
__BU_MAIN_EXIT_FILE_TOO_LARGE="27";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_FILE_TOO_LARGE' "${__BU_MAIN_EXIT_FILE_TOO_LARGE}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILE_TOO_LARGE__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Not space left on the hard drive.
__BU_MAIN_EXIT_NO_SPACE_LEFT='28';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_NO_SPACE_LEFT' "${__BU_MAIN_EXIT_NO_SPACE_LEFT}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__NO_SPACE_LEFT__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Read-only file system.
__BU_MAIN_EXIT_RO_FS='30';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_RO_FS' "${__BU_MAIN_EXIT_RO_FS}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__RO_FS__VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# File name too long.
__BU_MAIN_EXIT_FILENAME_TOO_LONG='36';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_EXIT_FILENAME_TOO_LONG' "${__BU_MAIN_EXIT_FILENAME_TOO_LONG}" 'Int' \
	"$(BU.Main.ModConfig.PrintReturnValue "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__EXIT__FILENAME_TOO_LONG_VAR_DESC}")" \
	"${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every file system-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### OTHER FUNCTIONS

## TEXT PRINTING

# Writing the command substitution text for the file systems description strings.
# shellcheck disable=SC2059
function BU.Main.ModConfig.Filesystem.PrintFSLengthDescription(){ printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__MAX_LENGHT_STR_MSG}" "${?}"; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### PROCESSING FILE SYSTEM'S INFORMATIONS

# Getting the file system's name with the "$(df)" command, and parsing the output list according to the operating system's command version.
BU.Main.OS.IsHaiku && __BU_MAIN_FS_NAME="$(df "$0" | awk 'FNR == 4 {print $3}')";
BU.Main.OS.IsLinux && __BU_MAIN_FS_NAME="$(df -Th "$0" | awk 'FNR == 2 {print $2}')";

## EXT2 FILE SYSTEM'S INFORMATIONS

if [ "${__BU_MAIN_FS_NAME,,}" == 'apfs' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'APFS')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## BTRFS FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'btrfs' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'Btrfs')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## EXT2 FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'ext2' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'EXT2')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## EXT3 FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'ext3' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'EXT3')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## EXT4 FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'ext4' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'EXT4')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## JFS FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'jfs' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'JFS')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## XFS FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'xfs' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'XFS')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## ZFS FILE SYSTEM'S INFORMATIONS

elif [ "${__BU_MAIN_FS_NAME,,}" == 'zfs' ]; then
    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "$(BU.Main.ModConfig.Filesystem.PrintFSLengthDescription 'ZFS')" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

else
    # shellcheck disable=SC2059
    BU.Main.Errors.HandleSmallErrors 'W' "$(printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__UNSUPPORTED_FILESYSTEM}" \
        "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_FS_NAME}")")" 'R';

    # File system max filename length.
    __BU_MAIN_FS_MAX_FILENAME_LENGTH='255';

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_FS_MAX_FILENAME_LENGTH' "${__BU_MAIN_FS_MAX_FILENAME_LENGTH}" 'Int' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__FILESYSTEM__SET_GENERAL_SPECIFICATION__FILENAME_LENGTH}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCAME[0]}" "$(( LINENO - 2 ))";
fi
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every locale-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

####

##

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

####

##

# List of every ISO 639-1 language codes.
__BU_MAIN_LOCALE_ISO_639_1_LOCALES_ARRAY=(  'ab' 'aa' 'af' 'ak' 'sq' 'am' 'ar' 'an' 'hy' 'as' 'av' 'ae' 'ay' 'az' 'bm' 'ba' 'eu' 'be' 'bn' 'bi' 'bs' 'br' 'bg' 'my' 'ca' 'ch' \
                                            'ce' 'ny' 'zh' 'cu' 'cv' 'kw' 'co' 'cr' 'hr' 'cs' 'da' 'dv' 'nl' 'dz' 'en' 'eo' 'et' 'ee' 'fo' 'fj' 'fi' 'fr' 'fy' 'ff' 'gd' 'gl' \
                                            'lg' 'ka' 'de' 'el' 'kl' 'gn' 'gu' 'ht' 'ha' 'he' 'hz' 'hi' 'ho' 'hu' 'is' 'io' 'ig' 'id' 'ia' 'ie' 'iu' 'ik' 'ga' 'it' 'ja' 'jv' \
                                            'kn' 'kr' 'ks' 'kk' 'km' 'ki' 'rw' 'ky' 'kv' 'kg' 'ko' 'kj' 'ku' 'lo' 'la' 'lv' 'li' 'ln' 'lt' 'lu' 'lb' 'mk' 'mg' 'ms' 'ml' 'mt' \
                                            'gv' 'mi' 'mr' 'mh' 'mn' 'na' 'nv' 'nd' 'nr' 'ng' 'ne' 'no' 'nb' 'nn' 'ii' 'oc' 'oj' 'or' 'om' 'os' 'pi' 'ps' 'fa' 'pl' 'pt' 'pa' \
                                            'qu' 'ro' 'rm' 'rn' 'ru' 'se' 'sm' 'sg' 'sa' 'sc' 'sr' 'sn' 'sd' 'si' 'sk' 'sl' 'so' 'st' 'es' 'su' 'sw' 'ss' 'sv' 'tl' 'ty' 'tg' \
                                            'ta' 'tt' 'te' 'th' 'bo' 'ti' 'to' 'ts' 'tn' 'tr' 'tk' 'tw' 'ug' 'uk' 'ur' 'uz' 've' 'vi' 'vo' 'wa' 'cy' 'wo' 'xh' 'yi' 'yo' 'za' 'zu')
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2016,SC2034,SC2059,SC2154

# This configuration file stores the global variables related to the "main" module initialization process.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### OPTIMISATION FUNCTIONS

## TEXT PROCESSING FUNCTIONS

# Main module's "config" folder's content.

# shellcheck disable=SC2059
function BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize() { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__MainModuleConfigFolderContentOptimize__FNCT}" "${1}"; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASH UTILS MAIN MODULE'S LIBRARY DIRECTORIES PATHS

## BASH UTIILS SUB-FOLDERS PATHS

# shellcheck disable=SC2016,SC2059
function BU.Main.ModConfig.Module.BUSubFoldersPaths()
{
    #**** Variables ****
    declare -i v_lineno; # VAR TYPE : Int   - DESC : Line number of a global variable declaration.

    #**** Code ****

    # -----------------------------------------------------------------------------------------------------
    # Bash Utils executable files folder        |	Default parent folder --> "${__BU_MAIN_ROOT_DIR_PATH}/"
    # -----------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_BIN_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_ROOT_DIR_PATH}" "bin" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_BIN_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_BIN_DIR_PATH' \
        "${__BU_MAIN_MODULE_BIN_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__BIN}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # -----------------------------------------------------------------------------------------------------
    # Bash Utils documentation folder			|	Default parent folder --> "${__BU_MAIN_ROOT_DIR_PATH}/"
    # -----------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DOCS_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_ROOT_DIR_PATH}" "docs" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DOCS_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DOCS_DIR_PATH' \
        "${__BU_MAIN_MODULE_DOCS_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__DOCS}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # -----------------------------------------------------------------------------------------------------
    # Bash Utils library root directory	        |	Default parent folder --> "${__BU_MAIN_ROOT_DIR_PATH}/"
    # -----------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_LIB_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_ROOT_DIR_PATH}" "lib" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_LIB_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_DIR_PATH' \
        "${__BU_MAIN_MODULE_LIB_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__LIB}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # -----------------------------------------------------------------------------------------------------
    # Bash Utils library resources path			|	Default parent folder --> "${__BU_MAIN_ROOT_DIR_PATH}/"
    # -----------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_RES_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_ROOT_DIR_PATH}" "res" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_RES_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_RES_DIR_PATH' \
        "${__BU_MAIN_MODULE_RES_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUSubFoldersPaths__FNCT__RES}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";
}

# -----------------------------------------------

## BASH UTILS DEV-TOOLS PATHS

# shellcheck disable=SC2016,SC2059
function BU.Main.ModConfig.Module.BUDevToolsPaths()
{
    #**** Variables ****
    declare -i v_lineno; # VAR TYPE : Int   - DESC : Line number of a global variable declaration.

    #**** Code ****

    # -----------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools root directory          	|	Default parent folder --> "${__BU_MAIN_MODULE_RES_DIR_PATH}/"
    # -----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_RES_DIR_PATH}" "dev-tools" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH' \
        "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";

    # ---------------------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools binary files folder		|	Default parent folder --> "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}/"
    # ---------------------------------------------------------------------------------------------------------------------------------
    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_BIN="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" "dev-bin" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_BIN';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;

    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_BIN' \
        "${__BU_MAIN_MODULE_DEVTOOLS_BIN}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_BIN}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";

    # ---------------------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools desktop files folder		|	Default parent folder --> "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}/"
    # ---------------------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_DSK="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" "dev-desktop" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_DSK';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_DSK' \
        "${__BU_MAIN_MODULE_DEVTOOLS_DSK}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_DSK}" \
        "${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ---------------------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools desktop icons folder		|	Default parent folder --> "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}/"
    # ---------------------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_IMG="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" "dev-img" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_IMG';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_IMG' \
        "${__BU_MAIN_MODULE_DEVTOOLS_IMG}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_IMG}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ---------------------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools source files             |	Default parent folder --> "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}/"
    # ---------------------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_SRC="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" "dev-src" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_SRC';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };
    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_SRC' \
        "${__BU_MAIN_MODULE_DEVTOOLS_SRC}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_SRC}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ---------------------------------------------------------------------------------------------------------------------------------
    # Bash Utils development tools translation files folder |	Default parent folder --> "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}/"
    # ---------------------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_DEVTOOLS_TRANSL="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_DEVTOOLS_ROOT_DIR_PATH}" "dev-translations" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_DEVTOOLS_TRANSL';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_DEVTOOLS_TRANSL' \
        "${__BU_MAIN_MODULE_DEVTOOLS_TRANSL}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BUDevToolsPaths__FNCT__DEVTOOLS_TRA}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";
}

# -----------------------------------------------

## "lib" FOLDER'S CONTENT.

# shellcheck disable=SC2016,SC2059
function BU.Main.ModConfig.Module.BULibFolderContent()
{
    #**** Variables ****
    declare -i v_lineno; # VAR TYPE : Int   - DESC : Line number of a global variable declaration.

    #**** Code ****

    # -------------------------------------------------------------------------------------------------------------------
    # Bash Utils main module's functions directory      |	Default parent folder --> "${__BU_MAIN_MODULE_LIB_DIR_PATH}/"
    # -------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_LIB_DIR_PATH}" "functions" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH' \
        "${__BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_FUNCTS_DIR_PATH}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";

    # --------------------------------------------------------------------------------------------------------------------------
    # Bash Utils library module's directory             |	Default parent folder --> "${__BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH}/"
    # --------------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_LIB_MOD_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_LIB_FUNCTS_DIR_PATH}" "$(BU.ModuleInit.GetModuleName "${BASH_SOURCE[0]}")" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_LIB_MOD_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_MOD_DIR_PATH' \
        "${__BU_MAIN_MODULE_LIB_MOD_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_MOD_DIR_PATH}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";

    # -------------------------------------------------------------------------------------------------------------------
    # Bash Utils languages directory			        |   Default parent folder --> "${__BU_MAIN_MODULE_LIB_DIR_PATH}/"
    # -------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_LIB_LANG_DIR_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_LIB_DIR_PATH}" "lang" 'd')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_LIB_LANG_DIR_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_LANG_DIR_PATH' \
        "${__BU_MAIN_MODULE_LIB_LANG_DIR_PATH}" 'Dirpath' \
        "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BULibFolderContent__FNCT__LIB_LANG_DIR_PATH}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASH UTILS LIBRARY FILES PATHS

## MAIN MODULE'S "config" FOLDER'S CONTENT

# shellcheck disable=SC2016,SC2059
function BU.Main.ModConfig.Module.MainModuleConfigFolderContent()
{
    #**** Variables ****
    declare -i v_lineno; # VAR TYPE : Int   - DESC : Line number of a global variable declaration.

    #**** Code ****
    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils general color variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------
    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_COLORS_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Colors.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Colors.conf")" \
        "${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils background color encoding variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_BG_COLORS_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "ColorsBG.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "ColorsBG.conf")" \
        "${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils text color encoding variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_TEXT_COLORS_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "ColorsText.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "ColorsText.conf")" \
        "${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils exit code variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_EXIT_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Exit.conf" 'f')" || {
        .ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_EXIT_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_EXIT_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_EXIT_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Exit.conf")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";

    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils file system variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_FILESYSTEM_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Filesystem.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_FILESYSTEM_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_FILESYSTEM_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_FILESYSTEM_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Filesystem.conf")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils project's initialization variables.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_INIT_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Project.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_INIT_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_INIT_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Project.conf")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils status variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_STATUS_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Status.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Status.conf")" \
        "${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils text variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_TEXT_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Text.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_TEXT_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_TEXT_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_TEXT_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Text.conf")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bash Utils time variables configuration file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_CONF_FILE_TIME_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_CONF_PATH}" "Time.conf" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_CONF_FILE_TIME_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONF_FILE_TIME_PATH' \
        "${__BU_MAIN_MODULE_CONF_FILE_TIME_PATH}" 'Filepath' \
        "$(BU.Main.ModConfig.Module.MainModuleConfigFolderContent.Optimize "Time.conf")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
        "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";
}

# -----------------------------------------------

## MAIN MODULE'S INITIALIZER PATH

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

# shellcheck disable=SC2016,SC2059
function BU.Main.ModConfig.Module.MainModuleInitializerPath() {
    #**** Variables ****
    declare -i v_lineno; # VAR TYPE : Int   - DESC : Line number of a global variable declaration.

    #**** Code

    # ----------------------------------------------------------------------------------------------------------------------
    # Main module's initializer file.
    # ----------------------------------------------------------------------------------------------------------------------

    v_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_MODULE_LIB_FILE_INITIALIZER_FILE_PATH="$(BU.ModuleInit.FindPath "${__BU_MODULE_INIT_CURRENT_MODULE_INIT_PATH}" "Initializer.sh" 'f')" || {
        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${v_lineno}" 'ERR_BU_MAIN_MOD_CONF__INIT_VARPATH_FAILED';

        printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${v_lineno}" '$__BU_MAIN_MODULE_LIB_FILE_INITIALIZER_FILE_PATH';

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1; return 1;
    };

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_FILE_INITIALIZER_FILE_PATH' "${__BU_MAIN_MODULE_LIB_FILE_INITIALIZER_FILE_PATH}" \
        'Filepath' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__MainModuleInitializerPath__FNCT__FILE_INITIALIZER_PATH}" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${v_lineno}";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Feel free to define any needed resources (functions, etc...) here.



# -----------------------------------------------

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### BASH-UTILS VARIABLES

## BASH-UTILS DIRECTORIES PATHS

# Bash Utils root directory path checking.

# If the Bash Utils root directory is located in the directory where the main developer is used to develop this framework, on Ubuntu.
if [ -d "/usr/local/lib/Bash-utils" ]; then
    __BU_MAIN_ROOT_DIR_PATH='/usr/local/lib/Bash-utils';

# If the Bash Utils root directory is installed in the hidden directory, normally located in the user's home directory.
elif [ -d "${__BU_MODULE_INIT__ROOT}/.Bash-utils" ]; then
    __BU_MAIN_ROOT_DIR_PATH="${__BU_MODULE_INIT__ROOT}/.Bash-utils";

elif [ -d "${__BU_MODULE_INIT__ROOT}/.Bash-utils/Bash-utils" ]; then
    __BU_MAIN_ROOT_DIR_PATH="${__BU_MODULE_INIT__ROOT}/.Bash-utils/Bash-utils";

# Else, if the library's root directory doesn't exists in at least one of the above paths, then the value stored in the "Bash-utils-root-val.path" is used as the path of this root directory.
else
    # For a better environment integration, it is highly advised to store the path in a file
    # in the configurations directory, and to call the "cat" command to display its value.

    if [ -f "${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}" ]; then
        __BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH="${__BU_MODULE_INIT__LIB_ROOT_DIR__FILE_PATH}";

        BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH' "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" 'Filepath' \
            "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

    # Including the same file, if it was generated by the "install_and_update.sh" file when executed with root privileges
    # (failsafe for the users who cannot execute this file with these privileges, if the same file than the one above exists
    # and is (still) owned by the super-user or its group, which means that this file cannot be modified normally, and may not be readable).
    elif [ -f "${__BU_MODULES_UTILS_LIB_ROOT_DIR_ROOT_FILE_PATH}" ]; then
        __BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH="${__BU_MODULE_INIT__LIB_ROOT_DIR_ROOT__FILE_PATH}";

        BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH' "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" 'Filepath' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH__ROOT}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

    # The possible absence of this file is managed below.
    fi

    # Checking if the "Bash-utils-root-val.path" file exists AND if this file contains a string (the wanted string here is the library's root folder path).
    if [ -f "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ] && [ -s "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ]; then
        __BU_MAIN_ROOT_DIR_PATH="$(cat "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}")"; declare -i ____bu_main_modconfig_lineno="${LINENO}";  # VAR TYPE : Int   - DESC : Line number of the "${__BU_MAIN_ROOT_DIR_PATH}" global variable declaration.

        # shellcheck disable=SC2059
        BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_ROOT_DIR_PATH' "${__BU_MAIN_ROOT_DIR_PATH}" 'Dirpath' \
            "$(printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_ROOT_DIR_PATH}" "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}")" \
            "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
            "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${____bu_main_modconfig_lineno}";

        # Checking if the library's root folder path written in this file is valid.
        if [ ! -d "${__BU_MAIN_ROOT_DIR_PATH}" ]; then declare -i ____bu_main_modconfig_lineno="${LINENO}"; # VAR TYPE : Int   - DESC : Line number of the error occurence.

            BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "ERR_BU_MAIN_MOD_CONF__INVALID_ROOT_DIR_PATH"; echo >&2;

            # shellcheck disable=SC2059
            printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__ERR}\n" "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "${__BU_MODULES_UTILS_LIB_FILE_PATH}" >&2; echo >&2;

            # shellcheck disable=SC2059
            printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__INFO}\n" "${__BU_MAIN_ROOT_DIR_PATH}" >&2; echo >&2;

            echo "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__INVALID_ROOT_DIR_PATH__ADVICE}" >&2; echo >&2;

            unset ____bu_main_modconfig_lineno;

            BU.ModuleInit.MsgAbort;

            BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

            BU.ModuleInit.IsInScript && exit 1;

			return 1;
        fi

    # Checking if the "Bash-utils-root-val.path" file exists AND if this file is empty (no library's path specified).
    elif [ -f "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ] && [ ! -s "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ]; then declare -i ____bu_main_modconfig_lineno="${LINENO}"; # VAR TYPE : Int   - DESC : Line number of the error occurence.

        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "ERR_BU_MAIN_MOD_CONF__EMPTY_ROOT_DIR_STORAGE_FILE_PATH";

        ____v_bu_module_init__bu_main_root_dir_path__chk_err="$(BU.ModuleInit.CheckPath "${__BU_MAIN_ROOT_DIR_PATH}")"; echo >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__EMPTY_ROOT_DIR_PATH__ERR}\n" "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "${____v_bu_module_init__bu_main_root_dir_path__chk_err}" >&2; echo >&2;
        echo "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__EMPTY_ROOT_DIR_PATH__ADVICE}" >&2; echo >&2;

        unset ____v_bu_module_init__bu_main_root_dir_path__chk_err;
        unset ____bu_main_modconfig_lineno;

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1;

		return 1;

    # Checking if the current user cannot read the "Bash-utils-root-val.path" (file created and owned by the "root" user).
    elif [ -f "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ] && [ ! -r "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ]; then declare -i ____bu_main_modconfig_lineno="${LINENO}"; # VAR TYPE : Int   - DESC : Line number of the error occurence.

        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "ERR_BU_MAIN_MOD_CONF__UNALLOWED_TO_READ_ROOT_DIR_STORAGE_FILE_PATH";

        ____v_bu_module_init__bu_main_root_dir_path__chk_err="$(BU.ModuleInit.CheckPath "${__BU_MAIN_ROOT_DIR_PATH}")"; echo >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ERR}\n" "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "${__BU_MAIN_ROOT_DIR_PATH}" >&2;
        echo "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__INFO}" >&2; echo >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ADVICE_1}\n" "${__BU_MAIN_ROOT_DIR_PATH}" "${__BU_MODULE_INIT__INITIALIZER_PATH}";
        echo "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__CANNOT_READ_ROOT_DIR_PATH__ADVICE_2}"; echo >&2;

        unset ____v_bu_module_init__bu_main_root_dir_path__chk_err;
        unset ____bu_main_modconfig_lineno;

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1;

		return 1;

    # Handling the absence of the "Bash-utils-root-val.path" file.
    elif [ ! -f "${__BU_MAIN_ROOT_DIR_PATH_STORAGE_FILE_PATH}" ]; then declare -i ____bu_main_modconfig_lineno="${LINENO}"; # VAR TYPE : Int   - DESC : Line number of the error occurence.

        BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "ERR_BU_MAIN_MOD_CONF__ABSENT_ROOT_DIR_STORAGE_FILE_PATH";

        ____v_bu_module_init__bu_main_root_dir_path__chk_err="$(BU.ModuleInit.CheckPath "${__BU_MAIN_ROOT_DIR_PATH}")"; echo >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__ABSENT_ROOT_DIR_PATH__ERR}\n" "${BASH_SOURCE[0]}" "${____bu_main_modconfig_lineno}" "${____v_bu_module_init__bu_main_root_dir_path__chk_err}" >&2; echo >&2;
        echo "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__ABSENT_ROOT_DIR_PATH__ADVICE}" >&2; echo >&2;

        unset ____v_bu_module_init__bu_main_root_dir_path__chk_err;

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        BU.ModuleInit.IsInScript && exit 1;

		return 1;
    fi
fi

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASH UTILS MAIN MODULE'S LIBRARY DIRECTORIES PATHS

## BASH UTIILS SUB-FOLDERS PATHS

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

BU.Main.ModConfig.Module.BUSubFoldersPaths;

# -----------------------------------------------

## BASH UTILS DEV-TOOLS PATHS

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

# The function call has been moved to the "Initializer.sh" script of the main module, in the "STEP THREE : PROCESSING THE MAIN MODULE'S PARAMETERS" category,
# because these folders are only used by the development tools provided with the framework, and are therefore useless in another project.

# BU.Main.ModConfig.Module.BUDevToolsPaths;

# -----------------------------------------------

## "lib" FOLDER'S CONTENT.

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

BU.Main.ModConfig.Module.BULibFolderContent;

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### BASH UTILS LIBRARY FILES PATHS

## MAIN MODULE'S "config" FOLDER'S CONTENT

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

BU.Main.ModConfig.Module.MainModuleConfigFolderContent;

# -----------------------------------------------

## MAIN MODULE'S INITIALIZER PATH

# Declaring the variables inside a function to prevent the displaying of the Shellcheck info messages when Shellchecking the wrapped file.

BU.Main.ModConfig.Module.MainModuleInitializerPath;

# -----------------------------------------------

## MAIN MODULE'S "functions" FOLDER'S SUB-FOLDERS CONTENT

# Note : if a variable is an array, please leave empty the second argument of the "BU.ModuleInit.DisplayInitGlobalVarsInfos()" function.

# Path to the function files of the main module's library.
__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY=("${__BU_MAIN_MODULE_LIB_MOD_DIR_PATH}/"*.lib);

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY' "" 'Array' \
    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY}" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))" "${__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY[@]}";

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### INITALIZATION VARIABLES

## INITIALIZATION VARIABLES DECLARATIONS

# Note : if a variable is an array, please leave empty the second argument of the "BU.ModuleInit.DisplayInitGlobalVarsInfos()" function.

# Defining an array of parameters in order to store the modified global status variables values,
# in order to check which status variables values have to be changed to their new default value,
# after the main module's initialization.

# It MUST NOT store any value now, it will be processed in the main module's initializer file.
__BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY=();

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY' "" 'Array' \
    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY}" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## LIBRARY INITALIZATION VARIABLES DECLARATIONS

# Defining an associative array to store each sourced library file's path.
__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY=();

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY' "" 'Array' \
    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY}" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## CONFIGURATION FILES INITALIZATION VARIABLES DECLARATIONS

# Defining an associative array to store each sourced configuration file's path.
__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY=();

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY' "" 'Array' \
    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY}" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Storing the configuration files path variable values into an array to source, print and add easier into the "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}" associative array.
# Those files contain, respectly, the :
#   - Exit codes used in this framework.
#   - Project's status variable.
#   - Project's and initialization process' global variables.
#   - Text color codes values and command substitutions.
#   - File system-related global variables.
#   - Text decoration, formatting and printing variable
#   - Time variable

__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY=();

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY' "" 'Array' \
    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__MODULE__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}" \
    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
    "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))" "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY[@]}";

# Please source these files in this order of priority :
#   - ${__BU_MAIN_MODULE_CONF_FILE_EXIT_PATH}   ("Exit.conf")
#   - ${__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH} ("Status.conf")
#   - ${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}   ("Project.conf")

#   - Then the rest of the configuration files.
__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY+=("${__BU_MAIN_MODULE_CONF_FILE_EXIT_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_STATUS_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_COLORS_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_TEXT_COLORS_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_BG_COLORS_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_FILESYSTEM_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_TEXT_PATH}" \
    "${__BU_MAIN_MODULE_CONF_FILE_TIME_PATH}");

# -----------------------------------------------
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every project-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### PROJECT'S VARIABLES

## PROJECT'S PATHS VARIABLES

# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Project.GetProjectFilePath()
{
    #**** Variables ****
    local v_cut="${__BU_MAIN_PROJECT_FILE_NAME##*./}";  # VAR TYPE : String     - DESC :
    local v_get_parent;                                 # VAR TYPE : Dirpath    - DESC :
    local find_path;                                    # VAR TYPE : Path       - DESC :

    declare -i v_return_code;                           # VAR TYPE : Int        - DESC :

    #**** Code ****
    v_get_parent="$(cd "$(printf "%s" "${__BU_MAIN_PROJECT_FILE_PARENT}")" || \
        {
            echo >&2; "$(printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__GetProjectFilePath__UNABLE_TO_GET_THE_PARENT_DIR}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))")" >&2; echo >&2; return 1;
        }; pwd)";

    find_path="$(BU.ModuleInit.FindPath "${v_get_parent}" "${v_cut}" 'f')"; v_return_code="${?}";

    [[ "${v_return_code}" -ne 0 ]] && return 1;

    echo "${find_path}";

	return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Feel free to define any other needed resources (functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### PROJECT'S VARIABLES

## PROJECT'S PATHS VARIABLES

# Script file's informations
__BU_MAIN_PROJECT_FILE_NAME=$(basename "${0}");                 # Project file's name.
__BU_MAIN_PROJECT_NAME=$(basename "${0}" | cut -f 1 -d '.');    # Name of the project (project file's name without its file extension).

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_FILE_NAME' "${__BU_MAIN_PROJECT_FILE_NAME}"   'String' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_FILE_NAME__VAR}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_NAME' "${__BU_MAIN_PROJECT_NAME}"             'String' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_NAME__VAR}"         "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";



__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME="tmp";
__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH="${__BU_MAIN_ROOT_DIR_PATH}/${__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME' "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME}" 'Dir'	    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PARENT_NAME}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH' "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}" 'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";

if [ ! -d "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}" ]; then
    mkdir -p "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}" || { echo >&2; echo "UNABLE TO CREATE THE PROJECT'S TEMPORARY FOLDER'S PARENT DIRECTORY « ${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH} » !" >&2; echo >&2; exit 1; };
fi

# Checking first if the effective user identifiant (EUID) is equal to super-user's EUID or not.
# The folders names have to be different according to the EUID, as files and folders created by the root user belong to this user,
# which means that a regular user won't have any write permission on these files, so nothing can be written on a log file, for example.

# To remove these folders, please run the "rm -rf ${folder}" command with sudo if you're not logged as super-user.
if [ "${EUID}" -eq 0 ]; then
    # Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}/${__BU_MAIN_PROJECT_NAME} - ROOT"
    __BU_MAIN_PROJECT_TMP_DIR_PATH="${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}/${__BU_MAIN_PROJECT_NAME} - ROOT";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_TMP_DIR_PATH' "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" 'Dirpath' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PATH__VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
else
    # Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}/${__BU_MAIN_PROJECT_NAME}"
    __BU_MAIN_PROJECT_TMP_DIR_PATH="${__BU_MAIN_PROJECT_TMP_DIR_PARENT_PATH}/${__BU_MAIN_PROJECT_NAME}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_TMP_DIR_PATH' "${__BU_MAIN_PROJECT_TMP_DIR_PATH}" 'Dirpath' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_TMP_DIR_PATH__ROOT_VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
fi

# Project's file path.
__BU_MAIN_PROJECT_FILE_PATH="$(BU.Main.ModConfig.Project.GetProjectFilePath "${__BU_MAIN_PROJECT_FILE_NAME}")" || {
    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(LINENO - 1)" 'E_BUINIT__BU_MAIN_MODCONFIG__CANNOT_GET_PROJECT_PARENT_DIR';

    BU.ModuleInit.MsgAbort;

    BU.ModuleInit.AskPrintLog >&2 || {
        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
};

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_FILE_PATH' "${__BU_MAIN_PROJECT_FILE_PATH}" 'Filepath' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_FILE_PATH__VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

echo "${__BU_MAIN_PROJECT_FILE_PATH}";


# -------

# Defining the informations of the aliases file of the project.
# __BU_MAIN_PROJECT_ALIAS_FILE_PARENT   --> Default value : "${__BU_MODULE_INIT__ROOT}" (~/.Bash-utils)
# __BU_MAIN_PROJECT_ALIAS_FILE_NAME     --> Default value : "Aliases.sh"
# __BU_MAIN_PROJECT_ALIAS_FILE_PATH     --> Default value : "${__BU_MAIN_PROJECT_ALIAS_FILE_PARENT}/${__BU_MAIN_PROJECT_ALIAS_FILE_NAME}"

__BU_MAIN_PROJECT_ALIAS_FILE_PARENT="${__BU_MODULE_INIT__ROOT}";
__BU_MAIN_PROJECT_ALIAS_FILE_NAME="Aliases.sh";
__BU_MAIN_PROJECT_ALIAS_FILE_PATH="${__BU_MAIN_PROJECT_ALIAS_FILE_PARENT}/${__BU_MAIN_PROJECT_ALIAS_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ALIAS_FILE_PARENT'      "${__BU_MAIN_PROJECT_ALIAS_FILE_PARENT}"    'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_PARENT}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ALIAS_FILE_NAME'        "${__BU_MAIN_PROJECT_ALIAS_FILE_NAME}"      'File'      "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_NAME}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ALIAS_FILE_PATH'        "${__BU_MAIN_PROJECT_ALIAS_FILE_PATH}"      'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ALIAS_FILE_PATH}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

# -------

# Defining the informations of the storage file containing the background color code.
# __BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT   --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}"
# __BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME     --> Default value : "fgcolor.tmp"
# __BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH     --> Default value : "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}"

__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT="${__BU_MAIN_PROJECT_TMP_DIR_PATH}";
__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME="bgcolor.tmp";
__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH="${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT'  "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}"    'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME'    "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}"      'File'		"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH'    "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}"      'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";


# -------

# Defining the informations of the storage file containing the terminal background color code's raw data (generated by the color processing function which execute a command substitution to get the terminal background's color code).
# __BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT   --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}"
# __BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME     --> Default value : "bgcolor.raw"
# __BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH     --> Default value : "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}/{__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME}"

__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT="${__BU_MAIN_PROJECT_TMP_DIR_PATH}";
__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME="bgcolor.raw";
__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH="${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT'  "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}"    'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PARENT}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME'    "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME}"      'File'      "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_NAME}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH'    "${__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}"      'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_BG_RAW_CODE_FILE_PATH}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";


# -------

# Defining the project's text color code storage file's informations.
# __BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}"
# __BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME   --> Default value : "fgcolor.tmp"
# __BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH   --> Default value : "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}"

__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT="${__BU_MAIN_PROJECT_TMP_DIR_PATH}";
__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME="fgcolor.tmp";
__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH="${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT'    "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}"  'Dirpath'	"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME'      "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}"    'File'		"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH'      "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}"    'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";


# -------

# Defining the informations of the storage file containing the terminal text color code's raw data (generated by the color processing functions which execute a command substitution to get the terminal's text color code).
# __BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT   --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}"
# __BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME     --> Default value : "bgcolor.raw"
# __BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH     --> Default value : "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}/{__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME}"

__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT="${__BU_MAIN_PROJECT_TMP_DIR_PATH}";
__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME="fgcolor.raw";
__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH="${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}/${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT'    "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}"  'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PARENT}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME'      "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME}"    'File'      "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_NAME}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH'      "${__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}"    'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_COLOR_TEXT_RAW_CODE_FILE_PATH}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";


# -------

# Defining the project's "BU.Echo<...>()" functions debug output (to have a better view during a "bash - x" debug).
# __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT --> Default value : "${__BU_MAIN_PROJECT_LOG_DIR_PATH}",    or "${__BU_MODULE_INIT__TMP_DIR_PATH}" if the project's temporary directory was not found.
# __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME   --> Default value : "echo_output.log",                      or "echo_output_${__BU_MAIN_PROJECT_NAME}.log", according to the last variable's path value.
# __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH   --> Default value : "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT}/${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}"

if [ -d "${__BU_MAIN_PROJECT_LOG_DIR_PATH}" ]; then __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT="${__BU_MAIN_PROJECT_LOG_DIR_PATH}";  else __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT="${__BU_MODULE_INIT__TMP_DIR_PATH}"; fi
if [ -d "${__BU_MAIN_PROJECT_LOG_DIR_PATH}" ]; then __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME="echo_output.log";                      else __BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME="echo_output_${__BU_MAIN_PROJECT_NAME}.log"; fi
__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH="${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT}/${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT'    "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT}"  'Dirpath'	"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PARENT}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME'      "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}"    'File'		"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_NAME}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH'      "${__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}"    'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_ECHO_OUTPUT_FILE_PATH}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

# -------

# Defining the project's log file's parent directory path.
# __BU_MAIN_PROJECT_LOG_DIR_PARENT  --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}"
# __BU_MAIN_PROJECT_LOG_DIR_NAME    --> Default value : "logs"
# __BU_MAIN_PROJECT_LOG_DIR_PATH    --> Default value : "${__BU_MAIN_PROJECT_TMP_DIR_PATH}/${__BU_MAIN_PROJECT_LOG_DIR_NAME}"

__BU_MAIN_PROJECT_LOG_DIR_PARENT="${__BU_MAIN_PROJECT_TMP_DIR_PATH}";
__BU_MAIN_PROJECT_LOG_DIR_NAME="logs";
__BU_MAIN_PROJECT_LOG_DIR_PATH="${__BU_MAIN_PROJECT_LOG_DIR_PARENT}/${__BU_MAIN_PROJECT_LOG_DIR_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_DIR_PARENT' "${__BU_MAIN_PROJECT_LOG_DIR_PARENT}"   'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_PARENT}"   "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_DIR_NAME'   "${__BU_MAIN_PROJECT_LOG_DIR_NAME}"     'Dir'		"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_NAME}"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_DIR_PATH'   "${__BU_MAIN_PROJECT_LOG_DIR_PATH}"     'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_DIR_PATH}"     "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

# -------

# Defining the project's log file's path.
# __BU_MAIN_PROJECT_LOG_FILE_PARENT --> Default value : "${__BU_MAIN_PROJECT_LOG_DIR_PATH}"
# __BU_MAIN_PROJECT_LOG_FILE_NAME   --> Default value : "${__BU_MAIN_PROJECT_NAME}.log"
# __BU_MAIN_PROJECT_LOG_FILE_PATH   --> Default value : "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}/${__BU_MAIN_PROJECT_LOG_FILE_NAME}"

__BU_MAIN_PROJECT_LOG_FILE_PARENT="${__BU_MAIN_PROJECT_LOG_DIR_PATH}";
__BU_MAIN_PROJECT_LOG_FILE_NAME="${__BU_MAIN_PROJECT_NAME}.log";
__BU_MAIN_PROJECT_LOG_FILE_PATH="${__BU_MAIN_PROJECT_LOG_FILE_PARENT}/${__BU_MAIN_PROJECT_LOG_FILE_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_FILE_PARENT'    "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}"  'Dirpath'	"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_PARENT}"  "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_FILE_NAME'      "${__BU_MAIN_PROJECT_LOG_FILE_NAME}"    'File'		"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_NAME}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LOG_FILE_PATH'      "${__BU_MAIN_PROJECT_LOG_FILE_PATH}"    'FilePath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LOG_FILE_PATH}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

# -------

# Defining the project's translations script's informations.
# __BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT   --> Default value : "${__BU_MAIN_MODULE_LIB_LANG_DIR_PATH}"
# __BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME     --> Default value : "SetModuleLang.pl"
# __BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH     --> Default value : "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT}/${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}"

__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT="${__BU_MAIN_MODULE_LIB_LANG_DIR_PATH}";
__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME="SetModuleLang.pl";
__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH="${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT}/${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT'  "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT}"    'Dirpath'   "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PARENT}"    "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME'    "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}"	    'File'	    "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_NAME}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH'    "${__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}"	    'Filepath'  "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__PROJECT__BU_MAIN_PROJECT_LANG_CSV_PARSER_SCRIPT_PATH}"      "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 4 ))";

# -----------------------------------------------
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# These status variable can be changed anywhere in the main script, except for the following variables :
#   - __BU_MAIN_STATUS_INITIALIZING     -> This variable is used as (...).

# Their values are checked in the "Status.lib" file, located in the "Bash-utils/lib/functions/main" directory, with the "CheckSTAT_" functions (CV = Correct Value).


# "BU.Main.Checkings.CheckProjectLogPath()" and other low level's functions authorization to call a "Decho<...>()" function in case of need.

# This variable only accepts "authorize", "forbid" or "restrict" as values.
# Default value : "forbid" (to avoid bugs during the program's initialization)

# shellcheck disable=SC2034
__BU_MAIN_STAT_DECHO="forbid";


# "BU.Main.Checkings.CheckProjectLogPath()" function's authorization to call an "BU.Echo<...>()" function in case of need.

# This variable only accepts "true" or "false" as values.
# Default value : "true" (to avoid bugs and infinite loops during the initialization processus)

# shellcheck disable=SC2034
__BU_MAIN_STAT_ECHO="true";


# Project's error handling

# This variable only accepts "fatal" or nothing as value.
# Default value : "fatal" (to avoid leaving bugs during the program's initialization)

# shellcheck disable=SC2034
__BU_MAIN_STAT_ERROR="fatal";


# Project's initialization status checker.

# This variable only accepts "true" or "false" as values.
# Default value : "true" (DON'T change thsi value here, since the project MUST be initialized first).

# shellcheck disable=SC2034
__BU_MAIN_STAT_INITIALIZING="true";


# Project's main log file informations

# This variable only accepts "true" or "false" as values.
# Default value : "true"

# shellcheck disable=SC2034
__BU_MAIN_STAT_LOG="true";


# Project's main log file redirections status.

# This variable only accepts "log", "tee" or nothing as value.
# Default value : "" (no value)

# shellcheck disable=SC2034
__BU_MAIN_STAT_LOG_REDIRECT="";


# Project's authorization to operate at the root directory or one of its sub-folders.

# This variable only accepts "authorized", "forbidden" or "restricted" as values.
# Default value : "forbidden" (by security, and since there's no need to change its value during the initialization, you have to change this value manually or in your code with the "BU.Main.Status.ChangeSTAT_OPERATE_ROOT()" function).

# shellcheck disable=SC2034
__BU_MAIN_STAT_OPERATE_ROOT="forbidden";


# Project's headers messages display pause time.

# This variable only accepts any integer of floating number.
# Default value : ".6"

# shellcheck disable=SC2034
__BU_MAIN_STAT_TIME_HEADER="1";


# Project's newlines pause time.

# This variable only accepts any integer of floating number.
# Default value ".2"

__BU_MAIN_STAT_TIME_NEWLINE=".2";


# Project's text messages display pause time.

# This variable only accepts any integer of floating number.
# Default value : ".4"

# shellcheck disable=SC2034
__BU_MAIN_STAT_TIME_TXT=".4";


# Project's text formatting handling (the "BU.Main.Decho.Decho<...>()" functions can format the text or not).

# This variable only accepts "true" or "false" as value.
# Default value : "true" (formatting accepted)

# shellcheck disable=SC2034
__BU_MAIN_STAT_TXT_FMT="true";
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores text-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### TEXT MODE PROCESSING

## COLUMNS AND LINES

# Writing the command substitution text when the text mode is processed.
# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Text.PrintTextModeCmdSubs()  { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintTextModeCmdSubs__FNCT}" "${1}" "${1}"; }

# -----------------------------------------------

## TEXT FORMATTING

# Writing the command substitution text when a formatting is defined.
# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Text.PrintFormatCmdSubs()    { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintFormatCmdSubs__FNCT}" "${1}"; }

# Writing the command substitution text when a resetting is defined.
# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Text.PrintResetCmdSubs()     { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintResetCmdSubs__FNCT}" "${1}"; }

# Writing the command substitution text when a total resetting is defined.
# shellcheck disable=SC2059,SC2154
function BU.Main.ModConfig.Text.PrintAllResetCmdSubs()  { printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintAllResetCmdSubs__FNCT}"; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### OTHER FUNCTIONS

## ERROR FUNCTIONS

# Writing the name of the variable that could not be initialized with it's command substitution.
function BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize() {
    # ${1} -> Variable's name | ${2} -> "$(basename "${BASH_SOURCE[0]}")" | ${3} -> LINENO (line number)
    BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "$(( LINENO - 2 ))" 'E_BUINIT__BU_MAIN_MODCONFIG__TEXT_VAR_NOT_INIT';

    # shellcheck disable=SC2059
    printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__PrintVariableNameFailedToInitialize__FNCT}\n" "${2}" "${3}" "${1}";
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Feel free to define any other needed resources (functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### TEXT MODE PROCESSING

## COLUMNS AND LINES

# Getting the columns number on the current text mode according to its window's length.
__BU_MAIN_TXT_COLS="$(tput cols || stty size | cut -d " " -f2)";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_COLS' "${__BU_MAIN_TXT_COLS}" 'CMD' "$(BU.Main.ModConfig.Text.PrintTextModeCmdSubs 'cols')" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Getting the lines number on the current text mode according to its window's height.
__BU_MAIN_TXT_LINES="$(tput lines || stty size | cut -d " " -f1)";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_LINES' "${__BU_MAIN_TXT_LINES}" 'CMD' "$(BU.Main.ModConfig.Text.PrintTextModeCmdSubs 'lines')" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

exit 0;
# -----------------------------------------------

## PRINTING CHARACTERS

# Caractère utilisé pour dessiner les lignes des headers. Si vous souhaitez mettre un autre caractère à la place d'un tiret, changez le caractère entre les double guillemets.
# Ne mettez pas plus d'un caractère si vous ne souhaitez pas voir le texte de chaque header apparaître entre plusieurs lignes (une ligne de chaque caractère).
__BU_MAIN_TXT_CHAR_HEADER_LINE="-"		# Caractère à afficher en boucle pour créer une ligne des headers de changement d'étapes.

# Since the color global variables are defined in the "Colors.conf" file, AND since this file is already sourced before this file, it's safe to call these global variables.

# shellcheck disable=SC2059
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_CHAR_HEADER_LINE' "${__BU_MAIN_TXT_CHAR_HEADER_LINE}" 'Char' "$(printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_CHAR_HEADER_LINE__VAR}" "${__BU_MAIN_COLOR_TXT_FUNCTION}BU.Main.Headers.DrawLine${__BU_MAIN_COLOR_TXT_RESET}")" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 5 ))";

# Affichage de chevrons avant une chaîne de caractères (par exemple).
__BU_MAIN_TXT_PRINT_TAB=">>>>";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_PRINT_TAB' "${__BU_MAIN_TXT_PRINT_TAB}" 'String' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_PRINT_TAB__VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## STORING TEXT

# Storing a string got from a specific line (with a function like "BU.Main.Files.GetLineFromTextFile()", from "main/Files.lib" source file).
__BU_MAIN_TXT_STORE_LINE="";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_STORE_LINE' "${__BU_MAIN_TXT_STORE_LINE}" 'String' "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_STORE_LINE__VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# Getting the messages printed with the "${__BU_MAIN_STAT_ECHO}='true'" status ?
__BU_MAIN_TXT_STORE_ECHO_TRUE_MESSAGES_ARRAY=();    # Note : since this variable is an array, please leave empty the second argument of the "BU.ModuleInit.DisplayInitGlobalVarsInfos()" function.

# shellcheck disable=SC2059
BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_STORE_ECHO_TRUE_MESSAGES_ARRAY' "" 'Array' "$(printf "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_STORE_ECHO_TRUE_MESSAGES_ARRAY__ARRAY}" "${__BU_MAIN_COLOR_TXT_VAR}\${__BU_MAIN_STAT_ECHO}${__BU_MAIN_COLOR_TXT_RESET}" "${__BU_MAIN_COLOR_TXT_VAR}true${__BU_MAIN_COLOR_TXT_RESET}")" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 3 ))";

# -----------------------------------------------

## SUBSTRINGS

# Splitting a string into substrings.
__BU_MAIN_TXT_ERR_SUBSTR_DELIM=' [/|\] ';

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_ERR_SUBSTR_DELIM' "${__BU_MAIN_TXT_ERR_SUBSTR_DELIM}" "String" "${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TEXT__BU_MAIN_TXT_ERR_SUBSTR_DELIM__VAR}" "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## TEXT FORMATTING

# Wrapping the code in a function to prevent the command substitutions from being executed, so that bugs are not ignored when sourcing configuration files in the loop of the "BU.Main.Initializer.SourceConfig()" function of the main module's initializer file.
function BU.Main.ModConfig.Text.WrapTextFormattingSubSection()
{
    #**** Variables ****

    # The "declare" command automatically makes the variable local.
    declare -i __bu_main_txt_fmt_blink_lineno;
    declare -i __bu_main_txt_fmt_blink_reset_lineno;

    declare -i __bu_main_txt_fmt_bold_lineno;
    declare -i __bu_main_txt_fmt_bold_reset_lineno;

    declare -i __bu_main_txt_fmt_dim_lineno;
    declare -i __bu_main_txt_fmt_dim_reset_lineno;

    declare -i __bu_main_txt_fmt_hidden_lineno;
    declare -i __bu_main_txt_fmt_hidden_reset_lineno;

    declare -i __bu_main_txt_fmt_italic_lineno;
    declare -i __bu_main_txt_fmt_italic_reset_lineno;

    declare -i __bu_main_txt_fmt_reset_lineno;

    declare -i __bu_main_txt_fmt_strikethrough_lineno;
    declare -i __bu_main_txt_fmt_strikethrough_reset_lineno;

    declare -i __bu_main_txt_fmt_underline_lineno;
    declare -i __bu_main_txt_fmt_underline_reset_lineno;

    #**** Code ****

    # ----------------------------------------------------------------------------------------------------------------------
    # Blink
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_blink_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_BLINK="$(BU.Main.TextFormat.SetTextFormat 'blink' '5' '--no-function')" || {
        printf "\e[25m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_BLINK' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_blink_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_BLINK}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_BLINK' "${__BU_MAIN_TXT_FMT_BLINK}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "blink")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_blink_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Blink reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_blink_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_BLINK_RESET="$(BU.Main.TextFormat.SetTextFormat 'sgr0' '25' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_BLINK_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_blink_reset_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_BLINK_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_BLINK_RESET' "${__BU_MAIN_TXT_FMT_BLINK_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "blink")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_blink_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bold
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_bold_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_BOLD="$(BU.Main.TextFormat.SetTextFormat 'bold' '1' '--no-function')" || {
        printf "\e[1m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_BOLD' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_bold_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_BOLD}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_BOLD' "${__BU_MAIN_TXT_FMT_BOLD}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "bold")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_bold_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Bold reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_bold_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_BOLD_RESET="$(BU.Main.TextFormat.SetTextFormat '' '0' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_BOLD_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_bold_reset_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_BOLD_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_BOLD_RESET' "${__BU_MAIN_TXT_FMT_BOLD_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "bold")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_bold_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Dim
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_dim_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_DIM="$(BU.Main.TextFormat.SetTextFormat 'dim' '2' '--no-function')" || {
        printf "\e[2m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_DIM' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_dim_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_DIM}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_DIM' "${__BU_MAIN_TXT_FMT_DIM}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs  "dim")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_dim_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Dim reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_dim_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_DIM_RESET="$(BU.Main.TextFormat.SetTextFormat '' '22' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_DIM_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_dim_reset_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_DIM_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_DIM_RESET' "${__BU_MAIN_TXT_FMT_DIM_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "dim")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_dim_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Hidden (useful for password typing).
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_hidden_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_HIDDEN="$(BU.Main.TextFormat.SetTextFormat '' '8' '--no-function')" || {
        printf "\e[8m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_HIDDEN' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_hidden_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_HIDDEN}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_HIDDEN' "${__BU_MAIN_TXT_FMT_HIDDEN}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "hidden")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_hidden_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Hidden reset (DO NOT USE THIS FORMAT BEFORE TYPING A PASSWORD !!!!!)
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_hidden_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_HIDDEN_RESET="$(BU.Main.TextFormat.SetTextFormat '' '28' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_HIDDEN_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_hidden_reset_lineno}";

        BU.ModuleInit.MsgAbort;

        BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_HIDDEN_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_HIDDEN_RESET' "${__BU_MAIN_TXT_FMT_HIDDEN_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "hidden")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_hidden_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Italic
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_italic_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_ITALIC="$(BU.Main.TextFormat.SetTextFormat 'sitm' '3' '--no-function')" || {
        printf "\e[3m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_ITALIC' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_italic_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_ITALIC}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_ITALIC' "${__BU_MAIN_TXT_FMT_ITALIC}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "italic")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_italic_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Italic reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_italic_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_ITALIC_RESET="$(BU.Main.TextFormat.SetTextFormat 'ritm' '23' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_ITALIC_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_italic_reset_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_ITALIC_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_ITALIC_RESET' "${__BU_MAIN_TXT_FMT_ITALIC_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "italic")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_italic_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Reset (total)
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_RESET="$(BU.Main.TextFormat.SetTextFormat 'sgr0' '0' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_reset_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_RESET' "${__BU_MAIN_TXT_FMT_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintAllResetCmdSubs)" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Strikethrough
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_strikethrough_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_STRIKETHROUGH="$(BU.Main.TextFormat.SetTextFormat '' '9' '--no-function')" || {
        printf "\e[9m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_STRIKETHROUGH' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_strikethrough_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi


    };

    printf "%s" "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_STRIKETHROUGH' "${__BU_MAIN_TXT_FMT_STRIKETHROUGH}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "strikethrough")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_strikethrough_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Strikethrough reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_strikethrough_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET="$(BU.Main.TextFormat.SetTextFormat '' '29' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_strikethrough_reset_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET' "${__BU_MAIN_TXT_FMT_STRIKETHROUGH_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "strikethrough")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_strikethrough_reset_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Underline
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_underline_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_UNDERLINE="$(BU.Main.TextFormat.SetTextFormat 'smul' '4' '--no-function')" || {
        printf "\e[4m"; printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_UNDERLINE' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_underline_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_UNDERLINE}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_UNDERLINE' "${__BU_MAIN_TXT_FMT_UNDERLINE}" 'CMD' "$(BU.Main.ModConfig.Text.PrintFormatCmdSubs "Underline")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_underline_lineno}";


    # ----------------------------------------------------------------------------------------------------------------------
    # Underline reset
    # ----------------------------------------------------------------------------------------------------------------------

    __bu_main_txt_fmt_underline_reset_lineno="$(( LINENO + 2 ))";

    __BU_MAIN_TXT_FMT_UNDERLINE_RESET="$(BU.Main.TextFormat.SetTextFormat 'rmul' '24' '--no-function')" || {
        printf "\n";

        BU.Main.ModConfig.Text.PrintVariableNameFailedToInitialize '__BU_MAIN_TXT_FMT_UNDERLINE_RESET' "$(basename "${BASH_SOURCE[0]}")" "${__bu_main_txt_fmt_underline_reset_lineno}";

        BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

        if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi
    };

    printf "%s" "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}";

    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TXT_FMT_UNDERLINE_RESET' "${__BU_MAIN_TXT_FMT_UNDERLINE_RESET}" 'CMD' "$(BU.Main.ModConfig.Text.PrintResetCmdSubs "Underline")" \
        "${__BU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${__bu_main_txt_fmt_underline_reset_lineno}";
}

BU.Main.ModConfig.Text.WrapTextFormattingSubSection || return 1;

# -----------------------------------------------
#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034

# This configuration file stores every date-related global variables.

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################## DEFINING RESOURCES - FUNCTIONS #################################

#### DEFINING THE NEEDED FUNCTIONS

## DEFINING THE NEEDED FUNCTIONS

# Feel free to define any needed resources (functions, etc...) here.

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

######################################## DEFINING VARIABLES #######################################

#### DATE PROCESSING

## GETTING THE DATE

# Saving the current date in YYYYY-MM-DD hh-mm-ss format (YEAR-MONTH-DAY hour-minute-second)
__BU_MAIN_TIME_DATE="$(date +"%Y-%m-%d %H:%M:%S")";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TIME_DATE' "${__BU_MAIN_TIME_DATE}" 'CMD' \
	"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TIME__BU_MAIN_TIME_DATE}"  \
	"${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";

# -----------------------------------------------

## PRINTING THE DATE

# Displaying the current date YYYYY-MM-DD hh:mm:ss format (YEAR-MONTH-DAY hour-minute-second) with a colored text (for a better view in the log file).

# Unlike the "${__BU_MODULES_UNIT_DATE_LOG}" global variable, this log entry displays colors.

# Declaring the variables which contains the color codes.
v_time_conf_date_display_color_1="$(tput setaf 78)";
v_time_conf_date_display_color_2="$(tput setaf 111)";
v_time_conf_date_display_color_3="$(tput setaf 78)";

__BU_MAIN_TIME_DATE_DISPLAY="$(echo -ne "${v_time_conf_date_display_color_1}" "[ ${v_time_conf_date_display_color_2}${__BU_MAIN_TIME_DATE}${v_time_conf_date_display_color_3} ]\033[0m")";

BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_TIME_DATE_DISPLAY' "${__BU_MAIN_TIME_DATE_DISPLAY}" 'CMD' \
	"${__BU_MODULE_INIT_MSG__BU_MAIN_MODCONFIG__TIME__BU_MAIN_TIME_DATE_DISPLAY}" \
	"${__BU_MU_MODULE_INIT_MSG__DISP_INIT_GLOB_VARS_INFO__IS_VAR_DEF_IN_INITIALIZER__MAIN_MODULE_CONF}" \
	"${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "$(( LINENO - 2 ))";
#!/usr/bin/env bash

# ---------------------
# SCRIPT'S INFORMATIONS

# Name          : Initializer.sh
# Module        : Main
# Description   : Module initializer file, initializing all the module's functions and variables you need for your scripts.
# Author(s)     : Dimitri OBEID
# Version       : 1.0

# ----------------------------
# SHELLCHECK GLOBAL DISABLER :

# Add a coma after each warning code to disable multiple warnings at one go.

# Do not uncomment the "shellcheck disable" line, or else the shellcheck command will be executed during the script's execution, and will not detect any coding mistake during a debugging process.

# DO NOT PUT A COMA AFTER A SHELLCHECK CODE IF THERE'S NO OTHER SHELLCHECK CODE FOLLOWING IT, OR ELSE SHELLCHECK WILL RETURN ERRORS DURING THE DEBUGGING PROCESS !!!

# IF YOU WANT TO ADD ANOTHER SHELLCHECK CODE, WRITE THIS CODE DIRECTLY AFTER THE COMMA, WITHOUT ADDING A BLANK SPACE AFTER IT !!!

# shellcheck disable=SC2154

# ---------------------
# NOTE ABOUT SHELLCHECK

# To display the content of a variable in a translated string, the use of the printf command is mandatory in order to interpret each "%s" pattern as the value of a variable.

# This means that the Shellcheck warning code SC2059 will be triggered anyway, since we have no choice but to store the entire translated string in a variable.

# If you add new messages to translate, you must call the directive "shellcheck disable=SC2059" before the line where you call the
# command "printf" to display the translated message, otherwise Shellcheck will display many warnings during the debugging procedure.

# ----------------------
# DO NOT EXECUTE THIS SCRIPT DIRECTLY, instead, just source it in the "Bash-utils-init.sh" file's function "BashUtils_InitModules()"

# /////////////////////////////////////////////////////////////////////////////////////////////// #

# Preventing the direct execution of this file, as this script is not meant to be directly executed, but sourced.
if [ "${0##*/}" == "${BASH_SOURCE[0]##*/}" ]; then if [[ "${LANG}" == de_* ]]; then
    echo -e "ACHTUNG !" >&2; echo >&2;
    echo -e "Dieses Shell-Skript (${BASH_SOURCE[0]}) ist nicht dazu gedacht, direkt ausgeführt zu werden !" >&2;
    echo -e "Verwenden Sie nur dieses Skript, indem Sie es in Ihr Projekt aufnehmen." >&2; echo >&2;

elif [[ "${LANG}" == es_* ]]; then
    echo -e "ATENCIÓN !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) no debe ejecutarse directamente !" >&2;
    echo -e "Utilice sólo este script incluyéndolo en el script de su proyecto." >&2; echo >&2;

elif [[ "${LANG}" == fr_* ]]; then
    echo -e "ATTENTION !" >&2; echo >&2;
    echo -e "Ce script shell (${BASH_SOURCE[0]}) n'est pas conçu pour être directement exécuté !" >&2;
    echo -e "Utilisez seulement ce script en l'incluant dans votre projet." >&2; echo >&2;

elif [[ "${LANG}" == pt_* ]]; then
    echo -e "ATENÇÃO !" >&2; echo >&2;
    echo -e "Este script de shell (${BASH_SOURCE[0]}) não é para ser executado directamente !" >&2;
    echo -e "Utilize este guião apenas incluindo-o no seu projecto." >&2; echo >&2;

elif [[ "${LANG}" == ru_* ]]; then
    echo -e "ВНИМАНИЕ !" >&2; echo >&2;
    echo -e "Этот сценарий оболочки (${BASH_SOURCE[0]}) не предназначен для непосредственного выполнения !" >&2;
    echo -e "Используйте только этот скрипт, включив его в свой проект." >&2; echo >&2;

else
    echo -e "WARNING !" >&2; echo >&2;
    echo -e "This shell script (${BASH_SOURCE[0]}) is not meant to be executed directly !" >&2;
    echo -e "Use only this script by including it in your project script." >&2; echo >&2;

fi; exit 1; fi

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

################################### INITIALIZING THE MAIN MODULE ##################################

#### STEP ONE : DEFINING THE NEEDED RESOURCES

## FUNCTIONS

# Sourcing each library file stored into the "function/main" directory, from the "${__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY}" array defined in the "~/.Bash-utils/config/modules/main/module.conf" file.
function BU.Main.Initializer.SourceLibrary()
{
    #**** Variables ****
    local v_loop_error; # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #**** Code ****
    # Note : there is no need to call the "BU.ModuleInit.PrintLogError" function here, the "BU.ModuleInit.SourcingFailure()" function already does.

	# Leaving a newline for a better text display in the log file and the terminal.
	BU.ModuleInit.Msg;

	# shellcheck disable=SC1090
	for f in "${__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY[@]}"; do

        BU.ModuleInit.CheckIsDebugging && BU.ModuleInit.Msg "Debug mode activated";

		BU.ModuleInit.IsFrameworkWrapped || source "${f}" || { BU.ModuleInit.SourcingFailure "${f}" "$(BU.ModuleInit.GetModuleName "${BASH_SOURCE[0]}")" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}"; __BU_MAIN_MODULE_LIB_FILES_PATH_ARRAY+=("${f}"); v_loop_error='error'; break; }

		# shellcheck disable=SC2059
		BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_ONE__SOURCE_LIBRARY}" "${f}")";
	done

	if [ "${v_loop_error,,}" == 'error' ]; then if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi; fi

	# Leaving a newline for a better text display in the log file and the terminal.
	BU.ModuleInit.Msg;

	return 0;
}

# Sourcing each file listed into the "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}" array defined in the "~/.Bash-utils/config/modules/main/module.conf" file.
function BU.Main.Initializer.SourceConfig()
{
    #**** Variables ****
    local v_loop_error; # This variable stores the 'error' string if a command or a function call failed during the execution of a loop.

    #**** Code ****
    # Note : there is no need to call the "BU.ModuleInit.PrintLogError" function here, the "BU.ModuleInit.SourcingFailure()" function already does.

    if [ "${__BU_MAIN_INITIALIZER__STATUS_MODIFIED_BY_MAIN_MODULE_ARGS,,}" == 'true' ]; then
        # Deleting the index 1 of the "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}[@]" array,
        # which contains the path to the "Status.conf" configuration file, which was included just
        # before the processing of the status global variables vaues given as main module's arguments.
        unset '__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY[1]';

        # Shifting each array's indexes which followed the deleted index.
        __BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY=( "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY[@]}" );
    fi

	# shellcheck disable=SC1090
	for f in "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY[@]}"; do
		BU.ModuleInit.IsFrameworkWrapped || source "${f}" || { BU.ModuleInit.SourcingFailure "${f}" "$(BU.ModuleInit.GetModuleName "${BASH_SOURCE[0]}")" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}"; __BU_MAIN_MODULE_CONFIG_FILES_PATH_ARRAY+=("${f}"); v_loop_error='error'; break; };

		# shellcheck disable=SC2059
		BU.ModuleInit.Msg "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_ONE__SOURCE_CONFIG}" "${f}")";
	done;

	if [ "${v_loop_error,,}" == 'error' ]; then if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi; fi

	# Leaving a newline for a better text display in the log file and the terminal.
	BU.ModuleInit.Msg;

	return 0;
}

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### STEP TWO : MINIMAL INCLUSION OF FILES IN ORDER TO USE THEIR RESOURCES DURING THE TRANSLATION PART

## SOURCING LIBRARY FILES FIRST

# Note : Several functions from the main module are used in the "BU.ModuleInit.()" function.

# Sourcing each needed library files stored into the function/main directory, from the "${__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY}" array.

# shellcheck disable=SC2059,SC2016
__BU_MAIN_INITIALIZER__TEXT_LIB_PATH="$(BU.ModuleInit.FindPath "${__BU_MAIN_MODULE_LIB_MOD_DIR_PATH}" "Text.lib" 'f')" || { printf "${__BU_MODULE_INIT_MSG__PRINT_MISSING_PATH_FOR_DEFINED_GLOBAL_VARIABLE__NO_FNCT}" "$(basename "${BASH_SOURCE[0]}")" "${LINENO}" '$__BU_MAIN_INITIALIZER__TEXT_LIB_PATH'; BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog; BU.ModuleInit.IsInScript && exit 1; return 1; };

# shellcheck disable=SC1090
BU.ModuleInit.IsFrameworkWrapped || source "${__BU_MAIN_INITIALIZER__TEXT_LIB_PATH}" || { BU.ModuleInit.SourcingFailure "${__BU_MAIN_INITIALIZER__TEXT_LIB_PATH}" "${__BU_MODULE_INIT_MODULE_NAME}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}"; BU.ModuleInit.IsInScript && exit 1; return 1; };

# -----------------------------------------------

## SOURCING CONFIGURATION FILES

# Sourcing each needed configuration files listed into the "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}" array.

# Remember that "Project.conf", the file whose path is stored in the "${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}" global variable,
# does not call any library functions from the main module, so it is totally safe to include this file.

# shellcheck disable=SC1090
BU.ModuleInit.IsFrameworkWrapped || source "${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}" || { BU.ModuleInit.SourcingFailure "${__BU_MAIN_MODULE_CONF_FILE_INIT_PATH}" "${__BU_MODULE_INIT_MODULE_NAME}" "${BASH_SOURCE[0]}" "${FUNCNAME[0]}" "${LINENO}"; BU.ModuleInit.IsInScript && exit 1; return 1; }

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### STEP THREE : PROCESSING THE MAIN MODULE'S PARAMETERS

# Usage function.
function BU.Main.Initializer.Usage()
{
    echo >&2; echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE__SUPPORTED_ARGS}" >&2;
    sleep 2;

    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______DECHO}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE________ECHO}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______ERROR}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_________LOG}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_______LOG_R}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_____OP_ROOT}" >&2;
    echo >&2;

    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_H}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_N}" >&2;
    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE______TIME_T}" >&2;
    echo >&2;

    echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__USAGE_____TXT_FMT}" >&2;
    echo >&2;

    echo >&2;
    echo "If you plan to debug the framework, the « __BU_MODULE_INIT_STAT_DEBUG_BASHX » status global variable can print the name of any function by file, category, sub-category or function" >&2;
    echo "With this global variable, you can print the name of the function before each instructions execution reported with the output of the « bash -x » command" >&2;
    echo >&2;

    return 0;
}

# Creating a function to print the correct values for the current option in different languages structures.
function BU.Main.Initializer.ProcessBadStatusOptionValues()
{
    BU.ModuleInit.Msg "$(printf "Warning : the supported values for the « %s » option are : %s" "${1}" "${2}")" >&2;
    BU.ModuleInit.Msg >&2;
}

# If arguments were given in the same double quotes as the "main" module's value.
if [ "${__BU_MODULE_INIT_MODULE_AND_ARGS_STRING}" == "main --*" ]; then

	# Defining an array (${main_module_array}) to store the module's arguments string as an array of words.
	read -ra main_module_array <<< "${__BU_MODULE_INIT_MODULE_AND_ARGS_STRING}";

	# Unsetting the "main" value from the newly created array, in order to avoid an "unsupported argument" error.
	unset "main_module_array[0]";

	# Process each supported arguments in this "for" loop.
	for module_arg in "${main_module_array[@]}"; do

        # stat_value_warning="Warning : the supported values for this option are :" >&2;

        # shellcheck disable=SC2059
        printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__BAD_VALUE_GIVEN}" "${value}" >&2;

        echo -ne "${__BU_MAIN_COLOR_TXT_RESET}" >&2; echo >&2;

        echo "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__BAD_VALUE_GIVEN__ADVICE}" >&2;

        # As the "Status.conf" file is sourced, the default global status variables values will be overwritten with the new values.
        if [[ "${module_arg,,}" == "--stat-"* ]]; then

            # shellcheck disable=SC2219
            let value;

            # --stat option argument, with all the global status variables that can be modified : main --stat='debug=true decho=restrict'
            # Extracting the "--stat" option's values.
            case "${module_arg,,}" in

                # "${__BU_MAIN_STAT_DECHO}" global status variable.
                '--stat-decho='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'authorize' ]             || [ "${value,,}" == 'forbid' ]             || [ "${value,,}" == 'restrict' ]; then
                            __BU_MAIN_STAT_DECHO="${value}";            BU.ModuleInit.DisplayInitGlobalVarsInfos    '__BU_MAIN_STAT_DECHO' "${__BU_MAIN_STAT_DECHO}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_DECHO}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-decho" "« --stat-decho=authorize », « --stat-decho=forbid », « --stat-decho=restrict »";
                    fi;;

                # "${__BU_MAIN_STAT_ECHO}" global status variable.
                '--stat-echo'*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'false' ]                 || [ "${value,,}" == 'true' ]; then
                            __BU_MAIN_STAT_ECHO="${value}";             BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_ECHO' "${__BU_MAIN_STAT_ECHO}" 'bool' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_ECHO}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-echo" "« --stat-echo=false », « stat-echo=true »";
                    fi;;

                # "${__BU_MAIN_STAT_ERROR}" global status variable.
                '--stat-error='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'fatal' ]; then
                            __BU_MAIN_STAT_ERROR="${value}";            BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_ERROR' "${__BU_MAIN_STAT_ERROR}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_ERROR}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");

                    elif    [ "${value,,}" == 'void' ]; then
                            __BU_MAIN_STAT_ERROR='';                    BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_ERROR' "${__BU_MAIN_STAT_ERROR}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_ERROR}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-error" "« --stat-error=fatal », « stat-error=void »";
                    fi;;

                # "${__BU_MAIN_STAT_LOG}" global status variable.
                '--stat-log='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'false' ]                 || [ "${value,,}" == 'true' ]; then
                            __BU_MAIN_STAT_LOG="${value}";              BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_LOG' "${__BU_MAIN_STAT_LOG}" 'bool' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_LOG}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-log" "« --stat-log=false », « stat-log=true »";
                    fi;;

                # "${__BU_MAIN_STAT_LOG_REDIRECT}" global status variable.
                'stat-log-r='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'log' ]                   || [ "${value,,}" == 'tee' ]; then
                            __BU_MAIN_STAT_LOG_REDIRECT="${value}";     BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_LOG_REDIRECT' "${__BU_MAIN_STAT_LOG_REDIRECT}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_LOG_R}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");

                    elif    [ "${value,,}" == 'void' ]; then
                            __BU_MAIN_STAT_LOG_REDIRECT='';             BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_LOG_REDIRECT' "${__BU_MAIN_STAT_LOG_REDIRECT}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_LOG_R}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-log-r" "« --stat-log-r=log », « stat-log-r=tee », « --stat-log-r=void »";
                    fi;;

                # "${__BU_MAIN_STAT_OPERATE_ROOT}" global status variable.
                '--stat-op-root='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'authorized' ]            || [ "${value,,}" == 'forbidden' ]           || [ "${value,,}" == 'restricted' ]; then
                            __BU_MAIN_STAT_OPERATE_ROOT="${value}";     BU.ModuleInit.DisplayInitGlobalVarsInfos  '__BU_MAIN_STAT_OPERATE_ROOT' "${__BU_MAIN_STAT_OPERATE_ROOT}" 'string' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_OP_ROOT}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-op-root" "« --stat-op-root=authorized », « stat-op-root=forbidden », « --stat-op-root=restricted »";
                    fi;;

                # "${__BU_MAIN_STAT_TIME_HEADER}" global status variable.
                '--stat-time-header='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      BU.Main.Checkings.IsPositiveFloat "${value}"; then
                            __BU_MAIN_STAT_TIME_HEADER="${value}";      BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_TIME_HEADER' "${__BU_MAIN_STAT_TIME_HEADER}" 'float' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_H}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-time-header" "« $(BU.Main.Decho.Decho.FMT_I "a floating number" "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}") »";
                    fi;;

                # "${__BU_MAIN_STAT_TIME_NEWLINE}" global status variable.
                '--stat-time-newline='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      BU.Main.Checkings.IsPositiveFloat "${value}"; then
                            __BU_MAIN_STAT_TIME_NEWLINE="${value}";     BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_TIME_NEWLINE' "${__BU_MAIN_STAT_TIME_NEWLINE}" 'float' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_N}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-time-newline" "« $(BU.Main.Decho.Decho.FMT_I "a floating number" "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}") »";
                    fi;;

                # "${__BU_MAIN_STAT_TIME_TXT}" global status variable.
                '--stat-time-txt='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      BU.Main.Checkings.IsPositiveFloat "${value}"; then
                            __BU_MAIN_STAT_TIME_TXT="${value}";         BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_TIME_TXT' "${__BU_MAIN_STAT_TIME_TXT}" 'float' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TIME_T}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-time-txt" "« $(BU.Main.Decho.Decho.FMT_I "a floating number" "${__BU_MAIN_COLOR_TXT_HIGHLIGHT}") »";
                    fi;;

                # "${__BU_MAIN_STAT_TXT_FMT}" global status variable.
                '--stat-txt-fmt='*)
                    value="${module_arg#*=}";
                    value="${value% *}";

                    if      [ "${value,,}" == 'false' ]                 || [ "${value,,}" == 'true' ]; then
                            __BU_MAIN_STAT_TXT_FMT="${value}";          BU.ModuleInit.DisplayInitGlobalVarsInfos '__BU_MAIN_STAT_TXT_FMT' "${__BU_MAIN_STAT_TXT_FMT}" 'bool' "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_THREE__STAT_GLOB_VAR_DESC_TXT_FMT}" "$(basename "${BASH_SOURCE[0]}")" "${FUNCNAME[0]}" "${LINENO}";

                            __BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY+=("${value}");

                            # Debug : testing if the checking of the arguments works.
                            echo "--stat-txt-time value : ${value}";
                    else
                            BU.Main.Initializer.ProcessBadStatusOptionValues "--stat-txt-fmt" "« --stat-txt-fmt=false », « --stat-txt-fmt=true »";
                    fi;;

                # Any unsupported global status variable.
                *)
                            echo "IN « ${BASH_SOURCE[0]} », LINE « $(( LINENO - 1 )) » --> WARNING : THE « ${value} » IS NOT A SUPPORTED STATUS ARGUMENT FOR THE $(BU.ModuleInit.GetModuleName "${BASH_SOURCE[0]}")" >&2;
                            echo >&2;

                            BU.Main.Initializer.Usage; ____bu_main_initializer__parse_args_list__loop_error='error'; break;
            esac

            if [ -z "${__BU_MAIN_INITIALIZER__STATUS_MODIFIED_BY_MAIN_MODULE_ARGS}" ]; then __BU_MAIN_INITIALIZER__STATUS_MODIFIED_BY_MAIN_MODULE_ARGS='true'; fi

        elif [[ "${module_arg,,}" == '--dev-tools'* ]]; then
            if [ -n "${____bu_main_initializer__parse_args_list__dev_tools_arg__state}" ] && [ "${____bu_main_initializer__parse_args_list__dev_tools_arg__state}" == 'true' ]; then
                BU.Main.ModConfig.Module.BUDevToolsPaths;

                ____bu_main_initializer__parse_args_list__dev_tools_arg__state='true';
            fi

        # Else, if an unsupported value is passed as « main » module's argument.
        else
            # Temporary situation.
            BU.Main.Initializer.Usage; ____bu_main_initializer__parse_args_list__loop_error='error'; break;
        fi

    done; if [ "${____bu_main_initializer__parse_args_list__loop_error,,}" == 'error' ]; then if BU.ModuleInit.IsInScript; then exit 1; else unset ____bu_main_initializer__parse_args_list__loop_error; return 1; fi; fi
fi

# Unsetting the "${____bu_main_initializer__parse_args_list__loop_error}" variable, since this code is not written inside a function.
unset ____bu_main_initializer__parse_args_list__loop_error;

unset ____bu_main_initializer__parse_args_list__dev_tools_arg__state;

# Checking if a new default status global variable's value was modified (passed as one of the « main » module's « --stat-* » arguments).
for value in "${__BU_MAIN_MODULE_MODIFIED_STATUS_VARS_ARRAY[@]}"; do

    if [ "${value,,}" != '--stat-decho=authorize' ] && [ "${value,,}" != '--stat-decho-forbid' ] && [ "${value,,}" != '--stat-decho-restrict' ]; then
        BU.Main.Status.ChangeSTAT_DECHO        "authorize" 'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    fi

    if [ "${value,,}" != '--stat-echo=false' ]      && [ "${value,,}" != '--stat-echo=true' ]; then
        BU.Main.Status.ChangeSTAT_ECHO         "false"     'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    fi

    # Don't forget to set the "${__BU_MAIN_STAT_LOG_REDIRECT}" value BEFORE calling a function which checks the value of the "${__BU_MAIN_STAT_LOG}" value, since this function calls a function which creates the logs file.
    if [ "${value,,}" != '--stat-log-r=log' ]       && [ "${value,,}" != '--stat-log-r=tee' ]   && [ "${value,,}" != '--stat-log-r=void' ]; then
        BU.Main.Status.ChangeSTAT_LOG_REDIRECT "tee"       'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    fi

    if [ "${value,,}" != '--stat-log=false' ]       && [ "${value,,}" != '--stat-true' ]; then

        # The function "CheckSTAT_LOG()" creates the log file and its path if the "${__BU_MAIN_STAT_LOG}" variable's value is equal to "true".
        BU.Main.Status.ChangeSTAT_LOG          "true"      'main' "$(basename "${BASH_SOURCE[0]}")" "${LINENO}";
    fi
done

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### STEP FOUR : INCLUSION OF THE REST OF THE LIBRARY AND CONFIGURATION FILES

# Sourcing each library file stored into the function/main directory, from the "${__BU_MAIN_MODULE_FUNCTIONS_FILES_PATH_ARRAY}" array.
BU.Main.Initializer.SourceLibrary || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

# -----------------------------------------------

## SOURCING CONFIGURATION FILES

# Sourcing each file listed into the "${__BU_MAIN_MODULE_LIST_CONFIG_FILES_PATH_ARRAY}" array.
BU.Main.Initializer.SourceConfig || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

# -----------------------------------------------



# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### STEP FIVE : PROCESSING PROJECT'S RESOURCES

## CALLING NECESSARY FUNCTIONS

# Translating the main module's library messages
# BU.ModuleInit.ParseCSVLang "${__BU_MODULE_INIT__USER_LANG}" "${__BU_MODULE_INIT__CSV_TRANSLATION_FILE__DELIM}" || { if BU.ModuleInit.IsInScript; then exit 1; else return 1; fi };

# Since the "CheckProjectLogFile()" function manages the text displaying if the log file doesn't exists, it's okay to call this function now.
BU.Main.Directories.MkTmpDir || { BU.ModuleInit.PrintLogError "${BASH_SOURCE[0]}" "${LINENO}" 'E_BUINIT__BU_MAIN_INIT__CANNOT_MK_TMPDIR'; BU.ModuleInit.MsgAbort; BU.ModuleInit.AskPrintLog >&2 || { if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi }; if BU.ModuleInit.IsInScript; then BU.ModuleInit.Exit 1; else return 1; fi };

# -----------------------------------------------

## PROCESSING SOME DIRECTORIES AND FILES

# Creating the text and background color code files if the "${__BU_MAIN_STAT_TXT_FMT}" global status variable's value is set to "true".
if BU.Main.Status.CheckStatAllowFormatting; then
    # If the file which contains the current foreground color code doesn't exists, then it must be created, and the file's creation message must be displayed.
    if [ ! -f "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}" ]; then
        # Creating the text color code file
        if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_NAME}" "f"; then
            # shellcheck disable=SC2059
            BU.Main.Errors.HandleErrors "${?}" "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__ERROR}" "$(BU.Main.Decho.Path "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}")")" "" "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}" "$(basename "${BASH_SOURCE[0]}")" "" "$(( LINENO - 2 ))"; return 1;

        else
            # shellcheck disable=SC2059
            BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__SUCCESS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PARENT}")")"; BU.Main.Echo.Newline;
        fi
    else
        # shellcheck disable=SC2059
        BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_TXT_COL_FILE__EXISTS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_TEXT_CODE_FILE_PATH}")")"; BU.Main.Echo.Newline;
    fi

    # If the file which contains the current background color file doesn't exists, then it must be created, and the file's creation message must be displayed.
    if [ ! -f "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}" ]; then
        # Creating the background color code file
        if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_NAME}")" 'f'; then
            # shellcheck disable=SC2059
            BU.Main.Errors.HandleErrors "${?}" "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__ERROR}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}")" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}")")" '' "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}" "$(basename "${BASH_SOURCE[0]}")" "" "$(( LINENO - 2 ))"; return 1;

        else
            # shellcheck disable=SC2059
            BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__SUCCESS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}")" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PARENT}")")"; BU.Main.Echo.Newline;
        fi
    else
        # shellcheck disable=SC2059
        BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_BG_COL_FILE__EXISTS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_COLOR_BG_CODE_FILE_PATH}")")"; BU.Main.Echo.Newline;
    fi
fi

# Creating the project's log file if the "${__BU_MAIN_STAT_LOG}" global status variable's value is set to "true".
if BU.Main.Status.CheckStatIsLogging; then

    # If the file which stores every log entry doesn't exists, then it must be created.
    if [ ! -f "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" ]; then
        if ! BU.Main.Checkings.CheckProjectRelatedFile "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}" "${__BU_MAIN_PROJECT_LOG_FILE_NAME}" "f"; then
            # shellcheck disable=SC2059
            BU.Main.Errors.HandleErrors '1' "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__ERROR}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PATH}")" "$(BU.Main.Decho.Decho.Highlight "${__BU_MAIN_PROJECT_NAME}")")" "" "${__BU_MAIN_PROJECT_LOG_FILE_PATH}" "$(basename "${BASH_SOURCE[0]}")" "" "${LINENO}";

            return 1;
        else
            # shellcheck disable=SC2059
            BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__SUCCESS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_NAME}")" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}")")"; BU.Main.Echo.Newline;
        fi
    else
        # shellcheck disable=SC2059
        BU.Main.Echo.Success "$(printf "${__BU_MODULE_INIT_MSG__INIT_MAIN_MODULE__STEP_FIVE__CREATE_LOG_FILE__EXISTS}" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_NAME}")" "$(BU.Main.Decho.Decho.Path "${__BU_MAIN_PROJECT_LOG_FILE_PARENT}")")"; BU.Main.Echo.Newline;
    fi
fi

# -----------------------------------------------

## END OF THE INITIALIZATION PROCESS OF THE "MAIN" MODULE.

__BU_MAIN_STAT_ECHO='true'

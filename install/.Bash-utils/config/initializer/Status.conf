#!/usr/bin/env bash

# Disabling the SC2034 warning from Shellcheck (SC2034: <Variable name> appears unused. Verify use (or export if used externally)), because of the huge number of global variables declared in the configuration files, but only used in the library files.
# shellcheck disable=SC2034


# Project's debug variable

# This variable only accepts "true" or "false" as values.
# Default value : "false"

# shellcheck disable=SC2034
__BU_MODULE_INIT_STAT_DEBUG="false"


# Advanced project's debug variable

# This variable accepts "file", "category", "sub-category" "subcategory" (both last values do the same thing) or nothing as values,
# if the value of the "$__BU_MODULE_INIT_STAT_DEBUG" status global variable is equal to 'true'.
# Default value : "file"

if [ "$__BU_MODULE_INIT_STAT_DEBUG" = 'false' ]; then
    # shellcheck disable=SC2034
    __BU_MODULE_INIT_STAT_DEBUG_BASHX="";

elif [ "$__BU_MODULE_INIT_STAT_DEBUG" = 'true' ]; then

    # ------------------------------------------------------
    # Add or remove any supported values inside these arrays
    # ------------------------------------------------------

    # -------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT
    # -------------------------------------

    if [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" = cat?(eg?(ory)) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == cat?(eg?(orie))s ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" = 'C' ]; then

        # Each accepted value is written under each category name, in each library file.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every categores.

        # Every values are case-insensitive.

        BashXCatConf="BashXCat.conf";

        # If the "" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "$BashXCatConf" ] && [ -s "$BashXCatConf" ]; then
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT=();

            cat "$BashXCatConf" | while read -r line; do __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT+=("$line"); done

        # Else, you can fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_CAT=();
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXCatConf;

    # ---------------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY
    # ---------------------------------------------
    
    elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" == file?(s) ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" = 'F' ]; then

        # The accepted values are the name of every ".lib" files from the Bash-utils/lib/functions/main/ directory.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every files.

        # Every values are case-insensitive.

        BashXFilesConf="BashXFiles.conf";

        # If the "BashXFiles.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "$BashXFilesConf" ] && [ -s "$BashXFilesConf" ]; then
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY=();

            cat "$BashXFilesConf" | while read -r line; do __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY+=("$line"); done

        # Else, you can fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY=("Args" "Decho" "Files" "Directories" "Status");
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXFilesConf;

    # -------------------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY
    # -------------------------------------------------

    elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" = function?(s) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" = FNCT?(S) ]]; then

        # The accepted values are the name of each function you want to debug.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every files.

        # Every values are case-insensitive.

        BashXFNCTConf="BashXFNCT.conf";

        # If the "BashXFNCT.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "$BashXFNCTConf" ] && [ -s "$BashXFNCTConf" ]; then
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FILES_ARRAY=();

            cat "$BashXFNCTConf" | while read -r line; do __BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY+=("$line"); done

        # Else, you can fill the following array with values.
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_FUNCTIONS_ARRAY=("Args" "Decho" "Errors");
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXFNCTConf;

    # -----------------------------------------
    # __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT
    # -----------------------------------------

    elif [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" = s?(ub)?(-)c?(at?(eg?(ory))) ]] || [[ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX,,}" = s?(ub)?(-)?(c?(at?(eg?(orie))))s ]] || [ "${__BU_MODULE_INIT_STAT_DEBUG_BASHX^^}" = 'S' ]; then
        # Each accepted value is written under each sub-category name, in each library file, and named according to their parent category.
        # The "All" value can be used as index 0, in order to allow printing the name of every functions from every sub-categories.

        # Every values are case-insensitive.

        BashXSubCatConf="BashXSubCat.conf";

        # If the "BashXSubCat.conf" file exists in the SAME directory than this script AND is not empty, then it's content is read, and each line is stored as a single value in each index.
        if [ -f "$BashXSubCatConf" ] && [ -s "$BashXSubCatConf" ]; then
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT=();

            cat "$BashXSubCatConf" | while read -r line; do __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT+=("$line"); done
        else
            __BU_MODULE_INIT_STAT_DEBUG_BASHX_SUB_CAT=();
        fi

        # Unsetting the created variable, in order to free the memory from a now useless variable.
        unset BashXSubCatConf;
    fi
fi
